// store the code for the worker module as a function that takes the shared module exports as an argument
const __dcg_worker_module__ = (__dcg_shared_module_exports__) => {
    var n = {};
    __dcg_shared_module_exports__['Te'].log = function(e) {
        self.postMessage({
            log: JSON.stringify(e)
        })
    }
    ;
    var o = self;
    o.window = o;
    o.onmessage = function(e) {
        let s = e.data && e.data.connectionId;
        if (s)
            if (e.data.originalMessage.type === "destroy")
                delete n[s];
            else {
                let a = n[s];
                a || (a = new __dcg_shared_module_exports__['mf']( (r, g) => {
                    o.postMessage({
                        connectionId: s,
                        originalMessage: {
                            type: r,
                            payload: g
                        }
                    })
                }
                ),
                n[s] = a),
                a.processChangeSet(e.data.originalMessage)
            }
    }
    ;
    o.loadMessageQueue && (o.loadMessageQueue.forEach(e => {
        o.onmessage(e)
    }
    ),
    delete o.loadMessageQueue);

}
;
// execute the shared module store its exports
const __dcg_worker_shared_module_exports__ = // shared.js
( () => {
    const __dcg_chunk_exports__ = {};
    var aq = Object.create;
    var BI = Object.defineProperty;
    var uq = Object.getOwnPropertyDescriptor;
    var cq = Object.getOwnPropertyNames;
    var lq = Object.getPrototypeOf
      , pq = Object.prototype.hasOwnProperty;
    var q9 = (e => typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(e,{
        get: (t, n) => (typeof require != "undefined" ? require : t)[n]
    }) : e)(function(e) {
        if (typeof require != "undefined")
            return require.apply(this, arguments);
        throw Error('Dynamic require of "' + e + '" is not supported')
    });
    var Sn = (e, t) => () => (e && (t = e(e = 0)),
    t);
    var z9 = (e, t) => () => (t || e((t = {
        exports: {}
    }).exports, t),
    t.exports)
      , cu = (e, t) => {
        for (var n in t)
            BI(e, n, {
                get: t[n],
                enumerable: !0
            })
    }
      , mq = (e, t, n, r) => {
        if (t && typeof t == "object" || typeof t == "function")
            for (let o of cq(t))
                !pq.call(e, o) && o !== n && BI(e, o, {
                    get: () => t[o],
                    enumerable: !(r = uq(t, o)) || r.enumerable
                });
        return e
    }
    ;
    var H9 = (e, t, n) => (n = e != null ? aq(lq(e)) : {},
    mq(t || !e || !e.__esModule ? BI(n, "default", {
        value: e,
        enumerable: !0
    }) : n, e));
    function dq(e) {
        return typeof e == "string" && ["graphing", "geometry-calculator", "graphing-3d"].includes(e)
    }
    function $9(e) {
        return !!(dq(e) || e === "notebook")
    }
    function Y9(e) {
        switch (e) {
        case "graphing-3d":
            return "3d";
        case "geometry-calculator":
            return "geometry";
        case "graphing":
            return "2d";
        case "notebook":
            return "notebook"
        }
    }
    function Z9(e) {
        switch (e) {
        case "2d":
            return "graphing";
        case "3d":
            return "graphing-3d";
        case "geometry":
            return "geometry-calculator";
        default:
            return
        }
    }
    function X9(e, t="") {
        switch (e) {
        case "graphing-3d":
            return `/3d/${t}`;
        case "geometry-calculator":
            return `/geometry/${t}`;
        case "graphing":
            return `/calculator/${t}`;
        case "notebook":
            return `/notebook/${t}`
        }
    }
    var DR, qI, k9, W9, fq, j9, J9, Q9, GI, yq, K9, ej, Gg = Sn( () => {
        DR = "v1.12",
        qI = ["graphing", "geometry-calculator", "graphing-3d"];
        k9 = [...qI, "notebook"];
        W9 = {
            graphing: "/assets/img/apps/graphing/favicon.ico",
            "graphing-3d": "/assets/img/apps/3d/favicon.ico",
            "geometry-calculator": "/assets/img/apps/geometry/favicon.ico",
            notebook: "/assets/img/apps/notebook/favicon.ico"
        },
        fq = ["education", "commercial", "generic", "prospect"],
        j9 = [...fq, "uncategorized"],
        J9 = "inactive",
        Q9 = e => !!e && ["open", "closed", "inactive"].includes(e),
        GI = [2024, 2023, 2022, 2021, 2020],
        yq = 2024,
        K9 = yq - 1,
        ej = ["/art", ...GI.map(e => `/art-${e}`), ...GI.map(e => `/certificate-${e}`), ...GI.map(e => `/winner-certificate-${e}`)]
    }
    );
    var rj, _R = Sn( () => {
        Gg();
        rj = [...qI, "recovery"]
    }
    );
    function zI(e) {
        let t = {};
        for (let n in e)
            t[n] = e[n].getAuthoringConfig();
        return t
    }
    function cf(e, t, n={}) {
        let r = n[e] || e === "validation";
        return `"${e}"${r ? "?" : ""}:${t}`
    }
    var lf, Fc, ie, vr, qg, pf, zg, HI, lu, UI = Sn( () => {
        lf = class {
        }
        ,
        Fc = class extends lf {
            constructor() {
                super(...arguments);
                this._conditionalAttributes = new Map;
                this.arrayBoundsChecks = [];
                this.latexs = [];
                this.labels = []
            }
            ensureNumber() {
                return this.validation = "number",
                this
            }
            ensureString() {
                return this.validation = "string",
                this
            }
            ensureEnum(n) {
                return this.validation = n,
                this
            }
            conditionalAttributes(n, r) {
                return this._conditionalAttributes.set(n, r),
                this
            }
            ensureWithinArrayBounds(n) {
                return this.arrayBoundsChecks.push(n),
                this
            }
            ensureWithinRange(n, r) {
                return this.numberRange = {
                    min: n,
                    max: r
                },
                this
            }
            latex(n) {
                return this.latexs.push(n),
                this
            }
            label(n) {
                return this.labels.push(n),
                this
            }
            validateReferences({validator: n, path: r, value: o, concreteCtx: i}) {
                if (this.arrayBoundsChecks.length)
                    if (!(typeof o == "number" && o >= 1 && Number.isInteger(o)))
                        n.reportError(r, "array index must be an integer of at least 1. Got: " + o);
                    else
                        for (let a of this.arrayBoundsChecks) {
                            let u = [];
                            for (let c of i.nodes)
                                c.type === "array" && c.node === a && u.push(c.rawValue.length);
                            if (u.length !== 1)
                                n.reportError(r, "expected exactly 1 array reference. got: " + u.length);
                            else {
                                let c = u[0];
                                o > c && n.reportError(r, "expected to be at most " + c + ", got: " + o)
                            }
                        }
            }
            addGraphMutations({validator: n, path: r, value: o, graphMutations: i}) {
                for (let s of this.latexs)
                    typeof o == "string" || typeof o == "number" ? i.push({
                        type: "value",
                        identifier: s,
                        value: o + ""
                    }) : typeof o == "boolean" ? i.push({
                        type: "value",
                        identifier: s,
                        value: o ? "1" : "0"
                    }) : n.reportError(r, "unexpected latexValue mutation value type:  " + typeof o);
                for (let s of this.labels)
                    typeof o == "string" ? i.push({
                        type: "label",
                        identifier: s,
                        value: o + ""
                    }) : n.reportError(r, "unexpected label mutation value type:  " + typeof o)
            }
            parseString({path: n, subData: r, validator: o}) {
                let i = r;
                if (!this.validation)
                    return o.reportError(n, 'has no validation. Use "string" for no validation'),
                    i;
                if (o.shouldSkipParsingDataVariable(i))
                    return i;
                if (typeof this.validation == "object")
                    return i in this.validation ? this.validation[i] : (o.reportError(n, "unknown type: " + i),
                    i);
                switch (this.validation) {
                case "string":
                    return i;
                case "number":
                    if (!/^-?[0-9]*[.]?[0-9]*$/.test(i) || !/[0-9]/g.test(i))
                        return o.reportError(n, "expected to be a number but it was not: " + i),
                        NaN;
                    let s = parseFloat(i);
                    return this.numberRange && (s < this.numberRange.min || s > this.numberRange.max) ? (o.reportError(n, "expected to be between " + this.numberRange.min + " and " + this.numberRange.max + " but was: " + i),
                    NaN) : s;
                default:
                    this.validation;
                    break
                }
                return i
            }
        }
        ;
        ie = class extends lf {
            constructor(n) {
                super();
                this.config = n;
                this.computedConditionalAttributes = [];
                for (let o in this.config.attributes) {
                    let i = this.config.attributes[o];
                    if (i instanceof Fc) {
                        let s = i._conditionalAttributes;
                        if (s.size > 0) {
                            let a = [];
                            for (let[u,c] of s.entries())
                                a.push({
                                    value: u,
                                    attributes: c
                                });
                            this.computedConditionalAttributes.push({
                                attribute_key: o,
                                conditions: a
                            })
                        }
                    }
                }
                let r = [];
                for (let o of this.computedConditionalAttributes) {
                    let i = [];
                    for (let s of o.conditions) {
                        for (let a in s.attributes) {
                            let u = s.attributes[a];
                            if (u instanceof Fc && u._conditionalAttributes.size)
                                throw new Error("cannot have nested conditional attributes. Must route through object")
                        }
                        i.push({
                            value: s.value,
                            attributes: zI(s.attributes)
                        })
                    }
                    r.push({
                        attribute_key: o.attribute_key,
                        conditions: i
                    })
                }
                this.authoringConfig = {
                    type: "object",
                    name: n.name,
                    attributes: zI(n.attributes),
                    conditional_attributes: r
                }
            }
            getAuthoringConfig() {
                return this.authoringConfig
            }
            getTypescriptType(n) {
                let r = []
                  , o = [];
                for (let i in this.config.attributes)
                    o.push(cf(i, this.config.attributes[i].getTypescriptType(n)));
                r.push(`{
` + o.join(`,
`) + `
}`);
                for (let i of this.computedConditionalAttributes) {
                    let s = []
                      , a = this.config.attributes[i.attribute_key];
                    if (!a)
                        throw new Error("did not find attribute_key in attributes");
                    if (!(a instanceof Fc))
                        throw new Error("attribute_key must be a primitive attribute");
                    let u = a.getEnumerableValues(n);
                    if (!u)
                        throw new Error("attribute_key must have a finite, enumerable set of values");
                    let c = new Set(u);
                    for (let l of i.conditions) {
                        if (n) {
                            let p = this.config.attributes[i.attribute_key];
                            p instanceof pf && typeof p.validation == "object" && (l = {
                                ...l,
                                value: p.validation[l.value]
                            })
                        }
                        if (o = [],
                        o.push(cf(i.attribute_key, JSON.stringify(l.value))),
                        c.has(l.value))
                            c.delete(l.value);
                        else
                            throw new Error("conditional_attribute specified value multiple times: " + l.value);
                        for (let p in l.attributes)
                            o.push(cf(p, l.attributes[p].getTypescriptType(n)));
                        s.push(`{
` + o.join(`,
`) + `
}`)
                    }
                    if (c.size)
                        for (let l of c)
                            s.push(`{
${cf(i.attribute_key, JSON.stringify(l))}}`);
                    r.push("(" + s.join(" | ") + ")")
                }
                return r.length > 1 ? "(" + r.join(" & ") + ")" : r[0]
            }
            toConcrete({validator: n, path: r, rawValue: o, concreteCtx: i}) {
                if (!o || typeof o != "object") {
                    n.reportError(r, "should be an object");
                    return
                }
                let s = {};
                for (let c in this.config.attributes)
                    s[c] = this.config.attributes[c].toConcrete({
                        path: r + "." + c,
                        validator: n,
                        rawValue: o[c],
                        concreteCtx: i
                    });
                for (let {attribute_key: c, conditions: l} of this.computedConditionalAttributes)
                    for (let {attributes: p, value: m} of l)
                        if (o[c] === m)
                            for (let d in p)
                                s[d] = p[d].toConcrete({
                                    path: r + "." + d,
                                    validator: n,
                                    rawValue: o[d],
                                    concreteCtx: i
                                });
                let a = {};
                for (let c in s) {
                    let l = s[c];
                    l ? a[c] = l.parsedValue : a[c] = void 0
                }
                let u = {
                    type: "object",
                    path: r,
                    rawValue: s,
                    parsedValue: a,
                    node: this
                };
                return i.nodes.push(u),
                u
            }
        }
        ,
        vr = class extends lf {
            constructor(n) {
                super();
                this.config = n;
                let r;
                ("minimum"in n || "maximum"in n) && (r = {
                    maximum: n.maximum,
                    minimum: n.minimum
                }),
                this.authoringConfig = {
                    type: "array",
                    required: !0,
                    name: n.name,
                    count: r,
                    items: n.items.getAuthoringConfig()
                }
            }
            getAuthoringConfig() {
                return this.authoringConfig
            }
            getTypescriptType(n) {
                return `(${this.config.items.getTypescriptType(n)})[]`
            }
            toConcrete({validator: n, path: r, rawValue: o, concreteCtx: i}) {
                if (!Array.isArray(o)) {
                    n.reportError(r, "should be an array");
                    return
                }
                let s = o.map( (c, l) => this.config.items.toConcrete({
                    path: r + "[" + l + "]",
                    validator: n,
                    rawValue: c,
                    concreteCtx: i
                }))
                  , a = s.map(c => {
                    if (c)
                        return c.parsedValue
                }
                )
                  , u = {
                    type: "array",
                    path: r,
                    rawValue: s,
                    parsedValue: a,
                    node: this
                };
                return i.nodes.push(u),
                u
            }
        }
        ,
        qg = class extends Fc {
            constructor(t) {
                super(),
                this.authoringConfig = {
                    type: "string",
                    element: "editor",
                    required: !0,
                    name: t.name,
                    default: t.default
                }
            }
            getAuthoringConfig() {
                return this.authoringConfig
            }
            getEnumerableValues(t) {
                if (typeof this.validation == "object")
                    return t ? Object.values(this.validation) : Object.keys(this.validation)
            }
            getTypescriptType(t) {
                let n = this.getEnumerableValues(t);
                return n ? n.map(r => JSON.stringify(r)).join(" | ") : t && this.validation === "number" ? "number" : "string"
            }
            toConcrete({validator: t, path: n, rawValue: r, concreteCtx: o}) {
                if (typeof r != "string") {
                    t.reportError(n, "should be a string");
                    return
                }
                let i = this.parseString({
                    path: n,
                    subData: r,
                    validator: t
                })
                  , s = {
                    type: "string",
                    path: n,
                    rawValue: r,
                    parsedValue: i,
                    node: this
                };
                return o.nodes.push(s),
                s
            }
        }
        ,
        pf = class extends Fc {
            constructor(t) {
                super(),
                this.authoringConfig = {
                    type: "string",
                    element: "select",
                    required: !0,
                    name: t.name,
                    default: t.default,
                    options: t.options
                }
            }
            getAuthoringConfig() {
                return this.authoringConfig
            }
            getEnumerableValues(t) {
                return typeof this.validation == "object" ? t ? Object.values(this.validation) : Object.keys(this.validation) : this.authoringConfig.options.map(n => n.value)
            }
            getTypescriptType(t) {
                return this.getEnumerableValues(t).map(n => JSON.stringify(n)).join(" | ")
            }
            toConcrete({validator: t, path: n, rawValue: r, concreteCtx: o}) {
                if (typeof r != "string") {
                    t.reportError(n, "should be a string");
                    return
                }
                if (!this.authoringConfig.options.find(a => a.value === r)) {
                    t.reportError(n, "value must be one of the select options: " + r);
                    return
                }
                let i = this.parseString({
                    path: n,
                    subData: r,
                    validator: t
                })
                  , s = {
                    type: "select",
                    path: n,
                    rawValue: r,
                    parsedValue: i,
                    node: this
                };
                return o.nodes.push(s),
                s
            }
        }
        ,
        zg = class extends Fc {
            constructor(t) {
                super(),
                this.authoringConfig = {
                    type: "boolean",
                    required: !0,
                    name: t.name,
                    default: t.default
                }
            }
            getAuthoringConfig() {
                return this.authoringConfig
            }
            getEnumerableValues() {
                return [!0, !1]
            }
            getTypescriptType() {
                return "boolean"
            }
            toConcrete({validator: t, path: n, rawValue: r, concreteCtx: o}) {
                if (typeof r != "boolean") {
                    t.reportError(n, "should be a boolean");
                    return
                }
                let i = {
                    type: "boolean",
                    path: n,
                    rawValue: r,
                    parsedValue: r,
                    node: this
                };
                return o.nodes.push(i),
                i
            }
        }
        ,
        HI = class {
            constructor(t) {
                this.shouldExpectDataVariables = t;
                this.errors = []
            }
            hasErrors() {
                return !!this.errors.length
            }
            getErrors() {
                return this.errors
            }
            reportError(t, n) {
                this.errors.push(t + " - " + n)
            }
            shouldSkipParsingDataVariable(t) {
                return this.shouldExpectDataVariables ? !!(typeof t == "string" && t.includes("{{var:")) : !1
            }
        }
        ;
        lu = class {
            constructor(t) {
                this.optionalSections = {};
                this.config = {};
                for (let n in t) {
                    let r = t[n]
                      , o = n;
                    o.endsWith("?") && (o = o.slice(0, n.length - 1),
                    this.optionalSections[o] = !0),
                    this.config[o] = r
                }
                this.authoringConfig = zI(this.config)
            }
            getAuthoringConfig() {
                return this.authoringConfig
            }
            inflateWithData(t, n) {
                var u;
                let r = new HI(t)
                  , o = {
                    nodes: []
                }
                  , i = {};
                for (let c in this.config)
                    i[c] = this.config[c].toConcrete({
                        path: c,
                        rawValue: n[c],
                        validator: r,
                        concreteCtx: o
                    });
                if (r.hasErrors())
                    return {
                        type: "errors",
                        errors: r.getErrors()
                    };
                let s = [];
                for (let c of o.nodes)
                    switch (c.type) {
                    case "array":
                    case "object":
                        break;
                    case "boolean":
                    case "select":
                    case "string":
                        c.node.validateReferences({
                            path: c.path,
                            validator: r,
                            value: c.parsedValue,
                            concreteCtx: o
                        }),
                        c.node.addGraphMutations({
                            path: c.path,
                            value: c.parsedValue,
                            validator: r,
                            graphMutations: s
                        });
                        break
                    }
                if (r.hasErrors())
                    return {
                        type: "errors",
                        errors: r.getErrors()
                    };
                let a = {};
                for (let c in i)
                    a[c] = (u = i[c]) == null ? void 0 : u.parsedValue;
                return {
                    type: "results",
                    graphMutations: s,
                    parsedValue: a
                }
            }
            getTypescriptType(t) {
                let n = [];
                for (let r in this.config)
                    n.push(cf(r, this.config[r].getTypescriptType(t === "Parsed"), this.optionalSections));
                return `{
` + n.join(`,
`) + `
}`
            }
        }
    }
    );
    function mu(e, t) {
        return new qg({
            name: e,
            default: t
        })
    }
    function Me(e, t) {
        return mu(e, t).ensureNumber()
    }
    function me(e, t) {
        return mu(e, t).ensureString()
    }
    function RR(e, t) {
        return mu(e, t).ensureNumber().ensureWithinRange(-1, 1)
    }
    function kI(e, t) {
        return mu(e, t).ensureEnum({
            left: 1,
            mid: 2,
            right: 3
        })
    }
    function mf(e, t) {
        return mu(e, t).ensureEnum({
            lowest: 1,
            lower: 2,
            low: 3,
            mid: 4,
            high: 5,
            higher: 6,
            highest: 7
        })
    }
    function gq(e, t) {
        return mu(e, t).ensureEnum({
            small: 1,
            medium: 2,
            large: 3
        })
    }
    function ge(e, t) {
        return new zg({
            name: e,
            default: t
        })
    }
    function oc(e, t, n) {
        return new pf({
            name: e,
            default: t,
            options: n
        }).ensureString()
    }
    function yr(e, t) {
        return oc(e, t || "blue", [{
            label: "Blue",
            value: "blue"
        }, {
            label: "Green",
            value: "green"
        }, {
            label: "Orange",
            value: "orange"
        }, {
            label: "Purple",
            value: "purple"
        }, {
            label: "Black",
            value: "black"
        }, {
            label: "Red",
            value: "red"
        }, {
            label: "Gray",
            value: "gray"
        }]).ensureEnum({
            red: "1",
            blue: "2",
            green: "3",
            orange: "4",
            purple: "5",
            black: "6",
            gray: "7"
        })
    }
    function hq(e) {
        return oc(e, "solid", [{
            label: "Solid",
            value: "solid"
        }, {
            label: "Dashed",
            value: "dashed"
        }, {
            label: "Dotted",
            value: "dotted"
        }]).ensureEnum({
            solid: "1",
            dashed: "2",
            dotted: "3"
        })
    }
    function NR(e) {
        return mu(e, "attainable").ensureEnum({
            attainable: 1,
            unattainable: 2,
            efficient: 3
        })
    }
    function Js(e) {
        return mu(e, "none").ensureEnum({
            none: 0,
            negative: -1,
            positive: 1
        })
    }
    function Hg(e) {
        return mu(e, "standard").ensureEnum({
            horizontal: "1",
            gradual: "2",
            standard: "3",
            steep: "4",
            vertical: "5"
        })
    }
    function pu(e, t) {
        return oc(e, t || "none", [{
            label: "None",
            value: "none"
        }, {
            label: "X",
            value: "x"
        }, {
            label: "Y",
            value: "y"
        }, {
            label: "Both",
            value: "both"
        }]).ensureEnum({
            none: "0",
            x: "1",
            y: "2",
            both: "3"
        })
    }
    var Ul, kl, $l, wR, OR, AR, LR, FR, VR, BR, bq, xq, Tq, Iq, Pq, nm, Sq, Eq, Cq, vq, Mq, Dq, aj, $I = Sn( () => {
        UI();
        Ul = new ie({
            name: "Horizontal Axis",
            attributes: {
                min: Me("X Min", "0").latex("x_{min}"),
                max: Me("X Max", "10").latex("x_{max}"),
                res: Me("X Res", "1").latex("x_{res}"),
                major_grid: Me("X Major Grid", "1").latex("x_{majorGrid}"),
                label: me("X Axis Label", "x-Axis").label("x_{label}"),
                tickmark_interval: Me("X Tickmarks", "1").latex("x_{tick}"),
                label_interval: Me("X Labels", "1").latex("x_{labelInt}")
            }
        }),
        kl = new ie({
            name: "Vertical Axis",
            attributes: {
                min: Me("Y Min", "0").latex("y_{min}"),
                max: Me("Y Max", "10").latex("y_{max}"),
                res: Me("Y Res", "1").latex("y_{res}"),
                major_grid: Me("Y Major Grid", "1").latex("y_{majorGrid}"),
                label: me("Y Axis Label", "y-Axis").label("y_{label}"),
                tickmark_interval: Me("Y Tickmarks", "1").latex("y_{tick}"),
                label_interval: Me("Y Labels", "1").latex("y_{labelInt}")
            }
        }),
        $l = new ie({
            name: "Graph Properties",
            attributes: {
                title: me("Graph Title", "Graph Title").label("p_{Title}")
            }
        }),
        wR = new ie({
            name: "Endpoint Mover",
            attributes: {
                appearance: oc("Appearance", "concaveDown", [{
                    label: "Concave Downward",
                    value: "concaveDown"
                }, {
                    label: "Linear",
                    value: "linear"
                }, {
                    label: "Concave Upward",
                    value: "concaveUp"
                }]).ensureEnum({
                    concaveDown: "1",
                    linear: "2",
                    concaveUp: "3"
                }),
                color: yr("Color"),
                style: hq("Style"),
                given: ge("Given", !0).conditionalAttributes(!0, {
                    x_shift: Js("xShift"),
                    y_shift: Js("yShift"),
                    label: me("Label", "")
                }).conditionalAttributes(!1, {
                    group_label: me("Label", ""),
                    validation: new ie({
                        attributes: {
                            x_shift: Js("xShift"),
                            y_shift: Js("yShift")
                        }
                    })
                }),
                group_points: new vr({
                    name: "Endpoint Mover Points",
                    maximum: 3,
                    items: new ie({
                        attributes: {
                            color: yr("Color"),
                            label: me("Label", ""),
                            given: ge("Given", !0).conditionalAttributes(!0, {
                                type: NR("Type")
                            }).conditionalAttributes(!1, {
                                validation: new ie({
                                    attributes: {
                                        type: NR("Type")
                                    }
                                })
                            }),
                            show_coords: ge("Show Coords", !1)
                        }
                    })
                })
            }
        }),
        OR = new vr({
            name: "Increasing Lines",
            items: new ie({
                attributes: {
                    color: yr("Color", "orange"),
                    scale: Me("Scale", "1"),
                    type: Hg("Type"),
                    label: me("Label", ""),
                    ghost_label: me("Ghost Label", ""),
                    post_shift_label: me("Post Shift Label", ""),
                    given: ge("Given", !0).conditionalAttributes(!1, {
                        validation: new ie({
                            attributes: {
                                shift: Js("Shift")
                            }
                        }),
                        shifter_point: new ie({
                            attributes: {
                                show: ge("Shifter Point", !1).conditionalAttributes(!0, {
                                    drop_lines: pu("Drop Lines", "none"),
                                    label: me("Label", ""),
                                    ghost_label: me("Ghost Label", ""),
                                    post_shift_label: me("Post Shift Label", ""),
                                    validation: new ie({
                                        attributes: {
                                            shift: Js("Shift")
                                        }
                                    })
                                })
                            }
                        })
                    }).conditionalAttributes(!0, {
                        shift: Js("Shift"),
                        shifter_point: new ie({
                            attributes: {
                                show: ge("Shifter Point", !1).conditionalAttributes(!0, {
                                    drop_lines: pu("Drop Lines", "none"),
                                    label: me("Label", ""),
                                    ghost_label: me("Ghost Label", ""),
                                    post_shift_label: me("Post Shift Label", ""),
                                    shift: Js("Shift")
                                })
                            }
                        })
                    })
                }
            })
        }),
        AR = new vr({
            name: "Decreasing Lines",
            items: new ie({
                attributes: {
                    color: yr("Color"),
                    scale: Me("Scale", "1"),
                    type: Hg("Type"),
                    label: me("Label", ""),
                    ghost_label: me("Ghost Label", ""),
                    post_shift_label: me("Post Shift Label", ""),
                    given: ge("Given", !0).conditionalAttributes(!1, {
                        validation: new ie({
                            attributes: {
                                shift: Js("Shift")
                            }
                        }),
                        shifter_point: new ie({
                            attributes: {
                                show: ge("Shifter Point", !1).conditionalAttributes(!0, {
                                    drop_lines: pu("Drop Lines", "none"),
                                    label: me("Label", ""),
                                    ghost_label: me("Ghost Label", ""),
                                    post_shift_label: me("Post Shift Label", ""),
                                    validation: new ie({
                                        attributes: {
                                            shift: Js("Shift")
                                        }
                                    })
                                })
                            }
                        })
                    }).conditionalAttributes(!0, {
                        shift: Js("Shift"),
                        shifter_point: new ie({
                            attributes: {
                                show: ge("Shifter Point", !1).conditionalAttributes(!0, {
                                    drop_lines: pu("Drop Lines", "none"),
                                    label: me("Label", ""),
                                    ghost_label: me("Ghost Label", ""),
                                    post_shift_label: me("Post Shift Label", ""),
                                    shift: Js("Shift")
                                })
                            }
                        })
                    })
                }
            })
        }),
        LR = new ie({
            name: "Shifter",
            attributes: {
                increasing_lines: OR,
                decreasing_lines: AR,
                shifter_intersections: new vr({
                    name: "Intersections",
                    items: new ie({
                        attributes: {
                            increasing_line: Me("Increasing Line", "1").ensureWithinArrayBounds(OR),
                            decreasing_line: Me("Decreasing Line", "1").ensureWithinArrayBounds(AR),
                            drop_lines: pu("Drop Lines", "both"),
                            show_coords: ge("Show Coords", !1),
                            show_point: ge("Show Point", !0)
                        }
                    })
                })
            }
        }),
        FR = new ie({
            name: "Cost Curves",
            attributes: {
                role: oc("Role", "taker", [{
                    label: "Price Taker",
                    value: "taker"
                }, {
                    label: "Price Setter Upward MC",
                    value: "setter-upward"
                }, {
                    label: "Price Setter Constant MC",
                    value: "setter-constant"
                }]).conditionalAttributes("taker", {
                    mc: new ie({
                        attributes: {
                            horizontal: kI("MC Horizontal Alignment", "mid"),
                            vertical: mf("MC Vertical Alignment", "mid"),
                            show: ge("Show MC", !0).conditionalAttributes(!0, {
                                label: me("MC Label", "MC"),
                                color: yr("MC Color", "orange")
                            })
                        }
                    }),
                    avc: new ie({
                        attributes: {
                            vertical: mf("AVC Vertical Alignment", "mid"),
                            show: ge("Show AVC", !0).conditionalAttributes(!0, {
                                label: me("AVC Label", "AVC"),
                                color: yr("AVC Color", "purple")
                            })
                        }
                    }),
                    atc: new ie({
                        attributes: {
                            show: ge("Show ATC", !0).conditionalAttributes(!0, {
                                label: me("ATC Label", "ATC"),
                                color: yr("ATC Color", "green")
                            })
                        }
                    })
                }).conditionalAttributes("setter-upward", {
                    mc: new ie({
                        attributes: {
                            horizontal: kI("MC Horizontal Alignment", "mid"),
                            vertical: mf("MC Vertical Alignment", "mid"),
                            show: ge("Show MC", !0).conditionalAttributes(!0, {
                                label: me("MC Label", "MC"),
                                color: yr("MC Color", "orange")
                            })
                        }
                    }),
                    avc: new ie({
                        attributes: {
                            show: ge("Show AVC", !0).conditionalAttributes(!0, {
                                label: me("AVC Label", "AVC"),
                                color: yr("AVC Color", "purple")
                            })
                        }
                    }),
                    atc: new ie({
                        attributes: {
                            horizontal: kI("ATC Horizontal Alignment", "mid"),
                            vertical: mf("ATC Vertical Alignment", "mid"),
                            show: ge("Show ATC", !0).conditionalAttributes(!0, {
                                label: me("ATC Label", "ATC"),
                                color: yr("ATC Color", "green")
                            })
                        }
                    })
                }).conditionalAttributes("setter-constant", {
                    mc: new ie({
                        attributes: {
                            vertical: mf("MC Vertical Alignment", "mid"),
                            show: ge("Show MC", !0).conditionalAttributes(!0, {
                                label: me("MC Label", "MC"),
                                color: yr("MC Color", "orange")
                            })
                        }
                    }),
                    atc: new ie({
                        attributes: {
                            show: ge("Show ATC", !0).conditionalAttributes(!0, {
                                label: me("ATC Label", "ATC"),
                                color: yr("ATC Color", "green")
                            })
                        }
                    }),
                    fc_scale: gq("FC Scale", "medium")
                })
            }
        }),
        VR = new ie({
            attributes: {
                curves: new vr({
                    name: "Indifference Curves",
                    minimum: 1,
                    items: new ie({
                        attributes: {
                            color: yr("Color", "blue"),
                            x_coord: Me("X", ""),
                            y_coord: Me("Y", ""),
                            slope: Me("Slope", "").ensureWithinRange(-1 / 0, 0),
                            substitutability: Me("Substitutability", ""),
                            label: me("Label", ""),
                            point: new ie({
                                attributes: {
                                    role: oc("Role", "hidden", [{
                                        value: "hidden",
                                        label: "Hidden"
                                    }, {
                                        value: "given",
                                        label: "Given"
                                    }, {
                                        value: "required",
                                        label: "Required"
                                    }]).conditionalAttributes("given", {
                                        label: me("Label", ""),
                                        color: yr("Color", "blue"),
                                        drop_lines: pu("Drop Lines", "none"),
                                        show_coords: ge("Show Coords", !0)
                                    }).conditionalAttributes("required", {
                                        label: me("Label", ""),
                                        color: yr("Color", "blue"),
                                        drop_lines: pu("Drop Lines", "none"),
                                        show_coords: ge("Show Coords", !0)
                                    })
                                }
                            }),
                            line: new ie({
                                attributes: {
                                    role: oc("Role", "hidden", [{
                                        value: "hidden",
                                        label: "Hidden"
                                    }, {
                                        value: "given",
                                        label: "Given"
                                    }, {
                                        value: "required",
                                        label: "Required"
                                    }]).conditionalAttributes("given", {
                                        label: me("Label", ""),
                                        color: yr("Color", "blue"),
                                        show_coords: ge("Show Coords", !0),
                                        show_x_int: ge("Show X Intercept", !1),
                                        show_y_int: ge("Show Y Intercept", !1),
                                        show_slope: ge("Show Slope", !1)
                                    }).conditionalAttributes("required", {
                                        label: me("Label", ""),
                                        color: yr("Color", "blue"),
                                        show_coords: ge("Show Coords", !0),
                                        show_x_int: ge("Show X Intercept", !1),
                                        show_y_int: ge("Show Y Intercept", !1),
                                        show_slope: ge("Show Slope", !1)
                                    })
                                }
                            })
                        }
                    })
                })
            }
        }),
        BR = new ie({
            name: "Input Driven Market",
            attributes: {
                input_variable: oc("Input Variable", "Y", [{
                    label: "X",
                    value: "X"
                }, {
                    label: "Y",
                    value: "Y"
                }]).ensureEnum({
                    X: 2,
                    Y: 1
                }).conditionalAttributes("X", {
                    editorOnly_x_below: me("Left Equilibrium", ""),
                    editorOnly_x_above: me("Right Equilibrium", "")
                }).conditionalAttributes("Y", {
                    editorOnly_y_below: me("Below Equilibrium", ""),
                    editorOnly_y_above: me("Above Equilibrium", "")
                }),
                input_value: Me("Default Value", ""),
                input_color: yr("Input Color", "green"),
                input_decimals: Me("Input Decimals", "2"),
                market_label: me("Market Label", ""),
                input_label: me("Input Label", ""),
                input_units: me("Input Units", ""),
                increasing_line: new ie({
                    attributes: {
                        show: ge("Show", !0).conditionalAttributes(!0, {
                            color: yr("Color", "orange"),
                            type: Hg("Type"),
                            label: me("Label", ""),
                            ghost_label: me("Ghost Label", ""),
                            post_shift_label: me("Post Shift Label", ""),
                            output_label: me("Output Label", ""),
                            output_units: me("Output Units", ""),
                            output_decimals: Me("Output Decimals", "2"),
                            shift: new ie({
                                attributes: {
                                    show: ge("Allow Shift", !1).conditionalAttributes(!0, {
                                        default_value: Me("Shift Default Value", "0"),
                                        shift_coefficient: Me("Shift Coefficient", "1"),
                                        shift_decimals: Me("Shift Decimals", "2"),
                                        title: me("Shift Title", ""),
                                        label: me("Shift Label", ""),
                                        units: me("Shift Units", "")
                                    })
                                }
                            })
                        })
                    }
                }),
                decreasing_line: new ie({
                    attributes: {
                        show: ge("Show", !0).conditionalAttributes(!0, {
                            color: yr("Color", "blue"),
                            type: Hg("Type"),
                            label: me("Label", ""),
                            ghost_label: me("Ghost Label", ""),
                            post_shift_label: me("Post Shift Label", ""),
                            output_label: me("Output Label", ""),
                            output_units: me("Output Units", ""),
                            output_decimals: Me("Output Decimals", "2"),
                            shift: new ie({
                                attributes: {
                                    show: ge("Allow Shift", !1).conditionalAttributes(!0, {
                                        default_value: Me("Shift Default Value", "0"),
                                        shift_coefficient: Me("Shift Coefficient", "1"),
                                        shift_decimals: Me("Shift Decimals", "2"),
                                        title: me("Shift Title", ""),
                                        label: me("Shift Label", ""),
                                        units: me("Shift Units", "")
                                    })
                                }
                            })
                        })
                    }
                }),
                shifter_intersection: new ie({
                    attributes: {
                        show: ge("Show", !0).conditionalAttributes(!0, {
                            drop_lines: pu("Drop Lines", "both")
                        })
                    }
                }),
                below_eqm: new ie({
                    attributes: {
                        show: ge("Show", !0).conditionalAttributes(!0, {
                            label: me("Label", ""),
                            units: me("Units", ""),
                            eqm_decimals: Me("Decimals", "2")
                        })
                    }
                }),
                above_eqm: new ie({
                    attributes: {
                        show: ge("Show", !0).conditionalAttributes(!0, {
                            label: me("Label", ""),
                            units: me("Units", ""),
                            eqm_decimals: Me("Decimals", "2")
                        })
                    }
                })
            }
        }),
        bq = new ie({
            attributes: {
                color: yr("Color"),
                connected: ge("Connected", !1),
                given: ge("Given", !0).conditionalAttributes(!0, {
                    when_given: new ie({
                        attributes: {
                            group_points: new vr({
                                name: "Group Points",
                                minimum: 1,
                                items: new ie({
                                    name: "Group Points",
                                    attributes: {
                                        x_coord: Me("X", ""),
                                        y_coord: Me("Y", ""),
                                        label: me("Label", ""),
                                        drop_lines: pu("Drop Lines"),
                                        show_point: ge("Show Point", !0).conditionalAttributes(!0, {
                                            show_coords: ge("Show Coords", !1)
                                        })
                                    }
                                })
                            })
                        }
                    })
                }).conditionalAttributes(!1, {
                    when_required: new ie({
                        attributes: {
                            group_label: me("Group Label", ""),
                            group_points: new vr({
                                name: "Group Points",
                                minimum: 1,
                                items: new ie({
                                    name: "Group Points",
                                    attributes: {
                                        drop_lines: pu("Drop Lines"),
                                        show_coords: ge("Show Coords", !1),
                                        validation: new ie({
                                            attributes: {
                                                x_coord: Me("X", ""),
                                                y_coord: Me("Y", "")
                                            }
                                        })
                                    }
                                })
                            })
                        }
                    })
                })
            }
        }),
        xq = new ie({
            attributes: {
                color: yr("Color"),
                given: ge("Given", !0).conditionalAttributes(!0, {
                    when_given: new ie({
                        attributes: {
                            group_lines: new vr({
                                name: "Group Lines",
                                minimum: 1,
                                items: new ie({
                                    attributes: {
                                        show_x_int: ge("Show X Intercept", !1),
                                        show_y_int: ge("Show Y Intercept", !1),
                                        show_slope: ge("Show Slope", !1),
                                        use_slope: ge("Use Slope", !0).conditionalAttributes(!0, {
                                            when_slope: new ie({
                                                attributes: {
                                                    x_coord_1: Me("X1", ""),
                                                    y_coord_1: Me("Y1", ""),
                                                    label_1: me("Label", ""),
                                                    slope: Me("Slope", "")
                                                }
                                            })
                                        }).conditionalAttributes(!1, {
                                            when_not_slope: new ie({
                                                attributes: {
                                                    x_coord_1: Me("X1", ""),
                                                    y_coord_1: Me("Y1", ""),
                                                    label_1: me("Label", ""),
                                                    x_coord_2: Me("X2", ""),
                                                    y_coord_2: Me("Y2", ""),
                                                    label_2: me("Label", "")
                                                }
                                            })
                                        }),
                                        show_points: ge("Show Points", !0).conditionalAttributes(!0, {
                                            show_coords: ge("Show Coords", !1)
                                        })
                                    }
                                })
                            })
                        }
                    })
                }).conditionalAttributes(!1, {
                    when_required: new ie({
                        attributes: {
                            group_label: me("Group Label", ""),
                            group_lines: new vr({
                                name: "Group Lines",
                                minimum: 1,
                                items: new ie({
                                    attributes: {
                                        show_coords: ge("Show Coords", !1),
                                        show_x_int: ge("Show X Intercept", !1),
                                        show_y_int: ge("Show Y Intercept", !1),
                                        show_slope: ge("Show Slope", !1),
                                        use_slope: ge("Use Slope", !0).conditionalAttributes(!0, {
                                            when_slope: new ie({
                                                attributes: {
                                                    validation: new ie({
                                                        attributes: {
                                                            x_coord_1: Me("X1", ""),
                                                            y_coord_1: Me("Y1", ""),
                                                            slope: Me("Slope", "")
                                                        }
                                                    })
                                                }
                                            })
                                        }).conditionalAttributes(!1, {
                                            when_not_slope: new ie({
                                                attributes: {
                                                    validation: new ie({
                                                        attributes: {
                                                            x_coord_1: Me("X1", ""),
                                                            y_coord_1: Me("Y1", ""),
                                                            x_coord_2: Me("X2", ""),
                                                            y_coord_2: Me("Y2", "")
                                                        }
                                                    })
                                                }
                                            })
                                        })
                                    }
                                })
                            })
                        }
                    })
                })
            }
        }),
        Tq = new ie({
            attributes: {
                color: yr("Color"),
                given: ge("Given", !0).conditionalAttributes(!0, {
                    when_given: new ie({
                        attributes: {
                            group_curves: new vr({
                                name: "Group Curves",
                                minimum: 1,
                                items: new ie({
                                    attributes: {
                                        curve_points: new vr({
                                            name: "Curve Points",
                                            minimum: 3,
                                            maximum: 6,
                                            items: new ie({
                                                attributes: {
                                                    x_coord: Me("X", ""),
                                                    y_coord: Me("Y", ""),
                                                    label: me("Label", "")
                                                }
                                            })
                                        }),
                                        show_points: ge("Show Points", !0).conditionalAttributes(!0, {
                                            show_coords: ge("Show Coords", !1)
                                        })
                                    }
                                })
                            })
                        }
                    })
                }).conditionalAttributes(!1, {
                    when_required: new ie({
                        attributes: {
                            group_label: me("Group Label", ""),
                            group_curves: new vr({
                                minimum: 1,
                                name: "Group Curves",
                                items: new ie({
                                    attributes: {
                                        show_coords: ge("Show Coords", !1),
                                        curve_points: new vr({
                                            name: "Curve Points",
                                            minimum: 3,
                                            maximum: 6,
                                            items: new ie({
                                                attributes: {
                                                    validation: new ie({
                                                        attributes: {
                                                            x_coord: Me("X", ""),
                                                            y_coord: Me("Y", "")
                                                        }
                                                    })
                                                }
                                            })
                                        })
                                    }
                                })
                            })
                        }
                    })
                })
            }
        }),
        Iq = new ie({
            attributes: {
                color: yr("Color"),
                given: ge("Given", !0).conditionalAttributes(!0, {
                    when_given: new ie({
                        attributes: {
                            group_mono_arcs: new vr({
                                name: "Group Monotonic Arcs",
                                minimum: 1,
                                items: new ie({
                                    attributes: {
                                        concavity: RR("Concavity", ""),
                                        x_coord_1: Me("X1", ""),
                                        y_coord_1: Me("Y1", ""),
                                        label_1: me("Label 1", ""),
                                        x_coord_2: Me("X2", ""),
                                        y_coord_2: Me("Y2", ""),
                                        label_2: me("Label 2", ""),
                                        show_points: ge("Show Points", !0).conditionalAttributes(!0, {
                                            show_coords: ge("Show Coords", !1)
                                        })
                                    }
                                })
                            })
                        }
                    })
                }).conditionalAttributes(!1, {
                    when_required: new ie({
                        attributes: {
                            group_label: me("Group Label", ""),
                            group_mono_arcs: new vr({
                                minimum: 1,
                                name: "Group Monotonic Arcs",
                                items: new ie({
                                    attributes: {
                                        show_coords: ge("Show Coords", !1),
                                        concavity: RR("Concavity", ""),
                                        validation: new ie({
                                            attributes: {
                                                x_coord_1: Me("X1", ""),
                                                y_coord_1: Me("Y1", ""),
                                                x_coord_2: Me("X2", ""),
                                                y_coord_2: Me("Y2", "")
                                            }
                                        })
                                    }
                                })
                            })
                        }
                    })
                })
            }
        }),
        Pq = new ie({
            attributes: {
                color: yr("Color"),
                given: ge("Given", !0).conditionalAttributes(!0, {
                    when_given: new ie({
                        attributes: {
                            group_polygons: new vr({
                                name: "Group Polygons",
                                minimum: 1,
                                items: new ie({
                                    attributes: {
                                        show_area: ge("Show Area", !1),
                                        show_perimeter: ge("Show Perimeter", !1),
                                        fill_pattern: ge("Fill Pattern", !0),
                                        polygon_points: new vr({
                                            name: "Polygon Points",
                                            minimum: 3,
                                            maximum: 10,
                                            items: new ie({
                                                attributes: {
                                                    x_coord: Me("X", ""),
                                                    y_coord: Me("Y", ""),
                                                    label: me("Label", "")
                                                }
                                            })
                                        }),
                                        show_points: ge("Show Points", !0).conditionalAttributes(!0, {
                                            show_coords: ge("Show Coords", !1)
                                        })
                                    }
                                })
                            })
                        }
                    })
                }).conditionalAttributes(!1, {
                    when_required: new ie({
                        attributes: {
                            group_label: me("Group Label", ""),
                            group_polygons: new vr({
                                minimum: 1,
                                name: "Group Polygons",
                                items: new ie({
                                    attributes: {
                                        show_coords: ge("Show Coords", !1),
                                        show_area: ge("Show Area", !1),
                                        show_perimeter: ge("Show Perimeter", !1),
                                        fill_pattern: ge("Fill Pattern", !0),
                                        polygon_points: new vr({
                                            name: "Polygon Points",
                                            minimum: 3,
                                            maximum: 10,
                                            items: new ie({
                                                attributes: {
                                                    validation: new ie({
                                                        attributes: {
                                                            x_coord: Me("X", ""),
                                                            y_coord: Me("Y", "")
                                                        }
                                                    })
                                                }
                                            })
                                        })
                                    }
                                })
                            })
                        }
                    })
                })
            }
        }),
        nm = new vr({
            name: "Common Components",
            items: new ie({
                name: "Common Component",
                attributes: {
                    notes: mu("Notes:", "").ensureString(),
                    object_type: oc("Component Type", "common_point", [{
                        label: "Point",
                        value: "common_point"
                    }, {
                        label: "Line",
                        value: "common_line"
                    }, {
                        label: "Curve",
                        value: "common_curve"
                    }, {
                        label: "Monotonic Arc",
                        value: "common_mono_arc"
                    }, {
                        label: "Polygon",
                        value: "common_polygon"
                    }]).conditionalAttributes("common_point", {
                        when_point: bq
                    }).conditionalAttributes("common_line", {
                        when_line: xq
                    }).conditionalAttributes("common_curve", {
                        when_curve: Tq
                    }).conditionalAttributes("common_mono_arc", {
                        when_mono_arc: Iq
                    }).conditionalAttributes("common_polygon", {
                        when_polygon: Pq
                    })
                }
            })
        }),
        Sq = new lu({
            dcg_x_axis: Ul,
            dcg_y_axis: kl,
            dcg_graph_properties: $l,
            dcg_common_components: nm
        }),
        Eq = new lu({
            dcg_x_axis: Ul,
            dcg_y_axis: kl,
            dcg_graph_properties: $l,
            dcg_common_components: nm,
            dcg_endpoint_mover: wR
        }),
        Cq = new lu({
            dcg_x_axis: Ul,
            dcg_y_axis: kl,
            dcg_graph_properties: $l,
            dcg_common_components: nm,
            dcg_shifter: LR
        }),
        vq = new lu({
            dcg_x_axis: Ul,
            dcg_y_axis: kl,
            dcg_graph_properties: $l,
            dcg_common_components: nm,
            dcg_cost_curves: FR
        }),
        Mq = new lu({
            dcg_x_axis: Ul,
            dcg_y_axis: kl,
            dcg_graph_properties: $l,
            dcg_common_components: nm,
            dcg_indifference_curves: VR
        }),
        Dq = new lu({
            dcg_x_axis: Ul,
            dcg_y_axis: kl,
            dcg_graph_properties: $l,
            dcg_input_driven_market: BR
        }),
        aj = new lu({
            dcg_x_axis: Ul,
            dcg_y_axis: kl,
            dcg_graph_properties: $l,
            "dcg_common_components?": nm,
            "dcg_endpoint_mover?": wR,
            "dcg_shifter?": LR,
            "dcg_cost_curves?": FR,
            "dcg_indifference_curves?": VR,
            "dcg_input_driven_market?": BR
        })
    }
    );
    var YI = Sn( () => {
        $I()
    }
    );
    var GR = Sn( () => {
        YI()
    }
    );
    var qR = Sn( () => {
        $I();
        GR();
        UI();
        YI()
    }
    );
    var zR, HR = Sn( () => {
        zR = e => Object.entries(e)
    }
    );
    var UR = Sn( () => {}
    );
    var kR = Sn( () => {}
    );
    var Pj, $R = Sn( () => {
        Pj = e => e !== null && (typeof e == "object" || typeof e == "function")
    }
    );
    var ue, YR = Sn( () => {
        ue = e => Object.keys(e)
    }
    );
    var Cj, vj, ZR = Sn( () => {
        Cj = e => ["3d", "art-contest", "authenticate"].includes(e),
        vj = e => ["art-contest"].includes(e)
    }
    );
    var XR = Sn( () => {}
    );
    var _j, WR = Sn( () => {
        _j = (e, t) => t.reduce( (n, r) => (r in e && (n[r] = e[r]),
        n), {})
    }
    );
    function jR(e) {
        var r;
        let[t,n] = (r = Nq.exec(e)) != null ? r : [];
        return n
    }
    function wq(e) {
        let t = jR(e);
        return t ? Oq.test(t) : !0
    }
    function Nj(e) {
        let t = jR(e);
        return t ? Aq.test(t) : !1
    }
    function Oj(e, t) {
        if (e === "" || !t || _q.test(e) || Rq.test(e) || !wq(e))
            return e;
        let n = encodeURIComponent(t);
        if (e.length) {
            let r = e.split("#")
              , o = /\?/.test(e) ? `${r[0]}&lang=${n}` : `${r[0]}?lang=${n}`;
            return r[1] !== void 0 ? `${o}#${r[1]}` : o
        } else
            return `?lang=${n}`
    }
    var _q, Rq, Nq, Oq, Aq, JR = Sn( () => {
        _q = /lang=[A-Za-z]+/,
        Rq = /(cl|learn|help).desmos.com/,
        Nq = /^(?:https?:)?(?:\/\/)?([^\s:\/\?]+)/i,
        Oq = /(^desmos\.com$)|(\.desmos.com$)/,
        Aq = /^(local|knox-pr-\d+)\.desmos\.com$/
    }
    );
    var QR = Sn( () => {}
    );
    var Lq, Lj, KR = Sn( () => {
        Lq = 0,
        Lj = (e="") => `${e}${++Lq}`
    }
    );
    var ZI = Sn( () => {
        HR();
        UR();
        kR();
        $R();
        YR();
        ZR();
        XR();
        WR();
        JR();
        QR();
        KR()
    }
    );
    var Fq, Vq, jj, Jj, e1 = Sn( () => {
        ZI();
        Fq = {
            "knox-app-config": {
                title: "App configuration"
            },
            calculatorBeta: {
                title: "Beta tester"
            },
            apStemRFI: {
                title: "AP Stem RFI"
            },
            artExpo: {
                title: "Art Expo testing"
            },
            savedGraphsRedesign: {
                title: "Saved graphs redesign"
            },
            apiConfiguration: {
                title: "API Configuration"
            },
            desNotebook: {
                title: "Notebook product"
            },
            selfService: {
                title: "Self Service"
            }
        },
        Vq = {
            "dcg-actions": {
                add: !0,
                remove: !0
            }
        },
        jj = [...ue(Fq), ...ue(Vq)],
        Jj = ["desNotebook"]
    }
    );
    var t1 = Sn( () => {}
    );
    var n1 = Sn( () => {}
    );
    var r1 = Sn( () => {}
    );
    var o1 = Sn( () => {}
    );
    var i1 = Sn( () => {}
    );
    var s1 = Sn( () => {}
    );
    var a1 = Sn( () => {}
    );
    var u1 = Sn( () => {}
    );
    var c1 = Sn( () => {}
    );
    var l1 = Sn( () => {}
    );
    var p1 = Sn( () => {}
    );
    var m1 = Sn( () => {}
    );
    var d1 = Sn( () => {
        e1();
        t1();
        n1();
        r1();
        o1();
        i1();
        s1();
        a1();
        u1();
        c1();
        l1();
        p1();
        m1()
    }
    );
    var f7, f1 = Sn( () => {
        f7 = () => {}
    }
    );
    var y1, h7, b7, g1 = Sn( () => {
        Gg();
        y1 = DR.replace(/\./g, "_"),
        h7 = `dcg-calculator-api-container-${y1}`,
        b7 = `dcg-matrix-api-container-${y1}`
    }
    );
    var $r = Sn( () => {
        _R();
        Gg();
        qR();
        ZI();
        d1();
        f1();
        g1()
    }
    );
    var h1 = function() {
        {
            let e = function() {}
              , t = ["log", "info", "warn", "error", "assert", "dir", "clear", "profile", "profileEnd", "time", "timeEnd", "group", "groupCollapsed", "groupEnd", "trace"]
              , n = {}
              , r = function(o) {
                typeof window != "undefined" && window.console && window.console[o] ? n[o] = function() {
                    Function.prototype.apply.call(window.console[o], window.console, arguments)
                }
                : n[o] = e
            };
            return t.forEach(r),
            n
        }
    }()
      , D7 = h1
      , {log: _7, warn: R7, error: N7, assert: O7, dir: A7, clear: w7, profile: L7, profileEnd: F7, time: V7, timeEnd: B7, group: G7, groupCollapsed: q7, groupEnd: z7, trace: H7} = h1;
    $r();
    function Vi(e) {
        let t = e;
        if (t && typeof t.toJSON == "function" && (t = t.toJSON()),
        !t || typeof t != "object")
            return t;
        if (Array.isArray(t))
            return t.map(Vi);
        let n = {};
        for (let r in t)
            t.hasOwnProperty(r) && (n[r] = Vi(t[r]));
        return n
    }
    var Ug = typeof self == "object" && self.self === self && self || typeof global == "object" && global.global === global && global || Function("return this")() || {}
      , Yg = Array.prototype
      , jI = Object.prototype
      , b1 = typeof Symbol != "undefined" ? Symbol.prototype : null
      , $7 = Yg.push
      , E1 = Yg.slice
      , kg = jI.toString
      , Bq = jI.hasOwnProperty
      , Gq = Array.isArray
      , x1 = Object.keys
      , T1 = Object.create
      , qq = Ug.isNaN
      , Y7 = Ug.isFinite
      , XI = function() {};
    function eo(e) {
        if (e instanceof eo)
            return e;
        if (!(this instanceof eo))
            return new eo(e);
        this._wrapped = e
    }
    var Z7 = eo.VERSION = "1.10.2";
    function Zg(e, t, n) {
        if (t === void 0)
            return e;
        switch (n == null ? 3 : n) {
        case 1:
            return function(r) {
                return e.call(t, r)
            }
            ;
        case 3:
            return function(r, o, i) {
                return e.call(t, r, o, i)
            }
            ;
        case 4:
            return function(r, o, i, s) {
                return e.call(t, r, o, i, s)
            }
        }
        return function() {
            return e.apply(t, arguments)
        }
    }
    function C1(e, t, n) {
        return e == null ? dz : ic(e) ? Zg(e, t, n) : am(e) && !sm(e) ? fz(e) : V1(e)
    }
    eo.iteratee = v1;
    function v1(e, t) {
        return C1(e, t, 1 / 0)
    }
    function sc(e, t, n) {
        return eo.iteratee !== v1 ? eo.iteratee(e, t) : C1(e, t, n)
    }
    function Ms(e, t) {
        return t = t == null ? e.length - 1 : +t,
        function() {
            for (var n = Math.max(arguments.length - t, 0), r = Array(n), o = 0; o < n; o++)
                r[o] = arguments[o + t];
            switch (t) {
            case 0:
                return e.call(this, r);
            case 1:
                return e.call(this, arguments[0], r);
            case 2:
                return e.call(this, arguments[0], arguments[1], r)
            }
            var i = Array(t + 1);
            for (o = 0; o < t; o++)
                i[o] = arguments[o];
            return i[t] = r,
            e.apply(this, i)
        }
    }
    function zq(e) {
        if (!am(e))
            return {};
        if (T1)
            return T1(e);
        XI.prototype = e;
        var t = new XI;
        return XI.prototype = null,
        t
    }
    function M1(e) {
        return function(t) {
            return t == null ? void 0 : t[e]
        }
    }
    function om(e, t) {
        return e != null && Bq.call(e, t)
    }
    function D1(e, t) {
        for (var n = t.length, r = 0; r < n; r++) {
            if (e == null)
                return;
            e = e[t[r]]
        }
        return n ? e : void 0
    }
    var Hq = Math.pow(2, 53) - 1
      , Vc = M1("length");
    function du(e) {
        var t = Vc(e);
        return typeof t == "number" && t >= 0 && t <= Hq
    }
    function im(e, t, n) {
        t = Zg(t, n);
        var r, o;
        if (du(e))
            for (r = 0,
            o = e.length; r < o; r++)
                t(e[r], r, e);
        else {
            var i = va(e);
            for (r = 0,
            o = i.length; r < o; r++)
                t(e[i[r]], i[r], e)
        }
        return e
    }
    function Xg(e, t, n) {
        t = sc(t, n);
        for (var r = !du(e) && va(e), o = (r || e).length, i = Array(o), s = 0; s < o; s++) {
            var a = r ? r[s] : s;
            i[s] = t(e[a], a, e)
        }
        return i
    }
    function _1(e) {
        var t = function(n, r, o, i) {
            var s = !du(n) && va(n)
              , a = (s || n).length
              , u = e > 0 ? 0 : a - 1;
            for (i || (o = n[s ? s[u] : u],
            u += e); u >= 0 && u < a; u += e) {
                var c = s ? s[u] : u;
                o = r(o, n[c], c, n)
            }
            return o
        };
        return function(n, r, o, i) {
            var s = arguments.length >= 3;
            return t(n, Zg(r, i, 4), o, s)
        }
    }
    var X7 = _1(1)
      , W7 = _1(-1);
    function Uq(e, t, n) {
        var r = [];
        return t = sc(t, n),
        im(e, function(o, i, s) {
            t(o, i, s) && r.push(o)
        }),
        r
    }
    function rm(e, t, n, r) {
        return du(e) || (e = df(e)),
        (typeof n != "number" || r) && (n = 0),
        jq(e, t, n) >= 0
    }
    var j7 = Ms(function(e, t, n) {
        var r, o;
        return ic(t) ? o = t : sm(t) && (r = t.slice(0, -1),
        t = t[t.length - 1]),
        Xg(e, function(i) {
            var s = o;
            if (!s) {
                if (r && r.length && (i = D1(i, r)),
                i == null)
                    return;
                s = i[t]
            }
            return s == null ? s : s.apply(i, n)
        })
    });
    function R1(e, t) {
        return Xg(e, V1(t))
    }
    function kq(e, t, n) {
        var r = -1 / 0, o = -1 / 0, i, s;
        if (t == null || typeof t == "number" && typeof e[0] != "object" && e != null) {
            e = du(e) ? e : df(e);
            for (var a = 0, u = e.length; a < u; a++)
                i = e[a],
                i != null && i > r && (r = i)
        } else
            t = sc(t, n),
            im(e, function(c, l, p) {
                s = t(c, l, p),
                (s > o || s === -1 / 0 && r === -1 / 0) && (r = c,
                o = s)
            });
        return r
    }
    function J7(e, t, n) {
        var r = 1 / 0, o = 1 / 0, i, s;
        if (t == null || typeof t == "number" && typeof e[0] != "object" && e != null) {
            e = du(e) ? e : df(e);
            for (var a = 0, u = e.length; a < u; a++)
                i = e[a],
                i != null && i < r && (r = i)
        } else
            t = sc(t, n),
            im(e, function(c, l, p) {
                s = t(c, l, p),
                (s < o || s === 1 / 0 && r === 1 / 0) && (r = c,
                o = s)
            });
        return r
    }
    function Q7(e) {
        return $q(e, 1 / 0)
    }
    function $q(e, t, n) {
        if (t == null || n)
            return du(e) || (e = df(e)),
            e[P1(e.length - 1)];
        var r = du(e) ? iz(e) : df(e)
          , o = Vc(r);
        t = Math.max(Math.min(t, o), 0);
        for (var i = o - 1, s = 0; s < t; s++) {
            var a = P1(s, i)
              , u = r[s];
            r[s] = r[a],
            r[a] = u
        }
        return r.slice(0, t)
    }
    function JI(e, t, n) {
        var r = 0;
        return t = sc(t, n),
        R1(Xg(e, function(o, i, s) {
            return {
                value: o,
                index: r++,
                criteria: t(o, i, s)
            }
        }).sort(function(o, i) {
            var s = o.criteria
              , a = i.criteria;
            if (s !== a) {
                if (s > a || s === void 0)
                    return 1;
                if (s < a || a === void 0)
                    return -1
            }
            return o.index - i.index
        }), "value")
    }
    function Wg(e, t) {
        return function(n, r, o) {
            var i = t ? [[], []] : {};
            return r = sc(r, o),
            im(n, function(s, a) {
                var u = r(s, a, n);
                e(i, s, u)
            }),
            i
        }
    }
    var K7 = Wg(function(e, t, n) {
        om(e, n) ? e[n].push(t) : e[n] = [t]
    })
      , eJ = Wg(function(e, t, n) {
        e[n] = t
    })
      , tJ = Wg(function(e, t, n) {
        om(e, n) ? e[n]++ : e[n] = 1
    });
    var nJ = Wg(function(e, t, n) {
        e[n ? 0 : 1].push(t)
    }, !0);
    function Yl(e, t, n, r) {
        r = r || [];
        for (var o = r.length, i = 0, s = Vc(e); i < s; i++) {
            var a = e[i];
            if (du(a) && (sm(a) || $g(a)))
                if (t)
                    for (var u = 0, c = a.length; u < c; )
                        r[o++] = a[u++];
                else
                    Yl(a, t, n, r),
                    o = r.length;
            else
                n || (r[o++] = a)
        }
        return r
    }
    function rJ(e, t) {
        return Yl(e, t, !1)
    }
    var oJ = Ms(function(e, t) {
        return KI(e, t)
    });
    function QI(e, t, n, r) {
        mz(t) || (r = n,
        n = t,
        t = !1),
        n != null && (n = sc(n, r));
        for (var o = [], i = [], s = 0, a = Vc(e); s < a; s++) {
            var u = e[s]
              , c = n ? n(u, s, e) : u;
            t && !n ? ((!s || i !== c) && o.push(u),
            i = c) : n ? rm(i, c) || (i.push(c),
            o.push(u)) : rm(o, u) || o.push(u)
        }
        return o
    }
    var iJ = Ms(function(e) {
        return QI(Yl(e, !0, !0))
    });
    var KI = Ms(function(e, t) {
        return t = Yl(t, !0, !0),
        Uq(e, function(n) {
            return !rm(t, n)
        })
    });
    function Yq(e) {
        for (var t = e && kq(e, Vc).length || 0, n = Array(t), r = 0; r < t; r++)
            n[r] = R1(e, r);
        return n
    }
    var sJ = Ms(Yq);
    function N1(e) {
        return function(t, n, r) {
            n = sc(n, r);
            for (var o = Vc(t), i = e > 0 ? 0 : o - 1; i >= 0 && i < o; i += e)
                if (n(t[i], i, t))
                    return i;
            return -1
        }
    }
    var Zq = N1(1)
      , Xq = N1(-1);
    function Wq(e, t, n, r) {
        n = sc(n, r, 1);
        for (var o = n(t), i = 0, s = Vc(e); i < s; ) {
            var a = Math.floor((i + s) / 2);
            n(e[a]) < o ? i = a + 1 : s = a
        }
        return i
    }
    function O1(e, t, n) {
        return function(r, o, i) {
            var s = 0
              , a = Vc(r);
            if (typeof i == "number")
                e > 0 ? s = i >= 0 ? i : Math.max(i + a, s) : a = i >= 0 ? Math.min(i + 1, a) : i + a + 1;
            else if (n && i && a)
                return i = n(r, o),
                r[i] === o ? i : -1;
            if (o !== o)
                return i = t(E1.call(r, s, a), pz),
                i >= 0 ? i + s : -1;
            for (i = e > 0 ? s : a - 1; i >= 0 && i < a; i += e)
                if (r[i] === o)
                    return i;
            return -1
        }
    }
    var jq = O1(1, Zq, Wq)
      , aJ = O1(-1, Xq);
    function uJ(e, t) {
        if (t == null || t < 1)
            return [];
        for (var n = [], r = 0, o = e.length; r < o; )
            n.push(E1.call(e, r, r += t));
        return n
    }
    function A1(e, t, n, r, o) {
        if (!(r instanceof t))
            return e.apply(n, o);
        var i = zq(e.prototype)
          , s = e.apply(i, o);
        return am(s) ? s : i
    }
    var Jq = Ms(function(e, t, n) {
        if (!ic(e))
            throw new TypeError("Bind must be called on a function");
        var r = Ms(function(o) {
            return A1(e, r, t, this, n.concat(o))
        });
        return r
    })
      , jg = Ms(function(e, t) {
        var n = jg.placeholder
          , r = function() {
            for (var o = 0, i = t.length, s = Array(i), a = 0; a < i; a++)
                s[a] = t[a] === n ? arguments[o++] : t[a];
            for (; o < arguments.length; )
                s.push(arguments[o++]);
            return A1(e, r, this, this, s)
        };
        return r
    });
    jg.placeholder = eo;
    var cJ = Ms(function(e, t) {
        t = Yl(t, !1, !1);
        var n = t.length;
        if (n < 1)
            throw new Error("bindAll must be passed function names");
        for (; n--; ) {
            var r = t[n];
            e[r] = Jq(e[r], e)
        }
    });
    var w1 = Ms(function(e, t, n) {
        return setTimeout(function() {
            return e.apply(null, n)
        }, t)
    })
      , lJ = jg(w1, eo, 1);
    function pJ(e, t, n) {
        var r, o, i, s, a = 0;
        n || (n = {});
        var u = function() {
            a = n.leading === !1 ? 0 : S1(),
            r = null,
            s = e.apply(o, i),
            r || (o = i = null)
        }
          , c = function() {
            var l = S1();
            !a && n.leading === !1 && (a = l);
            var p = t - (l - a);
            return o = this,
            i = arguments,
            p <= 0 || p > t ? (r && (clearTimeout(r),
            r = null),
            a = l,
            s = e.apply(o, i),
            r || (o = i = null)) : !r && n.trailing !== !1 && (r = setTimeout(u, p)),
            s
        };
        return c.cancel = function() {
            clearTimeout(r),
            a = 0,
            r = o = i = null
        }
        ,
        c
    }
    function mJ(e, t, n) {
        var r, o, i = function(a, u) {
            r = null,
            u && (o = e.apply(a, u))
        }, s = Ms(function(a) {
            if (r && clearTimeout(r),
            n) {
                var u = !r;
                r = setTimeout(i, t),
                u && (o = e.apply(this, a))
            } else
                r = w1(i, t, this, a);
            return o
        });
        return s.cancel = function() {
            clearTimeout(r),
            r = null
        }
        ,
        s
    }
    function Qq(e) {
        return function() {
            return !e.apply(this, arguments)
        }
    }
    function Kq(e, t) {
        var n;
        return function() {
            return --e > 0 && (n = t.apply(this, arguments)),
            e <= 1 && (t = null),
            n
        }
    }
    var dJ = jg(Kq, 2)
      , L1 = !{
        toString: null
    }.propertyIsEnumerable("toString")
      , I1 = ["valueOf", "isPrototypeOf", "toString", "propertyIsEnumerable", "hasOwnProperty", "toLocaleString"];
    function F1(e, t) {
        var n = I1.length
          , r = e.constructor
          , o = ic(r) && r.prototype || jI
          , i = "constructor";
        for (om(e, i) && !rm(t, i) && t.push(i); n--; )
            i = I1[n],
            i in e && e[i] !== o[i] && !rm(t, i) && t.push(i)
    }
    function va(e) {
        if (!am(e))
            return [];
        if (x1)
            return x1(e);
        var t = [];
        for (var n in e)
            om(e, n) && t.push(n);
        return L1 && F1(e, t),
        t
    }
    function eP(e) {
        if (!am(e))
            return [];
        var t = [];
        for (var n in e)
            t.push(n);
        return L1 && F1(e, t),
        t
    }
    function df(e) {
        for (var t = va(e), n = t.length, r = Array(n), o = 0; o < n; o++)
            r[o] = e[t[o]];
        return r
    }
    function ez(e) {
        for (var t = {}, n = va(e), r = 0, o = n.length; r < o; r++)
            t[e[n[r]]] = n[r];
        return t
    }
    function tP(e, t) {
        return function(n) {
            var r = arguments.length;
            if (t && (n = Object(n)),
            r < 2 || n == null)
                return n;
            for (var o = 1; o < r; o++)
                for (var i = arguments[o], s = e(i), a = s.length, u = 0; u < a; u++) {
                    var c = s[u];
                    (!t || n[c] === void 0) && (n[c] = i[c])
                }
            return n
        }
    }
    var tz = tP(eP)
      , nz = tP(va);
    function rz(e, t, n) {
        return t in n
    }
    var oz = Ms(function(e, t) {
        var n = {}
          , r = t[0];
        if (e == null)
            return n;
        ic(r) ? (t.length > 1 && (r = Zg(r, t[1])),
        t = eP(e)) : (r = rz,
        t = Yl(t, !1, !1),
        e = Object(e));
        for (var o = 0, i = t.length; o < i; o++) {
            var s = t[o]
              , a = e[s];
            r(a, s, e) && (n[s] = a)
        }
        return n
    })
      , fJ = Ms(function(e, t) {
        var n = t[0], r;
        return ic(n) ? (n = Qq(n),
        t.length > 1 && (r = t[1])) : (t = Xg(Yl(t, !1, !1), String),
        n = function(o, i) {
            return !rm(t, i)
        }
        ),
        oz(e, n, r)
    })
      , yJ = tP(eP, !0);
    function iz(e) {
        return am(e) ? sm(e) ? e.slice() : tz({}, e) : e
    }
    function sz(e, t) {
        var n = va(t)
          , r = n.length;
        if (e == null)
            return !r;
        for (var o = Object(e), i = 0; i < r; i++) {
            var s = n[i];
            if (t[s] !== o[s] || !(s in o))
                return !1
        }
        return !0
    }
    function WI(e, t, n, r) {
        if (e === t)
            return e !== 0 || 1 / e === 1 / t;
        if (e == null || t == null)
            return !1;
        if (e !== e)
            return t !== t;
        var o = typeof e;
        return o !== "function" && o !== "object" && typeof t != "object" ? !1 : az(e, t, n, r)
    }
    function az(e, t, n, r) {
        e instanceof eo && (e = e._wrapped),
        t instanceof eo && (t = t._wrapped);
        var o = kg.call(e);
        if (o !== kg.call(t))
            return !1;
        switch (o) {
        case "[object RegExp]":
        case "[object String]":
            return "" + e == "" + t;
        case "[object Number]":
            return +e != +e ? +t != +t : +e == 0 ? 1 / +e === 1 / t : +e == +t;
        case "[object Date]":
        case "[object Boolean]":
            return +e == +t;
        case "[object Symbol]":
            return b1.valueOf.call(e) === b1.valueOf.call(t)
        }
        var i = o === "[object Array]";
        if (!i) {
            if (typeof e != "object" || typeof t != "object")
                return !1;
            var s = e.constructor
              , a = t.constructor;
            if (s !== a && !(ic(s) && s instanceof s && ic(a) && a instanceof a) && "constructor"in e && "constructor"in t)
                return !1
        }
        n = n || [],
        r = r || [];
        for (var u = n.length; u--; )
            if (n[u] === e)
                return r[u] === t;
        if (n.push(e),
        r.push(t),
        i) {
            if (u = e.length,
            u !== t.length)
                return !1;
            for (; u--; )
                if (!WI(e[u], t[u], n, r))
                    return !1
        } else {
            var c = va(e), l;
            if (u = c.length,
            va(t).length !== u)
                return !1;
            for (; u--; )
                if (l = c[u],
                !(om(t, l) && WI(e[l], t[l], n, r)))
                    return !1
        }
        return n.pop(),
        r.pop(),
        !0
    }
    function $o(e, t) {
        return WI(e, t)
    }
    function gJ(e) {
        return e == null ? !0 : du(e) && (sm(e) || uz(e) || $g(e)) ? e.length === 0 : va(e).length === 0
    }
    function Ds(e) {
        return function(t) {
            return kg.call(t) === "[object " + e + "]"
        }
    }
    var sm = Gq || Ds("Array");
    function am(e) {
        var t = typeof e;
        return t === "function" || t === "object" && !!e
    }
    var $g = Ds("Arguments")
      , ic = Ds("Function")
      , uz = Ds("String")
      , cz = Ds("Number")
      , hJ = Ds("Date")
      , bJ = Ds("RegExp")
      , xJ = Ds("Error")
      , TJ = Ds("Symbol")
      , IJ = Ds("Map")
      , PJ = Ds("WeakMap")
      , SJ = Ds("Set")
      , EJ = Ds("WeakSet");
    (function() {
        $g(arguments) || ($g = function(e) {
            return om(e, "callee")
        }
        )
    }
    )();
    var lz = Ug.document && Ug.document.childNodes;
    typeof /./ != "function" && typeof Int8Array != "object" && typeof lz != "function" && (ic = function(e) {
        return typeof e == "function" || !1
    }
    );
    function pz(e) {
        return cz(e) && qq(e)
    }
    function mz(e) {
        return e === !0 || e === !1 || kg.call(e) === "[object Boolean]"
    }
    function dz(e) {
        return e
    }
    function V1(e) {
        return sm(e) ? function(t) {
            return D1(t, e)
        }
        : M1(e)
    }
    function fz(e) {
        return e = nz({}, e),
        function(t) {
            return sz(t, e)
        }
    }
    function P1(e, t) {
        return t == null && (t = e,
        e = 0),
        e + Math.floor(Math.random() * (t - e + 1))
    }
    var S1 = Date.now || function() {
        return new Date().getTime()
    }
      , B1 = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#x27;",
        "`": "&#x60;"
    }
      , yz = ez(B1);
    function G1(e) {
        var t = function(i) {
            return e[i]
        }
          , n = "(?:" + va(e).join("|") + ")"
          , r = RegExp(n)
          , o = RegExp(n, "g");
        return function(i) {
            return i = i == null ? "" : "" + i,
            r.test(i) ? i.replace(o, t) : i
        }
    }
    var q1 = G1(B1)
      , CJ = G1(yz);
    var gz = 0;
    function vJ(e) {
        var t = ++gz + "";
        return e ? e + t : t
    }
    var MJ = eo.templateSettings = {
        evaluate: /<%([\s\S]+?)%>/g,
        interpolate: /<%=([\s\S]+?)%>/g,
        escape: /<%-([\s\S]+?)%>/g
    };
    function z1(e, t) {
        return e._chain ? eo(t).chain() : t
    }
    im(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function(e) {
        var t = Yg[e];
        eo.prototype[e] = function() {
            var n = this._wrapped;
            return t.apply(n, arguments),
            (e === "shift" || e === "splice") && n.length === 0 && delete n[0],
            z1(this, n)
        }
    });
    im(["concat", "join", "slice"], function(e) {
        var t = Yg[e];
        eo.prototype[e] = function() {
            return z1(this, t.apply(this._wrapped, arguments))
        }
    });
    eo.prototype.value = function() {
        return this._wrapped
    }
    ;
    eo.prototype.valueOf = eo.prototype.toJSON = eo.prototype.value;
    eo.prototype.toString = function() {
        return String(this._wrapped)
    }
    ;
    function ff(e, t) {
        let n = {};
        for (let r in t)
            t.hasOwnProperty(r) && ($o(e[r], t[r]) || (n[r] = t[r]));
        return n
    }
    function yf(e, t) {
        let n, r = {};
        for (let o in t)
            t.hasOwnProperty(o) && ($o(e[o], t[o]) || (r[o] = t[o],
            n = r));
        return n
    }
    function _J(e, t) {
        t || (t = {});
        let n = {};
        for (let r in e)
            e.hasOwnProperty(r) && !t.hasOwnProperty(r) && (n[r] = Vi(e[r]));
        for (let r in t)
            t.hasOwnProperty(r) && (n[r] = t[r]);
        return n
    }
    var Jt = {
        NONE: "NONE",
        X: "X",
        Y: "Y",
        XY: "XY",
        AUTO: "AUTO"
    };
    function hz(e) {
        return !e || e[0].type === "none" && e[1].type === "none" ? Jt.NONE : e[1].type === "none" ? Jt.X : e[0].type === "none" ? Jt.Y : Jt.XY
    }
    function U1(e, t) {
        let n = hz(t);
        switch (e) {
        case Jt.NONE:
            return Jt.NONE;
        case Jt.AUTO:
            return n;
        case Jt.XY:
            return n;
        case Jt.X:
            return n === Jt.X || n === Jt.XY ? Jt.X : Jt.NONE;
        case Jt.Y:
            return n === Jt.Y || n === Jt.XY ? Jt.Y : Jt.NONE;
        default:
            return Jt.NONE
        }
    }
    var k1 = {
        DEFAULT: "DEFAULT",
        NONE: "NONE",
        POSITIVE: "POSITIVE",
        BOTH: "BOTH"
    }
      , NJ = {
        NONE: "NONE",
        POSITIVE: "POSITIVE",
        BOTH: "BOTH"
    };
    var $1 = {
        DEFAULT: "default",
        CENTER: "center",
        CENTER_AUTO: "center_auto",
        AUTO_CENTER: "auto_center",
        ABOVE: "above",
        ABOVE_LEFT: "above_left",
        ABOVE_RIGHT: "above_right",
        ABOVE_AUTO: "above_auto",
        BELOW: "below",
        BELOW_LEFT: "below_left",
        BELOW_RIGHT: "below_right",
        BELOW_AUTO: "below_auto",
        LEFT: "left",
        AUTO_LEFT: "auto_left",
        RIGHT: "right",
        AUTO_RIGHT: "auto_right"
    };
    var Bc = {
        LOOP_FORWARD_REVERSE: "LOOP_FORWARD_REVERSE",
        LOOP_FORWARD: "LOOP_FORWARD",
        PLAY_ONCE: "PLAY_ONCE",
        PLAY_INDEFINITELY: "PLAY_INDEFINITELY"
    };
    function wJ(e) {
        switch (e) {
        case Bc.LOOP_FORWARD:
            return "dcg-icon-arrow-one-way";
        case Bc.LOOP_FORWARD_REVERSE:
            return "dcg-icon-arrow-two-way";
        case Bc.PLAY_ONCE:
            return "dcg-icon-arrow-once";
        case Bc.PLAY_INDEFINITELY:
            return "dcg-icon-arrow-infinite"
        }
    }
    var Gc = {
        POINT: "POINT",
        OPEN: "OPEN",
        CROSS: "CROSS",
        SQUARE: "SQUARE",
        PLUS: "PLUS",
        TRIANGLE: "TRIANGLE",
        DIAMOND: "DIAMOND",
        STAR: "STAR"
    }
      , cm = {
        SOLID: "SOLID",
        DASHED: "DASHED",
        DOTTED: "DOTTED"
    };
    function BJ({from: e, to: t, props: n}) {
        for (let r in n)
            n[r] && e.hasOwnProperty(r) && (t[r] = Vi(e[r]))
    }
    function GJ(e, t) {
        for (let n in e)
            e.hasOwnProperty(n) && (t[n] = e[n])
    }
    function Y1(e, t) {
        let n = {};
        for (let r in t)
            t.hasOwnProperty(r) && (n[r] = e[r]);
        return n
    }
    function qJ(e) {
        let t = {};
        for (let n in e)
            e.hasOwnProperty(n) && (t[n] = !0);
        return t
    }
    var Yr = {
        xmin: -5,
        xmax: 5,
        ymin: -5,
        ymax: 5,
        zmin: -5,
        zmax: 5
    };
    $r();
    $r();
    var Et = {};
    cu(Et, {
        actionMergeFreeVariable: () => wE,
        addArgumentsToDefinition: () => ay,
        addTypeError: () => qS,
        adjacentMixedNumber: () => pb,
        adjacentNumbers: () => aC,
        andTypeError: () => JS,
        ansUndefined: () => Rv,
        assignmentsUnsupported: () => Av,
        badEqualitySlice: () => Lu,
        badExport: () => xy,
        badForInputListDependency: () => Uv,
        badForIntervalDependency: () => kv,
        badImplicitCall: () => lb,
        badIntegralBoundDependency: () => vv,
        badLogExponent: () => EC,
        badProductBoundDependency: () => hv,
        badSampleSize: () => Dv,
        badSumBoundDependency: () => gv,
        badSymbolContext: () => py,
        badTrigExponent: () => SC,
        badTupleDimensions: () => sC,
        baseCaseCannotDependOnRecursiveParameter: () => LS,
        baseCaseTooComplicatedUsePiecewise: () => Wf,
        baseCasesMustAllHaveSameReturnType: () => Xf,
        binaryOperatorMissingOperand: () => Lm,
        blankExpression: () => iy,
        boxplotBreadthInvalid: () => YE,
        boxplotOffsetInvalid: () => $E,
        cannotAssignColor: () => ZC,
        cannotRedefine: () => Fm,
        cannotRestrict: () => $C,
        cannotRestrictTrianglesWithList: () => YC,
        cannotRestrictWithEquality: () => XC,
        cannotSubscript: () => RC,
        cantCombineSphericalAndCylindrical: () => Tb,
        cdfBoundInvalid: () => HC,
        cdfRequiresArguments: () => WE,
        cdfTooManyArguments: () => jE,
        chiSquareListLengthMismatch: () => Bb,
        chiSquareListTooShort: () => Gb,
        chiSquareVariableListLength: () => by,
        clickableObjectAlreadyAssigned: () => y$,
        clickableObjectAssignmentNotDefined: () => f$,
        clickableObjectAssignmentNotIdentifier: () => g$,
        clickableObjectInvalidExpression: () => h$,
        colonMissingCondition: () => MC,
        colorArity: () => KE,
        combineTypeError: () => ab,
        comparatorTypeError: () => jS,
        complexPlottedTableCell: () => u$,
        complicatedDoubleInequality: () => Eb,
        complicatedPolarImplicit: () => tv,
        computedColumnHeader: () => rM,
        constantUnsupported: () => my,
        coordinateAccessTypeError: () => eE,
        customRegressionsUnsupported: () => Vv,
        cycle: () => NC,
        deeplyNested: () => BE,
        dependsOnDeletedGeoObject: () => Kv,
        derivativeMissingBody: () => Ev,
        derivativeRecursiveCycle: () => xE,
        derivativeTypeError: () => gE,
        derivativeTypeErrorRespect: () => hE,
        derivativeVariableTypeError: () => bE,
        differentialWithSuperscript: () => Tv,
        distributionAsFunction: () => Mb,
        divideTypeError: () => $S,
        domainMaxInvalid: () => qC,
        domainMaxLessThanMin: () => zC,
        domainMinInvalid: () => GC,
        dotLHSConstantNumberError: () => nb,
        dotLHSTypeError: () => iE,
        dotRHSPropertyError: () => sE,
        duplicateFunctionParameter: () => DC,
        duplicateUpdateRules: () => RE,
        eachBaseCaseArgumentMustBeSimple: () => Kh,
        emptyParen: () => oy,
        emptyPipe: () => PC,
        emptyRadical: () => xC,
        emptyRadicalIndex: () => TC,
        emptySquareBracket: () => IC,
        emptySubscript: () => fb,
        emptySuperscript: () => fC,
        equationRequired: () => Cb,
        equationsUnsupported: () => dy,
        eventHandlerTypeError: () => ey,
        expectedArgumentToBeButFound: () => BS,
        exponentTypeError: () => YS,
        featureUnavailable: () => Gv,
        fractionEmpty: () => dC,
        fractionMissingDenominator: () => mC,
        fractionMissingNumerator: () => pC,
        fractionsUnavailable: () => wb,
        functionDefinitionsUnsupported: () => wv,
        functionNameAsParameter: () => _C,
        functionNotDefined: () => hb,
        functionOnlyWorksInComplexMode: () => gA,
        functionRequiresNumberOfArguments: () => VS,
        functionTypeError: () => $i,
        functionUnsupported: () => Ga,
        geometryLengthTypeError: () => rE,
        getLogInternalErrors: () => r$,
        gpuLongProduct: () => kE,
        gpuLongSum: () => UE,
        gpuMaxListSize: () => hp,
        gpuUnsupportedFunction: () => wm,
        gpuUnsupportedIntegral: () => zE,
        gpuUnsupportedRecursion: () => HE,
        gpuVariableListLength: () => Qc,
        gpuVariableProduct: () => cb,
        gpuVariableSum: () => ub,
        heterogeneousList: () => ty,
        identifierAsFunction: () => mb,
        identifierIsNotFunction: () => db,
        illegalBinWidth: () => ly,
        illegalDotCall: () => Kf,
        implicitsDisabled: () => ev,
        incorrectProductLowerBound: () => yv,
        incorrectSumLowerBound: () => fv,
        indexTypeError: () => Qf,
        inequalitiesDisabled: () => Ib,
        inequalitiesUnsupported: () => Lv,
        integralArgumentTypeError: () => yE,
        integralLowerBoundTypeError: () => dE,
        integralMissingBody: () => Sv,
        integralMissingBound: () => bv,
        integralMissingDifferential: () => xv,
        integralUpperBoundTypeError: () => fE,
        internal: () => F,
        invalidDependentFirstTableColumn: () => c$,
        invalidDoubleEquality3d: () => rv,
        invalidDoubleInequality3d: () => nv,
        invalidDoubleInequalityVariables: () => Pb,
        invalidFirstTableColumn: () => sv,
        invalidFunctionName: () => Ab,
        invalidHalfEmptyRange: () => pv,
        invalidImplicitVariables: () => Tp,
        invalidImplicitVariables3d: () => QC,
        invalidInequalityVariables: () => JC,
        invalidIntervalComprehensionArity: () => tM,
        invalidIntervalComprehensionParameter: () => Bm,
        invalidIntervalComprehensionReturnType: () => eM,
        invalidLHS: () => WC,
        invalidNestedIntervalComprehension: () => nM,
        invalidOperatorName: () => gC,
        invalidPvalue: () => NS,
        invalidRegressionParameter: () => av,
        invalidSubscript: () => yC,
        invalidTableEntry: () => uy,
        invalidTableHeader: () => iv,
        listComprehensionIncorrectInput: () => Hv,
        listComprehensionInputListTypeError: () => zv,
        listTypeError: () => gp,
        logScaleBoxPlot: () => VE,
        logScaleDotPlot: () => FE,
        logScaleHistogram: () => LE,
        logScaleTypeError: () => Am,
        logbaseUnsupported: () => Ov,
        malformedList: () => iC,
        malformedPoint: () => oC,
        matrixAddDimensions: () => x$,
        matrixAssignment: () => b$,
        matrixElementTypeError: () => E$,
        matrixFractionalPower: () => P$,
        matrixInvalidVariable: () => C$,
        matrixMultiplyDimensions: () => I$,
        matrixPowerDimensions: () => S$,
        matrixSubtractDimensions: () => T$,
        maxListSize: () => ny,
        methodRequiresList: () => el,
        mismatchedBraces: () => Cv,
        mismatchedDoubleInequality: () => Sb,
        mixedComparatorChain: () => XS,
        mixedRestrictionEquation: () => qE,
        multipleEqualityRestrictions: () => GE,
        multiplyDefined: () => sy,
        multiplyTypeError: () => Jf,
        multiplyTypeError2D: () => US,
        multiplyTypeError3D: () => kS,
        multiplyTypeErrorCross: () => HS,
        negativeTypeError: () => ZS,
        nonArithmeticRange: () => cy,
        nonListDoubleReducer: () => cv,
        nonListParameterizedReducer: () => lv,
        nonSquareDeterminant: () => l$,
        nonSquareInverse: () => m$,
        nonSquareTrace: () => p$,
        nonlinearRegressionInference: () => OS,
        opaque: () => jf,
        optimizationError: () => uv,
        orTypeError: () => QS,
        parameterAlreadyDefined: () => bb,
        parenthesesUnavailable: () => qv,
        pdfWrongArity: () => XE,
        percentMissingOf: () => Mv,
        piecewiseBranchTypeError: () => IE,
        piecewiseConditionTypeError: () => ib,
        piecewiseMissingCondition: () => CC,
        piecewisePartMissingCondition: () => vC,
        pointTypeError: () => KS,
        pointsUnsupported: () => Bv,
        polygonTwoNumbersError: () => ry,
        polygonUnsupportedIn3d: () => Nb,
        primeVariableTypeError: () => TE,
        primeWithoutParen: () => gb,
        primedFunctionArity: () => bp,
        productArgumentTypeError: () => mE,
        productInfiniteBoundError: () => ob,
        productLowerBoundTypeError: () => lE,
        productMissingBody: () => Pv,
        productMissingBound: () => dv,
        productUpperBoundTypeError: () => pE,
        randomArity: () => JE,
        randomFromBroadcastDistribution: () => QE,
        recursionCyclicDependency: () => FS,
        recursionDoesNotTerminate: () => $P,
        recursionInRegression: () => EE,
        recursiveDepthExceeded: () => YP,
        recursiveFunctionCannotDependOnFreeVariable: () => wS,
        recursiveFunctionMissingBaseCase: () => Qh,
        recursiveFunctionMissingBaseCaseWithMetadata: () => AS,
        regressionTypeError: () => ME,
        regressionsUnsupported: () => Fv,
        selfReferentialBaseCase: () => OC,
        selfReferentialFunctions: () => xp,
        setLogInternalErrors: () => RS,
        shadowedIndex: () => xb,
        shadowedIntegrationVariable: () => Db,
        shadowedListComprehensionInput: () => Lb,
        singleVariableImplicitEquationsDisabled: () => KC,
        singularInverse: () => d$,
        sliderLimitReferencesExport: () => wC,
        sliderMaxInvalid: () => FC,
        sliderMaxLessThanMin: () => VC,
        sliderMinInvalid: () => LC,
        sliderStepInvalid: () => BC,
        substitutionAmbiguousComma: () => tl,
        substitutionBodyAction: () => M$,
        substitutionBodyDependsOnRegression: () => jv,
        substitutionDuplicateSymbol: () => Jv,
        substitutionFunctionLHS: () => hy,
        substitutionIllegalLHS: () => gy,
        substitutionInvalidAssignments: () => yy,
        substitutionLocalLHS: () => Wv,
        substitutionNested: () => Fb,
        substitutionRecursiveCallLHS: () => Qv,
        substitutionTypeError: () => v$,
        substitutionUnsupportedInterval: () => Vb,
        subtractTypeError: () => zS,
        sumArgumentTypeError: () => cE,
        sumInfiniteBoundError: () => rb,
        sumLowerBoundTypeError: () => aE,
        sumMissingBody: () => Iv,
        sumMissingBound: () => mv,
        sumUpperBoundTypeError: () => uE,
        superscriptWithPrime: () => bC,
        tableEntryTypeError: () => SE,
        tableHeaderTypeError: () => PE,
        tableRegressionInvalidData: () => vE,
        tableRegressionLogWithNegative: () => i$,
        tableRegressionTypeError: () => CE,
        tdistWrongArity: () => a$,
        threeDLengthTypeError: () => oE,
        tickerMinStepNonNegativeNumber: () => AC,
        tokenWithSubscript: () => uC,
        tooManyArguments: () => ZE,
        tooManyVariables: () => xn,
        transformationDefinitionTypeError: () => tE,
        transformationTypeError: () => nE,
        ttestListTooShort: () => _b,
        unaryOperatorMissingLeft: () => cC,
        unaryOperatorMissingRight: () => lC,
        unexpectedEquality: () => GS,
        unexpectedInequality: () => tb,
        unexpectedPrime: () => yb,
        unexpectedSubscript: () => hC,
        unexpectedSymbol: () => Mi,
        unexportableTableRegression: () => oM,
        unplottableEqualityChain: () => ov,
        unplottableLongInequalityChain: () => WS,
        unplottablePolarFunction: () => jC,
        unrecognizedSymbol: () => eb,
        updateRuleFunctionLHS: () => AE,
        updateRuleIllegalLHS: () => OE,
        updateRuleLocalLHS: () => sb,
        updateRuleNonIdentifierLHS: () => _E,
        updateRuleTypeError: () => DE,
        updateRuleUndefinedLHS: () => NE,
        useRForCylindricalCoordinates: () => kC,
        useRhoForSphericalCoordinates: () => UC,
        using3dObjectIn2d: () => Kc,
        variableAsFunction: () => vb,
        variableLengthDistributionList: () => fy,
        variableLengthIntegralDependsOnIntegrationVariable: () => Xv,
        variableLengthProductBodyDependsOnIndex: () => Zv,
        variableLengthSumBodyDependsOnIndex: () => Yv,
        variableLengthTopLevelList: () => $v,
        variableSeed: () => _v,
        variableUnsupported: () => Ob,
        variablesUnsupported: () => Nv,
        viewportBoundTypeError: () => s$,
        warnComplexImplicit: () => Vm,
        writeIntegral: () => Rb,
        wrongArity: () => Ba,
        wrongArityLengthAsCount: () => eC,
        wrongDoubleReducerArity: () => nC,
        wrongParameterizedReducerArity: () => tC,
        zeroArgReducer: () => rC
    });
    var La = {};
    cu(La, {
        DEFAULT_COMPLEX_EVALUATION_LABEL_OPTIONS: () => MS,
        DEFAULT_EVALUATION_LABEL_OPTIONS: () => lA,
        canDisplayAsFraction: () => mA,
        complexNumberLabel: () => kf,
        complexPlainMathNumberLabel: () => DS,
        formatSymbol: () => $,
        identifierToHTML: () => K8,
        identifierToLatex: () => go,
        latexToIdentifier: () => Bs,
        numericLabel: () => Zh,
        point: () => $8,
        point3dLabel: () => t$,
        pointLabel: () => e$,
        trimLatex: () => Au,
        truncatedHTMLLabel: () => Xh,
        truncatedLatexLabel: () => Jc,
        truncatedPlainmathLabel: () => Rm,
        value: () => vS
    });
    function Z1(e, t, n) {
        if (e = lm(e),
        n > 0) {
            let r = lm(t);
            return e < r && (e += 2 * Math.PI),
            (e - r) / n
        } else {
            let r = lm(t + n);
            return e < r && (e += 2 * Math.PI),
            1 + (e - r) / n
        }
    }
    function Jg(e, t, n) {
        e = lm(e);
        let r = lm(t)
          , o = lm(t + n);
        if (n < 0) {
            let i = r;
            r = o,
            o = i
        }
        return r < o ? r <= e && e <= o : r <= e || e <= o
    }
    function lm(e) {
        let t = 2 * Math.PI;
        return (e % t + t) % t
    }
    function UJ(e, t) {
        if (!(isNaN(e) || isNaN(t)))
            return e >= 0 ? Math.atan(t / e) : Math.atan(t / e) + Math.PI
    }
    var _s = Math.hypot;
    function ac(e, t) {
        return e > 0 == t > 0 ? e + .5 * (t - e) : .5 * (e + t)
    }
    function xz(e, t, n, r, o, i) {
        return e * r + t * o + n * i
    }
    function Qs(e, t, n, r, o, i, s, a, u) {
        let c = _s(s - r, a - o, u - i);
        return c === 0 ? 0 : xz((e - r) / c, (t - o) / c, (n - i) / c, (s - r) / c, (a - o) / c, (u - i) / c)
    }
    function Tz(e, t, n, r, o, i) {
        let s = Qs(e, t, 0, n, r, 0, o, i, 0);
        return s <= 0 ? [n, r] : s >= 1 ? [o, i] : [n + s * (o - n), r + s * (i - r)]
    }
    function Iz(e, t, n, r, o, i, s, a, u) {
        let c = Qs(e, t, n, r, o, i, s, a, u);
        return c <= 0 ? [r, o, i] : c >= 1 ? [s, a, u] : [r + c * (s - r), o + c * (a - o), i + c * (u - i)]
    }
    function $J(e, t, n, r, o, i, s, a) {
        let u = Qs(e, t, 0, n, r, 0, o, i, 0);
        return u <= 0 && !s ? [n, r] : u >= 1 && !a ? [o, i] : [n + u * (o - n), r + u * (i - r)]
    }
    function X1(e, t, n, r, o, i) {
        let s = Tz(e, t, n, r, o, i);
        return _s(e - s[0], t - s[1])
    }
    function W1(e, t, n, r, o, i, s, a, u) {
        let c = Iz(e, t, n, r, o, i, s, a, u);
        return _s(e - c[0], t - c[1], n - c[2])
    }
    function YJ(e, t, n, r, o, i, s) {
        let a = Math.atan2(t - r, e - n);
        if (Jg(a, i, s - i))
            return [o * Math.cos(a) + n, o * Math.sin(a) + r]
    }
    function Bi(e, t, n=1) {
        if (e === t)
            return !0;
        if (!isFinite(e) || !isFinite(t))
            return !1;
        if (n > 50)
            throw new Error("Within " + (52 - n) + " bits isn't really approximate any more");
        let r = Math.max(Math.max(Math.abs(e), Math.abs(t)), 1)
          , o = n === 1 ? .5 : Math.pow(.5, n);
        return r === r + o * Math.abs(t - e)
    }
    function ZJ(e) {
        return Math.round(e - .5) + .5
    }
    function cc(e, t=1e6) {
        if (e === 1 / 0)
            return {
                n: 1 / 0,
                d: 1
            };
        if (e === -1 / 0)
            return {
                n: -1 / 0,
                d: 1
            };
        if (!isFinite(e))
            return {
                n: NaN,
                d: 1
            };
        let n, r = 0, o = 1, i = 1, s = 0, a, u;
        for (; n = Math.floor(e),
        a = n * o + r,
        u = n * s + i,
        !(u > t || (r = o,
        i = s,
        o = a,
        s = u,
        e === n)); )
            e = 1 / (e - n);
        return {
            n: o,
            d: s
        }
    }
    var Lo = {};
    cu(Lo, {
        LruCache: () => Pm,
        RECURSIVE_COMPUTATION_LIMIT: () => uO,
        RECURSIVE_DEPTH_LIMIT: () => qf,
        RecursiveFunctionResult: () => aO,
        SYMBOL_DIVERGES: () => sO,
        TerminationStatus: () => cO,
        _chisqccdf: () => FP,
        _chisqcdf: () => LP,
        _complexGCD: () => ES,
        _poissonpdf: () => Xc,
        acosh: () => rO,
        acot: () => CH,
        acoth: () => AH,
        acsc: () => vH,
        acsch: () => OH,
        addTangentAngle: () => Sk,
        addTangentArc: () => Pk,
        addTangentCircle: () => Ik,
        addTangentLine: () => bk,
        addTangentPolygon: () => gk,
        addTangentRay: () => xk,
        addTangentSegment: () => Uh,
        addTangentSegmentThreeD: () => hk,
        addTangentTransformation: () => Ek,
        addTangentVector: () => Tk,
        angleMarkerMultiplier: () => ik,
        angleMarkerRawDelta: () => ok,
        angleStart: () => ek,
        angleVertex: () => KU,
        anglebisector: () => Gk,
        arc: () => WU,
        arcArcIntersection: () => Ak,
        arcCenter: () => Dm,
        arcCircleIntersection: () => Ok,
        arcFirstPoint: () => jU,
        arcGlider: () => kO,
        arcLineIntersection: () => ZO,
        arcMiddlePoint: () => JU,
        arcOmega: () => _m,
        arcThirdPoint: () => QU,
        arg: () => g8,
        argMax: () => bU,
        argMin: () => hU,
        asec: () => MH,
        asech: () => NH,
        asinh: () => oO,
        atanh: () => iO,
        basePointFromVector: () => zU,
        basePointFromVectorThreeD: () => kU,
        bernoulliTable: () => dO,
        binomSample: () => YH,
        binomcdf: () => WH,
        binompdf: () => Fh,
        center: () => ZU,
        chisqIndependenceColTotals: () => U8,
        chisqIndependenceExpectedValues: () => k8,
        chisqIndependenceRowTotals: () => H8,
        chisqcdf: () => rU,
        chisqpdf: () => rS,
        chooseNonIncidentPoint: () => _k,
        circle: () => YU,
        circleArcIntersection: () => Nk,
        circleCircleIntersection: () => Bf,
        circleGlider: () => vk,
        circleLineIntersection: () => yS,
        clamp: () => pr,
        coerceComplexToReal: () => PS,
        coerceComplexToRealWithTolerance: () => A8,
        coerceRealToComplex: () => F8,
        common_log: () => TH,
        compareComplexLexicographic: () => NO,
        complex: () => Zt,
        complexAcos: () => iA,
        complexAcosh: () => aA,
        complexAcot: () => _8,
        complexAcoth: () => O8,
        complexAcsc: () => D8,
        complexAcsch: () => N8,
        complexAsec: () => M8,
        complexAsech: () => R8,
        complexAsin: () => IS,
        complexAsinh: () => sA,
        complexAtan: () => zP,
        complexAtanh: () => Rh,
        complexCeil: () => B8,
        complexCommonLog: () => IH,
        complexCos: () => tA,
        complexCosh: () => oA,
        complexCot: () => S8,
        complexCoth: () => v8,
        complexCsc: () => P8,
        complexCsch: () => C8,
        complexDivide: () => jc,
        complexExp: () => b8,
        complexFloor: () => uA,
        complexFromPolarRounded: () => $c,
        complexGCD: () => UP,
        complexLCM: () => kP,
        complexListGCD: () => yH,
        complexListLCM: () => gH,
        complexLog: () => qP,
        complexLogbase: () => gO,
        complexMod: () => G8,
        complexMultiplyPoints: () => jO,
        complexPow: () => T8,
        complexPowReal: () => KO,
        complexReciprocal: () => jo,
        complexRound: () => Im,
        complexSec: () => I8,
        complexSech: () => E8,
        complexSin: () => eA,
        complexSinh: () => rA,
        complexSortPerm: () => mU,
        complexSqrt: () => QO,
        complexTan: () => nA,
        complexTanh: () => TS,
        composeTransformation: () => jk,
        conj: () => up,
        corr: () => Hh,
        cos: () => Yn,
        cosh: () => vm,
        cot: () => EH,
        cotDerivative: () => fO,
        coth: () => RH,
        cov: () => TU,
        covp: () => LO,
        csc: () => SH,
        csch: () => _H,
        dilation: () => Zk,
        directedAngleMarker: () => HO,
        directedAngleStart: () => nk,
        directedAngleVertex: () => tk,
        directedCoterminalAngle: () => UO,
        distance: () => Em,
        distanceThreeD: () => EU,
        elementsAt: () => a8,
        erf: () => aU,
        erfcx: () => Ou,
        executeRecursiveFunction: () => lH,
        expm1: () => rH,
        factorial: () => yc,
        frequency: () => l8,
        gcd: () => Ih,
        geocdf: () => eU,
        geopdf: () => QH,
        getArcDetails: () => kh,
        getBroadcastTargetElements: () => aH,
        getRecursiveDepthLimit: () => sH,
        gosperr: () => Si,
        handleRecursionLimitExceeded: () => pO,
        hsv: () => CU,
        hypot: () => Wo,
        identity: () => $U,
        imag: () => y8,
        invBinom: () => DO,
        invChisq: () => oU,
        invGeo: () => tU,
        invNorm: () => Bh,
        invPoisson: () => MO,
        invT: () => _O,
        invUniform: () => cU,
        invertTransformation: () => Jk,
        isDegenerateArc: () => lS,
        lcm: () => wP,
        line: () => VU,
        lineArcIntersection: () => YO,
        lineCircleIntersection: () => fS,
        lineGlider: () => mS,
        lineLineIntersection: () => $O,
        listGCD: () => dH,
        listLCM: () => fH,
        listLength: () => pU,
        listMax: () => qh,
        listMin: () => Gh,
        log: () => xH,
        log1p: () => Mm,
        log_base: () => Sh,
        losesInfoWhenCoercingToReal: () => SS,
        lowerQuantileIndex: () => fU,
        lowerQuartileIndex: () => gU,
        mad: () => xU,
        mathVector: () => GO,
        mathVectorThreeD: () => qO,
        md5Spyable: () => nO,
        mean: () => Zc,
        median: () => AO,
        mod: () => rp,
        nCr: () => kc,
        nPr: () => Ph,
        normalSample: () => kH,
        normalcdf: () => CO,
        normalpdf: () => Lh,
        parallel: () => Vk,
        peelableCoerceComplexToReal: () => w8,
        peelableCoerceComplexToRealWithTolerance: () => L8,
        perpendicular: () => Bk,
        pointDet: () => JO,
        pointDot: () => qk,
        pointPerp: () => zk,
        poissonSample: () => ZH,
        poissoncdf: () => JH,
        poissonpdf: () => Vh,
        polyGamma: () => yO,
        polygon: () => vU,
        polygonArea: () => uS,
        polygonEdgeByParameter: () => Mk,
        polygonEdges: () => NU,
        polygonGlider: () => Dk,
        polygonInteriorDirectedAngles: () => FU,
        polygonInteriorUndirectedAngles: () => LU,
        polygonPerimeter: () => OU,
        pow: () => iH,
        quad: () => SU,
        quantile: () => RO,
        quartile: () => ap,
        quartileIndex: () => zh,
        radius: () => XU,
        random: () => tS,
        randomPerm: () => nS,
        rank: () => BP,
        rawTransform: () => Hk,
        rawTransformConj: () => Uk,
        ray: () => BU,
        rayGlider: () => GP,
        real: () => f8,
        recursionCacheKey: () => AP,
        recursionDiverges: () => lO,
        recursionMissingCacheEntry: () => cH,
        recursionSuccess: () => uH,
        reflection: () => Wk,
        restriction: () => m8,
        restrictionToBoolean: () => d8,
        rgb: () => VO,
        rotation: () => Xk,
        scaleTangentAngle: () => yk,
        scaleTangentArc: () => fk,
        scaleTangentCircle: () => dk,
        scaleTangentLine: () => pk,
        scaleTangentPolygon: () => lk,
        scaleTangentRay: () => mk,
        scaleTangentSegment: () => pS,
        scaleTangentTransformation: () => ck,
        sec: () => PH,
        sech: () => DH,
        segment: () => cS,
        segmentGlider: () => dS,
        segmentThreeD: () => MU,
        segmentThreeDGlider: () => Ck,
        select: () => s8,
        serializeNonNumericSeedPart: () => eS,
        shuffle: () => UH,
        sign: () => XP,
        sin: () => Nn,
        sinh: () => lp,
        sortPerm: () => pp,
        spearman: () => IU,
        sphere: () => _U,
        sqrtxsqm1: () => mH,
        sqrtxsqp1: () => pH,
        stats: () => iS,
        stdev: () => FO,
        stdevp: () => PU,
        supplementAngle: () => ak,
        tSample: () => $H,
        tan: () => jP,
        tanh: () => ZP,
        tcdf: () => BH,
        testingOnlySetRecursiveDepthLimit: () => WP,
        toFraction: () => oH,
        tone: () => c8,
        total: () => bO,
        tpdf: () => wh,
        transformAngleMarker: () => i8,
        transformArc: () => r8,
        transformCircle: () => n8,
        transformLine: () => Kk,
        transformPoint: () => oa,
        transformPolygon: () => o8,
        transformRay: () => e8,
        transformScaleFactor: () => $k,
        transformSegment: () => xS,
        transformVector: () => t8,
        transformWithoutTranslation: () => kk,
        translation: () => Yk,
        triangle: () => DU,
        tscore: () => lU,
        undirectedAngleMarker: () => rk,
        undirectedCoterminalAngle: () => sk,
        uniformSample: () => Yc,
        uniformcdf: () => sU,
        uniformpdf: () => oS,
        uniquePerm: () => u8,
        upperQuantileIndex: () => dU,
        upperQuartileIndex: () => yU,
        validateRangeLength: () => sS,
        validateSampleCount: () => aS,
        variance: () => wO,
        varp: () => zf,
        vector: () => GU,
        vectorDisplacementAsPoint: () => qU,
        vectorThreeD: () => HU,
        vectorThreeDDisplacementAsPoint: () => UU,
        vertices: () => RU,
        volume: () => p8,
        wirtingerEqualOrWarning: () => V8
    });
    $r();
    var j1 = function() {
        "use strict";
        function e(g, f) {
            let h = (g & 65535) + (f & 65535);
            return (g >> 16) + (f >> 16) + (h >> 16) << 16 | h & 65535
        }
        function t(g, f) {
            return g << f | g >>> 32 - f
        }
        function n(g, f, h, x, T, P) {
            return e(t(e(e(f, g), e(x, P)), T), h)
        }
        function r(g, f, h, x, T, P, C) {
            return n(f & h | ~f & x, g, f, T, P, C)
        }
        function o(g, f, h, x, T, P, C) {
            return n(f & x | h & ~x, g, f, T, P, C)
        }
        function i(g, f, h, x, T, P, C) {
            return n(f ^ h ^ x, g, f, T, P, C)
        }
        function s(g, f, h, x, T, P, C) {
            return n(h ^ (f | ~x), g, f, T, P, C)
        }
        function a(g, f) {
            g[f >> 5] |= 128 << f % 32,
            g[(f + 64 >>> 9 << 4) + 14] = f;
            let h, x, T, P, C, S = 1732584193, E = -271733879, M = -1732584194, _ = 271733878;
            for (h = 0; h < g.length; h += 16)
                x = S,
                T = E,
                P = M,
                C = _,
                S = r(S, E, M, _, g[h], 7, -680876936),
                _ = r(_, S, E, M, g[h + 1], 12, -389564586),
                M = r(M, _, S, E, g[h + 2], 17, 606105819),
                E = r(E, M, _, S, g[h + 3], 22, -1044525330),
                S = r(S, E, M, _, g[h + 4], 7, -176418897),
                _ = r(_, S, E, M, g[h + 5], 12, 1200080426),
                M = r(M, _, S, E, g[h + 6], 17, -1473231341),
                E = r(E, M, _, S, g[h + 7], 22, -45705983),
                S = r(S, E, M, _, g[h + 8], 7, 1770035416),
                _ = r(_, S, E, M, g[h + 9], 12, -1958414417),
                M = r(M, _, S, E, g[h + 10], 17, -42063),
                E = r(E, M, _, S, g[h + 11], 22, -1990404162),
                S = r(S, E, M, _, g[h + 12], 7, 1804603682),
                _ = r(_, S, E, M, g[h + 13], 12, -40341101),
                M = r(M, _, S, E, g[h + 14], 17, -1502002290),
                E = r(E, M, _, S, g[h + 15], 22, 1236535329),
                S = o(S, E, M, _, g[h + 1], 5, -165796510),
                _ = o(_, S, E, M, g[h + 6], 9, -1069501632),
                M = o(M, _, S, E, g[h + 11], 14, 643717713),
                E = o(E, M, _, S, g[h], 20, -373897302),
                S = o(S, E, M, _, g[h + 5], 5, -701558691),
                _ = o(_, S, E, M, g[h + 10], 9, 38016083),
                M = o(M, _, S, E, g[h + 15], 14, -660478335),
                E = o(E, M, _, S, g[h + 4], 20, -405537848),
                S = o(S, E, M, _, g[h + 9], 5, 568446438),
                _ = o(_, S, E, M, g[h + 14], 9, -1019803690),
                M = o(M, _, S, E, g[h + 3], 14, -187363961),
                E = o(E, M, _, S, g[h + 8], 20, 1163531501),
                S = o(S, E, M, _, g[h + 13], 5, -1444681467),
                _ = o(_, S, E, M, g[h + 2], 9, -51403784),
                M = o(M, _, S, E, g[h + 7], 14, 1735328473),
                E = o(E, M, _, S, g[h + 12], 20, -1926607734),
                S = i(S, E, M, _, g[h + 5], 4, -378558),
                _ = i(_, S, E, M, g[h + 8], 11, -2022574463),
                M = i(M, _, S, E, g[h + 11], 16, 1839030562),
                E = i(E, M, _, S, g[h + 14], 23, -35309556),
                S = i(S, E, M, _, g[h + 1], 4, -1530992060),
                _ = i(_, S, E, M, g[h + 4], 11, 1272893353),
                M = i(M, _, S, E, g[h + 7], 16, -155497632),
                E = i(E, M, _, S, g[h + 10], 23, -1094730640),
                S = i(S, E, M, _, g[h + 13], 4, 681279174),
                _ = i(_, S, E, M, g[h], 11, -358537222),
                M = i(M, _, S, E, g[h + 3], 16, -722521979),
                E = i(E, M, _, S, g[h + 6], 23, 76029189),
                S = i(S, E, M, _, g[h + 9], 4, -640364487),
                _ = i(_, S, E, M, g[h + 12], 11, -421815835),
                M = i(M, _, S, E, g[h + 15], 16, 530742520),
                E = i(E, M, _, S, g[h + 2], 23, -995338651),
                S = s(S, E, M, _, g[h], 6, -198630844),
                _ = s(_, S, E, M, g[h + 7], 10, 1126891415),
                M = s(M, _, S, E, g[h + 14], 15, -1416354905),
                E = s(E, M, _, S, g[h + 5], 21, -57434055),
                S = s(S, E, M, _, g[h + 12], 6, 1700485571),
                _ = s(_, S, E, M, g[h + 3], 10, -1894986606),
                M = s(M, _, S, E, g[h + 10], 15, -1051523),
                E = s(E, M, _, S, g[h + 1], 21, -2054922799),
                S = s(S, E, M, _, g[h + 8], 6, 1873313359),
                _ = s(_, S, E, M, g[h + 15], 10, -30611744),
                M = s(M, _, S, E, g[h + 6], 15, -1560198380),
                E = s(E, M, _, S, g[h + 13], 21, 1309151649),
                S = s(S, E, M, _, g[h + 4], 6, -145523070),
                _ = s(_, S, E, M, g[h + 11], 10, -1120210379),
                M = s(M, _, S, E, g[h + 2], 15, 718787259),
                E = s(E, M, _, S, g[h + 9], 21, -343485551),
                S = e(S, x),
                E = e(E, T),
                M = e(M, P),
                _ = e(_, C);
            return [S, E, M, _]
        }
        function u(g) {
            let f, h = "", x = g.length * 32;
            for (f = 0; f < x; f += 8)
                h += String.fromCharCode(g[f >> 5] >>> f % 32 & 255);
            return h
        }
        function c(g) {
            let f, h = [];
            for (h[(g.length >> 2) - 1] = void 0,
            f = 0; f < h.length; f += 1)
                h[f] = 0;
            let x = g.length * 8;
            for (f = 0; f < x; f += 8)
                h[f >> 5] |= (g.charCodeAt(f / 8) & 255) << f % 32;
            return h
        }
        function l(g) {
            return u(a(c(g), g.length * 8))
        }
        function p(g) {
            let f = "0123456789abcdef", h = "", x, T;
            for (T = 0; T < g.length; T += 1)
                x = g.charCodeAt(T),
                h += f.charAt(x >>> 4 & 15) + f.charAt(x & 15);
            return h
        }
        function m(g) {
            return unescape(encodeURIComponent(g))
        }
        function d(g) {
            return l(m(g))
        }
        function y(g) {
            return p(d(g))
        }
        return y
    }();
    function Rs(e, t, n) {
        return e > 0 == t > 0 ? n === 1 ? t : e + n * (t - e) : e * (1 - n) + t * n
    }
    function Mr(e, t, n) {
        return [Rs(e[0], t[0], n), Rs(e[1], t[1], n)]
    }
    function Ns(e, t, n) {
        return [Rs(e[0], t[0], n), Rs(e[1], t[1], n), Rs(e[2], t[2], n)]
    }
    function gf(e, t) {
        return [e[0] + t[0], e[1] + t[1]]
    }
    function J1(e, t) {
        return [e[0] - t[0], e[1] - t[1]]
    }
    function nP(e, t) {
        return [e[0] - t[0], e[1] - t[1], e[2] - t[2]]
    }
    function rP(e, t) {
        return e[0] * t[0] + e[1] * t[1] + e[2] * t[2]
    }
    function lc(e, t) {
        return pm(nP(e, t))
    }
    function Qg(e, t, n) {
        return [Rs(e[0], t[0], n[0]), Rs(e[1], t[1], n[1])]
    }
    function Q1(e, t) {
        return [e[0] * t, e[1] * t]
    }
    function pm(e) {
        let[t,n,r] = e;
        return t * t + n * n + r * r
    }
    function mm(e, t) {
        let n = e[1] * t[2] - e[2] * t[1]
          , r = e[2] * t[0] - e[0] * t[2]
          , o = e[0] * t[1] - e[1] * t[0]
          , i = Math.sqrt(n * n + r * r + o * o);
        return [n / i, r / i, o / i]
    }
    function dm(e, t, n) {
        e = Math.fround(e),
        t = Math.fround(t),
        n = Math.fround(n);
        let r = Math.fround(e * e + t * t + n * n);
        return isFinite(r) && r != 0
    }
    function fu([e,t,n]) {
        return isFinite(e) && isFinite(t) && isFinite(n)
    }
    function ns(e, t) {
        let n;
        e > t && (n = e,
        e = t,
        t = n);
        let r = e > 0
          , o = t > 0
          , i = Math.abs(e) > .01
          , s = Math.abs(t) > .01;
        if (i || s)
            return ac(e, t);
        if (e === 0)
            return t * Math.abs(t);
        if (t === 0)
            return e * Math.abs(e);
        if (r !== o)
            return 0;
        let a = r ? Math.sqrt(e * t) : -Math.sqrt(e * t);
        return a >= e && t >= a ? a : ac(e, t)
    }
    function uP(e, t, n, r, o) {
        if (!(isNaN(t) || isNaN(r) || t < 0 == r < 0))
            for (; ; ) {
                let i = ns(e, n)
                  , s = o(i);
                if (!isFinite(s))
                    return;
                if (i === e || i === n)
                    return Math.abs(t) <= Math.abs(r) ? [e, t] : [n, r];
                if (s === 0)
                    return bf(e, t, i, s, n, r, o);
                t < 0 != s < 0 ? (n = i,
                r = s) : (e = i,
                t = s)
            }
    }
    function uN(e, t, n, r, o) {
        if (!(oP(t) || oP(r)) && iP(t, r))
            for (; ; ) {
                let i = ns(e, n)
                  , s = o(i);
                if (oP(s))
                    return;
                if (i === e || i === n)
                    return i;
                if (iP(t, s))
                    n = i,
                    r = s;
                else if (iP(s, r))
                    e = i,
                    t = s;
                else
                    return
            }
    }
    function oP(e) {
        for (let t of e)
            if (isNaN(t))
                return !0;
        return !1
    }
    function iP(e, t) {
        for (let n = 0; n < e.length; n++)
            if (!Pz(e[n], t[n]))
                return !1;
        return !0
    }
    function Pz(e, t) {
        return e <= 0 && t >= 0 || e >= 0 && t <= 0
    }
    function bf(e, t, n, r, o, i, s) {
        let a;
        if (!isFinite(r))
            return;
        isFinite(t) || (a = Yo(e, t, n, r, s),
        a !== void 0 && (e = a,
        t = s(e))),
        isFinite(i) || (a = Yo(n, r, o, i, s),
        a !== void 0 && (o = a,
        i = s(a)));
        let u, c;
        t === r ? u = [e, t] : u = K1(e, t, n, r, s, r),
        i === r ? c = [o, i] : c = K1(n, r, o, i, s, r);
        let l;
        return u && c && (l = ns(u[0], c[0])),
        l !== void 0 ? [l, s(l)] : void 0
    }
    function Yo(e, t, n, r, o) {
        if (isFinite(t) !== isFinite(r))
            for (; ; ) {
                let i = ns(e, n)
                  , s = o(i);
                if (i === e || i === n)
                    return isFinite(t) ? e : n;
                isFinite(s) !== isFinite(t) ? (n = i,
                r = s) : (e = i,
                t = s)
            }
    }
    function Kg(e, t, n, r, o) {
        if (fu(t) !== fu(r))
            for (; ; ) {
                let i = ns(e, n)
                  , s = o(i);
                if (i === e || i === n)
                    return fu(t) ? e : n;
                fu(s) !== fu(t) ? (n = i,
                r = s) : (e = i,
                t = s)
            }
    }
    function K1(e, t, n, r, o, i) {
        if (t === i != (r === i))
            for (; ; ) {
                let s = ns(e, n)
                  , a = o(s);
                if (s === e || s === n)
                    return t === i ? [e, t] : [n, r];
                a === i != (t === i) ? (n = s,
                r = a) : (e = s,
                t = a)
            }
    }
    function cN(e, t, n, r, o, i, s) {
        if (e < n && n < o && isFinite(t) && isFinite(r) && isFinite(i) && t !== r && r !== i && r > t == r > i)
            for (; ; ) {
                let a = ns(e, n)
                  , u = s(a)
                  , c = ns(n, o)
                  , l = s(c);
                if (!isFinite(u) || !isFinite(l))
                    return;
                if (a === e || a === n || c === n || c === o)
                    return u > r == r > t ? [a, u] : l > r == r > t ? [c, l] : [n, r];
                if (u === r || l === r)
                    return bf(e, t, n, r, o, i, s);
                r > t && u > t && u > r || r < t && u < t && u < r ? (o = n,
                i = r,
                n = a,
                r = u) : r > t && l > r && l > i || r < t && l < r && l < i ? (e = n,
                t = r,
                n = c,
                r = l) : (e = a,
                t = u,
                o = c,
                i = l)
            }
    }
    function Os([e,t], [n,r]) {
        return (n - e) * (n - e) + (r - t) * (r - t)
    }
    function eN(e, t, n, r, o, i) {
        let s = i(e)
          , a = i(t)
          , u = i(n)
          , c = Os(s, r)
          , l = Os(a, r)
          , p = Os(u, r);
        if (!(t <= e || n <= t) && !(!isFinite(c) || !isFinite(l) || !isFinite(p)) && !(l >= c || l >= p))
            for (; ; ) {
                if (Math.abs(u[0] - s[0]) < o && Math.abs(u[1] - s[1]) < o)
                    return [e, n];
                let m = ns(e, t)
                  , d = i(m)
                  , y = Os(d, r)
                  , g = ns(t, n)
                  , f = i(g)
                  , h = Os(f, r);
                if (!isFinite(y) || !isFinite(h))
                    return;
                if (m === e || m === t || g === t || g === n)
                    return y < l && y < h ? [m, m] : h < y && h < l ? [g, g] : [t, t];
                if ((y === l || h === l) && (t = .5 * (m + t),
                a = i(t),
                l = Os(a, r),
                y === l || h === l))
                    return [e, n];
                y < l && y < h ? ([n,t] = [t, m],
                [u,a] = [a, d],
                [p,l] = [l, y]) : h < y && h < l ? ([e,t] = [t, g],
                [s,a] = [a, f],
                [c,l] = [l, h]) : ([e,n] = [m, g],
                [s,u] = [d, f],
                [c,p] = [y, h])
            }
    }
    function tN(e, t, n) {
        return t === void 0 && (t = -1 / 0),
        n === void 0 && (n = 1 / 0),
        Math.min(n, Math.max(t, e))
    }
    function sP(e, t, n, r, o, i) {
        let s;
        if (r !== void 0 && o !== void 0) {
            let p = .5 * (r + o);
            s = n + .01 * (n < p ? o - r : r - o)
        } else
            s = Math.abs(n) > 1 ? n * 1.00001 : n + 1e-5;
        let a = e(n)
          , u = e(s)
          , c = Os(a, t)
          , l = Os(u, t);
        if (!(!isFinite(c) || !isFinite(l))) {
            if (c === l)
                return [n, s];
            for (l > c && ([n,s] = [s, n],
            [a,u] = [u, a],
            [c,l] = [l, c]); isFinite(n) && isFinite(s) && n !== s; ) {
                if (o !== void 0 && s > o)
                    return [o, o];
                if (r !== void 0 && s < r)
                    return [r, r];
                let p = n + 3 * (s - n)
                  , m = e(p)
                  , d = Os(m, t);
                if (!isFinite(d))
                    return [n, s];
                if (d === l)
                    return [n, s];
                if (d > l) {
                    let y = s > n ? eN(n, s, p, t, i, e) : eN(p, s, n, t, i, e);
                    return y && [tN(y[0], r, o), tN(y[1], r, o)]
                }
                [n,c,s,l] = [s, l, p, d]
            }
            return [n, s]
        }
    }
    function nN(e, t, n, r) {
        return n ? r ? Math.min(Os(e(r[0]), t), Os(e(r[1]), t)) < Math.min(Os(e(n[0]), t), Os(e(n[1]), t)) : !1 : !0
    }
    function QJ(e, t, n, r, o, i) {
        let s = sP(e, t, n, r, o, i);
        if (r !== void 0) {
            let a = sP(e, t, r, r, o, i);
            nN(e, t, s, a) && (s = a)
        }
        if (o !== void 0) {
            let a = sP(e, t, o, r, o, i);
            nN(e, t, s, a) && (s = a)
        }
        return s
    }
    function rN(e, t, n, r, o, i, s, a) {
        let u = Math.abs(r - t)
          , c = Math.abs(i - r)
          , l = Math.abs(a - i);
        return u > c && u > l ? [e, n] : l > c && l > u ? [o, s] : [n, o]
    }
    function fm(e, t, n, r, o, i, s, a=0) {
        if (!((n - e) * (o - n) <= 0) && !(!isFinite(e) || !isFinite(n) || !isFinite(o)) && !(!isFinite(t) || !isFinite(i))) {
            if (!isFinite(r)) {
                let u = Yo(e, t, n, r, s)
                  , c = Yo(n, r, o, i, s);
                return u === void 0 || c === void 0 ? void 0 : [u, c]
            }
            if (!(Math.abs(r - ((o - n) * t + (n - e) * i) / (o - e)) < a))
                for (; ; ) {
                    let u = ns(e, n)
                      , c = s(u)
                      , l = ns(n, o)
                      , p = s(l)
                      , m = Math.abs(c - ac(t, r))
                      , d = Math.abs(r - ac(c, p))
                      , y = Math.abs(p - ac(r, i));
                    if (m <= a && d <= a && y <= a)
                        return;
                    if (!isFinite(c)) {
                        let g = Yo(e, t, u, c, s)
                          , f = Yo(u, c, o, i, s);
                        return g === void 0 || f === void 0 ? void 0 : [g, f]
                    }
                    if (!isFinite(p)) {
                        let g = Yo(e, t, l, p, s)
                          , f = Yo(l, p, o, i, s);
                        return g === void 0 || f === void 0 ? void 0 : [g, f]
                    }
                    if ((u === e || u === n) && (l === n || l === o))
                        return Math.abs(r - t) > Math.abs(i - r) ? [e, n] : [n, o];
                    if (u === e || u === n)
                        return rN(e, t, n, r, l, p, o, i);
                    if (l === n || l === o)
                        return rN(e, t, u, c, n, r, o, i);
                    m > y && m >= d ? (o = n,
                    i = r,
                    n = u,
                    r = c) : y > m && y >= d ? (e = n,
                    t = r,
                    n = l,
                    r = p) : (e = u,
                    t = c,
                    o = l,
                    i = p)
                }
        }
    }
    var pc = (Math.sqrt(5) - 1) / 2;
    function hf(e, t) {
        return e > 0 == t > 0 ? e + pc * (t - e) : (1 - pc) * e + pc * t
    }
    function qc(e, t) {
        let n;
        e > t && (n = e,
        e = t,
        t = n);
        let r = e > 0
          , o = t > 0
          , i = Math.abs(e) > .01
          , s = Math.abs(t) > .01;
        if (i || s)
            return hf(e, t);
        if (e === 0)
            return t * Math.abs(t);
        if (t === 0)
            return e * Math.abs(e);
        if (r !== o)
            return 0;
        let a = r ? Math.sqrt(e * t) : -Math.sqrt(e * t);
        return a >= e && t >= a ? a : hf(e, t)
    }
    function lN(e, t, n, r, o, i) {
        if (!isFinite(e) || !isFinite(n) || !isFinite(t) || !isFinite(r))
            return;
        e > n && ([e,t,n,r] = [n, r, e, t]);
        let s = qc(e, n)
          , a = o(s);
        if (Math.abs(a - hf(t, r)) <= i)
            return;
        let u = qc(e, s)
          , c = o(u);
        for (; ; ) {
            let l = Math.abs(c - hf(t, a))
              , p = Math.abs(a - hf(r, c));
            if (l <= i && p <= i)
                return;
            if (l > p) {
                if (n = s,
                r = a,
                s = u,
                a = c,
                u = qc(e, s),
                c = o(u),
                u === e || u === s)
                    return iN(e, t, s, a, n, r);
                if (!isFinite(c))
                    return oN(e, t, u, c, n, r, o)
            } else {
                if (e = u,
                t = c,
                u = s,
                c = a,
                s = qc(n, s),
                a = o(s),
                s === n || s === u)
                    return iN(e, t, u, c, n, r);
                if (!isFinite(a))
                    return oN(e, t, s, a, n, r, o)
            }
        }
    }
    function oN(e, t, n, r, o, i, s) {
        let a = Yo(e, t, n, r, s)
          , u = Yo(n, r, o, i, s);
        if (!(a === void 0 || u === void 0))
            return [a, u]
    }
    function iN(e, t, n, r, o, i) {
        return Math.abs(r - t) > Math.abs(i - r) ? [e, n] : [n, o]
    }
    function aP(e, t, n) {
        let r = e[0] * (1 - pc) + t[0] * pc - n[0]
          , o = e[1] * (1 - pc) + t[1] * pc - n[1]
          , i = e[2] * (1 - pc) + t[2] * pc - n[2];
        return r * r + o * o + i * i
    }
    function eh(e, t, n, r, o, i, s, a) {
        if (!isFinite(e) || !isFinite(n) || !fu(t) || !fu(r))
            return;
        e > n && ([e,t,n,r] = [n, r, e, t]);
        let u = qc(e, n)
          , c = o(u)
          , l = i * i;
        if (aP(t, r, c) <= l)
            return;
        let p = qc(e, u)
          , m = o(p);
        for (; ; ) {
            let d = aP(t, c, m)
              , y = aP(r, m, c);
            if (d <= l && y <= l)
                return n - e < a ? p : void 0;
            if (d > y) {
                if (n = u,
                r = c,
                u = p,
                c = m,
                p = qc(e, u),
                m = o(p),
                p === e || u - p <= s)
                    return aN(e, t, u, c, n, r);
                if (!fu(m))
                    return sN(e, t, p, m, n, r, o)
            } else {
                if (e = p,
                t = m,
                p = u,
                m = c,
                u = qc(n, u),
                c = o(u),
                u === n || u - p <= s)
                    return aN(e, t, p, m, n, r);
                if (!fu(c))
                    return sN(e, t, u, c, n, r, o)
            }
        }
    }
    function sN(e, t, n, r, o, i, s) {
        let a = Kg(e, t, n, r, s)
          , u = Kg(n, r, o, i, s);
        if (!(a === void 0 || u === void 0))
            return [a, u]
    }
    function aN(e, t, n, r, o, i) {
        return lc(r, t) > lc(i, r) ? [e, n] : [n, o]
    }
    var xf = class {
        constructor(t) {
            this.comparator = t;
            this._data = []
        }
        size() {
            return this._data.length
        }
        queue(t) {
            let n = this._data.length;
            for (this._data.push(t); n > 0; ) {
                let r = n - 1 >>> 1;
                if (this.comparator(this._data[n], this._data[r]) < 0) {
                    let o = this._data[r];
                    this._data[r] = this._data[n],
                    this._data[n] = o,
                    n = r
                } else
                    break
            }
        }
        dequeue() {
            let t = this._data[0]
              , n = this._data.pop();
            if (this._data.length > 0 && n !== void 0) {
                this._data[0] = n;
                let r = 0
                  , o = this._data.length - 1;
                for (; ; ) {
                    let i = (r << 1) + 1
                      , s = i + 1
                      , a = r;
                    if (i <= o && this.comparator(this._data[i], this._data[a]) < 0 && (a = i),
                    s <= o && this.comparator(this._data[s], this._data[a]) < 0 && (a = s),
                    a !== r) {
                        let u = this._data[a];
                        this._data[a] = this._data[r],
                        this._data[r] = u,
                        r = a
                    } else
                        break
                }
            }
            return t
        }
        peek() {
            return this._data[0]
        }
        clear() {
            this._data.length = 0
        }
    }
    ;
    function Ez(e, t) {
        let n = e.start[1] - e.end[1]
          , r = e.end[0] - e.start[0]
          , o = t.start[1] - t.end[1]
          , i = t.end[0] - t.start[0]
          , s = n * e.end[0] + r * e.end[1]
          , a = o * t.end[0] + i * t.end[1]
          , u = n * i - o * r;
        if (u !== 0)
            return (n * a - o * s) / u
    }
    function Cz(e, t, n) {
        if (n.xSlope >= t.xSlope)
            return;
        if (t.scanlineX === n.scanlineX)
            return e;
        let r = t.start[1] > t.end[1] ? t.start : t.end
          , o = n.start[1] > n.end[1] ? n.start : n.end
          , i = r[1];
        if (o[1] < r[1]) {
            if (i = o[1],
            cP(i, t) < o[0])
                return
        } else if (r[1] < o[1]) {
            let a = cP(i, n);
            if (r[0] < a)
                return
        } else if (r[0] < o[0])
            return;
        let s = Ez(t, n);
        if (s !== void 0)
            return Math.max(Math.min(s, i), e)
    }
    function cP(e, t) {
        let n = t.end[0]
          , r = t.start[0]
          , o = t.end[1]
          , i = t.start[1];
        if (o === e)
            return n;
        if (i === e)
            return r;
        {
            let s = (e - o) / (i - o)
              , a = (1 - s) * n + s * r;
            if (n < r) {
                if (a <= n)
                    return n;
                if (r <= a)
                    return r
            } else {
                if (a <= r)
                    return r;
                if (n <= a)
                    return n
            }
            return a
        }
    }
    function lP(e) {
        let t = 0
          , n = 0
          , r = !1
          , o = 0;
        for (let {scanlineX: i, isClockwise: s} of e)
            s ? o += 1 : o -= 1,
            o !== 0 && !r ? (r = !0,
            n = i) : o === 0 && r && (r = !1,
            t += i - n);
        return t
    }
    var Tf = class {
        constructor(t) {
            this.scanlineY = -1 / 0;
            let n = 1;
            this.activeEdges = [],
            this.events = new xf( (r, o) => r.y - o.y),
            this.scanlineY = -1 / 0,
            this.polygonLength = t.length - 1;
            for (let r = t.length - 1; r >= 1; r--) {
                let o = t[r]
                  , i = t[r - 1]
                  , s = {
                    id: n++,
                    index: r - 1,
                    end: o,
                    start: i,
                    scanlineX: 0,
                    xSlope: 1 / 0,
                    isClockwise: i[1] > o[1],
                    skipIntersectionWith: {}
                };
                i[1] > o[1] ? (this.events.queue({
                    type: "+",
                    y: o[1],
                    edge: s
                }),
                this.events.queue({
                    type: "-",
                    y: i[1],
                    edge: s
                }),
                s.xSlope = (i[0] - o[0]) / (i[1] - o[1]),
                s.scanlineX = o[0]) : o[1] > i[1] ? (this.events.queue({
                    type: "+",
                    y: i[1],
                    edge: s
                }),
                this.events.queue({
                    type: "-",
                    y: o[1],
                    edge: s
                }),
                s.xSlope = (o[0] - i[0]) / (o[1] - i[1]),
                s.scanlineX = i[0]) : this.events.queue({
                    type: "h",
                    y: i[1],
                    edge: s
                })
            }
        }
        nextScanline() {
            var i;
            let t, n = this.events.peek();
            if (!n)
                return;
            if (n.y <= this.scanlineY)
                throw new Error("Programming error: expected next event to begin a new scanline");
            this.scanlineY = n.y,
            this.updateActiveEdgeScanlineIntersections();
            let r = lP(this.activeEdges)
              , o = [];
            for (; t = this.events.dequeue(); )
                if (t.type === "x" ? this.swapActiveEdges(t) : t.type === "+" ? this.insertActiveEdge(t) : t.type === "-" && this.removeActiveEdge(t),
                o.push(t),
                ((i = this.events.peek()) == null ? void 0 : i.y) !== this.scanlineY)
                    return {
                        y: this.scanlineY,
                        activeEdges: this.activeEdges,
                        lengthBeforeProcessingEvents: r,
                        events: o
                    }
        }
        updateActiveEdgeScanlineIntersections() {
            let t = -1 / 0;
            for (let n of this.activeEdges) {
                let r = cP(this.scanlineY, n);
                r < t ? r = t : t = r,
                n.scanlineX = r
            }
        }
        insertActiveEdge(t) {
            let n = this.activeEdges, r = t.edge, o = t.y, {xSlope: i, scanlineX: s} = r, a;
            for (a = 0; a < n.length; a++) {
                let u = n[a];
                if (s < u.scanlineX || s === u.scanlineX && i <= u.xSlope)
                    break
            }
            n.splice(a, 0, r),
            this.checkIntersection(o, n[a - 1], r),
            this.checkIntersection(o, r, n[a + 1])
        }
        checkIntersection(t, n, r) {
            if (!n || !r || n.index === (r.index + 1) % this.polygonLength || r.index === (n.index + 1) % this.polygonLength)
                return;
            if (n.id < r.id) {
                if (n.skipIntersectionWith[r.id])
                    return
            } else if (r.skipIntersectionWith[n.id])
                return;
            let o = Cz(t, n, r);
            if (o === void 0)
                return;
            n.id < r.id ? n.skipIntersectionWith[r.id] = !0 : r.skipIntersectionWith[n.id] = !0;
            let i = {
                type: "x",
                y: o,
                edge1: n,
                edge2: r
            };
            this.events.queue(i)
        }
        removeActiveEdge(t) {
            let n = this.activeEdges
              , r = t.edge
              , o = t.y
              , i = n.indexOf(r);
            n.splice(i, 1),
            this.checkIntersection(o, n[i - 1], n[i])
        }
        swapActiveEdges(t) {
            let n = this.activeEdges
              , r = t.edge1
              , o = t.edge2
              , i = t.y
              , s = n.indexOf(r)
              , a = s + 1;
            s === -1 || n[a] !== o ? r.id < o.id ? delete r.skipIntersectionWith[o.id] : delete o.skipIntersectionWith[r.id] : (n[s] = o,
            n[a] = r,
            this.checkIntersection(i, n[s - 1], o),
            this.checkIntersection(i, r, n[a + 1]))
        }
        static debugEvent(t) {
            let n = `y=${t.y} `;
            return n += t.type === "x" ? `[x ${t.edge1.index}/${t.edge2.index}]` : `[${t.type} ${t.edge.index}] (${t.edge.end})-(${t.edge.start})`,
            n
        }
        debugState() {
            return `y=${this.scanlineY}
${this.activeEdges.map(t => `[${t.index}] ${t.scanlineX}`)}`
        }
    }
    ;
    function vz(e) {
        let t = e.slice(0, 2)
          , n = e.slice(-2);
        return t[0] !== n[0] || t[1] !== n[1] ? [...e, ...t] : e
    }
    function rQ(e, t) {
        if (!e)
            return !1;
        let n = vz(e)
          , [r,o] = t
          , i = 0;
        for (let s = n.length - 1; s >= 3; s -= 2) {
            let a = n[s - 3]
              , u = n[s - 2]
              , c = n[s - 1]
              , l = n[s];
            u > o != l > o && r < (c - a) * (o - u) / (l - u) + a && (u > l ? i += 1 : u < l && (i -= 1))
        }
        return i !== 0
    }
    function mN(e) {
        if (e.length < 4 || e[0][0] !== e[e.length - 1][0] || e[0][1] !== e[e.length - 1][1])
            return 0;
        let t = new Tf(e), n, r = 0, o;
        for (; o = t.nextScanline(); ) {
            let i = o.lengthBeforeProcessingEvents;
            n && (r += .5 * (o.y - n.y) * (i + n.length)),
            n = {
                y: o.y,
                length: lP(o.activeEdges)
            }
        }
        return r
    }
    function dN(e) {
        if (!e.length)
            return [];
        if (e[0][0] !== e[e.length - 1][0] || e[0][1] !== e[e.length - 1][1])
            throw new Error("Programming error: expected last point to be a duplicate of the first point.");
        for (let m = 0; m < e.length - 1; m++)
            if (e[m][0] === e[m + 1][0] && e[m][1] === e[m + 1][1])
                throw new Error(`Programming error: unexpected duplicate point at ${m + 1}`);
        let t = new Tf(e), n = e.slice(0, -1).map( () => 0), r;
        for (; r = t.nextScanline(); )
            for (let m of r.events) {
                let d = {};
                if (m.type === "h") {
                    let y = m.edge;
                    d[y.index] = {
                        xMin: Math.min(y.end[0], y.start[0]),
                        xMax: Math.max(y.end[0], y.start[0]),
                        dx: y.end[0] - y.start[0]
                    }
                } else if (m.type === "x") {
                    let y = m.edge1
                      , g = m.edge2
                      , f = pN([y.start, y.end], [g.start, g.end])
                      , h = f > 0 ? -1 : f < 0 ? 1 : 0;
                    n[y.index] += h,
                    n[g.index] -= h
                }
                for (let y of r.activeEdges) {
                    let g = y.end[1] - y.start[1];
                    for (let f in d) {
                        let {xMin: h, xMax: x, dx: T} = d[f];
                        if (h < y.scanlineX && y.scanlineX < x) {
                            let P = T * g
                              , C = P > 0 ? -1 : P < 0 ? 1 : 0;
                            n[f] += C,
                            n[y.index] -= C
                        }
                    }
                }
            }
        let o = e.slice(0, -1).map( () => 0)
          , i = e[0][1]
          , s = 0;
        for (let m = 1; m < e.length; m++)
            e[m][1] < i && (i = e[m][1],
            s = m);
        let a = e.length - 1
          , u = s > 0 ? s - 1 : a - 1
          , c = (s + 1) % a
          , p = pN([e[u], e[s]], [e[s], e[c]]) > 0 ? 1 : 0;
        o[s] = p > 0 ? -1 : 1;
        for (let m = 0; m < a - 1; m++) {
            let d = (s + m) % a;
            p += n[d],
            o[(d + 1) % a] = p > 0 ? -1 : 1
        }
        return o
    }
    function pN(e, t) {
        let n = e[1][0] - e[0][0]
          , r = e[1][1] - e[0][1]
          , o = t[1][0] - t[0][0]
          , i = t[1][1] - t[0][1];
        return n * i - r * o
    }
    var Mz = fm
      , th = Yo
      , Dz = 3.154019550531224
      , fN = Math.pow(2, -13)
      , zc = fN * fN
      , yN = zc * zc
      , pP = zc
      , dP = 32
      , Ma = []
      , Hc = [];
    function _z(e, t) {
        for (let n = dP; n > 0; n--) {
            let r = Dz / dP * n
              , o = Math.sinh(r)
              , i = Math.cosh(Math.PI / 2 * o)
              , s = 1 / (Math.exp(Math.PI / 2 * o) * i)
              , a = Math.cosh(r) / (i * i);
            e.push(s),
            t.push(a)
        }
    }
    _z(Ma, Hc);
    var bN = 0;
    for (let e = 0; e < Hc.length; e++)
        bN += Hc[e];
    var nh = 1 / (1 + 2 * bN);
    function fi(e, t, n) {
        return .5 * (t * (2 - n) + e * n)
    }
    function Rz(e, t, n) {
        let r = .5 * (t + n)
          , o = Mz(t, e(t), r, e(r), n, e(n), e);
        return o ? .5 * (o[0] + o[1]) : r
    }
    function If(e, t, n, r, o) {
        return {
            x1: e,
            x2: t,
            value: n,
            error: r,
            minerror: o
        }
    }
    function gN(e, t, n) {
        let r = Math.abs(e(fi(t, n, zc)))
          , o = Math.abs(e(fi(t, n, 2 * zc)))
          , i = Math.abs(e(fi(t, n, 4 * zc)));
        return r < zc || o < zc ? !1 : r > 1.95 * o && o > 1.95 * i
    }
    function mP(e, t, n) {
        let r = fi(n, t, Ma[0]), o = fi(t, n, Ma[0]), i = e(r), s = e(o), a = fi(t, n, 1), u = e(a), c, l;
        if (isFinite(u) && !isFinite(i)) {
            if (c = th(r, i, a, u, e),
            Math.abs((c - t) / (n - t)) > pP)
                return If(t, n, NaN, NaN, NaN);
            t = c,
            i = e(t)
        }
        if (isFinite(u) && !isFinite(s)) {
            if (l = th(a, u, o, s, e),
            Math.abs((l - n) / (n - t)) > pP)
                return If(t, n, NaN, NaN, NaN);
            n = l,
            s = e(n)
        }
        if (isFinite(i) && isFinite(s) && !isFinite(u)) {
            if (c = th(r, i, a, u, e),
            l = th(a, u, o, s, e),
            Math.abs((l - c) / (n - t)) > pP)
                return If(t, n, NaN, NaN, NaN);
            u = .5 * (c + l)
        }
        if (gN(e, t, n) || gN(e, n, t))
            return If(t, n, NaN, NaN, NaN);
        let p = u
          , m = 0
          , d = 0
          , y = 0
          , g = 0
          , f = 0
          , h = 0;
        for (let U = 0; U < dP; U += 4)
            f = e(fi(t, n, Ma[U])),
            h = e(fi(n, t, Ma[U])),
            g = Math.max(g, Math.abs(f), Math.abs(h)),
            m += Hc[U] * (f + h),
            f = e(fi(t, n, Ma[U + 1])),
            h = e(fi(n, t, Ma[U + 1])),
            g = Math.max(g, Math.abs(f), Math.abs(h)),
            y += Hc[U + 1] * (f + h),
            f = e(fi(t, n, Ma[U + 2])),
            h = e(fi(n, t, Ma[U + 2])),
            g = Math.max(g, Math.abs(f), Math.abs(h)),
            d += Hc[U + 2] * (f + h),
            f = e(fi(t, n, Ma[U + 3])),
            h = e(fi(n, t, Ma[U + 3])),
            g = Math.max(g, Math.abs(f), Math.abs(h)),
            y += Hc[U + 3] * (f + h);
        let x = p + m, T = x + d, P = T + y, C = Math.abs(d - x), S = Math.abs(y - T), E = nh * (n - t) * P, M = nh * Math.abs(n - t) * g * Hc[0], _;
        return C === 0 ? _ = nh * Math.abs(n - t) * S : _ = nh * Math.abs(n - t) * S * (S / C) * (S / C),
        _ = Math.max(_, M),
        If(t, n, E, _, M)
    }
    function hN(e) {
        let t = -1 / 0
          , n = -1 / 0
          , r = -1
          , o = 0;
        for (let i = 0; i < e.length; i++) {
            let s = e[i];
            o += s.value,
            s.error > t && (t = s.error,
            r = i),
            s.minerror > n && (n = s.minerror)
        }
        return {
            maxerror: t,
            maxminerror: n,
            maxindex: r,
            totalvalue: o
        }
    }
    function Pf(e, t, n, r=32) {
        if (isNaN(t) || isNaN(n))
            return NaN;
        let o = 1;
        if (t > n) {
            let a = t;
            t = n,
            n = a,
            o = -1
        }
        if (t === 1 / 0 && n === 1 / 0)
            return NaN;
        if (t === -1 / 0 && n === -1 / 0)
            return NaN;
        if (t === -1 / 0 && n === 1 / 0)
            return o * Pf(a => e(a / ((1 + a) * (1 - a))) * (1 + a * a) / ((1 + a) * (1 + a) * (1 - a) * (1 - a)), -1, 1, r);
        if (t === -1 / 0)
            return o * Pf(a => -e(n - a / (1 - a)) / ((1 - a) * (1 - a)), 1, 0, r);
        if (n === 1 / 0)
            return o * Pf(a => e(t + a / (1 - a)) / ((1 - a) * (1 - a)), 0, 1, r);
        let i = [mP(e, t, n)]
          , s = hN(i);
        for (let a = 1; a < r && !(Math.abs(s.maxerror / s.totalvalue) <= 32 * yN || s.maxerror <= 32 * yN || s.maxerror <= 32 * s.maxminerror || !isFinite(s.maxerror) || !isFinite(s.maxminerror)); a++) {
            let u = i[i.length - 1];
            i[i.length - 1] = i[s.maxindex],
            i[s.maxindex] = u;
            let c = i.pop()
              , l = Rz(e, fi(c.x2, c.x1, .125), fi(c.x1, c.x2, .125));
            i.push(mP(e, c.x1, l)),
            i.push(mP(e, l, c.x2)),
            s = hN(i)
        }
        return !isFinite(s.maxerror) || !isFinite(s.maxminerror) ? NaN : Math.abs(s.totalvalue) <= 10 * s.maxminerror ? 0 : o * s.totalvalue
    }
    function rh(e, t, n) {
        e.prototype = t.prototype = n,
        n.constructor = e
    }
    function fP(e, t) {
        var n = Object.create(e.prototype);
        for (var r in t)
            n[r] = t[r];
        return n
    }
    function Cf() {}
    var Sf = .7
      , sh = 1 / Sf
      , ym = "\\s*([+-]?\\d+)\\s*"
      , Ef = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*"
      , yu = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*"
      , Oz = /^#([0-9a-f]{3,8})$/
      , Az = new RegExp(`^rgb\\(${ym},${ym},${ym}\\)$`)
      , wz = new RegExp(`^rgb\\(${yu},${yu},${yu}\\)$`)
      , Lz = new RegExp(`^rgba\\(${ym},${ym},${ym},${Ef}\\)$`)
      , Fz = new RegExp(`^rgba\\(${yu},${yu},${yu},${Ef}\\)$`)
      , Vz = new RegExp(`^hsl\\(${Ef},${yu},${yu}\\)$`)
      , Bz = new RegExp(`^hsla\\(${Ef},${yu},${yu},${Ef}\\)$`)
      , xN = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    };
    rh(Cf, vf, {
        copy(e) {
            return Object.assign(new this.constructor, this, e)
        },
        displayable() {
            return this.rgb().displayable()
        },
        hex: TN,
        formatHex: TN,
        formatHex8: Gz,
        formatHsl: qz,
        formatRgb: IN,
        toString: IN
    });
    function TN() {
        return this.rgb().formatHex()
    }
    function Gz() {
        return this.rgb().formatHex8()
    }
    function qz() {
        return MN(this).formatHsl()
    }
    function IN() {
        return this.rgb().formatRgb()
    }
    function vf(e) {
        var t, n;
        return e = (e + "").trim().toLowerCase(),
        (t = Oz.exec(e)) ? (n = t[1].length,
        t = parseInt(t[1], 16),
        n === 6 ? PN(t) : n === 3 ? new rs(t >> 8 & 15 | t >> 4 & 240,t >> 4 & 15 | t & 240,(t & 15) << 4 | t & 15,1) : n === 8 ? oh(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : n === 4 ? oh(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = Az.exec(e)) ? new rs(t[1],t[2],t[3],1) : (t = wz.exec(e)) ? new rs(t[1] * 255 / 100,t[2] * 255 / 100,t[3] * 255 / 100,1) : (t = Lz.exec(e)) ? oh(t[1], t[2], t[3], t[4]) : (t = Fz.exec(e)) ? oh(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = Vz.exec(e)) ? CN(t[1], t[2] / 100, t[3] / 100, 1) : (t = Bz.exec(e)) ? CN(t[1], t[2] / 100, t[3] / 100, t[4]) : xN.hasOwnProperty(e) ? PN(xN[e]) : e === "transparent" ? new rs(NaN,NaN,NaN,0) : null
    }
    function PN(e) {
        return new rs(e >> 16 & 255,e >> 8 & 255,e & 255,1)
    }
    function oh(e, t, n, r) {
        return r <= 0 && (e = t = n = NaN),
        new rs(e,t,n,r)
    }
    function zz(e) {
        return e instanceof Cf || (e = vf(e)),
        e ? (e = e.rgb(),
        new rs(e.r,e.g,e.b,e.opacity)) : new rs
    }
    function Wl(e, t, n, r) {
        return arguments.length === 1 ? zz(e) : new rs(e,t,n,r == null ? 1 : r)
    }
    function rs(e, t, n, r) {
        this.r = +e,
        this.g = +t,
        this.b = +n,
        this.opacity = +r
    }
    rh(rs, Wl, fP(Cf, {
        brighter(e) {
            return e = e == null ? sh : Math.pow(sh, e),
            new rs(this.r * e,this.g * e,this.b * e,this.opacity)
        },
        darker(e) {
            return e = e == null ? Sf : Math.pow(Sf, e),
            new rs(this.r * e,this.g * e,this.b * e,this.opacity)
        },
        rgb() {
            return this
        },
        clamp() {
            return new rs(Xl(this.r),Xl(this.g),Xl(this.b),ah(this.opacity))
        },
        displayable() {
            return -.5 <= this.r && this.r < 255.5 && -.5 <= this.g && this.g < 255.5 && -.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1
        },
        hex: SN,
        formatHex: SN,
        formatHex8: Hz,
        formatRgb: EN,
        toString: EN
    }));
    function SN() {
        return `#${Zl(this.r)}${Zl(this.g)}${Zl(this.b)}`
    }
    function Hz() {
        return `#${Zl(this.r)}${Zl(this.g)}${Zl(this.b)}${Zl((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`
    }
    function EN() {
        let e = ah(this.opacity);
        return `${e === 1 ? "rgb(" : "rgba("}${Xl(this.r)}, ${Xl(this.g)}, ${Xl(this.b)}${e === 1 ? ")" : `, ${e})`}`
    }
    function ah(e) {
        return isNaN(e) ? 1 : Math.max(0, Math.min(1, e))
    }
    function Xl(e) {
        return Math.max(0, Math.min(255, Math.round(e) || 0))
    }
    function Zl(e) {
        return e = Xl(e),
        (e < 16 ? "0" : "") + e.toString(16)
    }
    function CN(e, t, n, r) {
        return r <= 0 ? e = t = n = NaN : n <= 0 || n >= 1 ? e = t = NaN : t <= 0 && (e = NaN),
        new Da(e,t,n,r)
    }
    function MN(e) {
        if (e instanceof Da)
            return new Da(e.h,e.s,e.l,e.opacity);
        if (e instanceof Cf || (e = vf(e)),
        !e)
            return new Da;
        if (e instanceof Da)
            return e;
        e = e.rgb();
        var t = e.r / 255
          , n = e.g / 255
          , r = e.b / 255
          , o = Math.min(t, n, r)
          , i = Math.max(t, n, r)
          , s = NaN
          , a = i - o
          , u = (i + o) / 2;
        return a ? (t === i ? s = (n - r) / a + (n < r) * 6 : n === i ? s = (r - t) / a + 2 : s = (t - n) / a + 4,
        a /= u < .5 ? i + o : 2 - i - o,
        s *= 60) : a = u > 0 && u < 1 ? 0 : s,
        new Da(s,a,u,e.opacity)
    }
    function uh(e, t, n, r) {
        return arguments.length === 1 ? MN(e) : new Da(e,t,n,r == null ? 1 : r)
    }
    function Da(e, t, n, r) {
        this.h = +e,
        this.s = +t,
        this.l = +n,
        this.opacity = +r
    }
    rh(Da, uh, fP(Cf, {
        brighter(e) {
            return e = e == null ? sh : Math.pow(sh, e),
            new Da(this.h,this.s,this.l * e,this.opacity)
        },
        darker(e) {
            return e = e == null ? Sf : Math.pow(Sf, e),
            new Da(this.h,this.s,this.l * e,this.opacity)
        },
        rgb() {
            var e = this.h % 360 + (this.h < 0) * 360
              , t = isNaN(e) || isNaN(this.s) ? 0 : this.s
              , n = this.l
              , r = n + (n < .5 ? n : 1 - n) * t
              , o = 2 * n - r;
            return new rs(yP(e >= 240 ? e - 240 : e + 120, o, r),yP(e, o, r),yP(e < 120 ? e + 240 : e - 120, o, r),this.opacity)
        },
        clamp() {
            return new Da(vN(this.h),ih(this.s),ih(this.l),ah(this.opacity))
        },
        displayable() {
            return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1
        },
        formatHsl() {
            let e = ah(this.opacity);
            return `${e === 1 ? "hsl(" : "hsla("}${vN(this.h)}, ${ih(this.s) * 100}%, ${ih(this.l) * 100}%${e === 1 ? ")" : `, ${e})`}`
        }
    }));
    function vN(e) {
        return e = (e || 0) % 360,
        e < 0 ? e + 360 : e
    }
    function ih(e) {
        return Math.max(0, Math.min(1, e || 0))
    }
    function yP(e, t, n) {
        return (e < 60 ? t + (n - t) * e / 60 : e < 180 ? n : e < 240 ? t + (n - t) * (240 - e) / 60 : t) * 255
    }
    function jl(e, t) {
        if (!isFinite(e) || !isFinite(t))
            return NaN;
        if (e = Math.round(e),
        t = Math.round(t),
        e < 0 && (e = -e),
        t < 0 && (t = -t),
        t > e) {
            let r = t;
            t = e,
            e = r
        }
        if (t === 0)
            return e;
        let n = e % t;
        for (; n > 0; )
            e = t,
            t = n,
            n = e % t;
        return t
    }
    function Jl(e, t) {
        if (isNaN(e) && t === 0)
            return NaN;
        if (e >= 0 || t === Math.floor(t))
            return Math.pow(e, t);
        let n = cc(t, 100);
        return Bi(n.n / n.d, t, 2) && n.d % 2 === 1 ? (n.n % 2 === 0 ? 1 : -1) * Math.pow(-e, t) : NaN
    }
    var le = {};
    cu(le, {
        Action: () => pt,
        AngleMarker: () => Oe,
        Any: () => Dn,
        Arc: () => ce,
        Bool: () => Fe,
        BroadcastableArg: () => fh,
        ChiSquareGoodnessOfFit: () => qn,
        ChiSquareIndependence: () => zn,
        Circle: () => he,
        Complex: () => N,
        ConfidenceInterval: () => Pt,
        DirectedAngleMarker: () => Se,
        Distribution: () => Rn,
        EmptyList: () => He,
        ErrorType: () => ep,
        InferenceObjectTypes: () => mh,
        Line: () => Ce,
        ListArgType: () => dh,
        ListOfAngleMarker: () => Ar,
        ListOfAny: () => nr,
        ListOfArc: () => mo,
        ListOfBool: () => yi,
        ListOfChiSquareGoodnessOfFit: () => vu,
        ListOfChiSquareIndependence: () => Mu,
        ListOfCircle: () => hi,
        ListOfColor: () => Ao,
        ListOfComplex: () => ke,
        ListOfConfidenceInterval: () => bu,
        ListOfDirectedAngleMarker: () => wr,
        ListOfDistribution: () => gi,
        ListOfLine: () => bi,
        ListOfMapInterval2DComplex: () => Aa,
        ListOfMapInterval2DPoint: () => Ra,
        ListOfMapInterval2DPoint3D: () => Na,
        ListOfMapIntervalComplex: () => Oa,
        ListOfMapIntervalPoint: () => _a,
        ListOfMapIntervalPoint3D: () => ta,
        ListOfNumber: () => Y,
        ListOfNumberNC: () => na,
        ListOfOneProportionZInference: () => Su,
        ListOfOneSampleTInference: () => xu,
        ListOfOneSampleZInference: () => Iu,
        ListOfPoint: () => zt,
        ListOfPoint3D: () => to,
        ListOfPolygon: () => Dr,
        ListOfRay: () => fo,
        ListOfRegressionTInference: () => Cu,
        ListOfRestriction: () => gu,
        ListOfSegment: () => Tr,
        ListOfSegment3D: () => Gi,
        ListOfSphere3D: () => ea,
        ListOfTSignificanceTest: () => _u,
        ListOfTone: () => hu,
        ListOfTransformation: () => Ks,
        ListOfTriangle3D: () => Zo,
        ListOfTwoProportionZInference: () => Eu,
        ListOfTwoSampleTInference: () => Tu,
        ListOfTwoSampleZInference: () => Pu,
        ListOfVector: () => xi,
        ListOfVector3D: () => qi,
        ListOfZSignificanceTest: () => Du,
        MapInterval2DComplex: () => Fs,
        MapInterval2DPoint: () => ws,
        MapInterval2DPoint3D: () => Ls,
        MapIntervalComplex: () => Hi,
        MapIntervalPoint: () => zi,
        MapIntervalPoint3D: () => yo,
        NoCoerceComplexToReal: () => Rf,
        Number: () => b,
        NumberNC: () => Pe,
        OneProportionZInference: () => an,
        OneSampleTInference: () => $t,
        OneSampleZInference: () => Qt,
        Point: () => R,
        Point3D: () => G,
        Polygon: () => De,
        RGBColor: () => bn,
        Ray: () => Ae,
        RegressionTInference: () => Kt,
        Restriction: () => sn,
        SeedType: () => _t,
        Segment: () => Ee,
        Segment3D: () => en,
        SlotNameMap: () => Mf,
        Sphere3D: () => Lr,
        TSignificanceTest: () => mn,
        Tone: () => cr,
        Transformation: () => we,
        Triangle3D: () => lr,
        TupleTypeMap: () => dc,
        TwoProportionZInference: () => Yt,
        TwoSampleTInference: () => wt,
        TwoSampleZInference: () => Ht,
        UNKNOWN_RETURN_TYPE: () => Qz,
        Union: () => xr,
        Vector: () => Ie,
        Vector3D: () => qe,
        ZSignificanceTest: () => pn,
        allListTypes: () => Ui,
        allTupleTypes: () => bP,
        allValueTypes: () => Yz,
        angleTypes: () => IP,
        assertTypeIsOneOf: () => Nu,
        broadcastArg: () => Fr,
        broadcastable: () => q,
        commonCoerceableType: () => Uc,
        commonCoerceableTypeWithBroadcast: () => mc,
        elementType: () => Qe,
        getAllowedTypesForArg: () => Of,
        hasListType: () => jn,
        hasMapType: () => PP,
        isActionValue: () => fc,
        isEligibleForBroadcast: () => yh,
        isGeometryType: () => _f,
        isInferenceObjectType: () => Ti,
        isList: () => X,
        isMapOrListOfMap: () => wa,
        isMultipliableElementType: () => xP,
        isOneOf: () => Ru,
        isSubType: () => As,
        isSubTypeOrCoercible: () => ur,
        isSubTypeOrNonComplexCoercible: () => Ql,
        isSummableElementType: () => hm,
        isTupleType: () => gP,
        isTypeOrListOfType: () => ae,
        isValidOnLogScales: () => tp,
        listArg: () => Nf,
        listType: () => $n,
        mapType: () => SP,
        multipliableElementTypes: () => lh,
        namedSlot: () => Jz,
        nanOrZeroOfTupleType: () => hP,
        prettyPrint: () => se,
        repr: () => Ke,
        scalarType: () => rr,
        signature: () => St,
        slotIndex: () => Df,
        straightTypes: () => ph,
        summableElementTypes: () => gm,
        typeSatisfiesArgType: () => gh,
        typeSatisfiesArgTypeUncoerced: () => np,
        valueTypes: () => DN,
        variadicMinCount: () => no,
        vectorTypes: () => TP
    });
    function ch(e, t) {
        return t ? $n(e) : e
    }
    function As(e, t) {
        return e === He && X(t) || t === nr && X(e) || t === Dn && !X(e) ? !0 : e === t
    }
    function ur(e, t) {
        if (e === void 0)
            return !1;
        if (As(e, t))
            return !0;
        X(e) && X(t) && t !== He && (e = Qe(e),
        t = Qe(t));
        let n = t;
        switch (e) {
        case Oe:
        case Se:
        case sn:
        case b:
        case N:
            return n === b || n === N;
        default:
            return !1
        }
    }
    function Ql(e, t) {
        return t === b && e === N || t === Y && e === ke ? !1 : ur(e, t)
    }
    function Uc(e, t) {
        if (As(e, t))
            return t;
        if (As(t, e))
            return e;
        let n = X(e);
        if (n != X(t))
            return;
        let r = ch(N, n);
        if (e === r && ur(t, r))
            return r;
        if (t === r && ur(e, r))
            return r;
        let o = ch(b, n);
        if (ur(e, o) && ur(t, o)) {
            let i = ch(Oe, n)
              , s = ch(Se, n);
            return e === i && t === s || e === s && t === i ? void 0 : o
        }
    }
    function mc(e, t) {
        return X(e) && jn(t) ? Uc(e, $n(t)) : jn(e) && X(t) ? Uc($n(e), t) : Uc(e, t)
    }
    function I(e, t) {
        return {
            key: e,
            vars: t
        }
    }
    var Dn = 0
      , b = 1
      , Fe = 2
      , R = 3
      , Rn = 4
      , pt = 5
      , nr = 6
      , Y = 7
      , yi = 8
      , zt = 9
      , gi = 10
      , He = 11
      , ep = 12
      , _t = 13
      , bn = 14
      , Ao = 15
      , De = 16
      , Dr = 17
      , Ee = 18
      , Tr = 19
      , he = 20
      , hi = 21
      , ce = 22
      , mo = 23
      , Ce = 24
      , bi = 25
      , Ae = 26
      , fo = 27
      , Oe = 28
      , Ar = 29
      , Se = 30
      , wr = 31
      , we = 32
      , Ks = 33
      , Ie = 34
      , xi = 35
      , sn = 36
      , gu = 37
      , N = 38
      , ke = 39
      , cr = 50
      , hu = 51
      , Pt = 60
      , bu = 61
      , $t = 62
      , xu = 63
      , wt = 64
      , Tu = 65
      , Qt = 66
      , Iu = 67
      , Ht = 68
      , Pu = 69
      , an = 70
      , Su = 71
      , Yt = 72
      , Eu = 73
      , Kt = 76
      , Cu = 77
      , qn = 78
      , vu = 79
      , zn = 80
      , Mu = 81
      , pn = 82
      , Du = 83
      , mn = 84
      , _u = 85
      , G = 100
      , to = 101
      , en = 102
      , Gi = 103
      , lr = 104
      , Zo = 105
      , Lr = 106
      , ea = 107
      , qe = 108
      , qi = 109
      , zi = 200
      , yo = 201
      , ws = 202
      , Ls = 203
      , _a = 204
      , ta = 205
      , Ra = 206
      , Na = 207
      , Hi = 208
      , Fs = 209
      , Oa = 210
      , Aa = 211
      , DN = {
        Any: Dn,
        Number: b,
        Bool: Fe,
        Complex: N,
        ListOfComplex: ke,
        Point: R,
        Point3D: G,
        Distribution: Rn,
        Action: pt,
        ListOfAny: nr,
        ListOfNumber: Y,
        ListOfBool: yi,
        ListOfPoint: zt,
        ListOfPoint3D: to,
        ListOfDistribution: gi,
        EmptyList: He,
        ErrorType: ep,
        SeedType: _t,
        RGBColor: bn,
        ListOfColor: Ao,
        Polygon: De,
        ListOfPolygon: Dr,
        Segment: Ee,
        ListOfSegment: Tr,
        Circle: he,
        ListOfCircle: hi,
        Arc: ce,
        ListOfArc: mo,
        Line: Ce,
        ListOfLine: bi,
        Ray: Ae,
        ListOfRay: fo,
        Vector: Ie,
        ListOfVector: xi,
        Restriction: sn,
        ListOfRestriction: gu,
        AngleMarker: Oe,
        ListOfAngleMarker: Ar,
        DirectedAngleMarker: Se,
        ListOfDirectedAngleMarker: wr,
        Transformation: we,
        ListOfTransformation: Ks,
        Segment3D: en,
        ListOfSegment3D: Gi,
        Triangle3D: lr,
        ListOfTriangle3D: Zo,
        Sphere3D: Lr,
        ListOfSphere3D: ea,
        Vector3D: qe,
        ListOfVector3D: qi,
        Tone: cr,
        ListOfTone: hu,
        ConfidenceInterval: Pt,
        ListOfConfidenceInterval: bu,
        OneSampleTInference: $t,
        ListOfOneSampleTInference: xu,
        TwoSampleTInference: wt,
        ListOfTwoSampleTInference: Tu,
        RegressionTInference: Kt,
        ListOfRegressionTInference: Cu,
        OneSampleZInference: Qt,
        ListOfOneSampleZInference: Iu,
        TwoSampleZInference: Ht,
        ListOfTwoSampleZInference: Pu,
        OneProportionZInference: an,
        ListOfOneProportionZInference: Su,
        TwoProportionZInference: Yt,
        ListOfTwoProportionZInference: Eu,
        ChiSquareGoodnessOfFit: qn,
        ListOfChiSquareGoodnessOfFit: vu,
        ChiSquareIndependence: zn,
        ListOfChiSquareIndependence: Mu,
        ZSignificanceTest: pn,
        ListOfZSignificanceTest: Du,
        TSignificanceTest: mn,
        ListOfTSignificanceTest: _u,
        MapIntervalPoint: zi,
        MapIntervalComplex: Hi,
        MapIntervalPoint3D: yo,
        MapInterval2DPoint: ws,
        MapInterval2DComplex: Fs,
        MapInterval2DPoint3D: Ls,
        ListOfMapIntervalPoint: _a,
        ListOfMapIntervalComplex: Oa,
        ListOfMapIntervalPoint3D: ta,
        ListOfMapInterval2DPoint: Ra,
        ListOfMapInterval2DComplex: Aa,
        ListOfMapInterval2DPoint3D: Na
    }
      , _N = {
        [R]: [["x", b], ["y", b]],
        [G]: [["x", b], ["y", b], ["z", b]],
        [N]: [["real", b], ["imag", b]],
        [Pt]: [["min", b], ["max", b], ["standardError", b], ["dof", b]],
        [$t]: [["count", b], ["mean", b], ["stdev", b], ["dof", b]],
        [wt]: [["count1", b], ["mean1", b], ["stdev1", b], ["count2", b], ["mean2", b], ["stdev2", b], ["dof", b]],
        [Kt]: [["pointEstimate", b], ["standardError", b], ["dof", b]],
        [Qt]: [["count", b], ["mean", b], ["stdevp", b]],
        [Ht]: [["count1", b], ["mean1", b], ["stdevp1", b], ["count2", b], ["mean2", b], ["stdevp2", b]],
        [an]: [["successes", b], ["count", b]],
        [Yt]: [["successes1", b], ["count1", b], ["successes2", b], ["count2", b]],
        [pn]: [["p", b], ["score", b], ["hypothesis", b], ["pleft", b], ["pright", b]],
        [mn]: [["p", b], ["score", b], ["hypothesis", b], ["pleft", b], ["pright", b], ["dof", b]],
        [qn]: [["p", b], ["score", b], ["dof", b], ["observed", Y], ["expected", Y], ["contributions", Y], ["total", b]],
        [zn]: [["p", b], ["score", b], ["dof", b], ["observed", Y], ["expected", Y], ["contributions", Y], ["rows", b], ["columns", b], ["rowTotals", Y], ["columnTotals", Y], ["total", b]]
    };
    function kz() {
        let e = {};
        for (let[t,n] of Object.entries(_N))
            e[t] = n.map(r => r[1]);
        return e
    }
    function $z() {
        let e = {};
        for (let[t,n] of Object.entries(_N))
            e[t] = n.map(r => r[0]);
        return e
    }
    var dc = kz()
      , Mf = $z();
    function Df(e, t) {
        let n = Mf[e];
        if (n === void 0)
            throw new Error(`Programming error: ${Ke(e)} is not a tuple type.`);
        let r = n.indexOf(t);
        if (r === -1)
            throw new Error(`Programming error: ${t} is not a slot of ${Ke(e)}`);
        return r
    }
    function gP(e) {
        return e in Mf
    }
    function hP(e, t) {
        let n = dc[e];
        return {
            valueType: e,
            value: n.map(r => {
                if (r !== b)
                    throw new Error("Unable to handle tuple type unless all slots are Number");
                return t
            }
            )
        }
    }
    var xr = class e {
        constructor(t, {coerceComplexToReal: n}) {
            this.types = t;
            this.coerceComplexToReal = n
        }
        static of(t, n={
            coerceComplexToReal: !0
        }) {
            return new e(t,n)
        }
        getTypes() {
            return this.types
        }
    }
      , Yz = Object.values(DN)
      , Zz = Object.keys(dc).map(parseFloat)
      , bP = xr.of(Zz);
    function Ke(e) {
        if (X(e))
            return e === He ? "EmptyList" : `ListOf${Ke(Qe(e))}`;
        switch (e) {
        case Dn:
            return "Any";
        case b:
            return "Number";
        case Fe:
            return "Bool";
        case N:
            return "Complex";
        case R:
            return "Point";
        case G:
            return "Point3D";
        case Rn:
            return "Distribution";
        case Pt:
            return "ConfidenceInterval";
        case $t:
            return "OneSampleTInference";
        case wt:
            return "TwoSampleTInference";
        case Kt:
            return "RegressionTInference";
        case Qt:
            return "OneSampleZInference";
        case Ht:
            return "TwoSampleZInference";
        case an:
            return "OneProportionZInference";
        case Yt:
            return "TwoProportionZInference";
        case pn:
            return "ZSignificanceTest";
        case mn:
            return "TSignificanceTest";
        case qn:
            return "ChiSquareGoodnessOfFit";
        case zn:
            return "ChiSquareIndependence";
        case pt:
            return "Action";
        case ep:
            return "ErrorType";
        case _t:
            return "SeedType";
        case bn:
            return "RGBColor";
        case De:
            return "Polygon";
        case Ee:
            return "Segment";
        case he:
            return "Circle";
        case ce:
            return "Arc";
        case Ce:
            return "Line";
        case Ae:
            return "Ray";
        case Ie:
            return "Vector";
        case sn:
            return "Restriction";
        case Oe:
            return "Angle";
        case Se:
            return "DirectedAngle";
        case we:
            return "Transformation";
        case en:
            return "Segment3D";
        case qe:
            return "Vector3D";
        case lr:
            return "Triangle3D";
        case Lr:
            return "Sphere3D";
        case cr:
            return "Tone";
        case zi:
            return "MapIntervalPoint";
        case Hi:
            return "MapIntervalComplex";
        case yo:
            return "MapIntervalPoint3D";
        case ws:
            return "MapInterval2ToPoint";
        case Fs:
            return "MapInterval2ToComplex";
        case Ls:
            return "MapInterval2DPoint3D";
        default:
            let t = e;
            throw new Error(`Invalid type: ${t}`)
        }
    }
    function se(e, t) {
        var r;
        let n = (r = t == null ? void 0 : t.specifyPointDimensions) != null ? r : !1;
        switch (e) {
        case Dn:
            return I("shared-calculator-label-value-type-any");
        case b:
            return I("shared-calculator-label-value-type-number");
        case Fe:
            return I("shared-calculator-label-value-type-bool");
        case N:
            return I("shared-calculator-label-value-type-complex");
        case R:
            return n ? I("shared-calculator-label-value-type-point2d") : I("shared-calculator-label-value-type-point");
        case G:
            return I("shared-calculator-label-value-type-point3d");
        case Rn:
            return I("shared-calculator-label-value-type-distribution");
        case pt:
            return I("shared-calculator-label-value-type-action");
        case nr:
            return I("shared-calculator-label-value-type-list-of-any");
        case Y:
            return I("shared-calculator-label-value-type-list-of-numbers");
        case yi:
            return I("shared-calculator-label-value-type-list-of-bool");
        case ke:
            return I("shared-calculator-label-value-type-list-of-complex");
        case zt:
            return n ? I("shared-calculator-label-value-type-list-of-2d-points") : I("shared-calculator-label-value-type-list-of-points");
        case to:
            return I("shared-calculator-label-value-type-list-of-3d-points");
        case gi:
            return I("shared-calculator-label-value-type-list-of-distributions");
        case He:
            return I("shared-calculator-label-value-type-empty-list");
        case ep:
            return I("shared-calculator-label-value-type-error");
        case _t:
            return I("shared-calculator-label-value-type-seed");
        case bn:
            return I("shared-calculator-label-value-type-color");
        case Ao:
            return I("shared-calculator-label-value-type-list-of-colors");
        case De:
            return I("shared-calculator-label-value-type-polygon");
        case Dr:
            return I("shared-calculator-label-value-type-list-of-polygons");
        case Ee:
            return I("shared-calculator-label-value-type-segment");
        case Tr:
            return I("shared-calculator-label-value-type-list-of-segments");
        case he:
            return I("shared-calculator-label-value-type-circle");
        case hi:
            return I("shared-calculator-label-value-type-list-of-circles");
        case ce:
            return I("shared-calculator-label-value-type-arc");
        case mo:
            return I("shared-calculator-label-value-type-list-of-arcs");
        case Ce:
            return I("shared-calculator-label-value-type-line");
        case bi:
            return I("shared-calculator-label-value-type-list-of-lines");
        case Ae:
            return I("shared-calculator-label-value-type-ray");
        case fo:
            return I("shared-calculator-label-value-type-list-of-rays");
        case Ie:
            return I("shared-calculator-label-value-type-vector");
        case xi:
            return I("shared-calculator-label-value-type-list-of-vectors");
        case sn:
            return I("shared-calculator-label-value-type-restriction");
        case gu:
            return I("shared-calculator-label-value-type-list-of-restrictions");
        case Oe:
            return I("shared-calculator-label-value-type-angle");
        case Ar:
            return I("shared-calculator-label-value-type-list-of-angles");
        case Se:
            return I("shared-calculator-label-value-type-directed-angle");
        case wr:
            return I("shared-calculator-label-value-type-list-of-directed-angles");
        case we:
            return I("shared-calculator-label-value-type-transformation");
        case Ks:
            return I("shared-calculator-label-value-type-list-of-transformations");
        case en:
            return I("shared-calculator-label-value-type-segment3d");
        case Gi:
            return I("shared-calculator-label-value-type-list-of-segment3d");
        case qe:
            return I("shared-calculator-label-value-type-vector3d");
        case qi:
            return I("shared-calculator-label-value-type-list-of-vector3d");
        case lr:
            return I("shared-calculator-label-value-type-triangle3d");
        case Zo:
            return I("shared-calculator-label-value-type-list-of-triangle3d");
        case Lr:
            return I("shared-calculator-label-value-type-sphere3d");
        case ea:
            return I("shared-calculator-label-value-type-list-of-sphere3d");
        case cr:
            return I("shared-calculator-label-value-type-tone");
        case hu:
            return I("shared-calculator-label-value-type-list-of-tone");
        case Pt:
            return I("shared-calculator-label-value-type-confidence-interval");
        case bu:
            return I("shared-calculator-label-value-type-list-of-confidence-interval");
        case pn:
            return I("shared-calculator-label-value-type-z-significance-test");
        case mn:
            return I("shared-calculator-label-value-type-t-significance-test");
        case Du:
            return I("shared-calculator-label-value-type-list-of-z-significance-test");
        case _u:
            return I("shared-calculator-label-value-type-list-of-t-significance-test");
        case $t:
            return I("shared-calculator-label-value-type-one-sample-t-inference");
        case wt:
            return I("shared-calculator-label-value-type-two-sample-t-inference");
        case Kt:
            return I("shared-calculator-label-value-type-regression-t-inference");
        case Qt:
            return I("shared-calculator-label-value-type-one-sample-z-inference");
        case Ht:
            return I("shared-calculator-label-value-type-two-sample-z-inference");
        case an:
            return I("shared-calculator-label-value-type-one-proportion-z-inference");
        case Yt:
            return I("shared-calculator-label-value-type-two-proportion-z-inference");
        case xu:
            return I("shared-calculator-label-value-type-list-of-one-sample-t-inference");
        case Tu:
            return I("shared-calculator-label-value-type-list-of-two-sample-t-inference");
        case Cu:
            return I("shared-calculator-label-value-type-list-of-regression-t-inference");
        case Iu:
            return I("shared-calculator-label-value-type-list-of-one-sample-z-inference");
        case Pu:
            return I("shared-calculator-label-value-type-list-of-two-sample-z-inference");
        case Su:
            return I("shared-calculator-label-value-type-list-of-one-proportion-z-inference");
        case Eu:
            return I("shared-calculator-label-value-type-list-of-two-proportion-z-inference");
        case zn:
            return I("shared-calculator-label-value-type-chi-square-test-of-independence");
        case qn:
            return I("shared-calculator-label-value-type-chi-square-goodness-of-fit");
        case Mu:
            return I("shared-calculator-label-value-type-list-of-chi-square-test-of-independence");
        case vu:
            return I("shared-calculator-label-value-type-list-of-chi-square-goodness-of-fit");
        case zi:
        case ws:
            return I("shared-calculator-label-value-type-lambda-point");
        case Hi:
        case Fs:
            return I("shared-calculator-label-value-type-lambda-complex");
        case yo:
        case Ls:
            return I("shared-calculator-label-value-type-lambda-point3d");
        case _a:
        case Ra:
            return I("shared-calculator-label-value-type-list-of-lambda-point");
        case Oa:
        case Aa:
            return I("shared-calculator-label-value-type-list-of-lambda-complex");
        case ta:
        case Na:
            return I("shared-calculator-label-value-type-list-of-lambda-point3d");
        default:
            throw new Error(`Invalid type: ${e}`)
        }
    }
    var Xz = [nr, Y, yi, ke, gu, zt, to, gi, He, Ao, Dr, Tr, hi, mo, bi, fo, xi, Ar, wr, Ks, Gi, qi, Zo, ea, hu, bu, xu, Tu, Cu, Iu, Pu, Su, Eu, Du, _u, vu, Mu, _a, Oa, ta, Ra, Aa, Na]
      , Ui = xr.of(Xz, {
        coerceComplexToReal: !1
    })
      , RN = {
        [nr]: Dn,
        [He]: b,
        [Y]: b,
        [yi]: Fe,
        [ke]: N,
        [gu]: sn,
        [zt]: R,
        [to]: G,
        [gi]: Rn,
        [Ao]: bn,
        [Dr]: De,
        [Tr]: Ee,
        [hi]: he,
        [mo]: ce,
        [bi]: Ce,
        [fo]: Ae,
        [xi]: Ie,
        [Ar]: Oe,
        [wr]: Se,
        [Ks]: we,
        [Gi]: en,
        [qi]: qe,
        [Zo]: lr,
        [ea]: Lr,
        [hu]: cr,
        [bu]: Pt,
        [xu]: $t,
        [Tu]: wt,
        [Cu]: Kt,
        [Iu]: Qt,
        [Pu]: Ht,
        [Su]: an,
        [Eu]: Yt,
        [Du]: pn,
        [_u]: mn,
        [vu]: qn,
        [Mu]: zn,
        [_a]: zi,
        [Oa]: Hi,
        [ta]: yo,
        [Ra]: ws,
        [Aa]: Fs,
        [Na]: Ls
    };
    function X(e) {
        return e === void 0 ? !1 : e in RN
    }
    function Qe(e) {
        if (!X(e))
            throw new Error("Type " + Ke(e) + " does not implement elementType.");
        return RN[e]
    }
    function rr(e) {
        return X(e) ? Qe(e) : e
    }
    function $n(e) {
        if (X(e))
            throw new Error("Type " + Ke(e) + " does not implement listType.");
        switch (e) {
        case Dn:
            return nr;
        case b:
            return Y;
        case Fe:
            return yi;
        case N:
            return ke;
        case sn:
            return gu;
        case R:
            return zt;
        case G:
            return to;
        case Rn:
            return gi;
        case bn:
            return Ao;
        case De:
            return Dr;
        case Ee:
            return Tr;
        case he:
            return hi;
        case ce:
            return mo;
        case Ce:
            return bi;
        case Ae:
            return fo;
        case Ie:
            return xi;
        case Oe:
            return Ar;
        case Se:
            return wr;
        case we:
            return Ks;
        case en:
            return Gi;
        case qe:
            return qi;
        case lr:
            return Zo;
        case Lr:
            return ea;
        case cr:
            return hu;
        case Pt:
            return bu;
        case $t:
            return xu;
        case wt:
            return Tu;
        case Kt:
            return Cu;
        case Qt:
            return Iu;
        case Ht:
            return Pu;
        case an:
            return Su;
        case Yt:
            return Eu;
        case pn:
            return Du;
        case mn:
            return _u;
        case qn:
            return vu;
        case zn:
            return Mu;
        case zi:
            return _a;
        case Hi:
            return Oa;
        case yo:
            return ta;
        case ws:
            return Ra;
        case Fs:
            return Aa;
        case Ls:
            return Na;
        case ep:
        case _t:
        case pt:
            throw new Error("Type " + Ke(e) + " does not implement listType.");
        default:
            throw new Error(`Invalid type: ${e}`)
        }
    }
    function jn(e) {
        if (X(e))
            return !1;
        switch (e) {
        case _t:
        case pt:
        case ep:
            return !1;
        default:
            return !0
        }
    }
    function _f(e) {
        if (e === void 0)
            return !1;
        switch (e) {
        case R:
        case De:
        case Ee:
        case he:
        case ce:
        case Ce:
        case Ae:
        case Ie:
        case Oe:
        case Se:
        case we:
            return !0;
        default:
            return !1
        }
    }
    function tp(e) {
        if (X(e))
            return tp(Qe(e));
        switch (e) {
        case b:
        case Dn:
        case Fe:
        case N:
        case sn:
        case R:
        case zi:
        case Hi:
        case Rn:
        case pt:
        case ep:
        case _t:
        case bn:
        case cr:
        case Pt:
        case $t:
        case wt:
        case Kt:
        case Qt:
        case Ht:
        case an:
        case Yt:
        case pn:
        case mn:
        case zn:
        case qn:
            return !0;
        case G:
        case en:
        case qe:
        case lr:
        case Lr:
        case De:
        case Ee:
        case he:
        case ce:
        case Ce:
        case Ae:
        case Ie:
        case Oe:
        case Se:
        case we:
        case yo:
        case ws:
        case Fs:
        case Ls:
            return !1;
        default:
            throw new Error(`Invalid type: ${e}`)
        }
    }
    function Ru(e, t) {
        for (let n of t)
            if (e === n)
                return !0;
        return !1
    }
    var gm = [b, N, R, G];
    function hm(e) {
        return gm.includes(e)
    }
    var lh = [b, N];
    function xP(e) {
        return lh.includes(e)
    }
    var ph = xr.of([Ce, Ae, Ee, Ie])
      , TP = xr.of([Ie, qe])
      , IP = xr.of([Oe, Se]);
    function ae(e, t) {
        return e === void 0 ? !1 : e === t ? !0 : X(e) ? e === He ? !0 : Qe(e) === t : !1
    }
    function wa(e) {
        return Ru(e, [zi, Hi, yo, ws, Fs, Ls, _a, Oa, ta, Ra, Aa, Na])
    }
    var NN = {
        [R]: zi,
        [N]: Hi,
        [G]: yo
    }
      , Wz = {
        [R]: ws,
        [N]: Fs,
        [G]: Ls
    };
    function PP(e) {
        return NN[e] !== void 0
    }
    function SP(e, t) {
        let n = t === 1 ? NN[e] : Wz[e];
        if (n === void 0)
            throw new Error(`Unexpected return type for map: ${Ke(e)}`);
        return n
    }
    var mh = [$t, wt, Kt, Qt, Ht, an, Yt];
    function Ti(e) {
        return Ru(e, mh)
    }
    function Nu(e, t) {
        if (!Ru(e, t))
            throw new Error(`Programming error: expected one of ${t.map(Ke)} but found ${e && Ke(e)} instead.`)
    }
    function fc(e) {
        return typeof e == "object" && "type"in e && e.type === "Action"
    }
    function Jz(e, t) {
        return e.value[Df(e.valueType, t)]
    }
    var Qz = Symbol("UNKNOWN_RETURN_TYPE");
    function ON(e) {
        return typeof e == "object" && e.type === "variadic"
    }
    function no(e, t) {
        return {
            type: "variadic",
            initial: new Array(t).fill(e),
            rest: e
        }
    }
    var EP = class {
        constructor(t, n) {
            this.argTypes = t;
            this.productContext = n;
            this.minArity = this.argTypes.length,
            this.maxArity = this.argTypes.length
        }
        argTypeAtIndex(t) {
            if (!(t > this.argTypes.length - 1))
                return this.argTypes[t]
        }
        matches(t) {
            return AN(this, t)
        }
        satisfiesPolicy(t) {
            return t.is3dProduct() ? this.productContext["3d"] : t.isGeometryEnabled() ? this.productContext.geometry : this.productContext.graphing
        }
    }
      , CP = class {
        constructor(t, n) {
            this.productContext = n;
            this.maxArity = void 0;
            this.initial = t.initial,
            this.rest = t.rest,
            this.minArity = this.initial.length
        }
        argTypeAtIndex(t) {
            return t < this.initial.length ? this.initial[t] : this.rest
        }
        matches(t) {
            return AN(this, t)
        }
        satisfiesPolicy(t) {
            return t.is3dProduct() ? this.productContext["3d"] : t.isGeometryEnabled() ? this.productContext.geometry : this.productContext.graphing
        }
    }
    ;
    function AN(e, t) {
        return e.maxArity !== void 0 && e.maxArity < t.length ? !1 : !!t.every( (n, r) => {
            if (n === void 0)
                return !0;
            let o = e.argTypeAtIndex(r);
            return o === void 0 ? !1 : gh(n, o)
        }
        )
    }
    var Rf = class {
        constructor(t) {
            this.arg = t;
            this.coerceComplexToReal = !1
        }
        getTypes() {
            return typeof this.arg == "number" ? [this.arg] : this.arg.getTypes()
        }
    }
      , Pe = new Rf(b)
      , na = new Rf(Y)
      , dh = class {
        constructor(t) {
            typeof t == "number" ? (this.coerceComplexToReal = t === b,
            this.nodeTypes = [$n(t)]) : (this.coerceComplexToReal = t.coerceComplexToReal,
            this.nodeTypes = t.getTypes().map($n))
        }
        getTypes() {
            return this.nodeTypes
        }
    }
    ;
    function Nf(e) {
        return new dh(e)
    }
    var fh = class {
        constructor(t) {
            if (typeof t == "number")
                this.coerceComplexToReal = t === b,
                this.nodeTypes = [t, $n(t)];
            else {
                this.coerceComplexToReal = t.coerceComplexToReal,
                this.nodeTypes = [];
                for (let n of t.getTypes())
                    this.nodeTypes.push(n, $n(n))
            }
        }
        getTypes() {
            return this.nodeTypes
        }
    }
    ;
    function yh(e) {
        return typeof e == "number" ? jn(e) : e instanceof xr ? e.types.every(yh) : !1
    }
    function Fr(e) {
        return new fh(e)
    }
    function St(e, t={}) {
        let n = {
            geometry: !0,
            "3d": !0,
            graphing: !0,
            ...t
        };
        return ON(e) ? new CP(e,n) : new EP(e,n)
    }
    function q(e, t={}) {
        return ON(e) ? St({
            type: "variadic",
            initial: e.initial.map(Fr),
            rest: Fr(e.rest)
        }, t) : St(e.map(Fr), t)
    }
    function gh(e, t) {
        if (typeof t == "number")
            return ur(e, t);
        {
            let n = t.getTypes();
            return t.coerceComplexToReal ? n.some(r => ur(e, r)) : n.some(r => Ql(e, r))
        }
    }
    function np(e, t) {
        return typeof t == "number" ? As(e, t) : t.getTypes().some(r => As(e, r))
    }
    function Of(e, t) {
        let n = new Set;
        for (let r of e) {
            let o = r.argTypeAtIndex(t);
            if (o === void 0)
                continue;
            let i = Kz(o);
            for (let s of i)
                n.add(s)
        }
        return [...n]
    }
    function Kz(e) {
        return typeof e == "number" ? [e] : e.getTypes()
    }
    var vP = [Fe, sn, b, N, R, G, en, qe, lr, Lr, pt, bn, De, Ee, he, ce, Ce, Ae, Ie, Oe, Se, we, cr, Pt, pn, mn, $t, wt, Kt, Qt, Ht, an, Yt]
      , eH = new Set(vP)
      , Af = xr.of(vP.filter(e => jn(e)))
      , wf = xr.of(vP.filter(e => !jn(e)));
    function ra(e) {
        return eH.has(e)
    }
    function wN(e) {
        return ra(e)
    }
    function wo(e) {
        return FN(e, NaN).value
    }
    function LN(e) {
        return FN(e, 0).value
    }
    function FN(e, t) {
        switch (e) {
        case b:
            return {
                valueType: e,
                value: t
            };
        case en:
        case qe:
            return {
                valueType: e,
                value: [[t, t, t], [t, t, t]]
            };
        case lr:
            return {
                valueType: e,
                value: [[t, t, t], [t, t, t], [t, t, t]]
            };
        case Lr:
            return {
                valueType: e,
                value: [[t, t, t], t]
            };
        case bn:
            return {
                valueType: e,
                value: [t, t, t]
            };
        case pt:
            return {
                valueType: e,
                value: {
                    type: "Action",
                    updateRules: {}
                }
            };
        case Ee:
        case Ae:
        case Ce:
            return {
                valueType: e,
                value: [[t, t], [t, t]]
            };
        case Ie:
            return {
                valueType: e,
                value: [[t, t], [t, t]]
            };
        case he:
            return {
                valueType: e,
                value: [[t, t], t]
            };
        case ce:
            return {
                valueType: e,
                value: [[t, t], [t, t], [t, t]]
            };
        case Fe:
        case sn:
            return {
                valueType: e,
                value: !1
            };
        case De:
            return {
                valueType: e,
                value: []
            };
        case we:
            return {
                valueType: e,
                value: [[t, t], [t, t], !1]
            };
        case Oe:
        case Se:
            return {
                valueType: e,
                value: [[t, t], t, t, t]
            };
        case cr:
            return {
                valueType: e,
                value: [t, t]
            };
        default:
            if (gP(e))
                return hP(e, t);
            throw new Error(`${e} does not have a ${t === 0 ? "zero" : "NaN"} type.`)
        }
    }
    function VN(e, t) {
        return $o(wo(e), t)
    }
    function bm(e, t) {
        return {
            n: e,
            d: t
        }
    }
    function un(e) {
        return typeof e == "object" && typeof e.n == "number" && typeof e.d == "number"
    }
    var Lf = Math.pow(2, 53) - 1;
    function op(e) {
        let t = e.match(/^(-)?(\d*)?(?:\.(\d*))?$/);
        if (!t)
            return NaN;
        let n = t[1]
          , r = t[2]
          , o = t[3];
        if (!r && !o)
            return NaN;
        let i = !!n;
        if (o) {
            let s = o.replace(/0+$/, "")
              , a = s.length
              , u = Math.pow(10, a)
              , c = parseInt(r || "0", 10) * u + parseInt(s || "0", 10);
            return c > Lf || u > Lf ? parseFloat(e) : be(i ? -c : c, u)
        } else {
            let s = parseInt(r, 10);
            return s > Lf ? parseFloat(e) : be(i ? -s : s, 1)
        }
    }
    function L(e) {
        return un(e) ? e.n / e.d : +e
    }
    function Xo(e) {
        return un(e) ? !1 : isNaN(e)
    }
    function be(e, t) {
        if (!isFinite(e) || !isFinite(t) || t === 0 || Math.floor(e) !== e || Math.floor(t) !== t || Math.abs(e) > Lf || Math.abs(t) > Lf)
            return e / t;
        t < 0 && (e = -e,
        t = -t);
        let n = jl(e, t);
        return bm(e / n, t / n)
    }
    function Ii(e) {
        return un(e) ? bm(-e.n, e.d) : -e
    }
    function BN(e) {
        return un(e) ? bm(Math.abs(e.n), Math.abs(e.d)) : Math.abs(e)
    }
    function GN(e) {
        return un(e) ? e.n === 0 ? e.d / e.n : bm(e.n < 0 ? -e.d : e.d, Math.abs(e.n)) : 1 / e
    }
    function Pi(e, t) {
        if (!un(e) || !un(t))
            return L(e) + L(t);
        let n = jl(e.d, t.d);
        return be(e.n * (t.d / n) + t.n * (e.d / n), e.d / n * t.d)
    }
    function Zr(e, t) {
        if (!un(e) || !un(t))
            return L(e) * L(t);
        let n = jl(e.n, t.d)
          , r = jl(t.n, e.d);
        return be(e.n / n * (t.n / r), e.d / r * (t.d / n))
    }
    function ki(e, t) {
        return Pi(e, Ii(t))
    }
    function Fo(e, t) {
        return !un(e) || !un(t) ? L(e) / L(t) : Zr(e, GN(t))
    }
    function nH(e, t) {
        let n = e
          , r = t;
        if (t.n < 0 && (r = Ii(t),
        n = GN(e)),
        !un(n) || !un(r))
            return Jl(L(e), L(t));
        if (e = n,
        t = r,
        t.d === 1)
            return be(Math.pow(e.n, t.n), Math.pow(e.d, t.n));
        let o = e.n < 0;
        if (o && t.d % 2 !== 1)
            return NaN;
        let s = (o ? -1 : 1) * Math.round(Math.pow(Math.abs(e.n), 1 / t.d))
          , a = Math.round(Math.pow(Math.abs(e.d), 1 / t.d));
        return Math.pow(s, t.d) !== e.n || Math.pow(a, t.d) !== e.d ? Jl(L(e), L(t)) : be(Math.pow(s, t.n), Math.pow(a, t.n))
    }
    function qN(e, t) {
        if (!un(e) || !un(t))
            return Jl(L(e), L(t));
        let n = nH(e, t);
        return un(n) ? n : Jl(L(e), L(t))
    }
    function zN(e) {
        if (!un(e))
            return Math.sqrt(e);
        let t = Math.round(Math.sqrt(e.n))
          , n = Math.round(Math.sqrt(e.d));
        return t * t !== e.n || n * n !== e.d ? Math.sqrt(L(e)) : be(t, n)
    }
    function HN(e, t) {
        if (!un(e) || !un(t)) {
            let r = L(e)
              , o = L(t);
            rp(r, o)
        }
        let n = ki(e, Zr(t, bm(Math.floor(L(Fo(e, t))), 1)));
        return un(n) ? n : rp(L(e), L(t))
    }
    function MP(e) {
        let t = bm(0, 1);
        for (let n of e)
            t = Pi(t, n);
        return t
    }
    function UN(e) {
        return Fo(MP(e), be(e.length, 1))
    }
    var nO = {
        spy: j1
    }
      , {cosh: vm, sinh: lp, tanh: ZP, acosh: rO, asinh: oO, atanh: iO, expm1: rH, log1p: Mm, sign: XP, hypot: Wo} = Math
      , oH = cc
      , Ih = jl
      , iH = Jl
      , sO = Symbol("DIVERGES")
      , aO = (n => (n[n.SUCCESS = 0] = "SUCCESS",
    n[n.MISSING_CACHE_ENTRY = 1] = "MISSING_CACHE_ENTRY",
    n))(aO || {})
      , Nh = class Nh {
        constructor(t=Nh.defaultLimit, n) {
            this.limit = t;
            this.computeSize = n;
            this.currentSize = 0;
            this.cache = new Map
        }
        get(t) {
            let n = this.cache.get(t);
            return n && (this.cache.delete(t),
            this.cache.set(t, n)),
            n == null ? void 0 : n.value
        }
        set(t, n) {
            let r = this.computeSize ? this.computeSize(n) : 1;
            if (this.currentSize + r >= this.limit) {
                let o = this.cache.keys().next().value;
                o && this.cache.delete(o)
            }
            this.cache.set(t, {
                size: r,
                value: n
            })
        }
    }
    ;
    Nh.defaultLimit = 1e5;
    var Pm = Nh
      , qf = 1e4
      , uO = qf * 2;
    function sH() {
        return qf
    }
    function WP(e) {
        qf = e
    }
    var cO = (n => (n[n.DoesNotTerminate = 0] = "DoesNotTerminate",
    n[n.DepthLimitExceeded = 1] = "DepthLimitExceeded",
    n))(cO || {});
    function lO(e, t) {
        if (ra(t))
            return e.recursionTerminationStatus = 0,
            wo(t);
        throw $P()
    }
    function pO(e, t) {
        if (ra(t))
            return e.recursionTerminationStatus = 1,
            wo(t);
        throw YP()
    }
    var kN = new WeakMap;
    function aH(e) {
        let t = kN.get(e);
        return t || (t = new Set(e),
        kN.set(e, t)),
        t
    }
    function AP(e) {
        return `${e.fn}:${JSON.stringify(e.args)}`
    }
    function uH(e, t) {
        return {
            status: 0,
            result: [e, t]
        }
    }
    function cH(e) {
        return {
            status: 1,
            stackFrame: e
        }
    }
    function lH(e, t, n, r) {
        let o = e.recursiveFunctionCache || new Pm
          , i = [];
        i.push(r);
        let s = 0;
        for (; i.length > 0; ) {
            if (i.length > qf || s++ > uO)
                return pO(e, n);
            let a = i.pop()
              , {fn: u, args: c} = a
              , l = t[u](o, ...c);
            if (l === sO)
                return lO(e, n);
            if ((l == null ? void 0 : l.status) === 1)
                i.push({
                    fn: u,
                    args: c
                }),
                i.push(l.stackFrame);
            else {
                let p = AP(a);
                o.set(p, l.result)
            }
        }
        return o.get(AP(r))[0]
    }
    var pH = function(e) {
        let t = e * e;
        return 1 + t === 1 ? 1 : 1 + t === t ? Math.abs(e) : Math.sqrt(t + 1)
    }
      , mH = function(e) {
        let t = e * e;
        return t < 1 ? NaN : t - 1 === t ? Math.abs(e) : Math.sqrt(t - 1)
    };
    function pr(e, t, n) {
        return Math.max(t, Math.min(n, e))
    }
    function rp(e, t) {
        let n = e % t;
        return e * t < 0 && n !== 0 ? n + t : n
    }
    function wP(e, t) {
        if (e = Math.round(e),
        t = Math.round(t),
        !isFinite(e) || !isFinite(t))
            return NaN;
        if (e === 0 && t === 0)
            return 0;
        let n = Ih(e, t);
        return Math.abs(e / n * t)
    }
    function dH(e) {
        if (e.length === 0)
            return NaN;
        if (e.length === 1)
            return Ih(e[0], 0);
        let t = e[0];
        for (let n = 1; n < e.length; n++)
            t = Ih(t, e[n]);
        return t
    }
    function fH(e) {
        if (e.length === 0)
            return NaN;
        if (e.length === 1)
            return wP(e[0], 1);
        let t = e[0];
        for (let n = 1; n < e.length; n++)
            t = wP(t, e[n]);
        return t
    }
    function yH(e) {
        if (e.length === 0)
            return [NaN, NaN];
        if (e.length === 1)
            return UP(e[0], [0, 0]);
        let t = e[0];
        for (let n = 1; n < e.length; n++)
            t = UP(t, e[n]);
        return t
    }
    function gH(e) {
        if (e.length === 0)
            return [NaN, NaN];
        if (e.length === 1)
            return kP(e[0], [1, 0]);
        let t = e[0];
        for (let n = 1; n < e.length; n++)
            t = kP(t, e[n]);
        return t
    }
    function kc(e, t) {
        if (isNaN(e))
            return e;
        if (isNaN(t))
            return t;
        if (!isFinite(e) && !isFinite(t))
            return NaN;
        if (t === 0 || e === t)
            return 1;
        if (e === 0)
            return Vs(t);
        let n = isFinite(e) && e === Math.round(e)
          , r = isFinite(t) && t === Math.round(t);
        if (e < 0 && t < 0 && e - t < 0)
            return n && r ? 0 : Vs(e - t) * Vs(t) / (Vs(e) * kc(-e, -t));
        if (e < 0 && t > 0 && e - t < 0)
            return n && r ? Math.pow(-1, t) * kc(t - e - 1, t) : Vs(e - t) / Vs(e) * kc(-(e - t), t);
        if (e < 0 && t < 0 && e - t > 0)
            return n && r ? Math.pow(-1, e - t) * kc(-t - 1, e - t) : Vs(t) / Vs(e) * kc(-t, -e);
        if (e > 0 && t < 0 && e - t > 0) {
            let a = Math.abs(e) > Math.abs(t) ? -t : e;
            return Vs(t) / kc(e - t, a)
        }
        if (e > 0 && t > 0 && e - t < 0)
            return Vs(e - t) / kc(t, e);
        if (e < 0 || t < 0 || e - t < 0)
            return Ph(e, t) / yc(t);
        let o = Si(e) - Si(t) - Si(e - t) - (e - t) * Mm(-t / e)
          , i = Math.sqrt((e + 1 / 6) / (2 * Math.PI * (t + 1 / 6) * (e - t + 1 / 6))) * Math.pow(e / t, t) * Math.exp(o);
        return n && r && e > 0 && t > 0 && e - t > 0 ? Math.round(i) : i
    }
    function Ph(e, t) {
        if (isNaN(e))
            return e;
        if (isNaN(t))
            return t;
        if (!isFinite(e) && !isFinite(t))
            return NaN;
        if (t === 0)
            return 1;
        if (e === 0)
            return 1 / yc(-t);
        if (e === t)
            return yc(e);
        let n = isFinite(e) && e === Math.round(e)
          , r = isFinite(t) && t === Math.round(t);
        if (e < 0 && e - t < 0)
            return n && r ? Math.pow(-1, t) * Ph(t - e - 1, t) : Vs(e - t) / Vs(e) * Ph(-(e - t), t);
        if (e < 0 || e - t < 0)
            return yc(e) / yc(e - t);
        let o = Si(e) - Si(e - t) - (e - t) * Mm(-t / e)
          , i = Math.sqrt((e + 1 / 6) / (e - t + 1 / 6)) * mO(e, t) * Math.exp(o);
        return n && r && e > 0 && t > 0 && e - t > 0 ? Math.round(i) : i
    }
    function yc(e) {
        if (e === -1 / 0)
            return NaN;
        let t = Number.isInteger(e);
        if (t && e < 0)
            return 1 / 0;
        let n = Math.abs(e)
          , r = Math.sqrt(2 * Math.PI * (n + 1 / 6)) * mO(n, n) * Math.exp(Si(n));
        return e < 0 ? 1 / (Vs(e) * r) : t ? Math.round(r) : r
    }
    function $N(e) {
        let t = (e - 1) / 2
          , n = .003986126881698112
          , r = .018251909205311435
          , o = .029941517126885264
          , i = .02189053314125264
          , s = .006189087779028262
          , a = 5073115018776601e-24
          , u = 7.482475354254652
          , c = 23.07580194442752
          , l = 37.71198466711076
          , p = 34.64514153026584
          , m = 17.084767168000226
          , d = 3.5649457718715754
          , y = n + t * (r + t * (o + t * (i + t * (s + t * a))))
          , g = 1 + t * (u + t * (c + t * (l + t * (p + t * (m + t * d)))));
        return y / g
    }
    var hH = Math.pow(2, 27) + 1;
    function bH(e) {
        let t = hH * e;
        return t - (t - e)
    }
    var DP = .3678794428706169
      , _P = -16991745912462731e-25;
    function mO(e, t) {
        if (!isFinite(e) || !isFinite(t) || Math.abs(t) > 2 ** 26)
            return Math.pow(e / Math.E, t);
        let n = bH(e)
          , r = e - n
          , o = e * (DP + _P);
        if (o === 0)
            return Math.pow(e / Math.E, t);
        let i = n * DP - o + n * _P + r * DP + r * _P;
        return Math.pow(o, t) * (1 + t * (i / o))
    }
    var dO = [1 / 6, -1 / 30, 1 / 42, -1 / 30, 5 / 66, -691 / 2730, 7 / 6, -3617 / 510, 43867 / 798, -174611 / 330, 854513 / 138, -236364091 / 2730, 8553103 / 6, -23749461029 / 870];
    function fO(e, t) {
        if (e !== Math.floor(e))
            return NaN;
        if (e < 0)
            return NaN;
        if (e === 0)
            return 1 / jP(t);
        let n = Nn(t);
        if (e === 1)
            return -1 / (n * n);
        let r = Yn(t);
        if (e === 2)
            return 2 * r / (n * n * n);
        let o = [0, 2]
          , i = [];
        for (let a = 3; a <= e; a++) {
            i = [];
            for (let u = 0; u < a; u++) {
                let c = 0
                  , l = 0;
                u > 0 && (c = (a - u + 1) * o[u - 1]),
                u + 2 < a && (l = (u + 1) * o[u + 1]),
                i.push(-(c + l))
            }
            o = i
        }
        let s = 0;
        for (let a = e - 1; a >= 0; a--)
            s = i[a] + r * s;
        return s / Math.pow(n, e + 1)
    }
    function yO(e, t) {
        if (e < 0)
            return NaN;
        if (e !== Math.floor(e))
            return NaN;
        let n = e % 2 === 0 ? -1 : 1;
        if (t < 0)
            return -n * yO(e, 1 - t) - Math.pow(Math.PI, e + 1) * fO(e, Math.PI * t);
        let r = yc(e)
          , o = 0
          , i = Math.pow(t, -(e + 1));
        for (; t < 10; )
            o += i,
            t++,
            i = Math.pow(t, -(e + 1));
        o += e === 0 ? -Math.log(t) : i * t / e,
        o += .5 * i;
        let s = dO
          , a = e + 1
          , u = 2
          , c = i * t * a / u
          , l = 1 / (t * t);
        for (let p = 1; p <= 14; p++)
            c *= l,
            o += c * s[p - 1],
            a++,
            u++,
            c *= a / u,
            a++,
            u++,
            c *= a / u;
        return r * n * o
    }
    function xH(e) {
        let t = Math.log(e);
        return Math.exp(Math.round(t)) === e ? Math.round(t) : t
    }
    function Sh(e, t) {
        if (t === 0)
            return NaN;
        let n;
        return t === Math.E ? n = Math.log(e) : t === 2 && Math.log2 ? n = Math.log2(e) : t === 10 && Math.log10 ? n = Math.log10(e) : n = Math.log(e) / Math.log(t),
        Math.pow(t, Math.round(n)) === e ? Math.round(n) : n
    }
    function TH(e) {
        return Sh(e, 10)
    }
    function gO(e, t) {
        let[n,r] = e
          , [o,i] = t;
        return i === 0 && o === 0 ? [NaN, NaN] : n === 0 && r === 0 ? [-1 / 0, 0] : i === 0 && r === 0 && o > 0 ? n > 0 ? Zt(Sh(n, o), 0) : Zt(Sh(-n, o), Math.PI / Math.log(o)) : jc(qP(e), qP(t))
    }
    function IH(e) {
        return gO(e, [10, 0])
    }
    var hO = 1 / Math.PI;
    function Oh(e) {
        return e > 1e12 ? !1 : Math.round(hO * e) * Math.PI === e
    }
    function Ah(e) {
        if (e > 1e12)
            return !1;
        let t = Math.round(2 * hO * e);
        return t % 2 === 1 && t * Math.PI === 2 * e
    }
    function Nn(e) {
        return Oh(Math.abs(e)) ? 0 : Math.sin(e)
    }
    function Yn(e) {
        return Ah(Math.abs(e)) ? 0 : Math.cos(e)
    }
    function jP(e) {
        let t = Math.abs(e);
        return Oh(t) ? 0 : Ah(t) ? 1 / 0 : Math.tan(e)
    }
    function PH(e) {
        return Ah(Math.abs(e)) ? 1 / 0 : 1 / Math.cos(e)
    }
    function SH(e) {
        return Oh(Math.abs(e)) ? 1 / 0 : 1 / Math.sin(e)
    }
    function EH(e) {
        let t = Math.abs(e);
        return Oh(t) ? 1 / 0 : Ah(t) ? 0 : 1 / Math.tan(e)
    }
    function CH(e) {
        return e > 0 ? Math.atan(1 / e) : Math.PI / 2 - Math.atan(e)
    }
    function vH(e) {
        return Math.asin(1 / e)
    }
    function MH(e) {
        return Math.acos(1 / e)
    }
    function DH(e) {
        return 1 / vm(e)
    }
    function _H(e) {
        return 1 / lp(e)
    }
    function RH(e) {
        return 1 / ZP(e)
    }
    function NH(e) {
        return rO(1 / e)
    }
    function OH(e) {
        return oO(1 / e)
    }
    function AH(e) {
        return iO(1 / e)
    }
    function wH(e) {
        if (e === 0 || isNaN(e))
            return e;
        if (!isFinite(e))
            return NaN;
        if (e === Math.floor(e))
            return e > 0 ? 0 : -0;
        let t = Math.round(2 * e)
          , n = -.5 * t + e
          , r = t & 2 ? -1 : 1
          , o = t & 1 ? Math.cos(Math.PI * n) : Math.sin(Math.PI * n);
        return r * o
    }
    function Vs(e) {
        return e === 1 / 0 || e === -1 / 0 ? 0 : e === 0 ? 1 : wH(e) / (Math.PI * e)
    }
    function Zc(e) {
        let t = 0;
        for (let n = 0; n < e.length; n++)
            t += e[n];
        return t / e.length
    }
    function bO(e) {
        let t = 0;
        for (let n = 0; n < e.length; n++)
            t += e[n];
        return t
    }
    function xh(e) {
        if (e === 1 / 0)
            return 1 / Math.sqrt(2 * Math.PI);
        let t = Si(.5 * (e + 1)) - Si(.5 * e) + .5 * (e * (Math.log1p(1 / e) - 1 / e));
        return Math.exp(t) / Math.sqrt(2 * Math.PI * (1 + 1 / (e * (3 * e + 4))))
    }
    function Sm(e, t, n=e - t) {
        if (Math.abs(n) < .1 * (e + t)) {
            let r = n / (e + t)
              , o = n * n / (e + t)
              , i = 2 * e * r;
            for (let s = 1; s < 10; s++) {
                i *= r * r;
                let a = o + i / (2 * s + 1);
                if (a == o)
                    return a;
                o = a
            }
        }
        return e * Math.log(e / t) + t - e
    }
    function Si(e) {
        if (e < 0)
            return NaN;
        if (e >= 3)
            return LH(e) - .5 * Math.log1p(1 / (6 * e));
        if (e >= 1)
            return $N(e);
        let t = .5772156649015329
          , n = -.1952810437829498
          , r = e * (1 + 6 * e)
          , o = Math.log1p(6 * e / (1 + r));
        return (e - t) * o + .5 * Math.log1p(2 / 5 * (1 + 4 * e * (1 - 3 * e)) / (1 + r)) + (t - .5) * o + (e === 0 ? 0 : e * Math.log1p(1 / r)) + n + $N(e + 1)
    }
    function LH(e) {
        let t = 1 / (e * e)
          , n = .03333333333333229
          , r = .3816877588482201
          , o = 1.1226896867003733
          , i = .8424153799350397
          , s = .06216815175439515
          , a = 11.73634705109923
          , u = 36.819646921154714
          , c = 33.58045682700508
          , l = 6.435857736505945
          , p = n + t * (r + t * (o + t * (i + t * s)))
          , m = 1 + t * (a + t * (u + t * (c + t * l)));
        return (1 - t * (p / m)) / (12 * e)
    }
    function wh(e, t) {
        if (t <= 0)
            return NaN;
        if (t === 1 / 0)
            return Lh(e, 0, 1);
        let n = e * e / t;
        return n === 0 ? xh(t) * Math.exp(-.5 * e * e) : n < 1 ? xh(t) * (1 + n) ** -.5 * Math.exp(-.5 * t * Mm(n)) : xh(t) * (1 + n) ** -.5 * Math.pow(1 + n, -t / 2)
    }
    function ip(e, t) {
        if (e === 1 / 0)
            return CO(-1 / 0, t, 0, 1);
        if (t > 0)
            return 1 - ip(e, -t);
        if (t === -1 / 0)
            return 0;
        if (t === 0)
            return .5;
        if (2.25 * t * t < e - 23)
            return FH(e, t);
        if (t / e < -1e3) {
            let r = t * t;
            return xh(e) * Math.pow(e, .5 * (e - 1)) * Math.pow(Math.abs(t), -e) * (1 - e * e * (e + 1) * (1 / (2 + e) + e * (e + 3) / (4 * (4 + e) * r)) / (2 * r))
        }
        let n = Math.sqrt(t * t + e);
        return GH((t + n) / (2 * n), e / 2, e / 2)
    }
    var YN = [1 / 4, 1 / 96, -1 / 384, -1 / 10240, 19 / 368640, 79 / 61931520, -55 / 49545216, -2339 / 118908518400, 11813 / 475634073600, 677 / 1993133260800, -2117 / 3720515420160];
    function FH(e, t) {
        let n = Math.log1p(t * t / e)
          , r = Math.sign(t) * Math.sqrt(n)
          , o = 1 / e
          , i = Math.sqrt(.5 * e)
          , s = 0
          , a = 0;
        for (let u = YN.length - 1; u >= 0; u--)
            s = (s * (2 * u + 3) - YN[u]) * o,
            a = n * a + s;
        return Math.exp(-.5 * e * n) * (.5 * Ou(-r * i) + i / (Math.sqrt(Math.PI) * (1 - s)) * a * r)
    }
    function VH(e, t, n, r, o) {
        if (n <= 0 || !isFinite(r) || !isFinite(o))
            return NaN;
        if (o === 0)
            return e <= r && r <= t ? 1 : 0;
        let i = (e - r) / Math.abs(o)
          , s = (t - r) / Math.abs(o);
        return i === -1 / 0 ? ip(n, s) : i > 0 && s > 0 ? ip(n, -i) - ip(n, -s) : ip(n, s) - ip(n, i)
    }
    function BH(e, t, n, r, o) {
        return VH(Math.min(e, t), Math.max(e, t), n, r, o)
    }
    function GH(e, t, n) {
        if (e < 0 || e > 1)
            throw new RangeError("First argument must be between 0 and 1.");
        if (t === 1 && n === 1)
            return e;
        if (e === 0)
            return 0;
        if (e === 1)
            return 1;
        if (t === 0)
            return 1;
        if (n === 0)
            return 0;
        {
            let r = Si(t + n) - Si(t) - Si(n) - Sm(t, (t + n) * e) - Sm(n, (t + n) * (1 - e), (t + n) * e - t)
              , o = Math.exp(r) * Math.sqrt((1 + 1 / (6 * (t + n))) / (2 * Math.PI * (1 + 1 / (6 * t)) * (1 + 1 / (6 * n)) * (1 / t + 1 / n)));
            return e < (t + 1) / (t + n + 2) ? o * ZN(e, t, n) / t : 1 - o * ZN(1 - e, n, t) / n
        }
    }
    function ZN(e, t, n) {
        let r = Math.pow(2, -52)
          , o = 1e-300
          , i = t + n
          , s = t + 1
          , a = t - 1
          , u = 1
          , c = 1 - i * e / s;
        Math.abs(c) < o && (c = o),
        c = 1 / c;
        let l = c;
        for (let p = 1; p <= 100; p++) {
            let m = 2 * p
              , d = p * (n - p) * e / ((a + m) * (t + m));
            c = 1 + d * c,
            Math.abs(c) < o && (c = o),
            u = 1 + d / u,
            Math.abs(u) < o && (u = o),
            c = 1 / c,
            l *= c * u,
            d = -(t + p) * (i + p) * e / ((t + m) * (s + m)),
            c = 1 + d * c,
            Math.abs(c) < o && (c = o),
            u = 1 + d / u,
            Math.abs(u) < o && (u = o),
            c = 1 / c;
            let y = c * u;
            if (l *= y,
            Math.abs(y - 1) <= r)
                return l
        }
        return l
    }
    function xO(e, t) {
        let n = Math.pow(2, -52)
          , r = 1e-300
          , o = 1
          , i = e
          , s = o / i
          , a = o / r
          , u = 1 / i
          , c = 2
          , l = 0
          , p = i
          , m = -(e - 1)
          , d = 0;
        do
            m -= 1,
            p += 1,
            u = u * m * t + p,
            u === 0 && (u = r),
            a = p + m * t / a,
            a === 0 && (a = r),
            u = 1 / u,
            l = a * u,
            s = s * l,
            d += 1,
            p += 1,
            u = u * d * t + p,
            u === 0 && (u = r),
            a = p + d * t / a,
            a === 0 && (a = r),
            u = 1 / u,
            l = a * u,
            s *= l,
            c += 2;
        while (c < 100 && Math.abs(l - 1) > n);
        return s
    }
    function TO(e, t) {
        let n = Math.pow(2, -52)
          , r = 1e-300
          , o = 1
          , i = t + 1 - e
          , s = o / i
          , a = o / r
          , u = 1 / i
          , c = 2
          , l = 0
          , p = i;
        do {
            let m = -(c - 1) * (c - e - 1);
            p += 2,
            u = u * m + p,
            u === 0 && (u = r),
            a = p + m / a,
            a === 0 && (a = r),
            u = 1 / u,
            l = a * u,
            s *= l,
            c += 1
        } while (c < 100 && Math.abs(l - 1) > n);
        return s
    }
    function IO(e, t, n=!1) {
        let r = t / e
          , o = XP(t - e) * Math.sqrt(2 * Sm(1, r))
          , i = [1, -.3333333333333333, .08333333333333333, -.014814814814814815, .0011574074074074073, .0003527336860670194, -.0001787551440329218, 3919263178522438e-20, -2185448510679992e-21, -185406221071516e-20, 8296711340953087e-22, -17665952736826078e-23, 6707853543401498e-24, 10261809784240309e-24, -4382036018453353e-24, 914769958223679e-24, -25514193994946248e-27, -5830772132550426e-26, 24361948020667415e-27, -50276692801141755e-28, 11004392031956135e-29, 3371763262400985e-28, -1392388722418162e-28, 28534893807047445e-30, -5139111834242572e-31, -19752288294349442e-31, 8099521156704561e-31]
          , s = i.length - 2
          , a = 0
          , u = 0
          , c = 0
          , l = 0;
        for (; s >= 0; s--)
            c = (s + 2) * a / e + i[s + 1],
            l = o * l + c,
            a = u,
            u = c;
        if (l = e / (e + a) * l,
        t < e) {
            let p = Math.exp(-.5 * e * o * o) * (.5 * Ou(-o * Math.sqrt(e / 2)) - l / Math.sqrt(2 * Math.PI * e));
            return n ? isFinite(p) ? p : 0 : isFinite(p) ? 1 - p : 1
        } else {
            let p = Math.exp(-.5 * e * o * o) * (.5 * Ou(o * Math.sqrt(e / 2)) + l / Math.sqrt(2 * Math.PI * e));
            return n ? isFinite(p) ? 1 - p : 1 : isFinite(p) ? p : 0
        }
    }
    var JP = 0
      , QP = 1
      , KP = 2
      , Eh = 3;
    function PO(e, t) {
        return isNaN(e) || isNaN(t) || e < 0 || t < 0 ? Eh : e > 12 && 2.35 * e > t && .3 * e < t ? KP : e >= t || e < 1 && t < 4.25 ? JP : QP
    }
    function SO(e, t) {
        let n = PO(e, t);
        switch (n) {
        case KP:
            return IO(e, t, !0);
        case JP:
            {
                let r = xO(e, t);
                return isFinite(r) ? e * Xc(e, t) * r : 0
            }
        case QP:
            {
                let r = TO(e, t);
                return isFinite(r) ? 1 - e * Xc(e, t) * r : 1
            }
        case Eh:
            return NaN;
        default:
            return NaN
        }
    }
    function EO(e, t) {
        let n = PO(e, t);
        switch (n) {
        case KP:
            return IO(e, t);
        case JP:
            {
                let r = xO(e, t);
                return isFinite(r) ? 1 - e * Xc(e, t) * r : 1
            }
        case QP:
            {
                let r = TO(e, t);
                return isFinite(r) ? e * Xc(e, t) * r : 0
            }
        case Eh:
            return NaN;
        default:
            return NaN
        }
    }
    function qH(e, t) {
        let n, r;
        if (e < 25) {
            n = Math.pow(t * yc(e), 1 / e);
            let a = e - 1
              , u = -Math.log(yc(a) * (1 - t));
            r = u + a * Math.log(u),
            a < 0 && (r += .5 * Math.log1p(a / u)),
            Number.isNaN(r) && (r = 0)
        } else
            n = e / Math.E * Math.pow(t * Math.sqrt(2 * Math.PI * e), 1 / e),
            r = 0;
        let o = n / (1 + e)
          , i = n * (1 + o * (1 + o * ((5 + 3 * e) / (2 * (2 + e)))))
          , s = Bh(t) * Math.sqrt(e) + (e - .5);
        return Math.max(i, s, r)
    }
    function zH(e, t) {
        if (isNaN(e) || e <= 0 || t < 0 || t > 1)
            return NaN;
        if (e === 1 / 0)
            return t === 1 ? NaN : 0;
        if (t === 0)
            return 0;
        if (t === 1)
            return 1 / 0;
        let n = qH(e, t);
        if (n === 0 || n === 1 / 0)
            return n;
        for (let r = 0; r < 10; r++) {
            let o = t - SO(e, n)
              , i = o / (e / n * Xc(e, n) + .5 * ((e - 1) / n - 1) * o)
              , s = n + 1e-8 * i === n;
            if (n += i,
            s)
                break
        }
        return n
    }
    function XN(e, t, n) {
        return (e - t) / (Math.SQRT2 * Math.abs(n))
    }
    function Ff(e) {
        return e < 0 ? .5 * Math.exp(-e * e) * Ou(-e) : 1 - .5 * Math.exp(-e * e) * Ou(e)
    }
    function HH(e, t, n, r) {
        if (!isFinite(r) || isNaN(n))
            return NaN;
        if (r === 0)
            return e <= n && n <= t ? 1 : 0;
        let o = XN(e, n, r)
          , i = XN(t, n, r);
        return o === -1 / 0 ? Ff(i) : o > 0 && i > 0 ? Ff(-o) - Ff(-i) : Ff(i) - Ff(o)
    }
    function CO(e, t, n, r) {
        return HH(Math.min(e, t), Math.max(e, t), n, r)
    }
    function Lh(e, t, n) {
        return 1 / Math.sqrt(2 * Math.PI * n * n) * Math.exp(-(e - t) * (e - t) / (2 * n * n))
    }
    function eS(e, t) {
        return `t${e}:${_h(t)}`
    }
    function tS(e) {
        let t = nO.spy(e)
          , n = parseInt(t.slice(0, 8), 16) & 2097151
          , r = parseInt(t.slice(8, 16), 16);
        return (n * 4294967296 + r) / 9007199254740992
    }
    function vO(e, t) {
        for (let n = t.length - 1; n > 0; n--) {
            let r = e + "::sc" + n
              , o = Math.floor(tS(r) * (n + 1))
              , i = t[n];
            t[n] = t[o],
            t[o] = i
        }
    }
    function UH(e, t) {
        let n = t.slice();
        return vO(e, n),
        n
    }
    function nS(e, t) {
        let n = [];
        for (let r = 0; r < t; r++)
            n.push(r);
        return vO(e, n),
        n
    }
    function Yc(e, t, n) {
        return tS(e) * (n - t) + t
    }
    function kH(e, t, n) {
        let r = 0, o, i, s, a;
        do
            o = e + "::sc" + r,
            r += 1,
            i = Yc(o, 0, 1) * 2 - 1,
            o = e + "::sc" + r,
            r += 1,
            s = Yc(o, 0, 1) * 2 - 1,
            a = i * i + s * s;
        while (a >= 1 || a === 0);
        let u = Math.sqrt(-2 * Math.log(a) / a);
        return t + n * i * u
    }
    function $H(e, t) {
        if (t <= 0)
            return NaN;
        let n = 0, r, o, i, s;
        do
            r = e + "::sc" + n,
            n += 1,
            o = Yc(r, 0, 1) * 2 - 1,
            r = e + "::sc" + n,
            n += 1,
            i = Yc(r, 0, 1) * 2 - 1,
            s = o * o + i * i;
        while (s > 1);
        let a = o * o / s
          , u = t * (Math.pow(s, -2 / t) - 1);
        return r = e + "::sc" + n,
        n += 1,
        (Yc(r, 0, 1) < .5 ? -1 : 1) * Math.sqrt(a * u)
    }
    function YH(e, t, n) {
        return t = pr(Math.round(t), 0, 1 / 0),
        t === 1 / 0 ? NaN : (n = pr(n, 0, 1),
        DO(Yc(e, 0, 1), t, n))
    }
    function ZH(e, t) {
        return t < 0 ? NaN : MO(Yc(e, 0, 1), t)
    }
    function Th(e, t, n) {
        return e >= t ? 1 : e < 0 ? 0 : e < Math.floor((t + 1) * n) ? WN(e, t, n) : 1 - WN(t - e - 1, t, 1 - n)
    }
    function WN(e, t, n) {
        let r = (1 - n) / n
          , o = Fh(e, t, n)
          , i = o;
        for (; e > 0 && (o *= e / (t - e + 1) * r,
        i + o !== i); e--)
            i += o;
        return i
    }
    function XH(e, t, n, r) {
        return n = pr(Math.round(n), 0, 1 / 0),
        n === 1 / 0 ? NaN : (r = pr(r, 0, 1),
        e = Math.ceil(e),
        t = Math.floor(t),
        e === -1 / 0 ? Th(t, n, r) : Th(t, n, r) - Th(e - 1, n, r))
    }
    function WH(e, t, n, r) {
        return XH(Math.min(e, t), Math.max(e, t), n, r)
    }
    function Fh(e, t, n) {
        if (e = Math.round(e),
        t = pr(Math.round(t), 0, 1 / 0),
        t === 1 / 0)
            return NaN;
        if (n = pr(n, 0, 1),
        e < 0 || e > t)
            return 0;
        if (n === 0)
            return e === 0 ? 1 : 0;
        if (n === 1)
            return e === t ? 1 : 0;
        if (e === 0)
            return Math.exp(t * Mm(-n));
        if (e === t)
            return Math.pow(n, t);
        let r = Si(t) - Si(e) - Si(t - e) - Sm(e, t * n) - Sm(t - e, t * (1 - n), t * n - e);
        return Math.exp(r) * Math.sqrt((t + 1 / 6) / (2 * Math.PI * (e + 1 / 6) * (t - e + 1 / 6)))
    }
    function Xc(e, t) {
        return Math.exp(-Si(e) - Sm(e, t)) / Math.sqrt(2 * Math.PI * (e + 1 / 6))
    }
    function Vh(e, t) {
        return t < 0 ? NaN : (e = Math.round(e),
        e < 0 ? 0 : t === 0 ? e === 0 ? 1 : 0 : e === 0 ? Math.exp(-t) : Xc(e, t))
    }
    function Vf(e, t) {
        return isNaN(e) || isNaN(t) ? NaN : e === 1 / 0 ? 1 : (e = Math.floor(e),
        e < 0 ? 0 : t === 0 ? 1 : EO(Math.floor(e + 1), t))
    }
    function jH(e, t, n) {
        return n < 0 ? NaN : (e = Math.ceil(e),
        t = Math.floor(t),
        e === -1 / 0 ? Vf(t, n) : Vf(t, n) - Vf(e - 1, n))
    }
    function JH(e, t, n) {
        return jH(Math.min(e, t), Math.max(e, t), n)
    }
    function QH(e, t) {
        return isNaN(e) || isNaN(t) || t <= 0 ? NaN : (e = Math.round(e),
        t > 1 && (t = 1),
        e < 1 ? 0 : t === 1 ? e === 1 ? 1 : 0 : t * Math.exp((e - 1) * Math.log1p(-t)))
    }
    function RP(e, t) {
        return isNaN(e) || isNaN(t) || t <= 0 ? NaN : (t > 1 && (t = 1),
        e === 1 / 0 ? 1 : (e = Math.floor(e),
        e < 1 ? 0 : -Math.expm1(e * Math.log1p(-t))))
    }
    function jN(e, t) {
        return isNaN(e) || isNaN(t) || t <= 0 ? NaN : (t > 1 && (t = 1),
        e === 1 / 0 ? 0 : (e = Math.floor(e),
        e < 1 ? 1 : Math.exp(e * Math.log1p(-t))))
    }
    function KH(e, t, n) {
        if (n < 0)
            return NaN;
        if (e = Math.ceil(e),
        t = Math.floor(t),
        e === -1 / 0)
            return RP(t, n);
        let r = -Math.LN2 / Math.log1p(n);
        return e > r && t > r ? jN(e - 1, n) - jN(t, n) : RP(t, n) - RP(e - 1, n)
    }
    function eU(e, t, n) {
        return KH(Math.min(e, t), Math.max(e, t), n)
    }
    function tU(e, t) {
        return isNaN(e) || isNaN(t) || t <= 0 ? NaN : e < 0 || e > 1 ? NaN : e === 0 || t >= 1 ? 1 : e === 1 ? 1 / 0 : Math.ceil(Math.log1p(-e) / Math.log1p(-t))
    }
    function rS(e, t) {
        return isNaN(e) || isNaN(t) ? NaN : t <= 0 ? NaN : e < 0 ? 0 : e === 1 / 0 && t === 1 / 0 ? NaN : e === 1 / 0 || t === 1 / 0 ? 0 : e === 0 ? t < 2 ? 1 / 0 : t === 2 ? .5 : 0 : .5 * (t / e) * Xc(t / 2, e / 2)
    }
    function LP(e, t) {
        return e <= 0 ? 0 : t === 1 / 0 ? e === 1 / 0 ? NaN : 0 : e === 1 / 0 ? 1 : SO(t / 2, e / 2)
    }
    function FP(e, t) {
        return e <= 0 ? 1 : t === 1 / 0 ? e === 1 / 0 ? NaN : 1 : e === 1 / 0 ? 0 : EO(t / 2, e / 2)
    }
    function nU(e, t, n) {
        return isNaN(e) || isNaN(t) || isNaN(n) ? NaN : n <= 0 ? NaN : t > n && e > n ? FP(e, n) - FP(t, n) : LP(t, n) - LP(e, n)
    }
    function rU(e, t, n) {
        return nU(Math.min(e, t), Math.max(e, t), n)
    }
    function oU(e, t) {
        return 2 * zH(t / 2, e)
    }
    function oS(e, t, n) {
        return n <= t ? NaN : e < t || e > n ? 0 : 1 / (n - t)
    }
    function iU(e, t, n, r) {
        return r < n ? NaN : n === r ? e <= n && n <= t ? 1 : 0 : (pr(t, n, r) - pr(e, n, r)) / (r - n)
    }
    function sU(e, t, n, r) {
        return iU(Math.min(e, t), Math.max(e, t), n, r)
    }
    function aU(e) {
        let t = -e * e;
        return t < -750 ? e >= 0 ? 1 : -1 : e >= .065 ? 1 - Math.exp(t) * Ou(e) : e <= -.065 ? Math.exp(t) * Ou(-e) - 1 : e * (1.1283791670955126 + t * (.37612638903183754 + t * (.11283791670955126 + t * (.026866170645131252 + t * .005223977625442188))))
    }
    function Ou(e) {
        let t = .9999999999999999
          , n = 2.224574423459406
          , r = 2.444115549920689
          , o = 1.7057986861852539
          , i = .8257463703357973
          , s = .28647031042892007
          , a = .07124513844341643
          , u = .012296749268608364
          , c = .001347817214557592
          , l = 7263959403471071e-20
          , p = 1
          , m = 3.352953590554884
          , d = 5.227518529742423
          , y = 5.003720878235473
          , g = 3.266590890998987
          , f = 1.5255421920765353
          , h = .5185887413188858
          , x = .12747319185915415
          , T = .02185979575963238
          , P = .0023889438122503674
          , C = .00012875032817508128;
        if (e < 0)
            return e < -6.1 ? 2 * Math.exp(e * e) : 2 * Math.exp(e * e) - Ou(-e);
        if (e > 50) {
            let S = .5641895835477563
              , E = e * e;
            return e > 5e7 ? S / e : S * (E * (E + 4.5) + 2) / (e * (E * (E + 5) + 3.75))
        } else {
            let S = t + e * (n + e * (r + e * (o + e * (i + e * (s + e * (a + e * (u + e * (c + e * l))))))))
              , E = p + e * (m + e * (d + e * (y + e * (g + e * (f + e * (h + e * (x + e * (T + e * (P + e * C)))))))));
            return S / E
        }
    }
    function Bh(e) {
        let t = -39.6968302866538, n = 220.946098424521, r = -275.928510446969, o = 138.357751867269, i = -30.6647980661472, s = 2.50662827745924, a = -54.4760987982241, u = 161.585836858041, c = -155.698979859887, l = 66.8013118877197, p = -13.2806815528857, m = -.00778489400243029, d = -.322396458041136, y = -2.40075827716184, g = -2.54973253934373, f = 4.37466414146497, h = 2.93816398269878, x = .00778469570904146, T = .32246712907004, P = 2.445134137143, C = 3.75440866190742, S = .02425, E, M, _;
        return e > .5 ? -Bh(1 - e) : e === .5 ? 0 : e < 0 ? NaN : e === 0 ? -1 / 0 : (e < S ? (E = Math.sqrt(-2 * Math.log(e)),
        _ = (((((m * E + d) * E + y) * E + g) * E + f) * E + h) / ((((x * E + T) * E + P) * E + C) * E + 1)) : (E = e - .5,
        M = E * E,
        _ = (((((t * M + n) * M + r) * M + o) * M + i) * M + s) * E / (((((a * M + u) * M + c) * M + l) * M + p) * M + 1)),
        _ - Math.sqrt(2 * Math.PI) * (.5 * Ou(-_ / Math.SQRT2) - Math.exp(.5 * _ * _) * e))
    }
    function MO(e, t) {
        if (t < 0 || e < 0 || e > 1)
            return NaN;
        if (t === 0 || e === 0)
            return 0;
        if (e === 1)
            return 1 / 0;
        let n = -1
          , r = Math.ceil(t);
        for (; Vf(r, t) < e; )
            r = 2 * r;
        let o = Math.floor(n + (r - n) / 2);
        for (; n < o && o < r; )
            Vf(o, t) < e ? n = o : r = o,
            o = Math.floor(n + (r - n) / 2);
        return r
    }
    function DO(e, t, n) {
        if (t !== Math.round(t))
            return NaN;
        if (n < 0 || n > 1)
            return NaN;
        if (e < 0 || e > 1)
            return NaN;
        if (e === 0)
            return 0;
        if (e === 1)
            return t;
        if (t === 0)
            return 0;
        if (n === 1)
            return t;
        if (n === 0)
            return 0;
        let r = -1
          , o = t
          , i = Math.floor(r + (o - r) / 2);
        for (; r < i && i < o; )
            Th(i, t, n) < e ? r = i : o = i,
            i = Math.floor(r + (o - r) / 2);
        return o
    }
    function _O(e, t) {
        if (isNaN(t) || t <= 0 || e < 0 || e > 1)
            return NaN;
        if (e === 0)
            return -1 / 0;
        if (e === 1)
            return 1 / 0;
        if (t === 1 || t === 2 || t === 4)
            return NP(t, e);
        let n, r;
        if (e === .5)
            return 0;
        if (e > .5)
            n = t > 1 ? Bh(e) : NP(1, e),
            r = t > 1 ? NP(1, e) : Math.pow(wh(0, t) * Math.pow(t, (t - 1) / 2) / (1 - e), 1 / t);
        else
            return -_O(1 - e, t);
        return uU(t, e, n, r)
    }
    function NP(e, t) {
        let n = 4 * t * (1 - t);
        switch (e) {
        case 1:
            return Math.tan(Math.PI * (t - .5));
        case 2:
            return 2 * (t - .5) * Math.sqrt(2 / n);
        case 4:
            let r = Math.cos(Math.acos(Math.sqrt(n)) / 3) / Math.sqrt(n);
            return XP(t - .5) * 2 * Math.sqrt(r - 1);
        default:
            throw new Error("_invTSimple() must be called with 1, 2, or 4 df.")
        }
    }
    function uU(e, t, n, r) {
        if (!isFinite(n) || !isFinite(r))
            return NaN;
        let o = n
          , i = r;
        for (; ; ) {
            let s = ns(o, i)
              , a = ip(e, s);
            if (s === o || s === i)
                return a > t ? o : i;
            a < t ? o = s : i = s
        }
    }
    function cU(e, t, n) {
        return e < 0 || e > 1 || n <= t ? NaN : e === 0 ? t : e === 1 ? n : t + e * (n - t)
    }
    function lU(e, t) {
        let n = FO(e);
        return (Zc(e) - t) * Math.sqrt(e.length) / n
    }
    function iS(e) {
        return {
            min: Gh(e),
            q1: ap(e, 1),
            median: AO(e),
            q3: ap(e, 3),
            max: qh(e)
        }
    }
    function pU(e) {
        return e.length
    }
    function Gh(e) {
        if (e.length < 1)
            return NaN;
        let t = e[0];
        if (isNaN(t))
            return NaN;
        for (let n = 1; n < e.length; n++) {
            if (isNaN(e[n]))
                return NaN;
            e[n] < t && (t = e[n])
        }
        return t
    }
    function qh(e) {
        if (e.length < 1)
            return NaN;
        let t = e[0];
        if (isNaN(t))
            return NaN;
        for (let n = 1; n < e.length; n++) {
            if (isNaN(e[n]))
                return NaN;
            e[n] >= t && (t = e[n])
        }
        return t
    }
    function RO(e, t) {
        if (!isFinite(t) || t < 0 || t > 1)
            return NaN;
        if (e.some(isNaN))
            return NaN;
        if (e.length === 0)
            return NaN;
        let n = e.length
          , r = pp(e)
          , o = t * (n - 1);
        return Math.floor(o) === o ? e[r[o]] : (Math.ceil(o) - o) * e[r[Math.floor(o)]] + (o - Math.floor(o)) * e[r[Math.ceil(o)]]
    }
    function ap(e, t) {
        if (!isFinite(t) || t < 0 || t > 4)
            return NaN;
        if (e.some(isNaN))
            return NaN;
        let n = pp(e)
          , r = zh(e, t)
          , o = Math.floor(r)
          , i = Math.ceil(r);
        return (e[n[o]] + e[n[i]]) / 2
    }
    function VP(e, t) {
        let n = e - t;
        return Number.isNaN(n) ? +Number.isNaN(e) - +Number.isNaN(t) : n
    }
    function NO(e, t) {
        return VP(e[0], t[0]) || VP(e[1], t[1])
    }
    function OO(e) {
        let t = [];
        for (let n = 0; n < e; n++)
            t.push(n);
        return t
    }
    function pp(e) {
        return OO(e.length).sort( (t, n) => VP(e[t], e[n]))
    }
    function mU(e) {
        return OO(e.length).sort( (t, n) => NO(e[t], e[n]))
    }
    function zh(e, t) {
        t = Math.round(t);
        let n = e.length, r = n % 2 === 1, o;
        return n === 1 ? 0 : (t === 0 && (o = 0),
        t === 2 && (o = (n - 1) / 2),
        t === 4 && (o = n - 1),
        t === 1 && (o = r ? (n + 1) / 4 - 1 : (n + 2) / 4 - 1),
        t === 3 && (o = r ? (3 * n + 3) / 4 - 1 : (3 * n + 2) / 4 - 1),
        o === void 0 ? NaN : o)
    }
    function dU(e, t) {
        return pp(e)[Math.ceil(t * (e.length - 1))] + 1
    }
    function fU(e, t) {
        return pp(e)[Math.floor(t * (e.length - 1))] + 1
    }
    function yU(e, t) {
        return pp(e)[Math.ceil(zh(e, t))] + 1
    }
    function gU(e, t) {
        return pp(e)[Math.floor(zh(e, t))] + 1
    }
    function AO(e) {
        return RO(e, .5)
    }
    function hU(e) {
        if (e.length < 1)
            return 0;
        let t = e[0];
        if (isNaN(t))
            return 0;
        let n = 0;
        for (let r = 1; r < e.length; r++) {
            if (isNaN(e[r]))
                return 0;
            e[r] < t && (n = r,
            t = e[r])
        }
        return n + 1
    }
    function bU(e) {
        if (e.length < 1)
            return 0;
        let t = e[0];
        if (isNaN(t))
            return 0;
        let n = 0;
        for (let r = 1; r < e.length; r++)
            if (e[r] >= t) {
                if (isNaN(e[r]))
                    return 0;
                n = r,
                t = e[r]
            }
        return n + 1
    }
    function zf(e) {
        let t = Zc(e)
          , n = 0;
        for (let r = 0; r < e.length; r++) {
            let o = e[r] - t;
            n += o * o
        }
        return n / e.length
    }
    function xU(e) {
        let t = Zc(e)
          , n = 0;
        for (let r = 0; r < e.length; r++)
            n += Math.abs(e[r] - t);
        return n / e.length
    }
    function wO(e) {
        let t = e.length;
        return zf(e) * t / (t - 1)
    }
    function LO(e, t) {
        let n = Math.min(e.length, t.length);
        e.length !== n && (e = e.slice(0, n)),
        t.length !== n && (t = t.slice(0, n));
        let r = Zc(e)
          , o = Zc(t)
          , i = 0;
        for (let s = 0; s < n; s++)
            i += (e[s] - r) * (t[s] - o);
        return i / n
    }
    function TU(e, t) {
        let n = Math.min(e.length, t.length);
        return LO(e, t) * n / (n - 1)
    }
    function Hh(e, t) {
        let n = Math.min(e.length, t.length);
        e.length !== n && (e = e.slice(0, n)),
        t.length !== n && (t = t.slice(0, n));
        let r = Zc(e)
          , o = Zc(t)
          , i = 0
          , s = 0
          , a = 0;
        for (let u = 0; u < n; u++) {
            let c = e[u] - r
              , l = t[u] - o;
            i += c * c,
            s += l * l,
            a += c * l
        }
        return a / Math.sqrt(i * s)
    }
    function sS(e, t, n, r) {
        let o = e[0];
        for (let s = 2; s < e.length; s++) {
            let a = L(Fo(ki(e[s], o), n));
            if (!Bi(a, s, 10))
                return 0
        }
        let i = L(r);
        for (let s = 0; s < t.length - 1; s++) {
            let a = L(Fo(ki(t[s], o), n));
            if (!Bi(a, i - t.length + s, 10))
                return 0
        }
        return !isFinite(i) || i < e.length || i < t.length ? 0 : i
    }
    function aS(e) {
        return e < 0 || !isFinite(e) ? 0 : e
    }
    function BP(e) {
        let t = e.length;
        if (t === 0)
            return [];
        let n = []
          , r = [];
        for (let a = 0; a < t; a++)
            r.push([e[a], a]);
        r.sort( (a, u) => {
            let c = a[0]
              , l = u[0];
            return c === 1 / 0 && l === 1 / 0 || c === -1 / 0 && l === -1 / 0 ? 0 : c - l
        }
        );
        let o = 0
          , i = 1
          , s = 1;
        for (; o < t; ) {
            let a = o;
            for (; a < t - 1 && r[a][0] === r[a + 1][0]; )
                a += 1;
            s = a - o + 1;
            let u;
            for (a = 0; a < s; a++)
                u = r[o + a][1],
                n[u] = isNaN(e[u]) ? NaN : i + .5 * (s - 1);
            i += s,
            o += s
        }
        return n
    }
    function IU(e, t) {
        let n = Math.min(e.length, t.length);
        return e.length !== n && (e = e.slice(0, n)),
        t.length !== n && (t = t.slice(0, n)),
        Hh(BP(e), BP(t))
    }
    function FO(e) {
        return Math.sqrt(wO(e))
    }
    function PU(e) {
        return Math.sqrt(zf(e))
    }
    var SU = Pf;
    function Em(e, t) {
        return Wo(t[0] - e[0], t[1] - e[1])
    }
    function EU(e, t) {
        return Wo(t[0] - e[0], Wo(t[1] - e[1], t[2] - e[2]))
    }
    function VO(e, t, n) {
        return [pr(Math.round(e), 0, 255), pr(Math.round(t), 0, 255), pr(Math.round(n), 0, 255)]
    }
    function CU(e, t, n) {
        isFinite(e) || (e = 0),
        t = pr(t, 0, 1),
        n = pr(n, 0, 1);
        let r = n * (1 - t / 2);
        r === 0 || r === 1 ? t = 0 : t = (n - r) / Math.min(r, 1 - r);
        let {r: o, g: i, b: s} = uh(e, t, r).rgb();
        return VO(o, i, s)
    }
    function vU(e) {
        return e
    }
    function MU(e, t) {
        return [e, t]
    }
    function DU(e, t, n) {
        return [e, t, n]
    }
    function _U(e, t) {
        return [e, t]
    }
    function RU(e) {
        return e
    }
    function NU(e) {
        let t = [];
        if (e.length === 0)
            return [];
        for (let n = 0; n < e.length - 1; n++)
            t.push([e[n], e[n + 1]]);
        return t.push([e[e.length - 1], e[0]]),
        t
    }
    function uS(e) {
        if (e.length == 0)
            return 0;
        let t = [...e, e[0]];
        return mN(t)
    }
    function OU(e) {
        let t = 0;
        for (let n = 0; n < e.length - 1; n++) {
            let[r,o] = e[n]
              , [i,s] = e[n + 1];
            t += _s(i - r, s - o)
        }
        if (e.length > 1) {
            let[n,r] = e[e.length - 1]
              , [o,i] = e[0];
            t += _s(o - n, i - r)
        }
        return t
    }
    function AU(e) {
        let t = !1;
        for (let n = 0; n < e.length; n++) {
            let r = (n + 1) % e.length;
            e[n][0] === e[r][0] && e[n][1] === e[r][1] && (t = !0)
        }
        return t ? e.filter( (n, r) => {
            let o = e[r === 0 ? e.length - 1 : r - 1];
            return n[0] !== o[0] || n[1] !== o[1]
        }
        ) : e
    }
    function wU(e) {
        let[t,n,r,o] = e;
        return [t, r >= 0 ? n : n + r, r >= 0 ? r : -r, o]
    }
    function BO(e, t, n) {
        if (e.length === 0)
            return [];
        if (e = AU(e),
        e.length === 0)
            return [];
        let r = dN([...e, e[0]])
          , o = [];
        for (let i = 0; i < e.length; i++) {
            let s = e[i > 0 ? i - 1 : e.length - 1]
              , a = e[i]
              , u = e[i < e.length - 1 ? i + 1 : 0]
              , c = r[i] === 1
              , l = uk(s, a, u, c ? "counterclockwise" : "clockwise", n);
            o.push(t ? l : wU(l))
        }
        return o
    }
    function LU(e, t) {
        return BO(e, !1, t)
    }
    function FU(e, t) {
        return BO(e, !0, t)
    }
    function cS(e, t) {
        return [e, t]
    }
    var VU = cS
      , BU = cS;
    function GU(e, t) {
        let n = [t[0] - e[0], t[1] - e[1]]
          , r = [e[0], e[1]];
        return GO(n, r)
    }
    function GO(e, t) {
        return [e, t]
    }
    function qU(e) {
        return e[0]
    }
    function zU(e) {
        return e[1]
    }
    function HU(e, t) {
        let n = [t[0] - e[0], t[1] - e[1], t[2] - e[2]]
          , r = [e[0], e[1], e[2]];
        return qO(n, r)
    }
    function qO(e, t) {
        return [e, t]
    }
    function UU(e) {
        return e[0]
    }
    function kU(e) {
        return e[1]
    }
    function $U(e) {
        return e
    }
    function YU(e, t) {
        return [e, t]
    }
    function ZU(e) {
        return e[0]
    }
    function XU(e) {
        return e[1]
    }
    function WU(e, t, n) {
        return [e, t, n]
    }
    function Dm([e,t,n]) {
        let[r,o] = e
          , [i,s] = t
          , [a,u] = n
          , c = i * i + s * s
          , l = (r * r + o * o - c) / 2
          , p = (c - a * a - u * u) / 2
          , m = (r - i) * (s - u) - (i - a) * (o - s);
        m = 1 / m;
        let d = (l * (s - u) - p * (o - s)) * m
          , y = ((r - i) * p - (i - a) * l) * m;
        return [d, y]
    }
    function jU(e) {
        return e[0]
    }
    function JU(e) {
        return e[1]
    }
    function QU(e) {
        return e[2]
    }
    function _m(e) {
        let[[t,n],[r,o],[i,s]] = e
          , a = r - t
          , u = o - n
          , c = i - r
          , l = s - o;
        return 2 * Math.atan2(a * l - c * u, a * c + u * l)
    }
    function lS(e) {
        let t = Math.abs(_m(e));
        return t < 1e-9 || t > 2 * Math.PI - 1e-9
    }
    function KU(e) {
        return e[0]
    }
    function ek(e) {
        return e[1]
    }
    function tk(e) {
        return e[0]
    }
    function nk(e) {
        return e[1]
    }
    function zO(e) {
        return Math.abs(e) === Math.PI ? Math.PI : rp(e + Math.PI, 2 * Math.PI) - Math.PI
    }
    function HO(e, t, n, r) {
        return [e, zO(t), n, r]
    }
    function rk([e,t,n,r]) {
        return [e, t, n, r]
    }
    function ok(e) {
        return e[2]
    }
    function ik(e) {
        return e[3]
    }
    function UO(e) {
        let[t,n,r,o] = e
          , i = Math.PI * 2
          , s = r === 0 ? i : r > 0 ? r - i : r + i;
        return [t, n, s, o]
    }
    function sk(e) {
        let[t,n,r,o] = UO(e);
        return [t, n, r, o]
    }
    function ak(e) {
        let[t,n,r,o] = e
          , i = r >= 0 ? Math.PI - r : -Math.PI - r;
        return [t, zO(n + r), i, o]
    }
    function uk(e, t, n, r, o) {
        let i = e[0] - t[0]
          , s = e[1] - t[1]
          , a = n[0] - t[0]
          , u = n[1] - t[1]
          , c = Math.atan2(s, i)
          , l = Math.atan2(i * u - s * a, i * a + s * u)
          , p = 2 * Math.PI;
        return r === "clockwise" ? l -= l < 0 ? 0 : p : r === "counterclockwise" && (l += l < 0 ? p : 0),
        HO(t, c, l, o)
    }
    function ck(e, t) {
        let[[n,r],[o,i],s] = e;
        return [[n * t, r * t], [o * t, i * t], s]
    }
    function lk(e, t) {
        let n = new Array(e.length);
        for (let r = 0; r < n.length; r++) {
            let o = e[r];
            n[r] = [o[0] * t, o[1] * t]
        }
        return n
    }
    function pS(e, t) {
        let[[n,r],[o,i]] = e;
        return [[t * n, t * r], [t * o, t * i]]
    }
    var pk = pS
      , mk = pS;
    function dk(e, t) {
        let[[n,r],o] = e;
        return [[t * n, t * r], t * o]
    }
    function fk(e, t) {
        let[[n,r],[o,i],[s,a]] = e;
        return [[t * n, t * r], [t * o, t * i], [t * s, t * a]]
    }
    function yk(e, t) {
        let[[n,r],o,i,s] = e;
        return [[t * n, t * r], t * o, t * i, s]
    }
    function gk(e, t) {
        if (e.length !== t.length)
            throw new Error("Polygon tangent must be added to polygon of same length.");
        let n = new Array(e.length);
        for (let r = 0; r < n.length; r++) {
            let o = e[r]
              , i = t[r];
            n[r] = [o[0] + i[0], o[1] + i[1]]
        }
        return n
    }
    function Uh(e, t) {
        let[[n,r],[o,i]] = e
          , [[s,a],[u,c]] = t;
        return [[n + s, r + a], [o + u, i + c]]
    }
    function hk(e, t) {
        let[[n,r,o],[i,s,a]] = e
          , [[u,c,l],[p,m,d]] = t;
        return [[n + u, r + c, o + l], [i + p, s + m, a + d]]
    }
    var bk = Uh
      , xk = Uh
      , Tk = Uh;
    function Ik(e, t) {
        let[[n,r],o] = e
          , [[i,s],a] = t;
        return [[n + i, r + s], o + a]
    }
    function Pk(e, t) {
        let[[n,r],[o,i],[s,a]] = e
          , [[u,c],[l,p],[m,d]] = t;
        return [[n + u, r + c], [o + l, i + p], [s + m, a + d]]
    }
    function Sk(e, t) {
        let[[n,r],o,i,s] = e
          , [[a,u],c,l] = t;
        return [[n + a, r + u], o + c, i + l, s]
    }
    function Ek(e, t) {
        let[[n,r],[o,i],s] = e
          , [[a,u],[c,l]] = t;
        return [[n + a, r + u], [o + c, i + l], s]
    }
    function mS(e, t) {
        let[[n,r],[o,i]] = e;
        return [(1 - t) * n + t * o, (1 - t) * r + t * i]
    }
    function dS(e, t) {
        return mS(e, pr(t, 0, 1))
    }
    function Ck(e, t) {
        t = pr(t, 0, 1);
        let[[n,r,o],[i,s,a]] = e;
        return [(1 - t) * n + t * i, (1 - t) * r + t * s, (1 - t) * o + t * a]
    }
    function GP(e, t) {
        return mS(e, pr(t, 0, 1 / 0))
    }
    function vk(e, t) {
        let[[n,r],o] = e
          , i = Math.min(1, Math.max(0, t));
        return [n + o * Math.cos(2 * Math.PI * i), r + o * Math.sin(2 * Math.PI * i)]
    }
    function kO(e, t) {
        let n = kh(e);
        if (!n)
            return [NaN, NaN];
        if (n.type === "segment")
            return dS([e[0], e[2]], t);
        if (n.type === "rays")
            return t <= 0 ? GP([n.start1, n.end1], -t) : t >= 1 ? GP([n.start2, n.end2], t - 1) : [NaN, NaN];
        t = Math.min(1, Math.max(0, t));
        let r = Dm(e)
          , o = _m(e)
          , i = Math.atan2(e[0][1] - r[1], e[0][0] - r[0])
          , s = Em(r, e[0])
          , a = i + t * o;
        return [r[0] + s * Math.cos(a), r[1] + s * Math.sin(a)]
    }
    function Mk(e, t) {
        if (isNaN(t) || e.length === 0)
            return [[NaN, NaN], [NaN, NaN]];
        if (t < 0 || t >= e.length)
            return [e[0], e[0]];
        let n = Math.floor(t);
        return [e[n], e[(n + 1) % e.length]]
    }
    function Dk(e, t) {
        if (isNaN(t) || e.length === 0)
            return [NaN, NaN];
        if (t < 0 || t >= e.length)
            return e[0];
        let n = Math.floor(t);
        return dS([e[n], e[(n + 1) % e.length]], t - n)
    }
    function kh(e) {
        let[t,n,r] = e
          , [[o,i],[s,a],[u,c]] = [t, n, r];
        if (isNaN(o) || isNaN(i) || isNaN(s) || isNaN(a) || isNaN(u) || isNaN(c))
            return;
        let l = Dm([t, n, r])
          , p = Em(l, t);
        if (isFinite(p) && !lS([t, n, r])) {
            let m = Math.atan2(t[1] - l[1], t[0] - l[0])
              , d = m + _m([t, n, r]);
            return {
                type: "arc",
                center: l,
                radius: p,
                startAngle: m,
                endAngle: d
            }
        } else {
            let m = Qs(s, a, 0, o, i, 0, u, c, 0);
            return m < 0 || m > 1 ? {
                type: "rays",
                start1: [o, i],
                end1: [o + (o - u), i + (i - c)],
                start2: [u, c],
                end2: [u + (u - o), c + (c - i)]
            } : {
                type: "segment",
                start: [o, i],
                end: [u, c]
            }
        }
    }
    function _k(e, t, n) {
        let o = Em(e, t);
        if (o > 1e-9)
            return t;
        let i = Em(e, n);
        return i > 1e-9 ? n : isNaN(o) && isNaN(i) ? [NaN, NaN] : e
    }
    function Bf(e, t) {
        let[[n,r],o] = e, [[i,s],a] = t, u = Wo(i - n, s - r), c = u * u, l = o * o, p = a * a, [m,d,y] = [u, o, a].sort( (C, S) => S - C), g = m + d + y, f = y - (m - d), h = y + (m - d), x = m + (d - y), T = .01, P;
        return f < 0 && m + T * f === m || h < 0 && m + T * h === m || x < 0 && m + T * x === m ? P = 0 : P = Math.sqrt(g * f * h * x) / 4,
        [(i + n) / 2 + (i - n) * (l - p) / (2 * c) + -2 * (s - r) * P / c, (s + r) / 2 + (s - r) * (l - p) / (2 * c) + 2 * (i - n) * P / c]
    }
    function Ch(e, t, n) {
        let[[r,o],i] = e, [[s,a],[u,c]] = t, l = s - r, p = u - r, m = a - o, d = c - o, y = u - s, g = c - a, f = y * y + g * g, h = Wo(y, g), x = l * d - p * m, T = i * h, P = T + x, C = T - x, S = .01, E;
        if (P < 0 && T + S * P === T || C < 0 && T + S * C === T ? E = 0 : E = P * C,
        E < 0)
            return [NaN, NaN];
        let M = Math.sqrt(E);
        return [r + (x * g + n * y * M) / f, o + (-x * y + n * g * M) / f]
    }
    function Rk(e, t) {
        let[[n,r],[o,i]] = e
          , [[s,a],[u,c]] = t
          , l = i - r
          , p = n - o
          , m = c - a
          , d = s - u
          , y = l * n + p * r
          , g = m * s + d * a
          , f = l * d - m * p
          , h = f / (Wo(l, p) * Wo(m, d));
        return f === 0 || 1 + .1 * h === 1 ? [NaN, NaN] : [(d * y - p * g) / f, (l * g - m * y) / f]
    }
    function fS(e, t, n=0) {
        let r = Ch(t, e, -1);
        if (Wc(r, e, n, !0))
            return r;
        {
            let o = Ch(t, e, 1);
            return Wc(o, e, n, !0) ? o : [NaN, NaN]
        }
    }
    function yS(e, t, n=0) {
        let r = Ch(e, t, 1);
        if (Wc(r, t, n, !1))
            return r;
        {
            let o = Ch(e, t, -1);
            return Wc(o, t, n, !1) ? o : [NaN, NaN]
        }
    }
    function $O(e, t, n=0) {
        let r = Rk(e, t);
        return !Wc(r, e, n, !0) || !Wc(r, t, n, !1) ? [NaN, NaN] : r
    }
    function Nk(e, t, n=0) {
        let r = XO(t, e, n, -1);
        return Cm(r, t, n, !1) ? r : [NaN, NaN]
    }
    function YO(e, t, n=0) {
        let r = WO(t, e, n, -1);
        return !Wc(r, e, n, !0) || !Cm(r, t, n, !1) ? [NaN, NaN] : r
    }
    function Ok(e, t, n=0) {
        let r = XO(e, t, n, 1);
        return Cm(r, e, n, !0) ? r : [NaN, NaN]
    }
    function ZO(e, t, n=0) {
        let r = WO(e, t, n, 1);
        return !Cm(r, e, n, !0) || !Wc(r, t, n, !1) ? [NaN, NaN] : r
    }
    function Ak(e, t, n=0) {
        let r = wk(e, t, n);
        return !Cm(r, e, n, !0) || !Cm(r, t, n, !1) ? [NaN, NaN] : r
    }
    function wk(e, t, n) {
        let r = Mh(e);
        if (Dh(r))
            return YO(r, t, n);
        let o = Mh(t);
        return Dh(o) ? ZO(e, o, n) : gS( () => Bf(r, o), () => Bf(o, r), i => hS(-1, vh(e, i), vh(t, i)))
    }
    function XO(e, t, n, r) {
        let o = Mh(e);
        return Dh(o) ? r > 0 ? yS(t, o, n) : fS(o, t, n) : gS( () => Bf(o, t), () => Bf(t, o), i => hS(r, vh(e, i), Lk(t, i)))
    }
    function WO(e, t, n, r) {
        let o = Mh(e);
        return Dh(o) ? $O(o, t, n) : gS( () => yS(o, t, n), () => fS(t, o, n), i => hS(r, vh(e, i), Fk(t)))
    }
    function gS(e, t, n) {
        let r = e();
        if (n(r))
            return r;
        let o = t();
        return n(o) ? o : [NaN, NaN]
    }
    function hS(e, t, n) {
        return e * JO(t, n) > 0
    }
    function vh(e, [t,n]) {
        let[r,o] = Dm(e);
        return _m(e) > 0 ? [o - n, t - r] : [n - o, r - t]
    }
    function Lk([[e,t]], [n,r]) {
        return [t - r, n - e]
    }
    function Fk([[e,t],[n,r]]) {
        return [n - e, r - t]
    }
    function Mh(e) {
        let t = Dm(e)
          , n = Em(t, kO(e, 0));
        return isFinite(n) && !lS(e) ? [t, n] : [e[0], e[2]]
    }
    function Dh(e) {
        return Array.isArray(e[1])
    }
    function Cm([e,t], n, r, o) {
        let[i,s] = Dm(n);
        return (o ? (r & 3) === 0 : (r & 12) === 0) || Jg(Math.atan2(t - s, e - i), Math.atan2(n[0][1] - s, n[0][0] - i), _m(n))
    }
    function Wc([e,t], [[n,r],[o,i]], s, a) {
        let u = Qs(e, t, 0, n, r, 0, o, i, 0)
          , [c,l] = a ? [(s & 1) === 0, (s & 2) === 0] : [(s & 4) === 0, (s & 8) === 0];
        return !isNaN(u) && (u >= 0 || c) && (u <= 1 || l)
    }
    function Vk(e, t) {
        let[[n,r],[o,i]] = e
          , [s,a] = t;
        return [[s, a], [s + (o - n), a + (i - r)]]
    }
    function Bk(e, t) {
        let[[n,r],[o,i]] = e
          , [s,a] = t;
        return [[s, a], [s + (i - r), a - (o - n)]]
    }
    function Gk(e) {
        let[t,n,r] = e
          , [o,i] = t
          , s = Yn(n + r / 2)
          , a = Nn(n + r / 2);
        return [[o, i], [o + s, i + a]]
    }
    function jO(e, t) {
        let[n,r] = e
          , [o,i] = t;
        return [n * o - r * i, n * i + o * r]
    }
    function bS(e, t) {
        let[n,r,o] = e
          , [i,s] = n
          , [a,u] = t;
        return o && (u = -u),
        s === 0 ? [i * a, i * u] : [i * a - s * u, i * u + a * s]
    }
    function JO(e, t) {
        let[n,r] = e
          , [o,i] = t;
        return n * i - o * r
    }
    function qk(e, t) {
        let[n,r] = e
          , [o,i] = t;
        return n * o + r * i
    }
    function zk(e) {
        let[t,n] = e;
        return [-n, t]
    }
    function Hk(e, t) {
        return [e, t, !1]
    }
    function Uk(e, t) {
        return [e, t, !0]
    }
    function kk(e) {
        return [e[0], [0, 0], e[2]]
    }
    function $k(e) {
        return e[0]
    }
    function Yk(e) {
        return [[1, 0], e, !1]
    }
    function Zk(e, t) {
        let[n,r] = e;
        return [[t, 0], [(1 - t) * n, (1 - t) * r], !1]
    }
    function Xk(e, t) {
        let[n,r] = e
          , o = Math.cos(t)
          , i = Math.sin(t);
        return [[o, i], [n * (1 - o) + r * i, r * (1 - o) - n * i], !1]
    }
    function Wk(e) {
        let[[t,n],[r,o]] = e
          , i = r - t
          , s = o - n
          , a = i * i + s * s
          , u = (i * i - s * s) / a
          , c = 2 * i * s / a;
        return [[u, c], [(1 - u) * t - c * n, (1 + u) * n - c * t], !0]
    }
    function jk(e, t) {
        let n = e[2]
          , [r,o,i] = t;
        return [bS(e, r), oa(e, o), i !== n]
    }
    function Jk(e) {
        let[[t,n],[r,o],i] = e
          , s = t * t + n * n
          , a = t / s
          , u = -n / s
          , c = -(t / s * r + n / s * o)
          , l = -(t / s * o - n / s * r);
        return i && (u = -u,
        l = -l),
        [[a, u], [c, l], i]
    }
    function oa(e, t) {
        let[n,r] = bS(e, t)
          , [o,i] = e[1];
        return [n + o, r + i]
    }
    function Qk(e, t) {
        let[n,r,o] = e;
        return o ? -t : t
    }
    function xS(e, t) {
        let[n,r] = t;
        return [oa(e, n), oa(e, r)]
    }
    var Kk = xS
      , e8 = xS;
    function t8(e, t) {
        let[n,r] = t;
        return [bS(e, n), oa(e, r)]
    }
    function n8(e, t) {
        let[n,r] = t
          , [[o,i]] = e;
        return [oa(e, n), Wo(o, i) * r]
    }
    function r8(e, t) {
        let[n,r,o] = t;
        return [oa(e, n), oa(e, r), oa(e, o)]
    }
    function o8(e, t) {
        let n = [];
        for (let r of t)
            n.push(oa(e, r));
        return n
    }
    function i8(e, t) {
        let[n,r,o] = t
          , i = oa(e, n)
          , [s,a,u] = e
          , [c,l] = oa([s, [0, 0], u], [Math.cos(r), Math.sin(r)])
          , p = Math.atan2(l, c)
          , m = Qk(e, o);
        return [i, p, m, t[3]]
    }
    function s8(e, t) {
        let n = [];
        for (let r = 0; r < Math.min(e.length, t.length); r++)
            t[r] && n.push(e[r]);
        return n
    }
    function a8(e, t) {
        let n = [];
        for (let r of t)
            n.push(e[r]);
        return n
    }
    function u8(e) {
        let t = []
          , n = {};
        for (let r = 0; r < e.length; r++) {
            let o = e[r]
              , i = _h(o);
            n.hasOwnProperty(i) || (n[i] = !0,
            t.push(r))
        }
        return t
    }
    function c8(e, t) {
        return [e, t]
    }
    function l8(e) {
        return e[0]
    }
    function p8(e) {
        return e[1]
    }
    function _h(e) {
        if (Array.isArray(e))
            return `[${e.map(_h).join(",")}]`;
        switch (typeof e) {
        case "string":
            return e;
        case "boolean":
        case "number":
            return e.toString();
        case "object":
            if (fc(e)) {
                let n = [];
                for (let r of ue(e.updateRules))
                    n.push(`"${String(r)}": ${_h(e.updateRules[r].value)}`);
                return `{${n.join(",")}}`
            } else
                return L(e).toString();
        default:
            return e
        }
    }
    function m8(e) {
        return e
    }
    function d8(e) {
        return e
    }
    function Zt(e, t) {
        return isNaN(e) || isNaN(t) ? [NaN, NaN] : [e, t]
    }
    function $c(e, t) {
        return isNaN(e) || isNaN(t) ? Zt(NaN, NaN) : e === 0 ? Zt(0, 0) : Zt(e * Yn(t), e * Nn(t))
    }
    function f8([e,t]) {
        return e
    }
    function y8([e,t]) {
        return t
    }
    function g8([e,t]) {
        return Hf(t, e)
    }
    function up([e,t]) {
        return [e, -t]
    }
    function jc(e, t) {
        let[n,r] = t;
        return Math.abs(r) <= Math.abs(n) ? QN(e, t) : up(QN(JN(e), JN(t)))
    }
    function JN([e,t]) {
        return [t, e]
    }
    function QN([e,t], [n,r]) {
        let o = r / n
          , i = 1 / (n + r * o);
        return o === 0 ? Zt((e + r * (t / n)) * i, (t - r * (e / n)) * i) : Zt((e + t * o) * i, (t - e * o) * i)
    }
    function QO([e,t]) {
        return cp(e, t)
    }
    function cp(e, t) {
        let n = Math.sqrt(.5 * (Math.abs(e) + Wo(e, t)));
        return n === 1 / 0 && (n = 2 * Math.sqrt(.5 * (Math.abs(.25 * e) + Wo(.25 * e, .25 * t)))),
        n === 0 || !isFinite(t) ? Zt(n, t) : e > 0 ? Zt(n, .5 * (t / n)) : (t < 0 && (n = -n),
        Zt(.5 * (t / n), n))
    }
    function jo(e) {
        return jc(Zt(1, 0), e)
    }
    function Gf(e) {
        return 0 + e
    }
    function Hf(e, t) {
        return Math.atan2(Gf(e), Gf(t))
    }
    function h8(e, t) {
        let n = e * e + t * t;
        if (n === 1 / 0)
            return Math.log(Math.hypot(.5 * e, .5 * t)) + Math.LN2;
        if (n === 0)
            return Math.log(Math.hypot(e, t));
        if (.5 < n && n < 3) {
            let r = Math.max(e, t)
              , o = Math.min(e, t);
            return .5 * Math.log1p((r + 1) * (r - 1) + o * o)
        } else
            return .5 * Math.log(n)
    }
    function qP([e,t]) {
        return Zt(h8(e, t), Hf(t, e))
    }
    function b8([e,t]) {
        let n = Math.exp(e);
        return t === 0 ? Zt(n, 0) : $c(n, t)
    }
    function x8([e,t]) {
        return Zt((e + t) * (e - t), 2 * e * t)
    }
    function KN(e, t) {
        t = t >>> 0;
        let[n,r] = e
          , o = 1
          , i = 0;
        for (; t; ) {
            for (; !(t & 1); ) {
                let u = (n + r) * (n - r)
                  , c = 2 * n * r;
                n = u,
                r = c,
                t = t >>> 1
            }
            let s = n * o - r * i
              , a = n * i + o * r;
            o = s,
            i = a,
            t = t - 1 >>> 0
        }
        return Zt(o, i)
    }
    function T8(e, t) {
        let[n,r] = t;
        if (r === 0)
            return KO(e, n);
        let[o,i] = e;
        if (isNaN(o) || isNaN(i) || isNaN(n) || isNaN(r))
            return Zt(NaN, NaN);
        let s = Wo(o, i)
          , a = Hf(i, o)
          , u = Math.pow(s, n) * Math.exp(-a * r)
          , c = Math.log(s) * r + a * n;
        return isFinite(u) ? $c(u, c) : $c(Math.exp(n * Math.log(s) - a * r), c)
    }
    function KO(e, t) {
        let[n,r] = e;
        if (isNaN(n) || isNaN(r) || isNaN(t))
            return Zt(NaN, NaN);
        switch (t) {
        case -1:
            return jo(e);
        case 0:
            return Zt(1, 0);
        case .5:
            return QO(e);
        case 1:
            return e
        }
        return r === 0 ? Number.isInteger(t) || n >= 0 ? Zt(Math.pow(n, t), 0) : $c(Math.pow(-n, t), Math.PI * t) : n === 0 ? r >= 0 ? $c(Math.pow(r, t), .5 * Math.PI * t) : $c(Math.pow(-r, t), -.5 * Math.PI * t) : t === 2 ? x8(e) : t === (t | 0) ? t < 0 ? jo(KN(e, -t)) : KN(e, t) : $c(Math.pow(Math.hypot(n, r), t), t * Hf(r, n))
    }
    function eA([e,t]) {
        return Zt(Nn(e) * vm(t), Yn(e) * lp(t))
    }
    function tA([e,t]) {
        return Zt(Yn(e) * vm(t), -Nn(e) * lp(t))
    }
    function nA([e,t]) {
        let[n,r] = TS([-t, e]);
        return [r, -n]
    }
    function rA([e,t]) {
        return Zt(lp(e) * Yn(t), vm(e) * Nn(t))
    }
    function oA([e,t]) {
        return Zt(vm(e) * Yn(t), lp(e) * Nn(t))
    }
    function TS([e,t]) {
        let n = jP(t)
          , r = ZP(e);
        if (!isFinite(n))
            return Zt(1 / r, 1 / n);
        let o = n * n
          , i = 1 + o
          , s = lp(e)
          , a = s * s
          , u = r * r;
        return Zt(i * r / (1 + o * u), n / (1 + i * a))
    }
    function I8(e) {
        return jo(tA(e))
    }
    function P8(e) {
        return jo(eA(e))
    }
    function S8(e) {
        return jo(nA(e))
    }
    function E8(e) {
        return jo(oA(e))
    }
    function C8(e) {
        return jo(rA(e))
    }
    function v8(e) {
        return jo(TS(e))
    }
    function IS([e,t]) {
        let n = cp(1 - e, -t)
          , r = cp(1 + e, t);
        return Zt(Math.atan(e / Gf(sp(n, r)[0])), Math.asinh(sp(up(n), r)[1]))
    }
    function iA([e,t]) {
        let n = cp(1 - e, -t)
          , r = cp(1 + e, t);
        return Zt(2 * Math.atan(n[0] / Gf(r[0])), Math.asinh(sp(up(r), n)[1]))
    }
    function zP([e,t]) {
        let[n,r] = Rh([-t, e]);
        return [r, -n]
    }
    function sA([e,t]) {
        let[n,r] = IS([-t, e]);
        return [r, -n]
    }
    function aA([e,t]) {
        let n = cp(e - 1, t)
          , r = cp(e + 1, t);
        return Zt(Math.asinh(sp(up(n), r)[0]), 2 * Math.atan(n[1] / Gf(r[0])))
    }
    function Rh([e,t]) {
        if (e < 0) {
            let[n,r] = tO(-e, -t);
            return [-n, -r]
        } else
            return tO(e, t)
    }
    var eO = Math.sqrt(Number.MAX_VALUE) / 4;
    function tO(e, t) {
        if (e > eO || Math.abs(t) > eO)
            return Zt(jo([e, t])[0], t <= 0 ? -Math.PI / 2 : Math.PI / 2);
        if (e === 1) {
            if (t === 0)
                return Zt(1 / 0, 0);
            let n = Math.abs(t)
              , r = Math.log(Math.sqrt(Math.sqrt(4 + t * t)) / Math.sqrt(n))
              , o = (Math.PI / 2 + Math.atan(n / 2)) / 2;
            return t < 0 != o < 0 && (o = -o),
            Zt(r, o)
        } else
            return Zt(Mm(4 * e / ((1 - e) ** 2 + t ** 2)) / 4, -Hf(-2 * t, (1 - e) * (1 + e) - t ** 2) / 2)
    }
    function M8(e) {
        return iA(jo(e))
    }
    function D8(e) {
        return IS(jo(e))
    }
    function _8(e) {
        if (e[0] > 0)
            return zP(jo(e));
        let[t,n] = zP(e);
        return Zt(Math.PI / 2 - t, -n)
    }
    function R8(e) {
        let[t,n] = e;
        return t === 0 && n === 0 ? Zt(1 / 0, 0) : aA(jo(e))
    }
    function N8(e) {
        let[t,n] = e;
        return t === 0 && n === 0 ? Zt(1 / 0, 0) : sA(jo(e))
    }
    function O8(e) {
        return e[0] > 0 ? up(Rh(up(jo(e)))) : Rh(jo(e))
    }
    function PS([e,t]) {
        return t === 0 ? e : NaN
    }
    function A8([e,t]) {
        let r = Math.abs(t)
          , o = Math.abs(t / e);
        return (isNaN(o) ? r : Math.min(r, o)) < 1e-15 ? e : NaN
    }
    function w8([e,t], n) {
        var r, o;
        return t === 0 ? ((r = n.goodCoercionCount) != null || (n.goodCoercionCount = 0),
        n.goodCoercionCount++,
        e) : (isNaN(t) || ((o = n.badCoercionCount) != null || (n.badCoercionCount = 0),
        n.badCoercionCount++),
        NaN)
    }
    function SS(e) {
        return e !== 0 && !isNaN(e)
    }
    function L8([e,t], n) {
        var a, u;
        let o = Math.abs(t)
          , i = Math.abs(t / e);
        return (isNaN(i) ? o : Math.min(o, i)) < 1e-15 ? ((a = n.goodCoercionCount) != null || (n.goodCoercionCount = 0),
        n.goodCoercionCount++,
        e) : (isNaN(t) || ((u = n.badCoercionCount) != null || (n.badCoercionCount = 0),
        n.badCoercionCount++),
        NaN)
    }
    function F8(e) {
        return isNaN(e) ? [NaN, NaN] : [e, 0]
    }
    function V8(e, t) {
        return t
    }
    function uA([e,t]) {
        let n = Math.floor(e)
          , r = Math.floor(t);
        if (!isFinite(n) || !isFinite(r))
            return [n, r];
        let o = e - n
          , i = t - r;
        return o + i < 1 ? [n, r] : o >= i ? [n + 1, r] : [n, r + 1]
    }
    function B8([e,t]) {
        let n = uA([-e, -t]);
        return [-n[0], -n[1]]
    }
    function Im(e) {
        return [Math.round(e[0]), Math.round(e[1])]
    }
    function G8(e, t) {
        let[n,r] = e
          , [o,i] = t;
        if (!isFinite(n) || !isFinite(r) || isNaN(o) || isNaN(i))
            return [NaN, NaN];
        if (!isFinite(o) && !isFinite(i))
            return e;
        if (o === 1 / 0)
            return hh(n, r, i);
        if (o === -1 / 0) {
            let[m,d] = hh(-n, -r, -i);
            return [-m, -d]
        } else if (i === 1 / 0) {
            let[m,d] = hh(r, -n, -o);
            return [-d, m]
        } else if (i === -1 / 0) {
            let[m,d] = hh(-r, n, o);
            return [d, -m]
        }
        let s = HP(t)
          , a = n * o + r * i
          , u = r * o - n * i
          , c = rp(a, s)
          , l = rp(u, s);
        c + l < s || (c >= l ? c -= s : l -= s);
        let p = jc([c, l], [o, -i]);
        return Number.isInteger(n) && Number.isInteger(r) && Number.isInteger(o) && Number.isInteger(i) ? [Math.round(p[0]), Math.round(p[1])] : p
    }
    function hh(e, t, n) {
        return e + t < 0 ? e >= t ? Zt(e - n, 1 / 0) : Zt(1 / 0, t + n) : [e, t]
    }
    function HP([e,t]) {
        return e * e + t * t
    }
    function UP(e, t) {
        if (!isFinite(e[0]) || !isFinite(e[1]) || !isFinite(t[0]) || !isFinite(t[1]))
            return [NaN, NaN];
        e = Im(e),
        t = Im(t);
        let n = ES(e, t);
        return cA(n)
    }
    function ES(e, t) {
        let n = [1, 0];
        for (e = [e[0], e[1]],
        t = [t[0], t[1]]; ; ) {
            let r = HP(e)
              , o = HP(t);
            if (r === 1 || o === 1)
                return n;
            if (r === 0)
                return sp(t, n);
            if (o === 0)
                return sp(e, n);
            if (r === o && z8(e, t))
                return sp(e, n);
            switch (bh(e[0]) << 3 | bh(e[1]) << 2 | bh(t[0]) << 1 | bh(t[1])) {
            case 0:
                xm(e),
                xm(t),
                q8(n);
                break;
            case 1:
            case 2:
                xm(e);
                break;
            case 4:
            case 8:
                xm(t);
                break;
            case 3:
                xm(e),
                Tm(t),
                OP(n);
                break;
            case 12:
                Tm(e),
                xm(t),
                OP(n);
                break;
            case 14:
            case 13:
                Tm(e);
                break;
            case 7:
            case 11:
                Tm(t);
                break;
            case 15:
                Tm(e),
                Tm(t),
                OP(n);
                break;
            case 5:
            case 10:
                e = [.5 * (e[0] - t[0]), .5 * (e[1] - t[1])],
                t = [e[0] + t[0], e[1] + t[1]];
                break;
            case 6:
            case 9:
                e = [.5 * (e[0] + t[1]), .5 * (e[1] - t[0])],
                t = [e[0] - t[1], e[1] + t[0]];
                break
            }
        }
    }
    function q8(e) {
        e[0] *= 2,
        e[1] *= 2
    }
    function xm(e) {
        e[0] *= .5,
        e[1] *= .5
    }
    function OP(e) {
        let t = e[0] - e[1];
        e[1] = e[1] + e[0],
        e[0] = t
    }
    function Tm(e) {
        let t = .5 * (e[0] + e[1]);
        e[1] = .5 * (e[1] - e[0]),
        e[0] = t
    }
    function bh(e) {
        return e % 2 == 0 ? 0 : 1
    }
    function sp(e, t) {
        let[n,r] = e
          , [o,i] = t;
        return Zt(n * o - r * i, n * i + o * r)
    }
    function z8(e, t) {
        return e[0] == t[0] && e[1] == t[1] || e[0] == -t[0] && e[1] == -t[1] || e[0] == -t[1] && e[1] == t[0] || e[0] == t[1] && e[1] == -t[0]
    }
    function cA(e) {
        let[t,n] = e;
        return t >= 0 && n < 0 ? [-n, t] : t < 0 && n <= 0 ? [-t, -n] : t <= 0 && n > 0 ? [n, -t] : e
    }
    function kP(e, t) {
        if (!isFinite(e[0]) || !isFinite(e[1]) || !isFinite(t[0]) || !isFinite(t[1]))
            return [NaN, NaN];
        if (e[0] === 0 && e[1] === 0 || t[0] === 0 && t[1] === 0)
            return [0, 0];
        if (!isFinite(e[0]) || !isFinite(e[1]) || !isFinite(t[0]) || !isFinite(t[1]))
            return [NaN, NaN];
        e = Im(e),
        t = Im(t);
        let n = ES(e, t)
          , r = Im(jc(e, n))
          , o = jO(r, t);
        return cA(o)
    }
    function H8(e, t, n) {
        let r = e.length / t;
        if (r !== n || !Number.isInteger(r))
            throw new Error("Invalid matrix dimensions");
        let o = [];
        for (let i = 0; i < t; i++)
            for (let s = 0; s < n; s++)
                o[i] === void 0 && (o[i] = 0),
                o[i] += e[s * t + i];
        return o
    }
    function U8(e, t, n) {
        let r = e.length / t;
        if (r !== n || !Number.isInteger(r))
            throw new Error("Invalid matrix dimensions");
        let o = [];
        for (let i = 0; i < t; i++)
            for (let s = 0; s < n; s++)
                o[s] === void 0 && (o[s] = 0),
                o[s] += e[s * t + i];
        return o
    }
    function k8(e, t) {
        let n = bO(e)
          , r = [];
        for (let o = 0; o < t.length; o++)
            for (let i = 0; i < e.length; i++)
                r.push(e[i] * t[o] / n);
        return r
    }
    function ia(e) {
        if (typeof e == "string")
            return e;
        if (e === void 0)
            return "";
        if (isNaN(e))
            return "\\frac{0}{0}";
        if (e === 1 / 0)
            return "\\infty";
        if (e === -1 / 0)
            return "-\\infty";
        let t = e + "";
        return t = t.replace(/^1e\+?([-\d]+)/, "10^{$1}"),
        t = t.replace(/([-\d\.]+)e\+?([-\d]+)/, "$1\\cdot 10^{$2}"),
        t
    }
    function $h(e) {
        let t = e + "";
        if (/\d+\.?\d*e[\+\-]*\d+/i.test(t)) {
            let n = "0"
              , r = String(t).toLowerCase().split("e")
              , o = parseFloat(r[0])
              , i = parseInt(r[1], 10)
              , s = Math.abs(i)
              , a = Math.abs(o).toString().split(".");
            if (i < 0)
                t = "0." + new Array(s).join(n) + a.join("");
            else {
                let u = a[1];
                u && (s = s - u.length),
                t = a.join("") + new Array(s + 1).join(n)
            }
            o < 0 && (t = "-" + t)
        }
        return t
    }
    function vS(e, t=e, n=!1) {
        if (isNaN(e) || !isFinite(e))
            return {
                string: "undefined",
                latex: "undefined",
                value: e
            };
        if (e === 0)
            return {
                string: "0",
                latex: "0",
                value: e
            };
        Math.abs(e) > Math.abs(t) && (t = e);
        let r = cc(e / Math.PI, 24), o, i, s, a, u, c, l = n ? j8(t) : W8(t);
        if (l && Bi(r.n / r.d * Math.PI, e, 3))
            return r.n === 0 ? (o = "0",
            a = "0") : r.n === 1 ? (o = "\u03C0",
            a = "\\pi") : r.n === -1 ? (o = "-\u03C0",
            a = "-\\pi") : (o = r.n.toString() + "\u03C0",
            a = r.n.toString() + "\\pi"),
            r.d === 1 ? (i = "",
            u = "") : (i = "/" + r.d.toString(),
            u = r.d.toString()),
            s = o + i,
            u === "" ? c = a : a[0] === "-" ? c = `-\\frac{${a.slice(1)}}{${u}}` : c = `\\frac{${a}}{${u}}`,
            {
                string: s,
                latex: c,
                value: r.n / r.d * Math.PI
            };
        if (l)
            return s = X8(Uf(e.toFixed(CS(t)))),
            {
                string: s,
                latex: s,
                value: parseFloat(s)
            };
        {
            let p = Uf(e.toExponential(CS(t / e))).split("e")
              , m = p[0] === "1" && n ? "10" : p[0] + "\xD710"
              , d = p[1].replace("+", "");
            return s = Uf(e.toExponential(CS(t / e))).replace("+", ""),
            c = `${p[0]}\\times10^{${d}}`,
            {
                string: s,
                latex: c,
                mantissa: m,
                superscript: d,
                value: parseFloat(s)
            }
        }
    }
    function $8(e, t, n, r) {
        let o = vS(e, t)
          , i = vS(r(o.value), n);
        return [o, i]
    }
    var Y8 = /\.?0+$/
      , Z8 = /\.?0+e/;
    function Uf(e) {
        return e.indexOf(".") === -1 ? e : e.indexOf("e") !== -1 ? e.replace(Z8, "e") : e.replace(Y8, "")
    }
    function X8(e) {
        return e === "-0" ? "0" : e
    }
    function W8(e) {
        return e = Math.abs(e),
        1e-4 < e && e < 1e7
    }
    function j8(e) {
        return e = Math.abs(e),
        .001 < e && e < 1e4
    }
    var J8 = 5
      , Q8 = 5;
    function CS(e) {
        return e = Math.abs(e),
        e = Math.max(e, 1e-16),
        Math.max(J8, Math.floor(Q8 + 1.5 - Math.log10(e)))
    }
    var Yh = {
        zeroCutoff: 0,
        smallCutoff: .001,
        bigCutoff: 1e6,
        digits: 10,
        displayAsFraction: !1,
        addEllipses: !1,
        alwaysEmitImaginary: !1,
        spaceConstrained: !1
    }
      , lA = {
        smallCutoff: 1e-6,
        bigCutoff: 1e9,
        digits: 12
    }
      , MS = {
        ...lA,
        smallCutoff: 1e-4,
        bigCutoff: 1e6,
        digits: 9,
        scientificNotationDigits: 4,
        spaceConstrained: !0
    };
    function pA(e) {
        return 1e6 / Math.sqrt(Math.abs(e))
    }
    function mA(e) {
        let t = pA(e);
        if (t < 1 || t > 1e12)
            return !1;
        let {n, d: r} = cc(e, t);
        return r === 1 ? !1 : e === e + Math.pow(2, -3) * Math.abs(n / r - e)
    }
    function Zh(e, t) {
        var g;
        let {zeroCutoff: n, smallCutoff: r, bigCutoff: o, digits: i, displayAsFraction: s, addEllipses: a, spaceConstrained: u} = {
            ...Yh,
            ...t
        }
          , c = (g = t == null ? void 0 : t.scientificNotationDigits) != null ? g : i - 2;
        if (isNaN(e) || !isFinite(e))
            return {
                type: "undefined"
            };
        if (e === 0 || Math.abs(e) < n)
            return {
                type: "decimal",
                value: "0"
            };
        let p = Uf(e.toExponential(c)).match(/([\d\.\-]+)e\+?([\d\-]+)/);
        if (!p)
            return {
                type: "undefined"
            };
        let m = parseInt(p[2], 10)
          , d = m >= i;
        if (mA(e) && s) {
            let f = cc(e, pA(e));
            return {
                type: "fraction",
                numerator: f.n.toString(),
                denominator: f.d.toString()
            }
        } else {
            if (Math.abs(e) > o || Math.abs(e) < r || d)
                return {
                    type: "scientific",
                    mantissa: p[1],
                    exponent: p[2]
                };
            {
                let f = pr(u && m < 0 ? i + m : i, 1, 100)
                  , h = Uf(e.toPrecision(f));
                return e !== Number(h) && a && (h += "..."),
                {
                    type: "decimal",
                    value: h
                }
            }
        }
    }
    function Xh(e, t) {
        let n = Zh(e, t);
        switch (n.type) {
        case "undefined":
            return "undefined";
        case "decimal":
            return n.value;
        case "scientific":
            return n.mantissa + "<span class='dcg-cross'>\xD7</span>10<sup>" + n.exponent + "</sup>";
        case "fraction":
            return n.denominator === "1" ? n.numerator : `${n.numerator}/${n.denominator}`;
        default:
            return n
        }
    }
    function Rm(e, t) {
        let n = Zh(e, t);
        switch (n.type) {
        case "undefined":
            return "undefined";
        case "decimal":
            return n.value;
        case "scientific":
            return n.mantissa + " * 10^" + n.exponent;
        case "fraction":
            return n.denominator === "1" ? n.numerator : `${n.numerator}/${n.denominator}`;
        default:
            return n
        }
    }
    function Jc(e, t) {
        let n = Zh(e, t);
        switch (n.type) {
        case "undefined":
            return "undefined";
        case "decimal":
            return n.value;
        case "scientific":
            return n.mantissa + "\\times10^{" + n.exponent + "}";
        case "fraction":
            return n.denominator === "1" ? n.numerator : n.numerator[0] === "-" ? `-\\frac{${n.numerator.slice(1)}}{${n.denominator}}` : `\\frac{${n.numerator}}{${n.denominator}}`;
        default:
            return n
        }
    }
    function $(e) {
        if (e.startsWith("_base_case")) {
            let[n,r,o] = e.split(":")
              , i = [];
            for (let s of o.split(",")) {
                let a = parseFloat(s);
                isNaN(a) ? i.push($(s)) : i.push(Rm(a))
            }
            return `${$(r)}(${i.join(",")})`
        }
        e = e.replace("\\", "");
        let t = {
            alpha: "\u03B1",
            beta: "\u03B2",
            gamma: "\u03B3",
            delta: "\u03B4",
            epsilon: "\u03F5",
            varepsilon: "\u03B5",
            zeta: "\u03B6",
            eta: "\u03B7",
            theta: "\u03B8",
            vartheta: "\u03D1",
            iota: "\u03B9",
            kappa: "\u03BA",
            varkappa: "\u03F0",
            lambda: "\u03BB",
            mu: "\u03BC",
            xi: "\u03BE",
            pi: "\u03C0",
            varpi: "\u03D6",
            rho: "\u03C1",
            varrho: "\u03F1",
            sigma: "\u03C3",
            varsigma: "\u03C2",
            tau: "\u03C4",
            phi: "\u03D5",
            varphi: "\u03C6",
            chi: "\u03C7",
            psi: "\u03C8",
            omega: "\u03C9",
            Gamma: "\u0393",
            Delta: "\u0394",
            Theta: "\u0398",
            Lambda: "\u039B",
            Xi: "\u039E",
            Pi: "\u03A0",
            Sigma: "\u03A3",
            Phi: "\u03A6",
            Psi: "\u03A8",
            Omega: "\u03A9",
            div: "\xF7",
            cdot: "\u22C5",
            times: "\xD7",
            lt: "<",
            gt: ">",
            le: "\u2264",
            ge: "\u2265",
            sim: "\u223C",
            ldots: "\u2026",
            prime: "\u2032",
            approx: "\u2248",
            to: "\u2192",
            "->": "\u2192",
            "<=": "\u2264",
            ">=": "\u2265"
        };
        return t.hasOwnProperty(e) ? t[e] : e
    }
    function go(e) {
        let t = e.match(/^\$(\d+)$/);
        if (t)
            return `\\token{${t[1]}}`;
        let n = e.split("_")
          , r = "";
        return n[0].length > 1 && (r += "\\"),
        r += n[0],
        n[1] && (r += "_{" + n[1] + "}"),
        r
    }
    function K8(e) {
        if (!e)
            return "";
        let t = e.split("_");
        t[0] = $(t[0]);
        let n = t.map(q1);
        return n[1] && (n[1] = "<sub>" + n[1] + "</sub>"),
        n.join("")
    }
    function Bs(e) {
        let t = e.match(/\\token\{(\d+)\}/);
        return t ? `$${t[1]}` : (e = e.replace(/\\operatorname\{(.*)\}/, "$1"),
        e.replace(/[{}\\]/g, ""))
    }
    function Au(e) {
        return e.replace(/^(\\ |\s|\\space(?![a-zA-Z]))+/, "").replace(/(\\ |\s|\\space(?![a-zA-Z]))+$/, "")
    }
    function kf(e, t={}, n="latex") {
        let r = {
            ...Yh,
            ...t
        }, {alwaysEmitImaginary: o} = r, i;
        n === "decimalString" ? i = $h : n === "latex" ? i = Jc : i = Xh;
        let[s,a] = [e[0] !== 0 ? i(e[0], r) : void 0, e[1] !== 0 || o ? i(Math.abs(e[1]), r) : void 0];
        return s === "undefined" || a === "undefined" ? "undefined" : s && a ? `${s}${e[1] >= 0 ? "+" : "-"}${a !== "1" ? `${a}` : ""}i` : a ? `${e[1] >= 0 ? "" : "-"}${a !== "1" ? `${a}` : ""}i` : s != null ? s : "0"
    }
    function DS(e, t={}) {
        let[n,r] = [e[0] !== 0 ? Rm(e[0], t) : void 0, e[1] !== 0 ? Rm(Math.abs(e[1]), t) : void 0];
        if (n === "undefined" || r === "undefined")
            return "undefined";
        let o = r != null && r.includes(" * ") || r != null && r.includes("/") ? " " : "";
        return n && r ? `${n}${e[1] > 0 ? " + " : " - "}${r !== "1" ? `${r}${o}` : ""}i` : r ? `${e[1] > 0 ? "" : "-"}${r !== "1" ? `${r}${o}` : ""}i` : n != null ? n : "0"
    }
    function e$(e, t={}, n="latex") {
        let r = {
            ...Yh,
            ...t
        }, o;
        n === "decimalString" ? o = $h : n === "latex" ? o = Jc : o = Xh;
        let[i,s] = [o(e[0], r), o(e[1], r)];
        return i === "undefined" || s === "undefined" ? "undefined" : `\\left(${i},${s}\\right)`
    }
    function t$(e, t={}, n="latex") {
        let r = {
            ...Yh,
            ...t
        }, o;
        n === "decimalString" ? o = $h : n === "latex" ? o = Jc : o = Xh;
        let[i,s,a] = [o(e[0], r), o(e[1], r), o(e[2], r)];
        return i === "undefined" || s === "undefined" || a === "undefined" ? "undefined" : `\\left(${i},${s},${a}\\right)`
    }
    function $f(e) {
        return {
            __isLocalizableNumericValue: !0,
            value: e
        }
    }
    function VQ(e) {
        return e && e.__isLocalizableNumericValue
    }
    var wu = () => ({
        type: "empty"
    })
      , Vr = () => n$([-1 / 0, 1 / 0])
      , Fa = () => is([-1 / 0, 1 / 0])
      , is = e => Wh(e, !0)
      , n$ = e => Wh(e, !1)
      , Wh = (e, t) => isNaN(e[0]) || isNaN(e[1]) || e[1] < e[0] ? wu() : {
        type: "interval",
        bounds: e,
        tight: t
    };
    function Ei(e) {
        return e.type === "empty"
    }
    function os(e) {
        return Ei(e) || e.tight
    }
    var Nm = (e, t) => {
        if (t === 0)
            return e > 0 ? Fa() : wu();
        let n = -e / t
          , r = t < 0 ? [-1 / 0, n] : [n, 1 / 0];
        return is(r)
    }
      , mr = (e, t) => {
        if (Ei(e) || Ei(t))
            return wu();
        let n = [Math.max(e.bounds[0], t.bounds[0]), Math.min(e.bounds[1], t.bounds[1])]
          , r = os(e) && os(t);
        return Wh(n, r)
    }
      , Yf = (e, t) => {
        if (Ei(e))
            return t;
        if (Ei(t))
            return e;
        let n = [Math.min(e.bounds[0], t.bounds[0]), Math.max(e.bounds[1], t.bounds[1])], r;
        return !os(e) && !os(t) ? r = !1 : os(e) && !os(t) ? r = e.bounds[0] <= t.bounds[0] && e.bounds[1] >= t.bounds[1] : !os(e) && os(t) ? r = t.bounds[0] <= e.bounds[0] && t.bounds[1] >= e.bounds[1] : r = e.bounds[0] <= t.bounds[1] && t.bounds[0] <= e.bounds[1],
        Wh(n, r)
    }
      , dA = (e, t, n) => {
        if (Ei(e))
            return n;
        let r = mr(e, t);
        return os(e) ? (e.bounds[0] > -1 / 0 && (r = Yf(r, mr(is([-1 / 0, e.bounds[0]]), n))),
        e.bounds[1] < 1 / 0 && (r = Yf(r, mr(is([e.bounds[1], 1 / 0]), n)))) : r = Yf(r, mr(n, Vr())),
        r
    }
    ;
    function Ci(e, t, n) {
        return {
            input: e,
            start: t,
            end: n
        }
    }
    function Va(e, t) {
        return Ci(e, t, t)
    }
    function vi(e, t) {
        if (e.input !== t.input)
            throw new Error("Programming Error: cannot form a span on different inputs");
        return Ci(e.input, e.start, t.end)
    }
    function Ir(e) {
        return e.input.slice(e.start, e.end)
    }
    var ct = class {
        constructor() {
            this.tableFrameID = void 0;
            this._dependencies = [],
            this._optionalDependencies = [],
            this._updateSymbols = [],
            this._scope = {
                definitions: [],
                dependencies: [],
                substitutionDependencies: [],
                scopes: []
            },
            this._exports = [],
            this.metaData = {
                extraDepNodes: []
            },
            this.userData = {}
        }
        setInputSpan(t) {
            this._inputSpan = t
        }
        getInputString() {
            return this._inputSpan === void 0 ? "" : Ir(this._inputSpan)
        }
        getInputSpan() {
            return this._inputSpan
        }
        shouldExportAns() {
            return !1
        }
        getAnsVariable() {
            return this.shouldExportAns() && this.userData && this.userData.hasOwnProperty("index") ? ["ans_" + this.userData.index] : []
        }
        addDependency(t) {
            this._dependencies.indexOf(t) === -1 && this._dependencies.push(t),
            this._scope.dependencies.indexOf(t) === -1 && this._scope.dependencies.push(t)
        }
        addDependencies(t) {
            for (let n = 0; n < t.length; n++)
                this.addDependency(t[n])
        }
        addOptionalDependencies(t) {
            for (let n = 0; n < t.length; n++) {
                let r = t[n];
                this._dependencies.indexOf(r) === -1 && this._dependencies.push(r),
                this._optionalDependencies.indexOf(r) === -1 && this._optionalDependencies.push(r)
            }
        }
        addUpdateSymbol(t) {
            this._dependencies.indexOf(t) === -1 && this._dependencies.push(t),
            this._updateSymbols.indexOf(t) === -1 && this._updateSymbols.push(t)
        }
        addSubstitutionDependencies(t) {
            for (let n = 0; n < t.length; n++) {
                let r = t[n];
                if (this._dependencies.indexOf(r) === -1)
                    throw new Error("Programming error: substitution dependency " + r + " must also be registered as a regular dependency");
                this._scope.substitutionDependencies.indexOf(r) === -1 && this._scope.substitutionDependencies.push(r)
            }
        }
        mergeDependencies(...t) {
            for (let n = 0; n < t.length; n++) {
                let r = t[n];
                for (let o = 0; o < r._dependencies.length; o++)
                    this._dependencies.indexOf(r._dependencies[o]) === -1 && this._dependencies.push(r._dependencies[o]);
                for (let o = 0; o < r._updateSymbols.length; o++)
                    this._updateSymbols.indexOf(r._updateSymbols[o]) === -1 && this._updateSymbols.push(r._updateSymbols[o]);
                for (let o = 0; o < r._scope.dependencies.length; o++)
                    this._scope.dependencies.indexOf(r._scope.dependencies[o]) === -1 && this._scope.dependencies.push(r._scope.dependencies[o]);
                for (let o = 0; o < r._scope.substitutionDependencies.length; o++)
                    this._scope.substitutionDependencies.indexOf(r._scope.substitutionDependencies[o]) === -1 && this._scope.substitutionDependencies.push(r._scope.substitutionDependencies[o]);
                this.addOptionalDependencies(r.getOptionalDependencies()),
                Array.prototype.push.apply(this._scope.scopes, r._scope.scopes)
            }
        }
        mergeDependenciesInScope(t, n, r, o) {
            let i = r.getScope()
              , s = {
                kind: t,
                definitions: n,
                dependencies: i.dependencies,
                substitutionDependencies: i.substitutionDependencies,
                scopes: i.scopes,
                functionDefinitionSymbol: o == null ? void 0 : o.functionDefinitionSymbol
            };
            this._scope.scopes.push(s);
            for (let a = 0; a < r._dependencies.length; a++) {
                let u = r._dependencies[a];
                !n.includes(u) && !this._dependencies.includes(u) && this._dependencies.push(u)
            }
            for (let a = 0; a < r._updateSymbols.length; a++)
                this._updateSymbols.indexOf(r._updateSymbols[a]) === -1 && this._updateSymbols.push(r._updateSymbols[a]);
            this.addOptionalDependencies(r.getOptionalDependencies())
        }
        getDependencies() {
            return this._dependencies
        }
        graphmodeDependencies(t, n) {
            return this.getDependencies()
        }
        getOptionalDependencies() {
            return this._optionalDependencies
        }
        getUpdateSymbols() {
            return this._updateSymbols
        }
        getScope() {
            return this._scope
        }
        dependsOn(t) {
            return this._dependencies.indexOf(t) > -1
        }
        getExports(t) {
            let n = this._exports || [];
            if (this.userData && "id"in this.userData) {
                let r = this.userData.id;
                n = n.concat(["idref_" + r])
            }
            return t.ansEnabled() && (n = n.concat(this.getAnsVariable())),
            n
        }
        getLegalExports(t) {
            return this.getExports(t).filter(n => !t.assignmentForbidden(n))
        }
        exportsSymbol(t) {
            return this._exports.indexOf(t) > -1
        }
        exportTo(t, n, r) {
            let o = []
              , i = this.getLegalExports(t);
            for (let s = 0; s < i.length; s++) {
                let a = i[s];
                if (r.hasOwnProperty(a))
                    return o;
                r[a] = n.type === "Error" && n.blocksExport ? n : this,
                o.push(a)
            }
            return o
        }
        getOperator() {
            return this.operator || "="
        }
        isInequality() {
            return !1
        }
        isShadeBetween() {
            return !1
        }
        shouldPromoteToSlider(t) {
            return !1
        }
        getSliderVariables(t, n, r) {
            let o = t.sliderVariables(r != null ? r : n.getDependencies());
            return n.valueType === R || n.valueType === zt || n.valueType === G || n.valueType === to || n.valueType === N || n.valueType === ke ? t.is3dPolicy() ? o.includes("t") && !o.includes("u") && !o.includes("v") ? o.filter(i => i != "t") : !o.includes("t") && (o.includes("u") || o.includes("v")) ? o.filter(i => i != "u" && i != "v") : o : o.filter(i => !t.validParametricVariable(i)) : o
        }
        asValue() {}
        boundDomain(t) {
            return Vr()
        }
        getCursorContext() {}
        asCompilerValue() {}
        substitute(t) {}
        getExpressionType(t, n) {}
        tableInfo(t, n) {}
        getGraphMode(t, n) {}
        getMoveStrategy(t, n, r, o) {}
    }
    ;
    var v = class extends ct {
        constructor(n) {
            super();
            this.type = "Error";
            this.isError = !0;
            this.isList = !1;
            this.blocksExport = !1;
            this._msg = n,
            this.blocksExport = !0
        }
        evaluateOnce(n) {
            return this._msg
        }
        getError() {
            return this._msg
        }
        setDependencies(n) {
            return this.addDependencies(n),
            this
        }
        setActionValue(n) {
            this.actionValue = n
        }
        allowExport() {
            return this.blocksExport = !1,
            this
        }
        setCursorContext(n) {
            this.cursorContext = n
        }
        getCursorContext() {
            return this.cursorContext
        }
    }
      , Om = class extends v {
    }
    ;
    var Zf = {
        real: !0,
        imag: !0,
        conj: !0,
        arg: !0
    }
      , yA = Object.keys(Zf);
    var dp = class {
        constructor(t) {
            this.singleExpression = t.singleExpression
        }
        isGeometryEnabled() {
            return !1
        }
        is3dProduct() {
            return !1
        }
        is3dPolicy() {
            return !1
        }
        isComplexEnabled() {
            return !1
        }
        isRecursionEnabled() {
            return !1
        }
        polygonUnsupportedPreferTriangle() {
            return !1
        }
        areAllScalesLinear() {
            return !0
        }
        assignmentForbidden(t) {
            return t.slice(0, 3) !== "ans"
        }
        isValidSlider(t) {
            return !1
        }
        sliderVariables() {
            return []
        }
        graphingEnabled() {
            return !1
        }
        ansEnabled() {
            return !this.singleExpression
        }
        dimensionVarsEnabled() {
            return !1
        }
        disabledFeatures() {
            return ["Sum", "Product", "Integral", "List", "Derivative", "Piecewise", "Restriction", "Norm", "Exponent", "PercentOf", "Substitution"]
        }
        shouldIncludeFunctionParametersInRandomSeed() {
            return !0
        }
    }
    ;
    var Jh = !1;
    function RS(e) {
        Jh = e
    }
    function r$() {
        return Jh
    }
    function o$(...e) {
        Jh && console.error(...e)
    }
    function F(e) {
        if (Jh) {
            let t = e instanceof Error ? e : new Error(`${e}`);
            return o$(t.stack),
            new v(I("shared-calculator-error-internal-error", {
                msg: t.message
            }))
        }
        return new v(I("shared-calculator-error-parse-error"))
    }
    function NS() {
        return new v(I("graphing-calculator-error-inference-invalid-cdf-p-value"))
    }
    function OS() {
        return new v(I("shared-calculator-error-inference-nonlinear-regression"))
    }
    function Qh(e) {
        let t = e.length
          , n = e[0];
        return new v(I("shared-calculator-error-recursion-missing-base-case", {
            count: $f(t),
            lastSymbol: $(n),
            symbols: e.slice(1).map(r => $(r)).join("', '")
        }))
    }
    function AS(e, t) {
        let n = Qh(e);
        return n.recursionMetadata = t,
        n
    }
    function wS(e) {
        return new v(I("shared-calculator-error-recursion-base-case-free-variable", {
            freeVariable: $(e)
        }))
    }
    function LS(e) {
        return new v(I("shared-calculator-error-recursion-base-case-free-variable", {
            freeVariable: $(e)
        }))
    }
    function Xf({blockExport: e}) {
        let t = new v(I("shared-calculator-error-recursion-base-case-same-type"));
        return e || t.allowExport(),
        t
    }
    function Wf() {
        return new v(I("shared-calculator-error-recursion-base-case-too-complicated"))
    }
    function Kh() {
        return new v(I("shared-calculator-error-recursion-base-case-argument-non-number"))
    }
    function FS() {
        return new v(I("shared-calculator-error-recursion-does-not-terminate"))
    }
    function $P() {
        return new v(I("shared-calculator-error-recursion-does-not-terminate"))
    }
    function YP() {
        return new v(I("shared-calculator-error-recursion-depth-limit-exceeded"))
    }
    function VS(e, t) {
        return new v(I("shared-calculator-error-recursion-wrong-arity", {
            fnSymbol: $(e),
            count: $f(t)
        }))
    }
    function BS(e, t, n, {blockExport: r}) {
        let o = new v(I("shared-calculator-error-recursion-argument-type", {
            index: e + 1,
            expectedType: t,
            foundType: n
        }));
        return r || o.allowExport(),
        o
    }
    function jf() {
        return new v(I("shared-calculator-error-parse-error"))
    }
    function eb(e) {
        return e = $(e),
        new v(I("shared-calculator-error-unrecognized-symbol", {
            symbol: e
        }))
    }
    function tb() {
        return new v(I("shared-calculator-error-unexpected-inequality"))
    }
    function GS() {
        return new v(I("shared-calculator-error-unexpected-equality"))
    }
    function Mi(e) {
        return e = $(e),
        new v(I("shared-calculator-error-unexpected-symbol", {
            symbol: e
        }))
    }
    function qS(e, {blockExport: t}) {
        let n = new v(I("shared-calculator-error-add-type-error", {
            symbol1: e[0],
            symbol2: e[1]
        }));
        return t || n.allowExport(),
        n
    }
    function zS(e, {blockExport: t}) {
        let n = new v(I("shared-calculator-error-subtract-type-error", {
            symbol1: e[0],
            symbol2: e[1]
        }));
        return t || n.allowExport(),
        n
    }
    function Jf(e, {blockExport: t}) {
        let n = new v(I("shared-calculator-error-multiply-type-error", {
            symbol1: e[0],
            symbol2: e[1]
        }));
        return t || n.allowExport(),
        n
    }
    function HS(e, {blockExport: t}) {
        let n = new v(I("shared-calculator-error-multiply-type-error-cross", {
            symbol1: e[0],
            symbol2: e[1]
        }));
        return t || n.allowExport(),
        n
    }
    function US(e, {blockExport: t}) {
        let n = new v(I("shared-calculator-error-multiply-type-error-2d", {
            symbol1: e[0],
            symbol2: e[1]
        }));
        return t || n.allowExport(),
        n
    }
    function kS(e, {blockExport: t}) {
        let n = new v(I("shared-calculator-error-multiply-type-error-3d", {
            symbol1: e[0],
            symbol2: e[1]
        }));
        return t || n.allowExport(),
        n
    }
    function $S(e, {blockExport: t}) {
        let n = new v(I("shared-calculator-error-divide-type-error", {
            symbol1: e[0],
            symbol2: e[1]
        }));
        return t || n.allowExport(),
        n
    }
    function YS(e, {blockExport: t}) {
        let n = new v(I("shared-calculator-error-exponent-type-error", {
            symbol1: e[0],
            symbol2: e[1]
        }));
        return t || n.allowExport(),
        n
    }
    function ZS(e, {blockExport: t}) {
        let n = new v(I("shared-calculator-error-negative-type-error", {
            symbol: e[0]
        }));
        return t || n.allowExport(),
        n
    }
    function XS() {
        return new v(I("shared-calculator-error-mixed-comparator-chain"))
    }
    function WS() {
        return new v(I("shared-calculator-error-unplottable-long-inequality-chain"))
    }
    function jS(e, {blockExport: t}) {
        let n = new v(I("shared-calculator-error-comparator-type-error", {
            symbol1: e[0],
            symbol2: e[1]
        }));
        return t || n.allowExport(),
        n
    }
    function JS(e, {blockExport: t}) {
        let n = new v(I("shared-calculator-error-operator-type-error", {
            symbol: "and",
            symbol1: e[0],
            symbol2: e[1]
        }));
        return t || n.allowExport(),
        n
    }
    function QS(e, {blockExport: t}) {
        let n = new v(I("shared-calculator-error-operator-type-error", {
            symbol: "or",
            symbol1: e[0],
            symbol2: e[1]
        }));
        return t || n.allowExport(),
        n
    }
    function gp(e, {blockExport: t}) {
        let n = new v(I("shared-calculator-error-list-type-error", {
            symbol1: e[0]
        }));
        return t || n.allowExport(),
        n
    }
    function KS(e, {blockExport: t}) {
        let n = new v(I("shared-calculator-error-point-type-error", {
            symbol1: e,
            symbol2: se(R)
        }));
        return t || n.allowExport(),
        n
    }
    function Qf(e, {blockExport: t}) {
        let n = new v(I("shared-calculator-error-index-type-error", {
            symbol1: e[0],
            symbol2: e[1]
        }));
        return t || n.allowExport(),
        n
    }
    function eE(e, t, {blockExport: n}) {
        let r = t === ".p" ? new v(I("shared-calculator-error-unexpected-symbol", {
            symbol: "."
        })) : new v(I("shared-calculator-error-coordinate-access-type-error", {
            coordinate: t,
            symbol: e[0]
        }));
        return n || r.allowExport(),
        r
    }
    function $i(e, t, {blockExport: n}) {
        let r;
        switch (t.length) {
        case 1:
            r = new v(I("shared-calculator-error-function-type-error-1", {
                fn: $(e),
                arg: t[0]
            }));
            break;
        case 2:
            r = new v(I("shared-calculator-error-function-type-error-2", {
                fn: $(e),
                arg1: t[0],
                arg2: t[1]
            }));
            break;
        default:
            r = new v(I("shared-calculator-error-function-type-error-many", {
                fn: $(e)
            }));
            break
        }
        return n || r.allowExport(),
        r
    }
    var _S = {
        translate: "translation",
        rotate: "rotation",
        dilate: "dilation",
        reflect: "reflection"
    };
    function tE(e, t, n, {blockExport: r}) {
        let o = [];
        if (n.maxArity === void 0)
            return $i(e, t, {
                blockExport: r
            });
        for (let a = 1; a < n.argTypes.length; a++) {
            let u = n.argTypes[a];
            typeof u == "number" ? o.push(se(u)) : o.push(se(u.getTypes()[0]))
        }
        let i = "";
        switch (o.length) {
        case 1:
            i = I(t.length > o.length ? "shared-calculator-error-transformation-definition-expected-types-use-fewer-1" : "shared-calculator-error-transformation-definition-expected-types-1", {
                arg: o[0]
            });
            break;
        case 2:
            i = I(t.length > o.length ? "shared-calculator-error-transformation-definition-expected-types-use-fewer-2" : "shared-calculator-error-transformation-definition-expected-types-2", {
                arg1: o[0],
                arg2: o[1]
            });
            break
        }
        let s;
        switch (t.length) {
        case 1:
            s = new v(I(t.length < o.length ? "shared-calculator-error-transformation-definition-type-error-use-more-1" : "shared-calculator-error-transformation-definition-type-error-1", {
                fn: $(_S[e]),
                arg: t[0],
                expectedTypeMessage: i
            }));
            break;
        case 2:
            s = new v(I(t.length < o.length ? "shared-calculator-error-transformation-definition-type-error-use-more-2" : "shared-calculator-error-transformation-definition-type-error-2", {
                fn: $(_S[e]),
                arg1: t[0],
                arg2: t[1],
                expectedTypeMessage: i
            }));
            break;
        default:
            s = new v(I("shared-calculator-error-transformation-definition-type-error-many", {
                fn: $(_S[e])
            }));
            break
        }
        return r || s.allowExport(),
        s
    }
    function nE(e, t, {blockExport: n}) {
        let r;
        switch (t.length) {
        case 1:
            r = new v(I("shared-calculator-error-transformation-type-error-1", {
                fn: $(e),
                arg: t[0]
            }));
            break;
        case 2:
            r = new v(I("shared-calculator-error-transformation-type-error-2", {
                fn: $(e),
                arg1: t[0],
                arg2: t[1]
            }));
            break;
        default:
            r = new v(I("shared-calculator-error-transformation-type-error-many", {
                fn: $(e)
            }));
            break
        }
        return n || r.allowExport(),
        r
    }
    function rE(e, t, {blockExport: n}) {
        let r = $(e)
          , o = $("count")
          , i = new v(I("shared-calculator-error-geometry-length-type-error", {
            fn: r,
            alternativeFn: o,
            arg: t
        }));
        return n || i.allowExport(),
        i
    }
    function oE(e, t, {blockExport: n}) {
        let r = $(e)
          , o = $("count")
          , i = new v(I("shared-calculator-error-3d-length-type-error", {
            fn: r,
            alternativeFn: o,
            arg: t
        }));
        return n || i.allowExport(),
        i
    }
    function Kf(e) {
        return new v(I("shared-calculator-error-illegal-dot-call", {
            symbol: $(e)
        }))
    }
    function iE(e, t, {blockExport: n}) {
        let r = new v(I("shared-calculator-error-dot-lhs-type-error", {
            symbol: $(e),
            type: t
        }));
        return n || r.allowExport(),
        r
    }
    function nb() {
        return new v(I("shared-calculator-error-dot-lhs-constant-number"))
    }
    function sE(e) {
        return new v(I("shared-calculator-error-dot-rhs-property-error", {
            symbol: $(e)
        }))
    }
    function aE(e, {blockExport: t}) {
        let n = new v(I("shared-calculator-error-sum-lower-bound-type-error", {
            symbol: e[0]
        }));
        return t || n.allowExport(),
        n
    }
    function uE(e, {blockExport: t}) {
        let n = new v(I("shared-calculator-error-sum-upper-bound-type-error", {
            symbol: e[0]
        }));
        return t || n.allowExport(),
        n
    }
    function rb() {
        return new v(I("shared-calculator-error-sum-infinite-bound-type-error"))
    }
    function cE(e, {blockExport: t}) {
        let n = new v(I("shared-calculator-error-sum-argument-type-error", {
            symbol: e[0]
        }));
        return t || n.allowExport(),
        n
    }
    function lE(e, {blockExport: t}) {
        let n = new v(I("shared-calculator-error-product-lower-bound-type-error", {
            symbol: e[0]
        }));
        return t || n.allowExport(),
        n
    }
    function pE(e, {blockExport: t}) {
        let n = new v(I("shared-calculator-error-product-upper-bound-type-error", {
            symbol: e[0]
        }));
        return t || n.allowExport(),
        n
    }
    function ob() {
        return new v(I("shared-calculator-error-product-infinite-bound-type-error"))
    }
    function mE(e, {blockExport: t}) {
        let n = new v(I("shared-calculator-error-product-argument-type-error", {
            symbol: e[0]
        }));
        return t || n.allowExport(),
        n
    }
    function dE(e, {blockExport: t}) {
        let n = new v(I("shared-calculator-error-integral-lower-bound-type-error", {
            symbol: e[0]
        }));
        return t || n.allowExport(),
        n
    }
    function fE(e, {blockExport: t}) {
        let n = new v(I("shared-calculator-error-integral-upper-bound-type-error", {
            symbol: e[0]
        }));
        return t || n.allowExport(),
        n
    }
    function yE(e, {blockExport: t}) {
        let n = new v(I("shared-calculator-error-integral-argument-type-error", {
            symbol: e[0]
        }));
        return t || n.allowExport(),
        n
    }
    function gE(e, {blockExport: t}) {
        let n = new v(I("shared-calculator-error-derivative-type-error", {
            symbol: e[0]
        }));
        return t || n.allowExport(),
        n
    }
    function hE(e, {blockExport: t}) {
        let n = new v(I("shared-calculator-error-derivative-type-error-respect", {
            symbol1: e[0],
            symbol2: e[1]
        }));
        return t || n.allowExport(),
        n
    }
    function bE(e, t, {blockExport: n}) {
        let r = new v(I("shared-calculator-error-derivative-variable-type-error", {
            symbol1: $(e),
            symbol2: t[0]
        }));
        return n || r.allowExport(),
        r
    }
    function xE(e) {
        return new v(I("shared-calculator-error-derivative-recursive-cycle", {
            symbol1: $(e)
        }))
    }
    function TE(e, t, {blockExport: n}) {
        let r = new v(I("shared-calculator-error-prime-variable-type-error", {
            symbol1: $(e),
            symbol2: t[0]
        }));
        return n || r.allowExport(),
        r
    }
    function ib(e, {blockExport: t}) {
        let n = new v(I("shared-calculator-error-piecewise-condition-type-error", {
            symbol1: se(Fe),
            symbol2: e[0]
        }));
        return t || n.allowExport(),
        n
    }
    function IE(e, {blockExport: t}) {
        let n = new v(I("shared-calculator-error-piecewise-branch-type-error", {
            symbol1: e[0],
            symbol2: e[1]
        }));
        return t || n.allowExport(),
        n
    }
    function PE(e) {
        return new v(I("shared-calculator-error-table-header-type-error", {
            symbol: e[0]
        }))
    }
    function SE(e) {
        return new v(I("shared-calculator-error-table-entry-type-error", {
            symbol: e[0]
        }))
    }
    function EE() {
        return new v(I("shared-calculator-error-regression-recursion"))
    }
    function CE(e) {
        return new v(I("shared-calculator-error-table-regression-type-error", {
            symbol: e
        }))
    }
    function vE() {
        return new v(I("shared-calculator-error-table-regression-invalid-data"))
    }
    function i$() {
        return new v(I("shared-calculator-error-table-regression-log-with-negative"))
    }
    function ME(e) {
        return new v(I("shared-calculator-error-regression-type-error", {
            symbol1: e[0],
            symbol2: e[1]
        }))
    }
    function DE(e) {
        return new v(I("shared-calculator-error-update-rule-type-error", {
            symbol: e
        }))
    }
    function _E() {
        return new v(I("shared-calculator-error-update-rule-non-identifier-lhs", {
            arrow: "\u2192",
            example: "a"
        }))
    }
    function RE(e) {
        return new v(I("shared-calculator-error-duplicate-update-rules", {
            symbol: $(e)
        }))
    }
    function NE(e) {
        return new v(I("shared-calculator-error-update-rule-undefined-lhs", {
            symbol: $(e)
        }))
    }
    function OE(e) {
        return new v(I("shared-calculator-error-update-rule-illegal-lhs", {
            symbol: $(e)
        }))
    }
    function AE(e) {
        return new v(I("shared-calculator-error-update-rule-function-lhs", {
            symbol: $(e)
        }))
    }
    function sb(e) {
        return new v(I("shared-calculator-error-update-rule-local-lhs", {
            symbol: $(e)
        }))
    }
    function wE(e) {
        let t = e.filter(n => n.scope === "free").map(n => n.symbol);
        return new v(I("shared-calculator-error-action-merge-free-variable", {
            symbol: $(t[0] || "")
        })).setDependencies(t).allowExport()
    }
    function ey(e) {
        return new v(I("shared-calculator-error-event-handler-type-error", {
            example: "a\u2192a+1"
        }))
    }
    function s$(e) {
        return new v(I("shared-calculator-error-viewport-bound-type-error", {
            type: se(e)
        }))
    }
    function ty({blockExport: e}) {
        let t = new v(I("shared-calculator-error-heterogeneous-list"));
        return e || t.allowExport(),
        t
    }
    function ab(e, {blockExport: t}) {
        let n = new v(I("shared-calculator-error-combine-type-error", {
            symbol1: e[0],
            symbol2: e[1]
        }));
        return t || n.allowExport(),
        n
    }
    function Am(e) {
        return new v(I("shared-calculator-error-log-scale-type-error", {
            symbol: e
        })).allowExport()
    }
    function LE() {
        return new v(I("shared-calculator-error-log-scale-histogram"))
    }
    function FE() {
        return new v(I("shared-calculator-error-log-scale-dot-plot"))
    }
    function VE() {
        return new v(I("shared-calculator-error-log-scale-box-plot"))
    }
    function BE() {
        return new v(I("shared-calculator-error-deeply-nested")).allowExport()
    }
    function GE() {
        return new v(I("shared-calculator-error-3d-multiple-equality-restrictions")).allowExport()
    }
    function qE() {
        return new v(I("shared-calculator-error-3d-mixed-restriction-equation")).allowExport()
    }
    function Lu() {
        return new v(I("shared-calculator-error-3d-bad-equality-slice")).allowExport()
    }
    function Qc(e) {
        return new v(I("shared-calculator-error-gpu-variable-list-length", {
            symbol: $(e.filter(t => t.symbol !== "globalRandomSeed")[0].symbol)
        }))
    }
    function ub(e) {
        return new v(I("shared-calculator-error-gpu-variable-sum", {
            symbol: $(e[0].symbol)
        }))
    }
    function cb(e) {
        return new v(I("shared-calculator-error-gpu-variable-product", {
            symbol: $(e[0].symbol)
        }))
    }
    function wm(e) {
        return new v(I("shared-calculator-error-gpu-function-unsupported", {
            symbol: $(e)
        }))
    }
    function zE() {
        return new v(I("shared-calculator-error-gpu-integral-unsupported"))
    }
    function HE() {
        return new v(I("shared-calculator-error-gpu-recursion-unsupported"))
    }
    function UE() {
        return new v(I("shared-calculator-error-gpu-long-sum", {
            maxTermCount: 1e3.toLocaleString()
        }))
    }
    function kE() {
        return new v(I("shared-calculator-error-gpu-long-product", {
            maxTermCount: 1e3.toLocaleString()
        }))
    }
    function hp() {
        return new v(I("shared-calculator-error-gpu-max-list-size", {
            maxListSize: 100.toLocaleString()
        }))
    }
    function ny() {
        return new v(I("shared-calculator-error-max-list-size", {
            maxListSize: 1e4.toLocaleString()
        })).allowExport()
    }
    function ry() {
        return new v(I("shared-calculator-error-two-numbers-error"))
    }
    function $E() {
        return new v(I("shared-calculator-error-boxplot-offset-invalid"))
    }
    function YE() {
        return new v(I("shared-calculator-error-boxplot-breadth-invalid"))
    }
    function ZE(e, t) {
        return new v(I("shared-calculator-error-too-many-arguments", {
            symbol: e,
            max: t
        }))
    }
    function XE() {
        let e = I("shared-calculator-error-pdf-wrong-arity-recommendation")
          , t = I("shared-calculator-error-pdf-wrong-arity", {
            recommendation: e
        });
        return new v(t)
    }
    function WE() {
        let e = I("shared-calculator-error-cdf-wrong-arity-recommendation")
          , t = I("shared-calculator-error-cdf-wrong-arity", {
            recommendation: e
        });
        return new v(t)
    }
    function jE() {
        let e = I("shared-calculator-error-cdf-too-many-arguments-recommendation")
          , t = I("shared-calculator-error-cdf-too-many-arguments", {
            recommendation: e
        });
        return new v(t)
    }
    function a$() {
        return new v(I("shared-calculator-error-tdist-wrong-arity"))
    }
    function JE() {
        return new v(I("shared-calculator-error-random-arity"))
    }
    function QE() {
        return new v(I("shared-calculator-error-random-from-broadcast-distribution"))
    }
    function KE(e) {
        let t = e === "rgb" ? [150, 30, 100] : [180, .5, .5]
          , n = I("shared-calculator-error-color-arity-recommendation", {
            recommendation: $(e) + "(" + t.join(", ") + ")"
        })
          , r = I("shared-calculator-error-color-arity", {
            symbol: e,
            recommendation: n
        });
        return new v(r)
    }
    function Ba(e, t, n, r) {
        e = $(e);
        let o, i;
        if (t === 1)
            i = r.includeUsageExample ? I("shared-calculator-error-wrong-arity-supplement", {
                recommendation: r.usageExample || e + "(x)"
            }) : "",
            n > 1 ? o = I("shared-calculator-error-wrong-arity-single-arg-too-many", {
                dependency: e,
                supplement: i
            }) : o = I("shared-calculator-error-wrong-arity-single-arg-too-few", {
                dependency: e,
                supplement: i
            });
        else {
            let s = []
              , a = r.usageExample;
            if (!a) {
                for (let u = 0; u < t; u++)
                    s[u] = u + 1;
                a = $(e) + "(" + s.join(", ") + ")"
            }
            i = r.includeUsageExample ? I("shared-calculator-error-wrong-arity-supplement", {
                recommendation: a
            }) : "",
            o = I("shared-calculator-error-wrong-arity-many-arg", {
                dependency: e,
                assignment_arity: t,
                supplement: i
            })
        }
        return new v(o)
    }
    function eC() {
        let e = I("shared-calculator-error-wrong-arity-supplement", {
            recommendation: "length(x)"
        })
          , t = I("shared-calculator-error-wrong-arity-single-arg-too-few", {
            dependency: "length",
            supplement: e
        });
        return new v(t)
    }
    function tC(e) {
        return new v(I("shared-calculator-error-wrong-two-arg-arity", {
            symbol: $(e),
            recommendation: $(e) + "([1,2,3], 1)"
        }))
    }
    function nC(e) {
        return new v(I("shared-calculator-error-wrong-two-arg-arity", {
            symbol: $(e),
            recommendation: $(e) + "([1,2,3], [3,2,1])"
        }))
    }
    function bp() {
        return new v(I("shared-calculator-error-primed-function-arity"))
    }
    function rC(e) {
        return new v(I("shared-calculator-error-zero-arg-reducer", {
            symbol: $(e)
        }))
    }
    function oC() {
        return new v(I("shared-calculator-error-malformed-point"))
    }
    function iC() {
        return new v(I("shared-calculator-error-malformed-list"))
    }
    function sC(e) {
        return new v(I("shared-calculator-error-bad-tuple-dimensions", {
            symbol: e
        }))
    }
    function Kc(e) {
        return new v(I("shared-calculator-error-3d-object-in-2d", {
            type: se(e)
        }))
    }
    function lb(e) {
        return e = $(e),
        new v(I("shared-calculator-error-bad-implicit-call", {
            symbol: e
        }))
    }
    function aC(e, t) {
        return new v(I("shared-calculator-error-adjacent-numbers", {
            left: e,
            right: t
        }))
    }
    function pb(e) {
        return new v(I("shared-calculator-error-adjacent-mixed-number", {
            mixedNumber: e
        }))
    }
    function uC() {
        return new v(I("shared-calculator-error-token-with-subscript"))
    }
    function mb(e) {
        return e = $(e),
        new v(I("shared-calculator-error-identifier-as-function", {
            symbol: e
        }))
    }
    function db(e) {
        return e = $(e),
        new v(I("shared-calculator-error-identifier-is-not-function", {
            symbol: e
        }))
    }
    function Lm(e) {
        return e = $(e),
        e === "%" && (e = "% of"),
        new v(I("shared-calculator-error-binary-operator-missing-operand", {
            symbol: e
        }))
    }
    function cC(e) {
        return e = $(e),
        new v(I("shared-calculator-error-unary-operator-missing-left", {
            symbol: e
        }))
    }
    function lC(e) {
        return e = $(e),
        new v(I("shared-calculator-error-unary-operator-missing-right", {
            symbol: e
        }))
    }
    function pC() {
        return new v(I("shared-calculator-error-fraction-missing-numerator"))
    }
    function mC() {
        return new v(I("shared-calculator-error-fraction-missing-denominator"))
    }
    function dC() {
        return new v(I("shared-calculator-error-fraction-empty"))
    }
    function fb() {
        return new v(I("shared-calculator-error-empty-subscript"))
    }
    function fC() {
        return new v(I("shared-calculator-error-empty-superscript"))
    }
    function yC(e) {
        return e = $(e),
        new v(I("shared-calculator-error-invalid-subscript", {
            symbol: e
        }))
    }
    function gC() {
        return new v(I("shared-calculator-error-invalid-operator-name"))
    }
    function hC() {
        return new v(I("shared-calculator-error-unexpected-subscript"))
    }
    function bC() {
        return new v(I("shared-calculator-error-superscript-with-prime"))
    }
    function yb() {
        return new v(I("shared-calculator-error-unexpected-prime"))
    }
    function gb() {
        return new v(I("shared-calculator-error-prime-without-paren"))
    }
    function xC() {
        return new v(I("shared-calculator-error-empty-radical"))
    }
    function TC() {
        return new v(I("shared-calculator-error-empty-radical-index"))
    }
    function oy() {
        return new v(I("shared-calculator-error-empty-paren"))
    }
    function IC() {
        return new v(I("shared-calculator-error-empty-square-bracket"))
    }
    function PC() {
        return new v(I("shared-calculator-error-empty-pipe"))
    }
    function SC(e) {
        let t = e + "^2"
          , n = e + "^-1";
        return new v(I("shared-calculator-error-bad-trig-exponent", {
            form1: t,
            form2: n
        }))
    }
    function EC(e) {
        let t = e + "^2";
        return new v(I("shared-calculator-error-bad-log-exponent", {
            form: t
        }))
    }
    function CC() {
        return new v(I("shared-calculator-error-piecewise-missing-condition"))
    }
    function vC() {
        return new v(I("shared-calculator-error-piecewise-part-missing-condition"))
    }
    function MC() {
        return new v(I("shared-calculator-error-colon-missing-condition"))
    }
    function iy() {
        let e = new v(I("shared-calculator-error-blank-expression"));
        return e.silent = !0,
        e
    }
    function hb(e) {
        return e = $(e),
        new v(I("shared-calculator-error-function-not-defined", {
            dependency: e
        }))
    }
    function bb(e) {
        return e = $(e),
        new v(I("shared-calculator-error-parameter-already-defined", {
            dependency: e
        }))
    }
    function DC(e) {
        return e = $(e),
        new v(I("shared-calculator-error-duplicate-function-parameter", {
            dependency: e
        }))
    }
    function _C(e) {
        return e = $(e),
        new v(I("shared-calculator-error-function-name-as-parameter", {
            dependency: e
        }))
    }
    function Fm(e, t) {
        return e = $(e),
        t === void 0 ? new v(I("shared-calculator-error-cannot-redefine", {
            symbol: e
        })) : new v(I("shared-calculator-error-cannot-redefine-root", {
            symbol: e,
            symbolRoot: t
        }))
    }
    function RC(e) {
        return e = $(e),
        new v(I("shared-calculator-error-cannot-subscript", {
            symbol: e
        }))
    }
    function sy(e) {
        return e = $(e),
        new v(I("shared-calculator-error-multiply-defined", {
            dependency: e
        }))
    }
    function xb(e) {
        return e = $(e),
        new v(I("shared-calculator-error-shadowed-index", {
            symbol: e
        }))
    }
    function NC(e) {
        e = e.map($);
        let t = e.pop() || ""
          , n = new v(I("shared-calculator-error-dependency-cycle", {
            symbols: e.join("', '"),
            lastSymbol: t
        }));
        return n.isCyclicDependencyError = !0,
        n
    }
    function xp(e, t) {
        let n = e.length
          , r = e[0];
        return t.suggestAlternativeFunctionName && n == 1 ? new v(I("shared-calculator-error-self-referential-suggest-alternative", {
            symbol: $(r)
        })) : new v(I("shared-calculator-error-self-referential-functions", {
            symbols: e.slice(1).map(o => $(o)).join("', '"),
            lastSymbol: $(r),
            count: $f(n)
        }))
    }
    function OC(e) {
        return new v(I("shared-calculator-error-self-referential-base-case", {
            symbol: $(e)
        }))
    }
    function AC() {
        return new v(I("shared-calculator-error-ticker-min-step-nonnegative"))
    }
    function wC(e) {
        return new Om(I("shared-calculator-error-slider-limit-references-export", {
            symbol: $(e)
        }))
    }
    function LC() {
        return new v(I("shared-calculator-error-slider-min-invalid"))
    }
    function FC() {
        return new v(I("shared-calculator-error-slider-max-invalid"))
    }
    function VC() {
        return new v(I("shared-calculator-error-slider-max-less-than-min"))
    }
    function BC() {
        return new v(I("shared-calculator-error-slider-step-invalid"))
    }
    function GC() {
        return new v(I("shared-calculator-error-domain-min-invalid"))
    }
    function qC() {
        return new v(I("shared-calculator-error-domain-max-invalid"))
    }
    function zC() {
        return new v(I("shared-calculator-error-domain-max-less-than-min"))
    }
    function HC() {
        return new v(I("shared-calculator-error-cdf-bound-invalid"))
    }
    function UC() {
        return new v(I("shared-calculator-error-use-rho-for-spherical-coordinates"))
    }
    function kC() {
        return new v(I("shared-calculator-error-use-r-for-cylindrical-coordinates"))
    }
    function Tb() {
        return new v(I("shared-calculator-error-cant-combine-spherical-and-cylindrical"))
    }
    function xn(e) {
        if (e = e.map($),
        e.length === 0)
            return new v(I("shared-calculator-error-too-many-variables-no-symbols"));
        let t = e.pop() || "";
        return e.length > 0 ? new v(I("shared-calculator-error-too-many-variables-many-symbols", {
            variables: e.join("', '"),
            lastVariable: t
        })) : new v(I("shared-calculator-error-too-many-variables-one-symbol", {
            variable: t
        }))
    }
    function $C(e) {
        return new v(I("shared-calculator-error-cannot-restrict", {
            variable: $(e)
        }))
    }
    function YC() {
        return new v(I("shared-calculator-error-cannot-restrict-triangles-with-list"))
    }
    function ZC(e) {
        return new v(I("shared-calculator-error-cannot-assign-color", {
            variable: $(e)
        }))
    }
    function XC(e) {
        return new v(I("shared-calculator-error-cannot-restrict-with-equality", {
            variable: $(e)
        }))
    }
    function ay(e, t, n) {
        e = e.map($),
        t = $(t),
        n = n.map($);
        let r = t + "(" + n.join(",") + "," + e.join(",") + ")"
          , o = e.pop() || ""
          , i = {
            symbols: e.join("', '"),
            lastSymbol: o,
            newSignature: r
        };
        return e.length ? new v(I("shared-calculator-error-add-arguments-to-definition-many", i)) : new v(I("shared-calculator-error-add-arguments-to-definition-one", i))
    }
    function WC(e) {
        return e = $(e),
        new v(I("shared-calculator-error-invalid-lhs", {
            symbol: e
        }))
    }
    function jC() {
        return new v(I("shared-calculator-error-unplottable-polar-function"))
    }
    function JC() {
        return new v(I("shared-calculator-error-invalid-inequality-variables"))
    }
    function Tp() {
        return new v(I("shared-calculator-error-invalid-implicit-variables"))
    }
    function QC() {
        return new v(I("shared-calculator-error-invalid-implicit-variables-3d"))
    }
    function KC() {
        return new v(I("shared-calculator-error-single-variable-implicit-equations-disabled"))
    }
    function ev() {
        return new v(I("shared-calculator-error-implicits-disabled"))
    }
    function Vm(e) {
        let t = new v(e === "=" ? I("graphing-calculator-error-nan-blame-complex-coercion") : I("shared-calculator-error-complex-operation-undefined", {
            symbol: $(e)
        }));
        return t.warning = t.getError(),
        t.silent = !0,
        t
    }
    function u$() {
        return new v(I("shared-calculator-error-complex-table-point-coordinate"))
    }
    function Ib() {
        return new v(I("shared-calculator-error-inequalities-disabled"))
    }
    function tv() {
        return new v(I("shared-calculator-error-complicated-polar-implicit"))
    }
    function nv() {
        return new v(I("shared-calculator-error-invalid-double-inequality-3d"))
    }
    function rv() {
        return new v(I("shared-calculator-error-invalid-double-equality-3d"))
    }
    function ov() {
        return new v(I("shared-calculator-error-unplottable-chained-equality"))
    }
    function Pb() {
        return new v(I("shared-calculator-error-invalid-double-inequality-variables"))
    }
    function Sb() {
        return new v(I("shared-calculator-error-mismatched-double-inequality", {
            example: "1 < y < 2"
        }))
    }
    function Eb() {
        return new v(I("shared-calculator-error-complicated-double-inequality"))
    }
    function Cb(e) {
        return e ? (e = $(e),
        new v(I("shared-calculator-error-equation-required-symbol", {
            lhs: e + "="
        }))) : new v(I("shared-calculator-error-equation-required"))
    }
    function vb(e) {
        return e = $(e),
        new v(I("shared-calculator-error-variable-as-function", {
            dependency: e
        }))
    }
    function Mb(e) {
        return e = $(e),
        new v(I("shared-calculator-error-distribution-as-function", {
            symbol: e
        }))
    }
    function iv(e) {
        return new v(I("shared-calculator-error-invalid-table-header", {
            supplement: e
        }))
    }
    function uy(e) {
        return new v(I("shared-calculator-error-invalid-table-entry", {
            supplement: e
        }))
    }
    function sv() {
        return new v(I("shared-calculator-error-invalid-first-table-column", {
            most: "'y', 'r',",
            last: "'\u03B8'"
        }))
    }
    function c$() {
        return new v(I("shared-calculator-error-invalid-dependent-first-table-column"))
    }
    function av(e) {
        return new v(I("shared-calculator-error-invalid-regression-parameter", {
            symbol: $(e)
        }))
    }
    function uv() {
        return new v(I("shared-calculator-error-optimization-error"))
    }
    function cv(e, {blockExport: t}) {
        let n = new v(I("shared-calculator-error-non-list-double-reducer", {
            symbol: $(e),
            recommendation: $(e) + "([1,2,3], [3,2,1])"
        }));
        return t || n.allowExport(),
        n
    }
    function lv(e, {blockExport: t}) {
        let n = new v(I("shared-calculator-error-non-list-parameterized-reducer", {
            symbol: $(e),
            recommendation: $(e) + "([1,2,3], 1)"
        }));
        return t || n.allowExport(),
        n
    }
    function el(e, {blockExport: t}) {
        let n = new v(I("shared-calculator-error-method-requires-list", {
            symbol: $(e),
            recommendation: $(e) + "([1,2,3])"
        }));
        return t || n.allowExport(),
        n
    }
    function cy() {
        return new v(I("shared-calculator-error-non-arithmetic-range")).allowExport()
    }
    function pv() {
        return new v(I("shared-calculator-error-invalid-half-empty-range"))
    }
    function mv() {
        return new v(I("shared-calculator-error-sum-missing-bound"))
    }
    function dv() {
        return new v(I("shared-calculator-error-product-missing-bound"))
    }
    function fv() {
        return new v(I("shared-calculator-error-incorrect-sum-lower-bound"))
    }
    function yv() {
        return new v(I("shared-calculator-error-incorrect-product-lower-bound"))
    }
    function gv(e) {
        return new v(I("shared-calculator-error-bad-sum-bound-dependency", {
            symbol: $(e)
        }))
    }
    function hv(e) {
        return new v(I("shared-calculator-error-bad-product-bound-dependency", {
            symbol: $(e)
        }))
    }
    function bv() {
        return new v(I("shared-calculator-error-integral-missing-bound"))
    }
    function xv() {
        return new v(I("shared-calculator-error-integral-missing-differential"))
    }
    function Tv() {
        return new v(I("shared-calculator-error-differential-with-superscript"))
    }
    function Iv() {
        return new v(I("shared-calculator-error-sum-missing-body"))
    }
    function Pv() {
        return new v(I("shared-calculator-error-product-missing-body"))
    }
    function Sv() {
        return new v(I("shared-calculator-error-integral-missing-body"))
    }
    function Ev() {
        return new v(I("shared-calculator-error-derivative-missing-body"))
    }
    function Cv(e, t) {
        return e = $(e),
        t = $(t),
        new v(I("shared-calculator-error-mismatched-braces", {
            symbol1: e,
            symbol2: t
        }))
    }
    function Db(e) {
        return new v(I("shared-calculator-error-shadowed-integration-variable", {
            symbol: $(e)
        }))
    }
    function vv(e) {
        return new v(I("shared-calculator-error-bad-integral-bound-dependency", {
            symbol: $(e)
        }))
    }
    function Mv() {
        return new v(I("shared-calculator-error-percent-missing-of"))
    }
    function ly(e) {
        return e = $(e),
        new v(I("shared-calculator-error-illegal-bin-width", {
            symbol: e
        }))
    }
    function _b(e) {
        return e = $(e),
        new v(I("shared-calculator-error-ttest-list-too-short", {
            symbol: e
        }))
    }
    function Dv() {
        return new v(I("shared-calculator-error-bad-sample-size"))
    }
    function _v(e) {
        return new v(I("shared-calculator-error-variable-seed", {
            symbol: $(e[0].symbol)
        })).setDependencies(e.filter(t => t.scope === "free").map(t => t.symbol)).allowExport()
    }
    function py(e) {
        return new v(I("shared-calculator-error-bad-symbol-context", {
            symbol: $(e)
        }))
    }
    function Rb() {
        return new v(I("shared-calculator-error-write-integral", {
            command: "integral",
            symbol: "\u222B"
        }))
    }
    function Rv() {
        return new v(I("shared-calculator-error-ans-undefined"))
    }
    function Nv(e) {
        return new v(I("shared-calculator-error-variables-unsupported", {
            variable: $(e)
        }))
    }
    function Nb() {
        return new v(I("shared-calculator-error-polygon-unsupported-in-3d"))
    }
    function gA(e) {
        return new v(I("shared-calculator-error-function-only-works-in-complex", {
            symbol: $(e)
        }))
    }
    function Ga(e, t) {
        return t != null && t.is3dPolicy() && e === "polygon" ? Nb() : !!t && !(t != null && t.isGeometryEnabled()) && !(t instanceof dp) && !t.isComplexEnabled() && yA.indexOf(e) !== -1 ? gA(e) : new v(I("shared-calculator-error-function-unsupported", {
            symbol: $(e)
        }))
    }
    function Ov() {
        return new v(I("shared-calculator-error-logbase-unsupported"))
    }
    function my(e) {
        return new v(I("shared-calculator-error-constant-unsupported", {
            symbol: $(e)
        }))
    }
    function Ob(e) {
        return new v(I("shared-calculator-error-variable-unsupported", {
            symbol: $(e)
        }))
    }
    function Ab(e) {
        return new v(I("shared-calculator-error-variable-invalid-function-name", {
            symbol: $(e)
        }))
    }
    function Av() {
        return new v(I("shared-calculator-error-assignments-unsupported"))
    }
    function wv() {
        return new v(I("shared-calculator-error-function-definition-unsupported"))
    }
    function dy() {
        return new v(I("shared-calculator-error-equations-unsupported"))
    }
    function Lv() {
        return new v(I("shared-calculator-error-inequalities-unsupported"))
    }
    function Fv() {
        return new v(I("shared-calculator-error-regressions-unsupported"))
    }
    function Vv() {
        return new v(I("shared-calculator-error-custom-regressions-unsupported"))
    }
    function Bv() {
        return new v(I("shared-calculator-error-points-unsupported"))
    }
    function Gv() {
        return new v(I("shared-calculator-error-feature-unavailable"))
    }
    function wb() {
        return new v(I("basic-calculator-error-fractions-unavailable"))
    }
    function qv() {
        return new v(I("basic-calculator-error-parentheses-unavailable"))
    }
    function l$() {
        return new v(I("shared-calculator-error-non-square-determinant"))
    }
    function p$() {
        return new v(I("shared-calculator-error-non-square-trace"))
    }
    function m$() {
        return new v(I("shared-calculator-error-non-square-inverse"))
    }
    function d$() {
        return new v(I("shared-calculator-error-non-singular-inverse"))
    }
    function f$(e) {
        return new v(I("shared-calculator-error-clickable-object-assignment-not-defined", {
            symbol: e
        }))
    }
    function y$(e) {
        return new v(I("shared-calculator-error-multiply-defined", {
            dependency: e
        }))
    }
    function g$() {
        return new v(I("shared-calculator-error-clickable-object-assignment-not-identifier"))
    }
    function h$() {
        return new v(I("shared-calculator-error-clickable-object-invalid-expression"))
    }
    function b$() {
        return new v(I("shared-calculator-error-matrix-assignment"))
    }
    function x$() {
        return new v(I("shared-calculator-error-matrix-add-dimensions"))
    }
    function T$() {
        return new v(I("shared-calculator-error-matrix-subtract-dimensions"))
    }
    function I$() {
        return new v(I("shared-calculator-error-matrix-multiply-dimensions"))
    }
    function P$() {
        return new v(I("shared-calculator-error-matrix-fractional-power"))
    }
    function S$() {
        return new v(I("shared-calculator-error-matrix-power-dimensions"))
    }
    function E$(e) {
        return new v(I("shared-calculator-error-matrix-element-type-error", {
            arg: e[0]
        }))
    }
    function C$(e) {
        return new v(I("shared-calculator-error-matrix-invalid-variable", {
            symbol: $(e)
        }))
    }
    function zv(e, t, n, {blockExport: r}) {
        let o = "[1...10]";
        n && !/[\\]/.test(n) && (o = `[${n}]`);
        let i = new v(I("shared-calculator-error-list-comprehension-input-type-error", {
            identifier: e,
            actual: t,
            example: o
        }));
        return r || i.allowExport(),
        i
    }
    function Hv() {
        return new v(I("shared-calculator-error-incorrect-list-comprehension-input"))
    }
    function Lb(e) {
        return e = $(e),
        new v(I("shared-calculator-error-shadowed-list-comprehension-input", {
            symbol: e
        }))
    }
    function Uv(e) {
        return e = $(e),
        new v(I("shared-calculator-error-bad-for-input-list-dependency", {
            symbol: e
        }))
    }
    function kv(e) {
        return e = $(e),
        new v(I("shared-calculator-error-bad-for-interval-dependency", {
            symbol: e
        }))
    }
    function $v(e) {
        let t = e.filter(n => n.scope === "free").map(n => n.symbol);
        return new v(I("shared-calculator-error-variable-length-top-level-list", {
            symbol: $(t[0] || "")
        })).setDependencies(t).allowExport()
    }
    function fy(e) {
        return new v(I("shared-calculator-error-variable-length-distribution-list", {
            symbol: e[0].symbol
        })).setDependencies(e.filter(t => t.scope === "free").map(t => t.symbol))
    }
    function Yv(e) {
        return new v(I("shared-calculator-error-variable-length-sum-body-depends-on-index", {
            symbol: e
        }))
    }
    function Zv(e) {
        return new v(I("shared-calculator-error-variable-length-product-body-depends-on-index", {
            symbol: e
        }))
    }
    function Xv(e) {
        return new v(I("shared-calculator-error-variable-length-integral-depends-on-integration-var", {
            symbol: e
        }))
    }
    function v$(e, t) {
        return new v(I("shared-calculator-error-substitution-type-error", {
            actual: se(e),
            expected: se(t)
        }))
    }
    function yy() {
        return new v(I("shared-calculator-error-substitution-invalid-assignments"))
    }
    function Wv(e) {
        return new v(I("shared-calculator-error-substitution-local-lhs", {
            symbol: $(e)
        }))
    }
    function gy(e) {
        return new v(I("shared-calculator-error-substitution-illegal-lhs", {
            symbol: $(e)
        }))
    }
    function hy(e) {
        return new v(I("shared-calculator-error-substitution-function-lhs", {
            symbol: $(e)
        }))
    }
    function jv(e, t, n) {
        return new v(I("shared-calculator-error-substitution-body-regression-parameter-dependency", {
            globalVariable: $(e),
            regressionParameter: $(t),
            operator: n
        }))
    }
    function M$() {
        return new v(I("shared-calculator-error-substitution-body-action"))
    }
    function Fb() {
        return new v(I("shared-calculator-error-substitution-nested"))
    }
    function tl(e) {
        return new v(I("shared-calculator-error-substitution-ambiguous-comma", {
            operation: e
        }))
    }
    function Jv(e) {
        return new v(I("shared-calculator-error-substitution-duplicate-assignment", {
            symbol: $(e)
        }))
    }
    function Qv(e, t, n) {
        return new v(I("shared-calculator-error-substitution-recursive-call-lhs", {
            operator: e,
            globalVariable: $(t),
            fnSymbol: $(n)
        }))
    }
    function Kv() {
        return new v(I("shared-calculator-error-depends-on-deleted-geo-object"))
    }
    function eM(e) {
        return new v(I("shared-calculator-error-invalid-interval-comprehension-return-type", {
            type: se(e)
        }))
    }
    function tM(e, t) {
        return new v(I("shared-calculator-error-bad-interval-comprehension-arity", {
            type: se(e),
            count: $f(t)
        }))
    }
    function Bm(e) {
        return new v(I("shared-calculator-error-invalid-interval-comprehension-invalid-bound", {
            identifier: e
        }))
    }
    function nM() {
        return new v(I("shared-calculator-error-nested-interval-comprehension"))
    }
    function Vb() {
        return new v(I("shared-calculator-error-substitution-unsupported-interval"))
    }
    function rM(e) {
        return new v(I("shared-calculator-error-table-regression-invalid-export-identifier", {
            latex: "`" + e + "`"
        }))
    }
    function oM(e) {
        return new v(e.length === 1 ? I("graphing-calculator-error-table-regression-unexportable-reserved-variable-single", {
            variable: "`" + e[0] + "`"
        }) : I("graphing-calculator-error-table-regression-unexportable-reserved-variables-many"))
    }
    function Bb(e) {
        return new v(I("shared-calculator-error-chisq-list-length-mismatch", {
            symbol: $(e)
        }))
    }
    function by(e) {
        return new v(I("shared-calculator-error-chisq-variable-list-length", {
            symbol: $(e)
        }))
    }
    function Gb(e) {
        return new v(I("shared-calculator-error-chisq-list-too-short", {
            symbol: $(e)
        }))
    }
    function xy() {
        return new v(I("shared-calculator-error-bad-export"))
    }
    function iM(e, t) {
        return `dcg_import_${e}__${t}`
    }
    function nl(e) {
        return `dcg_policy_frameID__${e}`
    }
    function hA(e) {
        let t = "dcg_policy_frameID__";
        if (e.startsWith(t))
            return e.slice(t.length)
    }
    var or = "**dcg_global_module_id**";
    function Gn(e, t) {
        return {
            frameID: e,
            symbol: t
        }
    }
    function Ty(e, t) {
        let n = [];
        for (let r of t)
            n.push({
                frameID: e,
                symbol: r
            });
        return n
    }
    function sM(e, t) {
        let n = [];
        for (let r of t)
            n.push({
                frameID: e,
                symbol: r
            });
        return n
    }
    var Ip = class e {
        constructor(t) {
            this.map = new Map;
            if (t)
                for (let[n,r] of t)
                    this.set(n, r)
        }
        getOrCreateEntry(t) {
            let n = this.map.get(t);
            if (n)
                return n;
            let r = new Map;
            return this.map.set(t, r),
            r
        }
        set(t, n) {
            this.getOrCreateEntry(t.frameID).set(t.symbol, n)
        }
        get(t) {
            var n;
            return (n = this.map.get(t.frameID)) == null ? void 0 : n.get(t.symbol)
        }
        getOrInsert(t, n) {
            let r = this.get(t);
            return r !== void 0 ? r : (this.set(t, n),
            n)
        }
        delete(t) {
            var n;
            (n = this.map.get(t.frameID)) == null || n.delete(t.symbol)
        }
        *[Symbol.iterator]() {
            for (let[t,n] of this.map)
                for (let[r,o] of n)
                    yield[Gn(t, r), o]
        }
        *keys() {
            for (let[t,n] of this.map)
                for (let r of n.keys())
                    yield Gn(t, r)
        }
        mapForFrame(t) {
            return this.map.get(t)
        }
        toJSONForTests() {
            let t = {}
              , n = JI([...this].map( ([{symbol: r, frameID: o},i]) => [o + "::" + r, i]), ([r,o]) => r);
            for (let[r,o] of n)
                t[r] = o;
            return t
        }
        static fromJSONForTests(t) {
            let n = new e;
            for (let r of ue(t))
                for (let o of ue(t[r]))
                    n.set(Gn(r, o), t[r][o]);
            return n
        }
    }
      , ho = class e {
        constructor(t) {
            this.map = new Ip;
            if (t)
                for (let n of t)
                    this.add(n)
        }
        add(t) {
            this.map.set(t, !0)
        }
        delete(t) {
            this.map.delete(t)
        }
        has(t) {
            return !!this.map.get(t)
        }
        [Symbol.iterator]() {
            return this.map.keys()
        }
        mapForFrame(t) {
            return this.map.mapForFrame(t)
        }
        toJSONForTests() {
            return JI([...this].map( ({symbol: t, frameID: n}) => n + "::" + t), t => t)
        }
        static fromJSONForTests(t) {
            let n = new e;
            for (let r of ue(t))
                for (let o of t[r])
                    n.add(Gn(r, o));
            return n
        }
    }
    ;
    function Fn(e) {
        return Object.create(e)
    }
    var bA = Symbol("DEPENDENCY_ORDER");
    function Iy(e) {
        let t = e[bA];
        if (!t)
            throw F("Missing dependency order.");
        return t
    }
    function xA(e, t) {
        e[bA] = t
    }
    var TA = Symbol("FRAME_CONTEXT");
    function IA(e) {
        let t = e[TA];
        if (!t)
            throw F("Missing frame context.");
        return t
    }
    function PA(e, t) {
        e[TA] = t
    }
    var SA = Symbol("MODULE_ID");
    function EA(e, t) {
        e[SA] = t
    }
    function CA(e) {
        let t = e[SA];
        if (!t)
            throw F("Missing module ID.");
        return t
    }
    function aM(e) {
        return X(e.valueType)
    }
    function vA(e, t) {
        if (aM(e) && e.valueType !== He)
            return {
                valueType: Qe(e.valueType),
                value: e.value[t]
            };
        throw new Error("Programming Error: expected a list type but found " + se(e.valueType))
    }
    var cM = or;
    function tK(e) {
        switch (e) {
        case void 0:
        case "IDLE":
        case "UNPUBLISHED":
        case "RESOLVED":
            return !1;
        case "ANALYZING":
        case "GRAPHING":
            return !0;
        default:
            throw new Error(`Unexpected progress status: ${e}`)
        }
    }
    function lM(e, t) {
        if (e.startsWith(t))
            return e.slice(t.length)
    }
    function uM(e, t) {
        let n = {};
        for (let r of ue(e)) {
            let o = lM(r, t);
            o && (n[o] = e[r])
        }
        return n
    }
    function D$(e, t) {
        if ("tableId"in e && e.tableId) {
            let n = {
                ...e
            };
            return n.tableId = lM(e.tableId, t),
            n
        }
        return e
    }
    function _$(e, t) {
        let n = {};
        for (let r of ue(e)) {
            let o = lM(r, t);
            if (!o)
                continue;
            let i = [];
            for (let s of e[r])
                i.push(D$(s, t));
            n[o] = i
        }
        return n
    }
    function nK(e, t) {
        return {
            evaluationStates: uM(e.evaluationStates, t),
            graphData: {
                addedGraphs: _$(e.graphData.addedGraphs, t),
                removedGraphs: uM(e.graphData.removedGraphs, t),
                intersections: uM(e.graphData.intersections, t)
            },
            dependencyOrder: e.dependencyOrder,
            renderSlowly: e.renderSlowly,
            timingData: e.timingData,
            eventUpdates: e.eventUpdates
        }
    }
    function rK(e) {
        return {
            allDefinedQualifiedNames: e.allDefinedQualifiedNames,
            multiplyDefined: new ho(e.multiplyDefined)
        }
    }
    var DA = {
        collapsed: !1,
        hidden: !1,
        secret: !1,
        inFrontOfEverything: !1,
        readonly: !1,
        title: ""
    };
    function sK(e) {
        return {
            ...DA,
            ...e
        }
    }
    function aK(e) {
        return ff(DA, e)
    }
    var pM = "**dcg_geo_folder**";
    function uK(e) {
        return {
            type: "module",
            id: e.id,
            imports: R$(e.title, e.id)
        }
    }
    function R$(e, t) {
        if (!e.includes("@"))
            return [];
        let n = [];
        for (let[r,o] of MA(e, "@import "))
            n.push({
                from: {
                    frameID: cM,
                    symbol: r
                },
                to: {
                    frameID: t,
                    symbol: o
                }
            });
        for (let[r,o] of MA(e, "@export "))
            n.push({
                from: {
                    frameID: t,
                    symbol: r
                },
                to: {
                    frameID: cM,
                    symbol: o
                }
            });
        return n
    }
    function MA(e, t) {
        let n = e.split(`
`)
          , r = [];
        for (let o of n) {
            if (!o.startsWith(t))
                continue;
            let i = o.slice(t.length);
            for (let s of i.split(",")) {
                let a = " as "
                  , u = s.indexOf(a);
                if (u !== -1) {
                    r.push([s.slice(0, u).trim(), s.slice(u + a.length).trim()]);
                    continue
                }
                let c = s.trim();
                c !== "" && r.push([c, c])
            }
        }
        return r
    }
    function cK() {
        return {
            type: "folder",
            id: pM,
            title: "geometry",
            secret: !0
        }
    }
    var mM = {
        show: !1,
        bound1: "",
        bound2: "",
        p: "",
        tails: "inner",
        compute: "p"
    }
      , dM = {
        breadth: "",
        axisOffset: "",
        alignedAxis: "x",
        showBoxplotOutliers: !0,
        binAlignment: "center",
        dotplotXMode: "exact",
        histogramMode: ""
    }
      , fM = {
        enabled: !1,
        latex: ""
    }
      , zb = {
        None: "NONE",
        Math: "MATH",
        Text: "TEXT"
    }
      , N$ = {
        type: !0,
        id: !0,
        folderId: !0,
        color: !0,
        latex: !0,
        showLabel: !0,
        showAngleLabel: !0,
        label: !0,
        hidden: !0,
        secret: !0,
        readonly: !0,
        disableGraphInteractions: !0,
        fill: !0,
        points: !0,
        lines: !0,
        extendTo3D: !0,
        lineStyle: !0,
        arrowMode: !0,
        pointStyle: !0,
        dragMode: !0,
        labelOrientation: !0,
        labelSize: !0,
        suppressTextOutline: !0,
        pointOutline: !0,
        interactiveLabel: !0,
        editableLabelMode: !0,
        residualVariable: !0,
        regressionParameters: !0,
        isLogModeRegression: !0,
        displayEvaluationAsFraction: !0,
        slider: !0,
        strictIntersection: !0,
        inference: !0
    }
      , xK = Object.keys(N$)
      , _A = 4e3
      , qb = {
        polarDomain: {
            min: "",
            max: ""
        },
        parametricDomain: {
            min: "",
            max: ""
        },
        parametricDomain3Du: {
            min: "",
            max: ""
        },
        parametricDomain3Dv: {
            min: "",
            max: ""
        },
        parametricDomain3Dr: {
            min: "",
            max: ""
        },
        parametricDomain3Dphi: {
            min: "",
            max: ""
        },
        cdf: mM,
        colorLatex: "",
        description: "",
        fillOpacity: "",
        surfaceOpacity: "",
        lineOpacity: "",
        pointOpacity: "",
        pointSize: "",
        movablePointSize: "",
        lineWidth: "",
        resolution: "",
        labelAngle: "",
        vizProps: dM,
        clickableInfo: fM
    }
      , RA = .95
      , yM = {
        significance: {
            show: !1
        },
        confidence: {
            show: !1
        },
        chiSquare: {
            showTable: !1,
            showExpected: !0
        }
    }
      , NA = {
        folderId: "",
        latex: "",
        color: "",
        showLabel: !1,
        showAngleLabel: !0,
        label: "",
        hidden: !1,
        secret: !1,
        readonly: !1,
        disableGraphInteractions: !1,
        dragMode: Jt.AUTO,
        labelSize: "",
        labelOrientation: $1.DEFAULT,
        suppressTextOutline: !1,
        pointOutline: !1,
        interactiveLabel: !1,
        editableLabelMode: zb.None,
        residualVariable: "",
        isLogModeRegression: !1,
        pointStyle: Gc.POINT,
        lineStyle: cm.SOLID,
        arrowMode: k1.DEFAULT,
        regressionParameters: {},
        displayEvaluationAsFraction: !1,
        slider: {},
        strictIntersection: !1,
        extendTo3D: !1,
        inference: yM,
        ...qb,
        points: void 0,
        lines: void 0,
        fill: void 0
    }
      , OA = {
        hardMin: !1,
        hardMax: !1,
        animationPeriod: _A,
        loopMode: Bc.LOOP_FORWARD_REVERSE,
        playDirection: 1,
        isPlaying: !1,
        min: "-10",
        max: "10",
        step: ""
    }
      , AA = {
        hardMin: !1,
        hardMax: !1,
        animationPeriod: _A,
        loopMode: Bc.LOOP_FORWARD_REVERSE,
        playDirection: 1,
        isPlaying: !1,
        min: `${Yr.xmin}`,
        max: `${Yr.xmax}`,
        step: ""
    };
    function TK(e, t) {
        return {
            ...NA,
            isLogModeRegression: t.defaultLogModeRegressions,
            ...e,
            slider: {
                ...t.is3d ? AA : OA,
                ...e.slider
            },
            cdf: {
                ...mM,
                ...e.cdf
            },
            vizProps: {
                ...dM,
                ...e.vizProps
            },
            clickableInfo: {
                ...fM,
                ...e.clickableInfo
            },
            inference: {
                ...yM,
                ...e.inference
            }
        }
    }
    function IK(e, t) {
        let n = ff(NA, {
            ...e,
            slider: ff(t.is3d ? AA : OA, e.slider)
        })
          , r = yf(mM, e.cdf);
        r === void 0 ? delete n.cdf : n.cdf = r;
        let o = yf(dM, e.vizProps);
        o === void 0 ? delete n.vizProps : n.vizProps = o;
        let i = yf(fM, e.clickableInfo);
        i === void 0 ? delete n.clickableInfo : n.clickableInfo = i;
        let s = yf(yM, e.inference);
        return s === void 0 ? delete n.inference : n.inference = s,
        n
    }
    function O$(e) {
        return Y1(e, qb)
    }
    function PK(e, t) {
        for (let n in qb)
            if (qb.hasOwnProperty(n) && e[n] !== t[n])
                return !1;
        return !0
    }
    function SK(e) {
        return {
            type: "statement",
            id: e.id,
            latex: e.latex,
            label: e.label,
            color: e.color,
            fill: e.fill,
            points: e.points,
            lines: e.lines,
            extendTo3D: e.extendTo3D,
            pointStyle: e.pointStyle,
            lineStyle: e.lineStyle,
            arrowMode: e.arrowMode,
            dragMode: e.dragMode,
            labelSize: e.labelSize,
            labelOrientation: e.labelOrientation,
            suppressTextOutline: e.suppressTextOutline,
            pointOutline: e.pointOutline,
            interactiveLabel: e.interactiveLabel,
            editableLabelMode: e.editableLabelMode,
            residualVariable: e.residualVariable,
            regressionParameters: e.regressionParameters,
            isLogModeRegression: e.isLogModeRegression,
            showLabel: e.showLabel,
            showAngleLabel: e.showAngleLabel,
            shouldGraph: !e.hidden,
            slider: A$(e.slider),
            strictIntersection: e.strictIntersection,
            isInConstructionsFolder: e.folderId === pM,
            inference: e.inference,
            ...O$(e)
        }
    }
    function A$(e) {
        return {
            min: e.hardMin ? e.min : "",
            max: e.hardMax ? e.max : "",
            softMin: e.hardMin ? "" : e.min,
            softMax: e.hardMax ? "" : e.max,
            step: e.step,
            isPlayingOnce: e.isPlaying && e.loopMode === Bc.PLAY_ONCE
        }
    }
    $r();
    $r();
    var Z = class extends ct {
        constructor(t, n) {
            if (!Array.isArray(t))
                throw new TypeError("Argument to expression constructor must be an Array.");
            super(),
            this.args = t,
            (!n || !n.skipRegisterDependencies) && this.registerDependencies()
        }
        shouldExportAns() {
            return !0
        }
        registerDependencies() {
            for (let t = 0; t < this.args.length; t++)
                this.mergeDependencies(this.args[t])
        }
        copyWithArgs(t) {
            throw new Error(`Programming Error: copyWithArgs not implemented for ${this.constructor.name}`)
        }
    }
    ;
    var Hn = class extends Z {
        constructor(t) {
            super([]),
            typeof t == "number" && (t = be(t, 1)),
            this._constantValue = t
        }
        asValue() {
            let t = this._constantValue;
            return typeof t == "boolean" ? t : L(t)
        }
        asCompilerValue() {
            return this._constantValue
        }
        scalarExprString() {
            return this.asValue() > 0 ? String(this.asValue()) : "(" + String(this.asValue()) + ")"
        }
        isNaN() {
            let t = this.asValue();
            return typeof t == "number" && isNaN(t)
        }
    }
      , Vn = class extends Hn {
        constructor() {
            super(...arguments);
            this.type = "Constant"
        }
    }
    ;
    function xM(e) {
        if (!un(e))
            throw new Error("Programming Error: numeric constants should be rational");
        return {
            type: 1,
            valueType: b,
            value: e
        }
    }
    var hc = xM(be(0, 1))
      , rl = xM(be(1, 1))
      , zm = xM(be(1, 2));
    function nt(e) {
        return e.map(t => q(t))
    }
    function Fu(e) {
        return e.map(t => St(t))
    }
    function J(e, t) {
        var d, y, g, f, h;
        let n = t == null ? void 0 : t.defaultArguments
          , r = 1 / 0
          , o = 0
          , i = (d = n == null ? void 0 : n.length) != null ? d : 0;
        for (let x of e) {
            let T = x.minArity - i;
            T < r && (r = T);
            let P = (y = x.maxArity) != null ? y : 1 / 0;
            P > o && (o = P)
        }
        let s = (g = t == null ? void 0 : t.fallthroughUnlessDistribution) != null ? g : !1
          , a = (f = t == null ? void 0 : t.allowDotCall) != null ? f : !1
          , u = (h = t == null ? void 0 : t.isSeeded) != null ? h : !1
          , c = t == null ? void 0 : t.minArityExampleArgs
          , l = t == null ? void 0 : t.maxArityExampleArgs
          , p = t == null ? void 0 : t.dotMinArityExampleArgs
          , m = t == null ? void 0 : t.dotMaxArityExampleArgs;
        return {
            minArity: r,
            getSignatures: x => e.filter(T => T.satisfiesPolicy(x)),
            maxArity: o,
            defaultArguments: n,
            fallthroughUnlessDistribution: s,
            minArityExampleArgs: c,
            maxArityExampleArgs: l,
            dotMinArityExampleArgs: p,
            dotMaxArityExampleArgs: m,
            allowDotCall: a,
            isSeeded: u
        }
    }
    function gc() {
        return J(nt([{
            type: "variadic",
            initial: [],
            rest: Dn
        }]), {})
    }
    var Hb = xr.of([Ee, he, Ce, Ae, ce])
      , gM = xr.of([Ee, Ce, Ae, Ie])
      , Gm = xr.of([R, Ee, he, Ce, Ae, Ie, ce, De, Oe, Se, we])
      , hM = xr.of([...Ui.types.filter(e => e !== gi), Rn])
      , bM = xr.of([Dn, nr], {
        coerceComplexToReal: !1
    });
    function Pp(e) {
        return !!qa[e]
    }
    function Jn(e) {
        return [St([Nf(e)]), St([e]), q({
            type: "variadic",
            initial: [e, e],
            rest: e
        })]
    }
    function qm(e) {
        return [St([Nf(e), Nf(e)])]
    }
    var qa = {
        midpoint: J([...nt([[R, R], [Ee]]), ...nt([[G, G], [en]])], {
            allowDotCall: !0
        }),
        segment: J([q([R, R]), q([G, G])]),
        vector: J([q([R, R]), q([G, G])]),
        sphere: J([q([R, b]), q([G, b])]),
        distance: J(nt([[R, R], [G, G]])),
        glider: J(nt([[xr.of([Ee, he, Ce, Ae, ce, De]), b]])),
        circle: J(nt([[R, Ee], [R, R], [R, b]]), {}),
        center: J(nt([[he], [ce]]), {
            allowDotCall: !0
        }),
        radius: J(nt([[he], [ce]]), {
            allowDotCall: !0
        }),
        intersection: J(nt([[Hb, Hb]])),
        strictintersection: J(nt([[Hb, Hb]])),
        parallel: J(nt([[gM, R]])),
        perpendicular: J(nt([[gM, R]])),
        anglebisector: J(nt([[IP]])),
        start: J([q([Ie]), q([qe])], {
            allowDotCall: !0
        }),
        end: J([q([Ie]), q([qe])], {
            allowDotCall: !0
        }),
        length: J([St([Ui], {
            geometry: !1,
            "3d": !1
        }), q([en]), q([qe]), q([Ee]), q([Ie]), q([ce]), St({
            type: "variadic",
            initial: [Dn],
            rest: Dn
        }, {
            geometry: !1,
            "3d": !1
        })], {
            allowDotCall: !0
        }),
        translate: J(nt([[Gm, Ie], [Gm, R, R]])),
        dilate: J(nt([[Gm, R, b]])),
        rotate: J(nt([[Gm, R, b]])),
        reflect: J(nt([[Gm, gM]])),
        apply: J(nt([[we, Gm]])),
        points: J([]),
        lines: J([]),
        circles: J([]),
        arcs: J([]),
        polygons: J([]),
        rays: J([]),
        vectors: J([]),
        angle: J(nt([[R, R, R]])),
        directedangle: J(nt([[R, R, R]])),
        angles: J(Fu([[De]]), {
            allowDotCall: !0
        }),
        directedangles: J(Fu([[De]]), {
            allowDotCall: !0
        }),
        coterminal: J(nt([[Oe], [Se]])),
        round: J([...nt([[Pe], [Pe, b]]), ...nt([[N], [N, b]])]),
        mod: J([...nt([[Pe, Pe]]), ...nt([[N, N]])]),
        floor: J([...nt([[Pe]]), ...nt([[N]])]),
        ceil: J([...nt([[Pe]]), ...nt([[N]])]),
        abs: J([...nt([[Pe]]), ...nt([[N]])]),
        sign: J([q([Pe]), q([N])]),
        coerceToReal: J([...nt([[Dn]])]),
        real: J([q([N])], {
            allowDotCall: !0
        }),
        imag: J([q([N])], {
            allowDotCall: !0
        }),
        conj: J([...nt([[Pe]]), ...nt([[N]])]),
        exp: J([q([Pe]), q([N])]),
        sin: J([q([Pe]), q([N])]),
        cos: J([q([Pe]), q([N])]),
        tan: J([q([Pe]), q([N])]),
        sinh: J([q([Pe]), q([N])]),
        cosh: J([q([Pe]), q([N])]),
        tanh: J([q([Pe]), q([N])]),
        sec: J([q([Pe]), q([N])]),
        csc: J([q([Pe]), q([N])]),
        cot: J([q([Pe]), q([N])]),
        sech: J([q([Pe]), q([N])]),
        csch: J([q([Pe]), q([N])]),
        coth: J([q([Pe]), q([N])]),
        arctan: J([q([Pe]), q([N]), ...nt([[b, b]])]),
        arcsinh: J([q([Pe]), q([N])]),
        arccot: J([q([Pe]), q([N])]),
        arccsch: J([q([Pe]), q([N])]),
        nthroot: J([...nt([[b, b]])]),
        complexNthRoot: J([...nt([[N, N]])]),
        sort: J(Fu([[na], [ke], [Ui, na], [Ui, ke]]), {
            minArityExampleArgs: "([3,2,1])",
            maxArityExampleArgs: "([1,2,3],[3,2,1])",
            dotMaxArityExampleArgs: "([3,4])",
            allowDotCall: !0
        }),
        shuffle: J(Fu([[_t, Ui], [_t, Ui, b]]), {
            minArityExampleArgs: "([1,2,3])",
            maxArityExampleArgs: "([1,2,3],2)",
            dotMaxArityExampleArgs: "(2)",
            allowDotCall: !0,
            isSeeded: !0
        }),
        join: J(Fu([{
            type: "variadic",
            initial: [bM, bM],
            rest: bM
        }]), {
            minArityExampleArgs: "([1,2],[3,4])",
            dotMinArityExampleArgs: "([3,4])",
            allowDotCall: !0
        }),
        unique: J(Fu([[xr.of(Ui.types.filter(e => e !== gi && e !== nr), {
            coerceComplexToReal: !1
        })]]), {
            minArityExampleArgs: "([1,2,3])",
            maxArityExampleArgs: "([1,2,3])",
            allowDotCall: !0
        }),
        normaldist: J(nt([[b, b]]), {
            defaultArguments: [hc, rl]
        }),
        tdist: J(nt([[b, b, b]]), {
            defaultArguments: [hc, rl]
        }),
        chisqdist: J(nt([[b]])),
        binomialdist: J(nt([[b, b]]), {
            defaultArguments: [zm]
        }),
        poissondist: J(nt([[b]])),
        geodist: J(nt([[b]]), {
            defaultArguments: [zm]
        }),
        uniformdist: J(nt([[b, b]]), {
            defaultArguments: [hc, rl]
        }),
        pdf: J(nt([[Rn, b]]), {
            allowDotCall: !0
        }),
        cdf: J(nt([[Rn, b], [Rn, b, b]]), {
            allowDotCall: !0
        }),
        median: J([...nt([[Rn]]), ...Jn(b)], {
            fallthroughUnlessDistribution: !0,
            allowDotCall: !0
        }),
        stdev: J([...nt([[Rn]]), ...Jn(Pe), ...Jn(N)], {
            fallthroughUnlessDistribution: !0,
            allowDotCall: !0
        }),
        stdevp: J([...Jn(Pe), ...Jn(N)], {
            allowDotCall: !0
        }),
        var: J([...nt([[Rn]]), ...Jn(Pe), ...Jn(N)], {
            fallthroughUnlessDistribution: !0,
            allowDotCall: !0
        }),
        cov: J([...qm(Pe), ...qm(N)]),
        covp: J([...qm(Pe), ...qm(N)]),
        corr: J([...qm(Pe), ...qm(N)]),
        quantile: J([...nt([[Rn, b]]), St([Y, Fr(b)])], {
            fallthroughUnlessDistribution: !0,
            allowDotCall: !0,
            minArityExampleArgs: "([1,2,3], 1)",
            maxArityExampleArgs: "([1,2,3], 1)",
            dotMinArityExampleArgs: "(x)",
            dotMaxArityExampleArgs: "(x)"
        }),
        random: J([St([_t]), ...Fu([[_t, b], [_t, b, b], [_t, hM], [_t, hM, b], [_t, hM, b, b]])], {
            allowDotCall: !0,
            isSeeded: !0
        }),
        polygon: J([St([]), ...Jn(R), ...Fu([[Y, Y], [b, Y], [Y, b]])]),
        total: J([...Jn(Pe), ...Jn(N), ...Jn(R), ...Jn(G)], {
            allowDotCall: !0
        }),
        mean: J([q([Rn]), ...Jn(Pe), ...Jn(N), ...Jn(R), ...Jn(G)], {
            fallthroughUnlessDistribution: !0,
            allowDotCall: !0
        }),
        varp: J([q([Rn]), ...Jn(Pe), ...Jn(N)], {
            fallthroughUnlessDistribution: !0,
            allowDotCall: !0
        }),
        mad: J([...Jn(Pe), ...Jn(N)]),
        lcm: J([...Jn(Pe), ...Jn(N)], {
            allowDotCall: !0
        }),
        gcd: J([...Jn(Pe), ...Jn(N)], {
            allowDotCall: !0
        }),
        min: J([...Jn(b), q([Pt])], {
            allowDotCall: !0
        }),
        lower: J([q([Pt])], {
            allowDotCall: !0
        }),
        max: J([...Jn(b), q([Pt])], {
            allowDotCall: !0
        }),
        upper: J([q([Pt])], {
            allowDotCall: !0
        }),
        ztest: J([St([Y, Fr(b)]), q([b, b, b]), St([Y, Fr(b), Y, Fr(b)]), q([b, b, b, b, b, b])]),
        zproptest: J(nt([[b, b], [b, b, b, b]])),
        ttest: J([St([Y]), q([b, b, b]), St([Y, Y]), q([b, b, b, b, b, b])]),
        null: J([q([$t, b]), q([wt, b]), q([Kt, b]), q([Qt, b]), q([Ht, b]), q([an, b]), q([Yt, b])], {
            allowDotCall: !0
        }),
        conf: J([q([$t, b]), q([wt, b]), q([Kt, b]), q([Qt, b]), q([Ht, b]), q([an, b]), q([Yt, b])], {
            allowDotCall: !0
        }),
        score: J([q([pn]), q([mn]), q([$t]), q([wt]), q([Kt]), q([Qt]), q([Ht]), q([an]), q([Yt]), q([qn]), q([zn])], {
            allowDotCall: !0
        }),
        pleft: J([q([pn]), q([mn]), q([$t]), q([wt]), q([Kt]), q([Qt]), q([Ht]), q([an]), q([Yt])], {
            allowDotCall: !0
        }),
        pright: J([q([pn]), q([mn]), q([$t]), q([wt]), q([Kt]), q([Qt]), q([Ht]), q([an]), q([Yt])], {
            allowDotCall: !0
        }),
        dof: J([q([$t]), q([wt]), q([Kt]), q([mn]), q([qn]), q([zn])], {
            allowDotCall: !0
        }),
        stderr: J([q([$t]), q([wt]), q([Kt]), q([Qt]), q([Ht]), q([an]), q([Yt])], {
            allowDotCall: !0
        }),
        estimate: J([q([$t]), q([wt]), q([Kt]), q([Qt]), q([Ht]), q([an]), q([Yt])], {
            allowDotCall: !0
        }),
        chisqtest: J(Fu([{
            type: "variadic",
            initial: [Y, Y],
            rest: Y
        }])),
        chisqgof: J(Fu([[Y], [Y, Y]])),
        histogram: gc(),
        dotplot: gc(),
        boxplot: gc(),
        stats: gc(),
        det: gc(),
        inv: gc(),
        transpose: gc(),
        rref: gc(),
        trace: gc()
    };
    function w$(e) {
        switch (e) {
        case "default":
        case "trig":
        case "inverseTrig":
        case "trig2":
        case "never-broadcast":
            return [b];
        case "reducer":
            return [Y];
        case "doubleReducer":
            return [Y, Y];
        case "parameterizedReducer":
            return [Y, b];
        case "color":
            return [b, b, b]
        }
    }
    function L$(e) {
        switch (e) {
        case "default":
        case "trig":
        case "inverseTrig":
        case "trig2":
        case "doubleReducer":
        case "color":
        case "never-broadcast":
            return !1;
        case "reducer":
        case "parameterizedReducer":
            return !0
        }
    }
    function F$(e, t, n) {
        return e === "reducer" ? 1 / 0 : t + n
    }
    function D(e, t, n) {
        var d, y, g, f, h;
        n === void 0 && (n = {});
        let r = (d = n.tag) != null ? d : "default"
          , o = (y = n.argumentTypes) != null ? y : w$(r)
          , i = n.defaultArguments ? n.defaultArguments.length : 0
          , s = o.length - i
          , a = F$(r, s, i)
          , u = (g = n.allowDotCall) != null ? g : L$(r)
          , c = (f = n.noPeel) != null ? f : !1
          , {defaultArguments: l, minArityExampleArgs: p, maxArityExampleArgs: m} = n;
        return {
            module: e,
            symbol: t,
            argumentTypes: o,
            defaultArguments: l,
            returnType: (h = n.returnType) != null ? h : b,
            tag: r,
            minArity: s,
            maxArity: a,
            allowDotCall: u,
            noPeel: c,
            minArityExampleArgs: p,
            maxArityExampleArgs: m
        }
    }
    function ol(e) {
        let t;
        return e in ir && (t = ir[e].tag),
        t === "trig" || t === "trig2" || t === "inverseTrig" ? !0 : e === "angle" || e === "angles" || e === "directedangle" || e === "directedangles" || e === "rotate"
    }
    var ir = {
        sin: D("BuiltIn", "sin", {
            tag: "trig"
        }),
        cos: D("BuiltIn", "cos", {
            tag: "trig"
        }),
        tan: D("BuiltIn", "tan", {
            tag: "trig"
        }),
        cot: D("BuiltIn", "cot", {
            tag: "trig"
        }),
        sec: D("BuiltIn", "sec", {
            tag: "trig"
        }),
        csc: D("BuiltIn", "csc", {
            tag: "trig"
        }),
        arcsin: D("Math", "asin", {
            tag: "inverseTrig"
        }),
        arccos: D("Math", "acos", {
            tag: "inverseTrig"
        }),
        arctan: D("Math", "atan2", {
            argumentTypes: [b, b],
            tag: "inverseTrig"
        }),
        arccot: D("BuiltIn", "acot", {
            tag: "inverseTrig"
        }),
        arcsec: D("BuiltIn", "asec", {
            tag: "inverseTrig"
        }),
        arccsc: D("BuiltIn", "acsc", {
            tag: "inverseTrig"
        }),
        sinh: D("BuiltIn", "sinh"),
        cosh: D("BuiltIn", "cosh"),
        tanh: D("BuiltIn", "tanh"),
        coth: D("BuiltIn", "coth"),
        sech: D("BuiltIn", "sech"),
        csch: D("BuiltIn", "csch"),
        arcsinh: D("BuiltIn", "asinh"),
        arccosh: D("BuiltIn", "acosh"),
        arctanh: D("BuiltIn", "atanh"),
        arccoth: D("BuiltIn", "acoth"),
        arcsech: D("BuiltIn", "asech"),
        arccsch: D("BuiltIn", "acsch"),
        sqrt: D("Math", "sqrt"),
        rtxsqpone: D("BuiltIn", "sqrtxsqp1"),
        rtxsqmone: D("BuiltIn", "sqrtxsqm1"),
        hypot: D("BuiltIn", "hypot", {
            argumentTypes: [b, b]
        }),
        log: D("BuiltIn", "common_log"),
        logbase: D("BuiltIn", "log_base", {
            argumentTypes: [b, b]
        }),
        ln: D("BuiltIn", "log"),
        exp: D("Math", "exp"),
        floor: D("Math", "floor"),
        complexFloor: D("BuiltIn", "complexFloor", {
            argumentTypes: [N],
            returnType: N
        }),
        ceil: D("Math", "ceil"),
        complexCeil: D("BuiltIn", "complexCeil", {
            argumentTypes: [N],
            returnType: N
        }),
        round: D("Math", "round"),
        complexRound: D("BuiltIn", "complexRound", {
            argumentTypes: [N],
            returnType: N
        }),
        abs: D("Math", "abs"),
        sign: D("BuiltIn", "sign"),
        mod: D("BuiltIn", "mod", {
            argumentTypes: [b, b]
        }),
        complexMod: D("BuiltIn", "complexMod", {
            argumentTypes: [N, N],
            returnType: N
        }),
        nCr: D("BuiltIn", "nCr", {
            argumentTypes: [b, b]
        }),
        nPr: D("BuiltIn", "nPr", {
            argumentTypes: [b, b]
        }),
        factorial: D("BuiltIn", "factorial"),
        polyGamma: D("BuiltIn", "polyGamma", {
            argumentTypes: [b, b]
        }),
        lcm: D("BuiltIn", "listLCM", {
            tag: "reducer"
        }),
        complexLCM: D("BuiltIn", "complexListLCM", {
            argumentTypes: [ke],
            returnType: N,
            tag: "reducer"
        }),
        gcd: D("BuiltIn", "listGCD", {
            tag: "reducer"
        }),
        complexGCD: D("BuiltIn", "complexListGCD", {
            argumentTypes: [ke],
            returnType: N,
            tag: "reducer"
        }),
        distance: D("BuiltIn", "distance", {
            argumentTypes: [R, R]
        }),
        polygon: D("BuiltIn", "polygon", {
            tag: "reducer",
            argumentTypes: [zt],
            returnType: De
        }),
        area: D("BuiltIn", "polygonArea", {
            argumentTypes: [De]
        }),
        perimeter: D("BuiltIn", "polygonPerimeter", {
            argumentTypes: [De]
        }),
        pointDet: D("BuiltIn", "pointDet", {
            argumentTypes: [R, R]
        }),
        pointDot: D("BuiltIn", "pointDot", {
            argumentTypes: [R, R]
        }),
        pointPerp: D("BuiltIn", "pointPerp", {
            argumentTypes: [R],
            returnType: R
        }),
        complexMultiplyPoints: D("BuiltIn", "complexMultiplyPoints", {
            argumentTypes: [R, R],
            returnType: R
        }),
        segment: D("BuiltIn", "segment", {
            argumentTypes: [R, R],
            returnType: Ee
        }),
        line: D("BuiltIn", "line", {
            argumentTypes: [R, R],
            returnType: Ce
        }),
        ray: D("BuiltIn", "ray", {
            argumentTypes: [R, R],
            returnType: Ae
        }),
        vector: D("BuiltIn", "vector", {
            argumentTypes: [R, R],
            returnType: Ie
        }),
        vectorThreeD: D("BuiltIn", "vectorThreeD", {
            argumentTypes: [G, G],
            returnType: qe
        }),
        mathVector: D("BuiltIn", "mathVector", {
            argumentTypes: [R, R],
            returnType: Ie
        }),
        mathVectorThreeD: D("BuiltIn", "mathVectorThreeD", {
            argumentTypes: [G, G],
            returnType: qe
        }),
        vectorDisplacementAsPoint: D("BuiltIn", "vectorDisplacementAsPoint", {
            argumentTypes: [Ie],
            returnType: R
        }),
        vectorThreeDDisplacementAsPoint: D("BuiltIn", "vectorThreeDDisplacementAsPoint", {
            argumentTypes: [qe],
            returnType: G
        }),
        basePointFromVector: D("BuiltIn", "basePointFromVector", {
            argumentTypes: [Ie],
            returnType: R
        }),
        basePointFromVectorThreeD: D("BuiltIn", "basePointFromVectorThreeD", {
            argumentTypes: [qe],
            returnType: G
        }),
        circle: D("BuiltIn", "circle", {
            argumentTypes: [R, b],
            returnType: he
        }),
        center: D("BuiltIn", "center", {
            argumentTypes: [he],
            returnType: R,
            allowDotCall: !0
        }),
        radius: D("BuiltIn", "radius", {
            argumentTypes: [he],
            returnType: b,
            allowDotCall: !0
        }),
        arc: D("BuiltIn", "arc", {
            argumentTypes: [R, R, R],
            returnType: ce
        }),
        arcCenter: D("BuiltIn", "arcCenter", {
            argumentTypes: [ce],
            returnType: R
        }),
        arcFirstPoint: D("BuiltIn", "arcFirstPoint", {
            argumentTypes: [ce],
            returnType: R
        }),
        arcMiddlePoint: D("BuiltIn", "arcMiddlePoint", {
            argumentTypes: [ce],
            returnType: R
        }),
        arcThirdPoint: D("BuiltIn", "arcThirdPoint", {
            argumentTypes: [ce],
            returnType: R
        }),
        arcOmega: D("BuiltIn", "arcOmega", {
            argumentTypes: [ce],
            returnType: b
        }),
        undirectedAngleMarker: D("BuiltIn", "undirectedAngleMarker", {
            argumentTypes: [Se],
            returnType: Oe
        }),
        directedAngleMarker: D("BuiltIn", "directedAngleMarker", {
            argumentTypes: [R, b, b, b],
            returnType: Se
        }),
        directedCoterminalAngle: D("BuiltIn", "directedCoterminalAngle", {
            argumentTypes: [Se],
            returnType: Se
        }),
        undirectedCoterminalAngle: D("BuiltIn", "undirectedCoterminalAngle", {
            argumentTypes: [Oe],
            returnType: Oe
        }),
        supplement: D("BuiltIn", "supplementAngle", {
            argumentTypes: [Se],
            returnType: Se
        }),
        directedAngleMarkerRawDelta: D("BuiltIn", "angleMarkerRawDelta", {
            argumentTypes: [Se],
            returnType: b
        }),
        undirectedAngleMarkerRawDelta: D("BuiltIn", "angleMarkerRawDelta", {
            argumentTypes: [Oe],
            returnType: b
        }),
        directedAngleMarkerMultiplier: D("BuiltIn", "angleMarkerMultiplier", {
            argumentTypes: [Se],
            returnType: b
        }),
        undirectedAngleMarkerMultiplier: D("BuiltIn", "angleMarkerMultiplier", {
            argumentTypes: [Oe],
            returnType: b
        }),
        polygonInteriorUndirectedAngles: D("BuiltIn", "polygonInteriorUndirectedAngles", {
            argumentTypes: [De, b],
            returnType: Ar,
            allowDotCall: !0,
            tag: "never-broadcast"
        }),
        polygonInteriorDirectedAngles: D("BuiltIn", "polygonInteriorDirectedAngles", {
            argumentTypes: [De, b],
            returnType: wr,
            allowDotCall: !0,
            tag: "never-broadcast"
        }),
        vertices: D("BuiltIn", "vertices", {
            argumentTypes: [De],
            returnType: zt,
            allowDotCall: !0,
            tag: "never-broadcast"
        }),
        segments: D("BuiltIn", "polygonEdges", {
            argumentTypes: [De],
            returnType: Tr,
            allowDotCall: !0,
            tag: "never-broadcast"
        }),
        scaleTangentTransformation: D("BuiltIn", "scaleTangentTransformation", {
            argumentTypes: [we, b],
            returnType: De
        }),
        scaleTangentPolygon: D("BuiltIn", "scaleTangentPolygon", {
            argumentTypes: [De, b],
            returnType: De
        }),
        scaleTangentSegment: D("BuiltIn", "scaleTangentSegment", {
            argumentTypes: [Ee, b],
            returnType: Ee
        }),
        scaleTangentLine: D("BuiltIn", "scaleTangentLine", {
            argumentTypes: [Ce, b],
            returnType: Ce
        }),
        scaleTangentRay: D("BuiltIn", "scaleTangentRay", {
            argumentTypes: [Ae, b],
            returnType: Ae
        }),
        scaleTangentCircle: D("BuiltIn", "scaleTangentCircle", {
            argumentTypes: [he, b],
            returnType: he
        }),
        scaleTangentArc: D("BuiltIn", "scaleTangentArc", {
            argumentTypes: [ce, b],
            returnType: he
        }),
        scaleTangentDirectedAngleMarker: D("BuiltIn", "scaleTangentAngle", {
            argumentTypes: [Se, b],
            returnType: Se
        }),
        scaleTangentUndirectedAngleMarker: D("BuiltIn", "scaleTangentAngle", {
            argumentTypes: [Oe, b],
            returnType: Oe
        }),
        addTangentPolygon: D("BuiltIn", "addTangentPolygon", {
            argumentTypes: [De, De],
            returnType: De
        }),
        addTangentSegment: D("BuiltIn", "addTangentSegment", {
            argumentTypes: [Ee, Ee],
            returnType: Ee
        }),
        addTangentSegmentThreeD: D("BuiltIn", "addTangentSegmentThreeD", {
            argumentTypes: [en, en],
            returnType: en
        }),
        addTangentLine: D("BuiltIn", "addTangentLine", {
            argumentTypes: [Ce, Ce],
            returnType: Ce
        }),
        addTangentRay: D("BuiltIn", "addTangentRay", {
            argumentTypes: [Ae, Ae],
            returnType: Ae
        }),
        addTangentVector: D("BuiltIn", "addTangentVector", {
            argumentTypes: [Ie, Ie],
            returnType: Ie
        }),
        addTangentCircle: D("BuiltIn", "addTangentCircle", {
            argumentTypes: [he, he],
            returnType: he
        }),
        addTangentArc: D("BuiltIn", "addTangentArc", {
            argumentTypes: [ce, ce],
            returnType: ce
        }),
        addTangentTransformation: D("BuiltIn", "addTangentTransformation", {
            argumentTypes: [we, we],
            returnType: we
        }),
        addTangentDirectedAngleMarker: D("BuiltIn", "addTangentAngle", {
            argumentTypes: [Se, Se],
            returnType: Se
        }),
        addTangentUndirectedAngleMarker: D("BuiltIn", "addTangentAngle", {
            argumentTypes: [Oe, Oe],
            returnType: Oe
        }),
        segmentGlider: D("BuiltIn", "segmentGlider", {
            argumentTypes: [Ee, b],
            returnType: R
        }),
        segmentThreeDGlider: D("BuiltIn", "segmentThreeDGlider", {
            argumentTypes: [en, b],
            returnType: G
        }),
        lineGlider: D("BuiltIn", "lineGlider", {
            argumentTypes: [Ce, b],
            returnType: R
        }),
        rayGlider: D("BuiltIn", "rayGlider", {
            argumentTypes: [Ae, b],
            returnType: R
        }),
        circleGlider: D("BuiltIn", "circleGlider", {
            argumentTypes: [he, b],
            returnType: R
        }),
        arcGlider: D("BuiltIn", "arcGlider", {
            argumentTypes: [ce, b],
            returnType: R
        }),
        polygonEdgeByParameter: D("BuiltIn", "polygonEdgeByParameter", {
            argumentTypes: [De, b],
            returnType: Ee
        }),
        polygonGlider: D("BuiltIn", "polygonGlider", {
            argumentTypes: [De, b],
            returnType: R
        }),
        chooseNonIncidentPoint: D("BuiltIn", "chooseNonIncidentPoint", {
            argumentTypes: [R, R, R],
            returnType: R
        }),
        circleCircleIntersection: D("BuiltIn", "circleCircleIntersection", {
            argumentTypes: [he, he, b],
            returnType: R
        }),
        circleArcIntersection: D("BuiltIn", "circleArcIntersection", {
            argumentTypes: [he, ce, b],
            returnType: R
        }),
        circleLineIntersection: D("BuiltIn", "circleLineIntersection", {
            argumentTypes: [he, Ce, b],
            returnType: R
        }),
        arcCircleIntersection: D("BuiltIn", "arcCircleIntersection", {
            argumentTypes: [ce, he, b],
            returnType: R
        }),
        arcArcIntersection: D("BuiltIn", "arcArcIntersection", {
            argumentTypes: [ce, ce, b],
            returnType: R
        }),
        arcLineIntersection: D("BuiltIn", "arcLineIntersection", {
            argumentTypes: [ce, Ce, b],
            returnType: R
        }),
        lineCircleIntersection: D("BuiltIn", "lineCircleIntersection", {
            argumentTypes: [Ce, he, b],
            returnType: R
        }),
        lineArcIntersection: D("BuiltIn", "lineArcIntersection", {
            argumentTypes: [Ce, ce, b],
            returnType: R
        }),
        lineLineIntersection: D("BuiltIn", "lineLineIntersection", {
            argumentTypes: [Ce, Ce, b],
            returnType: R
        }),
        lineFromSegment: D("BuiltIn", "identity", {
            argumentTypes: [Ee],
            returnType: Ce
        }),
        lineFromRay: D("BuiltIn", "identity", {
            argumentTypes: [Ae],
            returnType: Ce
        }),
        parallel: D("BuiltIn", "parallel", {
            argumentTypes: [Ce, R],
            returnType: Ce
        }),
        perpendicular: D("BuiltIn", "perpendicular", {
            argumentTypes: [Ce, R],
            returnType: Ce
        }),
        anglebisector: D("BuiltIn", "anglebisector", {
            argumentTypes: [Oe],
            returnType: Ae
        }),
        directedanglebisector: D("BuiltIn", "anglebisector", {
            argumentTypes: [Se],
            returnType: Ae
        }),
        rawTransform: D("BuiltIn", "rawTransform", {
            argumentTypes: [R, R],
            returnType: we
        }),
        rawTransformConj: D("BuiltIn", "rawTransformConj", {
            argumentTypes: [R, R],
            returnType: we
        }),
        transformWithoutTranslation: D("BuiltIn", "transformWithoutTranslation", {
            argumentTypes: [we],
            returnType: we
        }),
        transformScaleFactor: D("BuiltIn", "transformScaleFactor", {
            argumentTypes: [we],
            returnType: R
        }),
        translation: D("BuiltIn", "translation", {
            argumentTypes: [R],
            returnType: we
        }),
        dilation: D("BuiltIn", "dilation", {
            argumentTypes: [R, b],
            returnType: we
        }),
        rotation: D("BuiltIn", "rotation", {
            tag: "trig2",
            argumentTypes: [R, b],
            returnType: we
        }),
        reflection: D("BuiltIn", "reflection", {
            argumentTypes: [Ce],
            returnType: we
        }),
        compose: D("BuiltIn", "composeTransformation", {
            argumentTypes: [we, we],
            returnType: we
        }),
        inverse: D("BuiltIn", "invertTransformation", {
            argumentTypes: [we],
            returnType: we
        }),
        transformPoint: D("BuiltIn", "transformPoint", {
            argumentTypes: [we, R],
            returnType: R
        }),
        transformSegment: D("BuiltIn", "transformSegment", {
            argumentTypes: [we, Ee],
            returnType: Ee
        }),
        transformLine: D("BuiltIn", "transformLine", {
            argumentTypes: [we, Ce],
            returnType: Ce
        }),
        transformRay: D("BuiltIn", "transformRay", {
            argumentTypes: [we, Ae],
            returnType: Ae
        }),
        transformVector: D("BuiltIn", "transformVector", {
            argumentTypes: [we, Ie],
            returnType: Ie
        }),
        transformCircle: D("BuiltIn", "transformCircle", {
            argumentTypes: [we, he],
            returnType: he
        }),
        transformArc: D("BuiltIn", "transformArc", {
            argumentTypes: [we, ce],
            returnType: ce
        }),
        transformPolygon: D("BuiltIn", "transformPolygon", {
            argumentTypes: [we, De],
            returnType: De
        }),
        transformAngleMarker: D("BuiltIn", "transformAngleMarker", {
            argumentTypes: [we, Oe],
            returnType: Oe
        }),
        transformDirectedAngleMarker: D("BuiltIn", "transformAngleMarker", {
            argumentTypes: [we, Se],
            returnType: Se
        }),
        distanceThreeD: D("BuiltIn", "distanceThreeD", {
            argumentTypes: [G, G]
        }),
        segmentThreeD: D("BuiltIn", "segmentThreeD", {
            argumentTypes: [G, G],
            returnType: en
        }),
        triangle: D("BuiltIn", "triangle", {
            argumentTypes: [G, G, G],
            returnType: lr
        }),
        sphere: D("BuiltIn", "sphere", {
            argumentTypes: [G, b],
            returnType: Lr
        }),
        mean: D("BuiltIn", "mean", {
            tag: "reducer"
        }),
        total: D("BuiltIn", "total", {
            tag: "reducer"
        }),
        stdev: D("BuiltIn", "stdev", {
            tag: "reducer"
        }),
        stdevp: D("BuiltIn", "stdevp", {
            tag: "reducer"
        }),
        mad: D("BuiltIn", "mad", {
            tag: "reducer"
        }),
        count: D("BuiltIn", "listLength", {
            tag: "reducer",
            argumentTypes: [nr],
            noPeel: !0
        }),
        listMin: D("BuiltIn", "listMin", {
            tag: "reducer"
        }),
        listMax: D("BuiltIn", "listMax", {
            tag: "reducer"
        }),
        min: D("Math", "min", {
            argumentTypes: [b, b],
            returnType: b
        }),
        max: D("Math", "max", {
            argumentTypes: [b, b],
            returnType: b
        }),
        argmin: D("BuiltIn", "argMin", {
            tag: "reducer",
            noPeel: !0
        }),
        argmax: D("BuiltIn", "argMax", {
            tag: "reducer",
            noPeel: !0
        }),
        median: D("BuiltIn", "median", {
            tag: "reducer"
        }),
        var: D("BuiltIn", "variance", {
            tag: "reducer"
        }),
        varp: D("BuiltIn", "varp", {
            tag: "reducer"
        }),
        cov: D("BuiltIn", "cov", {
            tag: "doubleReducer"
        }),
        covp: D("BuiltIn", "covp", {
            tag: "doubleReducer"
        }),
        corr: D("BuiltIn", "corr", {
            tag: "doubleReducer"
        }),
        spearman: D("BuiltIn", "spearman", {
            tag: "doubleReducer"
        }),
        quantile: D("BuiltIn", "quantile", {
            tag: "parameterizedReducer"
        }),
        quartile: D("BuiltIn", "quartile", {
            tag: "parameterizedReducer"
        }),
        upperQuantileIndex: D("BuiltIn", "upperQuantileIndex", {
            tag: "parameterizedReducer"
        }),
        lowerQuantileIndex: D("BuiltIn", "lowerQuantileIndex", {
            tag: "parameterizedReducer"
        }),
        quartileIndex: D("BuiltIn", "quartileIndex", {
            tag: "parameterizedReducer"
        }),
        upperQuartileIndex: D("BuiltIn", "upperQuartileIndex", {
            tag: "parameterizedReducer"
        }),
        lowerQuartileIndex: D("BuiltIn", "lowerQuartileIndex", {
            tag: "parameterizedReducer"
        }),
        normalcdf: D("BuiltIn", "normalcdf", {
            argumentTypes: [b, b, b, b],
            defaultArguments: [hc, rl]
        }),
        normalpdf: D("BuiltIn", "normalpdf", {
            argumentTypes: [b, b, b],
            defaultArguments: [hc, rl]
        }),
        binomcdf: D("BuiltIn", "binomcdf", {
            argumentTypes: [b, b, b, b],
            defaultArguments: [zm]
        }),
        binompdf: D("BuiltIn", "binompdf", {
            argumentTypes: [b, b, b],
            defaultArguments: [zm]
        }),
        poissoncdf: D("BuiltIn", "poissoncdf", {
            argumentTypes: [b, b, b]
        }),
        poissonpdf: D("BuiltIn", "poissonpdf", {
            argumentTypes: [b, b]
        }),
        geocdf: D("BuiltIn", "geocdf", {
            argumentTypes: [b, b, b]
        }),
        geopdf: D("BuiltIn", "geopdf", {
            argumentTypes: [b, b]
        }),
        uniformcdf: D("BuiltIn", "uniformcdf", {
            argumentTypes: [b, b, b, b],
            defaultArguments: [hc, rl]
        }),
        uniformpdf: D("BuiltIn", "uniformpdf", {
            argumentTypes: [b, b, b],
            defaultArguments: [hc, rl]
        }),
        invT: D("BuiltIn", "invT", {
            argumentTypes: [b, b]
        }),
        invPoisson: D("BuiltIn", "invPoisson", {
            argumentTypes: [b, b]
        }),
        invGeo: D("BuiltIn", "invGeo", {
            argumentTypes: [b, b]
        }),
        invBinom: D("BuiltIn", "invBinom", {
            argumentTypes: [b, b, b]
        }),
        invUniform: D("BuiltIn", "invUniform", {
            argumentTypes: [b, b, b]
        }),
        tpdf: D("BuiltIn", "tpdf", {
            argumentTypes: [b, b]
        }),
        tcdf: D("BuiltIn", "tcdf", {
            argumentTypes: [b, b, b, b, b]
        }),
        erf: D("BuiltIn", "erf"),
        invNorm: D("BuiltIn", "invNorm"),
        tscore: D("BuiltIn", "tscore", {
            tag: "parameterizedReducer",
            defaultArguments: [hc]
        }),
        normalSample: D("BuiltIn", "normalSample", {
            argumentTypes: [_t, b, b]
        }),
        uniformSample: D("BuiltIn", "uniformSample", {
            argumentTypes: [_t, b, b]
        }),
        tSample: D("BuiltIn", "tSample", {
            argumentTypes: [_t, b]
        }),
        poissonSample: D("BuiltIn", "poissonSample", {
            argumentTypes: [_t, b]
        }),
        binomSample: D("BuiltIn", "binomSample", {
            argumentTypes: [_t, b, b]
        }),
        rgb: D("BuiltIn", "rgb", {
            returnType: bn,
            tag: "color"
        }),
        hsv: D("BuiltIn", "hsv", {
            returnType: bn,
            tag: "color"
        }),
        tone: D("BuiltIn", "tone", {
            argumentTypes: [b, b],
            returnType: cr,
            defaultArguments: [zm],
            minArityExampleArgs: "(440)",
            maxArityExampleArgs: "(440, 0.5)"
        }),
        validateRangeLength: D("BuiltIn", "validateRangeLength", {
            returnType: b,
            argumentTypes: [Y, Y, b, b],
            tag: "never-broadcast",
            noPeel: !0
        }),
        validateSampleCount: D("BuiltIn", "validateSampleCount", {
            returnType: b,
            argumentTypes: [b]
        }),
        select: D("BuiltIn", "select", {
            argumentTypes: [nr, yi],
            returnType: e => e[0],
            tag: "never-broadcast",
            noPeel: !0
        }),
        shuffle: D("BuiltIn", "shuffle", {
            argumentTypes: [_t, nr],
            returnType: e => e[1],
            tag: "never-broadcast"
        }),
        sortPerm: D("BuiltIn", "sortPerm", {
            argumentTypes: [Y],
            returnType: Y,
            tag: "never-broadcast",
            noPeel: !0
        }),
        complexSortPerm: D("BuiltIn", "complexSortPerm", {
            argumentTypes: [ke],
            returnType: Y,
            tag: "never-broadcast",
            noPeel: !0
        }),
        elementsAt: D("BuiltIn", "elementsAt", {
            argumentTypes: [nr, Y],
            returnType: e => e[0],
            tag: "never-broadcast",
            noPeel: !0
        }),
        uniquePerm: D("BuiltIn", "uniquePerm", {
            argumentTypes: [nr],
            returnType: Y,
            tag: "never-broadcast",
            noPeel: !0
        }),
        restriction: D("BuiltIn", "restriction", {
            argumentTypes: [Fe],
            returnType: sn
        }),
        restrictionToBoolean: D("BuiltIn", "restrictionToBoolean", {
            argumentTypes: [sn],
            returnType: Fe
        }),
        complex: D("BuiltIn", "complex", {
            argumentTypes: [b, b],
            returnType: N
        }),
        arg: D("BuiltIn", "arg", {
            argumentTypes: [N],
            returnType: b
        }),
        wirtingerEqualOrWarning: D("BuiltIn", "wirtingerEqualOrWarning", {
            argumentTypes: [N, N],
            returnType: N
        }),
        complexDivide: D("BuiltIn", "complexDivide", {
            argumentTypes: [N, N],
            returnType: N
        }),
        peelableCoerceComplexToReal: D("BuiltIn", "coerceComplexToReal", {
            argumentTypes: [N],
            returnType: b
        }),
        peelableCoerceComplexToRealWithTolerance: D("BuiltIn", "coerceComplexToReal", {
            argumentTypes: [N],
            returnType: b
        }),
        coerceComplexToReal: D("BuiltIn", "coerceComplexToReal", {
            argumentTypes: [N],
            returnType: b
        }),
        coerceComplexToRealWithTolerance: D("BuiltIn", "coerceComplexToRealWithTolerance", {
            argumentTypes: [N],
            returnType: b
        }),
        coerceRealToComplex: D("BuiltIn", "coerceRealToComplex", {
            argumentTypes: [b],
            returnType: N
        }),
        complexSqrt: D("BuiltIn", "complexSqrt", {
            argumentTypes: [N],
            returnType: N
        }),
        complexLn: D("BuiltIn", "complexLog", {
            argumentTypes: [N],
            returnType: N
        }),
        complexLogbase: D("BuiltIn", "complexLogbase", {
            argumentTypes: [N, N],
            returnType: N
        }),
        complexLog: D("BuiltIn", "complexCommonLog", {
            argumentTypes: [N],
            returnType: N
        }),
        complexExp: D("BuiltIn", "complexExp", {
            argumentTypes: [N],
            returnType: N
        }),
        complexPow: D("BuiltIn", "complexPow", {
            argumentTypes: [N, N],
            returnType: N
        }),
        complexSin: D("BuiltIn", "complexSin", {
            argumentTypes: [N],
            returnType: N
        }),
        complexCos: D("BuiltIn", "complexCos", {
            argumentTypes: [N],
            returnType: N
        }),
        complexTan: D("BuiltIn", "complexTan", {
            argumentTypes: [N],
            returnType: N
        }),
        complexSinh: D("BuiltIn", "complexSinh", {
            argumentTypes: [N],
            returnType: N
        }),
        complexCosh: D("BuiltIn", "complexCosh", {
            argumentTypes: [N],
            returnType: N
        }),
        complexTanh: D("BuiltIn", "complexTanh", {
            argumentTypes: [N],
            returnType: N
        }),
        complexSec: D("BuiltIn", "complexSec", {
            argumentTypes: [N],
            returnType: N
        }),
        complexCsc: D("BuiltIn", "complexCsc", {
            argumentTypes: [N],
            returnType: N
        }),
        complexCot: D("BuiltIn", "complexCot", {
            argumentTypes: [N],
            returnType: N
        }),
        complexSech: D("BuiltIn", "complexSech", {
            argumentTypes: [N],
            returnType: N
        }),
        complexCsch: D("BuiltIn", "complexCsch", {
            argumentTypes: [N],
            returnType: N
        }),
        complexCoth: D("BuiltIn", "complexCoth", {
            argumentTypes: [N],
            returnType: N
        }),
        complexArcsin: D("BuiltIn", "complexAsin", {
            argumentTypes: [N],
            returnType: N
        }),
        complexArccos: D("BuiltIn", "complexAcos", {
            argumentTypes: [N],
            returnType: N
        }),
        complexArctan: D("BuiltIn", "complexAtan", {
            argumentTypes: [N],
            returnType: N
        }),
        complexArcsec: D("BuiltIn", "complexAsec", {
            argumentTypes: [N],
            returnType: N
        }),
        complexArccsc: D("BuiltIn", "complexAcsc", {
            argumentTypes: [N],
            returnType: N
        }),
        complexArccot: D("BuiltIn", "complexAcot", {
            argumentTypes: [N],
            returnType: N
        }),
        complexArcsinh: D("BuiltIn", "complexAsinh", {
            argumentTypes: [N],
            returnType: N
        }),
        complexArccosh: D("BuiltIn", "complexAcosh", {
            argumentTypes: [N],
            returnType: N
        }),
        complexArctanh: D("BuiltIn", "complexAtanh", {
            argumentTypes: [N],
            returnType: N
        }),
        complexArcsech: D("BuiltIn", "complexAsech", {
            argumentTypes: [N],
            returnType: N
        }),
        complexArccsch: D("BuiltIn", "complexAcsch", {
            argumentTypes: [N],
            returnType: N
        }),
        complexArccoth: D("BuiltIn", "complexAcoth", {
            argumentTypes: [N],
            returnType: N
        }),
        angleVertex: D("BuiltIn", "angleVertex", {
            argumentTypes: [Oe],
            returnType: R
        }),
        angleStart: D("BuiltIn", "angleStart", {
            argumentTypes: [Oe],
            returnType: b
        }),
        directedAngleVertex: D("BuiltIn", "angleVertex", {
            argumentTypes: [Se],
            returnType: R
        }),
        directedAngleStart: D("BuiltIn", "angleStart", {
            argumentTypes: [Se],
            returnType: b
        }),
        chisqIndependenceRowTotals: D("BuiltIn", "chisqIndependenceRowTotals", {
            argumentTypes: [Y, b, b],
            returnType: Y,
            tag: "never-broadcast",
            noPeel: !0
        }),
        chisqIndependenceColTotals: D("BuiltIn", "chisqIndependenceColTotals", {
            argumentTypes: [Y, b, b],
            returnType: Y,
            tag: "never-broadcast",
            noPeel: !0
        }),
        chisqIndependenceExpectedValues: D("BuiltIn", "chisqIndependenceExpectedValues", {
            argumentTypes: [Y, Y],
            returnType: Y,
            tag: "never-broadcast",
            noPeel: !0
        }),
        chisqcdf: D("BuiltIn", "chisqcdf", {
            argumentTypes: [b, b, b],
            returnType: b,
            noPeel: !0
        }),
        chisqpdf: D("BuiltIn", "chisqpdf", {
            argumentTypes: [b, b],
            returnType: b,
            noPeel: !0
        }),
        invChisq: D("BuiltIn", "invChisq", {
            argumentTypes: [b, b]
        })
    }
      , Um = {
        sqrt: "complexSqrt",
        ln: "complexLn",
        log: "complexLog",
        logbase: "complexLogbase",
        exp: "complexExp",
        sin: "complexSin",
        cos: "complexCos",
        tan: "complexTan",
        sinh: "complexSinh",
        cosh: "complexCosh",
        tanh: "complexTanh",
        sec: "complexSec",
        csc: "complexCsc",
        cot: "complexCot",
        sech: "complexSech",
        csch: "complexCsch",
        coth: "complexCoth",
        arcsin: "complexArcsin",
        arccos: "complexArccos",
        arctan: "complexArctan",
        arcsec: "complexArcsec",
        arccsc: "complexArccsc",
        arccot: "complexArccot",
        arcsinh: "complexArcsinh",
        arccosh: "complexArccosh",
        arctanh: "complexArctanh",
        arcsech: "complexArcsech",
        arccsch: "complexArccsch",
        arccoth: "complexArccoth",
        floor: "complexFloor",
        ceil: "complexCeil",
        mod: "complexMod",
        nthroot: "complexNthRoot",
        sortPerm: "complexSortPerm"
    }
      , V$ = {
        sqrt: !0,
        ln: !0,
        log: !0,
        logbase: !0,
        arcsin: !0,
        arccos: !0,
        arcsec: !0,
        arccsc: !0,
        arccosh: !0,
        arctanh: !0,
        arcsech: !0,
        arccoth: !0,
        nthroot: !0
    };
    function Ub(e, t) {
        return e.isComplexEnabled() && t in V$ ? Um[t] : t
    }
    function Hm(e) {
        return !!ir[e]
    }
    function Py(e, t) {
        let n = Pp(t) ? qa[t] : void 0;
        if (!n && !Hm(t))
            return;
        let r = [];
        return n && (r = [...n.getSignatures(e)]),
        Hm(t) && !n && r.push(...TM(t)),
        r
    }
    function TM(e) {
        var o;
        let t = []
          , n = ir[e]
          , r = (o = n.returnType) != null ? o : b;
        switch (n.tag) {
        case "reducer":
            {
                if (Array.isArray(n.argumentTypes) && typeof n.argumentTypes[0] == "number" && X(n.argumentTypes[0]) && typeof r == "number" && jn(r)) {
                    let i = n.argumentTypes[0]
                      , s = Qe(i);
                    t.push(...Jn(s))
                } else
                    throw new Error(`Programming error: declared argumentTypes for built-in function ${e} is not consistent with "reducer"`);
                break
            }
        case "parameterizedReducer":
            {
                if (t.push(St(n.argumentTypes)),
                Array.isArray(n.argumentTypes) && n.argumentTypes.length === 2) {
                    let i = n.argumentTypes[1];
                    t.push(St([n.argumentTypes[0], typeof i == "number" && jn(i) ? Fr(i) : i]))
                }
                break
            }
        case "doubleReducer":
        case "never-broadcast":
            {
                t.push(St(n.argumentTypes));
                break
            }
        default:
            {
                t.push(St(n.argumentTypes.map(i => yh(i) ? Fr(i) : i)));
                break
            }
        }
        return t
    }
    var ze = class extends Z {
        constructor(t) {
            super([]),
            this._symbol = Bs(t),
            this._errorSymbol = this._symbol,
            this.addDependency(this._symbol)
        }
        setInputSpan(t) {
            super.setInputSpan(t),
            this._errorSymbol = Bs(this.getInputString())
        }
        getInputSpan() {
            return this._inputSpan === void 0 ? Ci(this._symbol, 0, this._symbol.length) : this._inputSpan
        }
    }
      , dn = class extends ze {
        constructor() {
            super(...arguments);
            this.type = "Identifier"
        }
    }
    ;
    var _n = class extends Z {
        constructor(t, n) {
            super(n, {
                skipRegisterDependencies: !0
            }),
            typeof t == "string" && (t = new dn(t)),
            this._identifier = t,
            this._symbol = t._symbol,
            this._errorSymbol = t._errorSymbol === "logbase" ? "log" : t._errorSymbol,
            this.registerDependencies()
        }
        registerDependencies() {
            this.addDependency(this._symbol),
            super.registerDependencies(),
            ol(this._symbol) && this.addDependency("trigAngleMultiplier")
        }
    }
      , Qn = class extends _n {
        constructor() {
            super(...arguments);
            this.type = "FunctionCall"
        }
    }
    ;
    var Gs = class extends Z {
        slot(t) {
            return this.args[t]
        }
    }
      , il = class extends Gs {
        constructor() {
            super(...arguments);
            this.type = "ParenSeq"
        }
    }
    ;
    var IM = {
        pi: new Vn(Math.PI),
        tau: new Vn(2 * Math.PI),
        e: new Vn(Math.E),
        trigAngleMultiplier: new Vn(be(1, 1)),
        infty: new Vn(1 / 0),
        identityTransformation: new Qn("translation",[new il([new Vn(0), new Vn(0)])])
    };
    var Sp = class extends ct {
        constructor() {
            super(...arguments);
            this.type = "Placeholder"
        }
    }
    ;
    var Ep, rt = {};
    for (Ep of ue(IM))
        rt[Ep] = IM[Ep];
    for (Ep of ue(ir))
        rt[Ep] = new Sp;
    for (Ep of ue(qa))
        rt[Ep] = new Sp;
    var km = class extends ct {
        constructor(n, r) {
            super();
            this.type = "AssignmentImport";
            this._symbol = n,
            this._importFrom = r,
            this._exports = [n]
        }
    }
    ;
    var ro = {
        "<": {
            inclusive: !1,
            direction: -1
        },
        "!=": {
            inclusive: !1,
            direction: 0
        },
        ">": {
            inclusive: !1,
            direction: 1
        },
        "<=": {
            inclusive: !0,
            direction: -1
        },
        "=": {
            inclusive: !0,
            direction: 0
        },
        ">=": {
            inclusive: !0,
            direction: 1
        }
    };
    function sl(e, t) {
        switch (t) {
        case -1:
            return e ? "<=" : "<";
        case 0:
            return e ? "=" : "!=";
        case 1:
            return e ? ">=" : ">";
        default:
            throw "Programming error.  Comparators must have a direction of -1, 0, or 1"
        }
    }
    var Jo = class extends Z {
        constructor() {
            super(...arguments);
            this.type = "Subtract"
        }
    }
    ;
    var bo = class extends Z {
        constructor(n, r) {
            super(r);
            this.operator = n;
            this._difference = ro[this.operator].direction === -1 ? new Jo([r[1], r[0]]) : new Jo([r[0], r[1]])
        }
        asComparator() {
            return this
        }
        isInequality() {
            return ro[this.operator].direction !== 0
        }
    }
      , Ey = class extends bo {
        constructor(n) {
            super("<", n);
            this.type = "Comparator['<']"
        }
    }
      , Cy = class extends bo {
        constructor(n) {
            super("<=", n);
            this.type = "Comparator['<=']"
        }
    }
      , vy = class extends bo {
        constructor(n) {
            super(">", n);
            this.type = "Comparator['>']"
        }
    }
      , My = class extends bo {
        constructor(n) {
            super(">=", n);
            this.type = "Comparator['>=']"
        }
    }
      , za = class extends bo {
        constructor(n) {
            super("=", n);
            this.type = "Comparator['=']"
        }
    }
    ;
    function kb(e, t) {
        switch (e) {
        case ">":
            return new vy(t);
        case "<":
            return new Ey(t);
        case ">=":
            return new My(t);
        case "<=":
            return new Cy(t);
        case "=":
            return new za(t);
        default:
            throw new Error(`Unsupported operator ${e}`)
        }
    }
    var al = class extends ct {
        constructor(n, r) {
            super();
            this.type = "Equation";
            this.mergeDependencies(n, r),
            this._lhs = n,
            this._rhs = r,
            this._difference = new Jo([this._lhs, this._rhs])
        }
        asComparator() {
            return new za([this._lhs, this._rhs])
        }
    }
    ;
    var _r = class extends ct {
        constructor(n, r, o, i) {
            super();
            this.recursionInfo = i;
            this.type = "FunctionDefinition";
            this.externalBaseCases = [];
            this._symbol = n._symbol,
            this._argSymbols = r.map(s => s._symbol);
            for (let s of this._argSymbols)
                if (s === this._symbol)
                    throw _C(s);
            this._exports = [this._symbol],
            this._expression = o,
            this.mergeDependenciesInScope("FunctionDefinition", [this._symbol].concat(this._argSymbols), this._expression, {
                functionDefinitionSymbol: this._symbol
            }),
            this.combinedDependencies = super.getDependencies()
        }
        getDependencies() {
            return this.combinedDependencies
        }
        setExternalBaseCases(n) {
            this.externalBaseCases = [...n],
            this.combinedDependencies = [...super.getDependencies()];
            for (let r of n) {
                let o = r.getRef();
                o && this.combinedDependencies.push(o)
            }
        }
        getExternalBaseCases() {
            return this.externalBaseCases
        }
        getSliderVariables(n, r) {
            let o = this._argSymbols;
            return super.getSliderVariables(n, r).filter(i => o.indexOf(i) === -1)
        }
        asEquation() {
            let n = this._argSymbols.map(o => new dn(o))
              , r = new al(new Qn(new dn(this._symbol),n),this._expression);
            return r.userData = this.userData,
            r.metaData = this.metaData,
            r
        }
    }
    ;
    var xo = class e extends ct {
        constructor(n, r, o, i, s) {
            super();
            this.specifiedArg = o;
            this.rhs = i;
            this.originalNode = s;
            this.type = "RecursiveFunctionBaseCase";
            if (this._symbol = n,
            this._argSymbols = r.map(a => a._symbol),
            this._expression = i,
            this.userData = s.userData,
            this.metaData = s.metaData,
            this._inputSpan = s._inputSpan,
            this.mergeDependenciesInScope("FunctionDefinition", this._argSymbols, this._expression, {
                functionDefinitionSymbol: this._symbol
            }),
            o.valid) {
                let a = o.functionDefArgSymbols.slice();
                a[o.argIndex] = o.argValue.toString(),
                this.ref = `_base_case:${n}:${a.join(",")}`,
                this._exports = [this.ref]
            } else {
                let a = this._exports.find(u => u.indexOf("idref") !== -1);
                a && (this.ref = a)
            }
        }
        static fromCallAssignment(n, r) {
            let o = r._lhs;
            if (!(o instanceof _n))
                return;
            let i = n[o._symbol];
            if (!i || !(i instanceof _r))
                return;
            if (o.args.length !== i._argSymbols.length)
                return new e(i._symbol,[],{
                    valid: !1,
                    error: VS(i._symbol, i._argSymbols.length)
                },r._rhs,r);
            let s, a = [];
            for (let u = 0; u < o.args.length; u++) {
                let c = o.args[u];
                if (c instanceof Hn) {
                    if (s) {
                        s = {
                            valid: !1,
                            error: Wf()
                        };
                        break
                    }
                    s = {
                        valid: !0,
                        argIndex: u,
                        functionDefArgSymbols: i._argSymbols,
                        argValue: c.asValue(),
                        argSymbol: i._argSymbols[u]
                    }
                } else if (c instanceof ze)
                    if (c._symbol !== i._argSymbols[u]) {
                        s = {
                            valid: !1,
                            error: Kh()
                        };
                        break
                    } else
                        a.push(c);
                else {
                    s = {
                        valid: !1,
                        error: Kh()
                    };
                    break
                }
            }
            if (s)
                return new e(i._symbol,a,s,r._rhs,r)
        }
        getRef() {
            return this.ref
        }
        getSliderVariables(n, r) {
            let o = this._argSymbols;
            return super.getSliderVariables(n, r).filter(i => o.indexOf(i) === -1)
        }
    }
    ;
    $r();
    $r();
    var $m = class extends ct {
        constructor(n, r, o, i, s) {
            super();
            this.type = "OptimizedRegression";
            this.parameters = n,
            this.residuals = r,
            this.statistics = o,
            this.model = i,
            this.isModelValid = s.isModelValid,
            this.residualVariable = s.residualVariable,
            this.residualSuggestionId = s.residualSuggestionId,
            this.shouldSuggestLogMode = s.shouldSuggestLogMode,
            this.isLinear = s.isLinear,
            this.parameterWarning = s.parameterWarning,
            this.displayPrecision = s.displayPrecision,
            this.scaleFactors = s.scaleFactors,
            this._exports = [this.residualVariable];
            for (let a of ue(n))
                this._exports.push(a);
            this.mergeDependencies(i)
        }
        getCompiledFunction() {
            return this.model.getCompiledFunction.apply(this.model, arguments)
        }
        getCompiledDerivative() {
            return this.model.getCompiledDerivative.apply(this.model, arguments)
        }
    }
    ;
    var ul = class extends ct {
        constructor(n, r) {
            super();
            this._symbol = n;
            this._optimizedRegression = r;
            this.type = "RegressionParameter"
        }
        asValue() {
            return this._optimizedRegression.parameters[this._symbol].asValue()
        }
        asCompilerValue() {
            return this._optimizedRegression.parameters[this._symbol].asCompilerValue()
        }
    }
    ;
    function wA(e) {
        let t = 1 / 0;
        for (let n = 0; n < e.length; n++)
            (e[n].isList || e[n].isBroadcast) && (t = Math.min(t, e[n].length));
        return t
    }
    var Yi = class extends Z {
        constructor(n) {
            super(n);
            this.isList = !0;
            this.length = n.length
        }
        elementAt(n) {
            if (n = Math.floor(n),
            n >= 0 && n < this.args.length)
                return this.args[n];
            throw new Error("Out of bounds list access")
        }
        eachElement(n) {
            for (let r = 0; r < this.length; r++)
                n(this.elementAt(r), r)
        }
        mapElements(n) {
            let r = [];
            for (let o = 0; o < this.length; o++)
                r.push(n(this.elementAt(o), o));
            return r
        }
        asValue() {
            let n = [];
            for (let r = 0; r < this.args.length; r++)
                n.push(this.args[r].asValue());
            return n
        }
        asCompilerValue() {
            let n = [];
            for (let r = 0; r < this.args.length; r++)
                n.push(this.args[r].asCompilerValue());
            return n
        }
    }
      , Dy = class Dy extends Yi {
        constructor() {
            super(...arguments);
            this.type = "List"
        }
    }
    ;
    Dy.eachArgs = function(n, r) {
        let o = wA(n);
        if (!isFinite(o)) {
            r(n);
            return
        }
        for (let i = 0; i < o; i++) {
            let s = [];
            for (let a = 0; a < n.length; a++)
                s.push(PM(n[a]) || X(n[a].valueType) ? n[a].elementAt(i) : n[a]);
            r(s, i)
        }
    }
    ,
    Dy.wrap = function(n) {
        return n instanceof Yi || X(n.valueType) ? n : new Dy([n])
    }
    ;
    var Zm = Dy
      , Ym = class Ym extends Yi {
        constructor() {
            super(...arguments);
            this.type = "List"
        }
    }
    ;
    Ym.eachArgs = function(n, r) {
        let o = wA(n);
        if (!isFinite(o)) {
            r(n);
            return
        }
        for (let i = 0; i < o; i++) {
            let s = [];
            for (let a = 0; a < n.length; a++)
                s.push(PM(n[a]) || X(n[a].valueType) ? n[a].elementAt(i) : n[a]);
            r(s, i)
        }
    }
    ,
    Ym.wrap = function(n) {
        return n instanceof Ym || X(n.valueType) ? n : new Ym([n])
    }
    ;
    var Vo = Ym;
    function _y(e) {
        return (e == null ? void 0 : e.type) === "FunctionDefinition"
    }
    function cl(e) {
        return (e == null ? void 0 : e.type) === "Placeholder" || (e == null ? void 0 : e.type) === "FunctionDefinition"
    }
    function Ha(e) {
        return e.type === "Identifier"
    }
    function Vu(e) {
        return e.type === "Table"
    }
    function $b(e) {
        return e.type === "Image"
    }
    function To(e) {
        return e.type === "Error"
    }
    function ss(e) {
        return e.type === "Regression"
    }
    function bc(e) {
        return e.type === "TableColumn"
    }
    function Bu(e) {
        return e.type === "TableColumnValue"
    }
    function Xm(e) {
        return e.type === "IRExpression" || e instanceof Yi
    }
    function PM(e) {
        return Xm(e) && e.isList
    }
    function Yb(e) {
        return (e == null ? void 0 : e.type) === "Constant" || (e == null ? void 0 : e.type) === "IRExpression" && (e == null ? void 0 : e.isConstant)
    }
    function Wm(e) {
        return (e == null ? void 0 : e.type) === "MixedNumber" || Yb(e)
    }
    function qs(e) {
        return e.type === "MovablePoint" || e.type === "MovableComplexNumber" || e.type === "IRExpression" && e.isTypedConstant
    }
    function Zb(e) {
        return (e == null ? void 0 : e.type) === "MovableComplexNumber" || (e == null ? void 0 : e.type) === "MovablePoint"
    }
    var jm = class extends ct {
        constructor(n, r) {
            super();
            this.type = "Regression";
            this.isRegression = !0;
            this.tableRegressionData = void 0;
            this._lhs = n,
            this.isLhsSimple = n instanceof ze,
            this._logLhs = new Qn("ln",[n]),
            this._rhs = r,
            this._difference = new Jo([n, r]),
            this._logDifference = new Jo([new Qn("ln",[n]), new Qn("ln",[r])]),
            this.mergeDependencies(n, r)
        }
        getExportsFromConcrete(n, r) {
            if (To(r))
                return [];
            let o = [];
            for (let i of ue(r.parameters))
                n.assignmentForbidden(i) || o.push(i);
            return n.assignmentForbidden(r.residualVariable) || o.push(r.residualVariable),
            o
        }
        exportTo(n, r, o) {
            if (r.type === "Error")
                return [];
            if (!(r instanceof $m))
                throw F(`Expected optimized regression but got ${r.type}.`);
            let i = [];
            for (let s of ue(r.parameters))
                n.assignmentForbidden(s) || (i.push(s),
                o[s] = o[s] ? sy(s) : new ul(s,r));
            return n.assignmentForbidden(r.residualVariable) ? [] : (o[r.residualVariable] = r.residuals,
            i.push(r.residualVariable),
            i)
        }
        getSliderVariables() {
            return []
        }
    }
    ;
    var Xb = class extends ct {
        constructor(n, r, o, i) {
            super();
            this.calcColumns = r;
            this.regression = o;
            this.type = "Table";
            this.exportPenalty = 1;
            this.isTable = !0;
            this.columns = n,
            this.mergeDependencies.apply(this, n),
            this.tableFrameID = i
        }
        getExports() {
            return []
        }
        getColumnIdsForGraphing() {
            return this.columns.map(n => n.userData.id)
        }
        getColumnStatementIds() {
            return this.calcColumns.map(n => n.userData.id)
        }
        getRegressionId() {
            var n;
            return (n = this.regression) == null ? void 0 : n.userData.id
        }
        columnIsViewportDependency(n) {
            return this.calcColumns[n].isViewportDependency
        }
        isValueDraggable(n, r, o) {
            if (n.columns[r].type !== "TableColumnValue" || !n.columns[r].isIndependent)
                return !1;
            let s = this.calcColumns[r].values
              , a = s && s[o]
              , u = a && a.asValue();
            return !!(typeof u == "number" && isFinite(u) && a.getDependencies().length === 0)
        }
    }
      , Gu = class extends Xb {
    }
      , Wb = class extends Xb {
    }
    ;
    var sa = class extends ct {
        constructor(n, r, o, i) {
            super();
            this.tableID = o;
            this.columnIndex = i;
            this.type = "TableColumn";
            this.headerDependencies = new Set;
            this.cellDependencies = new Set;
            this.length = 0;
            this.isViewportDependency = !1;
            this.header = n,
            this.values = r,
            this.registerDependencies(),
            this._exports = this.computeExports(),
            this.tableFrameID = o
        }
        registerDependencies() {
            this.mergeDependencies(this.header),
            this.mergeDependencies.apply(this, this.values);
            for (let n of this.header.getDependencies())
                this.headerDependencies.add(n);
            for (let n of this.header.getOptionalDependencies())
                this.headerDependencies.add(n);
            for (let n of this.values) {
                for (let r of n.getDependencies())
                    this.cellDependencies.add(r);
                for (let r of n.getOptionalDependencies())
                    this.cellDependencies.add(r)
            }
        }
        computeExports() {
            return this.header instanceof ze ? [this.header._symbol] : []
        }
        _exportSymbolsTo(n, r, o) {
            if (n.length === 0)
                return n;
            let i = this.getExportValue(r, o);
            this.header instanceof ze && !this.isFreeVariable(o) && (n = n.filter(s => s !== this.header._symbol));
            for (let s of n)
                o.hasOwnProperty(s) || (o[s] = i);
            return n
        }
        getExportValue(n, r) {
            return this.isFreeVariable(r) || n.type === "Error" && n.blocksExport ? n : this.header
        }
        isFreeVariable(n) {
            if (!(this.header instanceof ze))
                return !1;
            let r = Gn(this.tableFrameID, this.header._symbol);
            return !!Iy(n).assignmentMaps.assignments.get(r)
        }
        exportTo(n, r, o) {
            let i = this.getLegalExports(n);
            return this._exportSymbolsTo(i, r, o)
        }
        exportToLocal(n, r, o) {
            this._exportSymbolsTo(this.getExports(n), r, o)
        }
    }
    ;
    var Qb = "dcg_viewport"
      , jb = class extends ct {
        constructor(n) {
            super();
            this.type = "Viewport";
            this.bounds = n,
            this.mergeDependencies(this.bounds.xmin),
            this.mergeDependencies(this.bounds.xmax),
            this.mergeDependencies(this.bounds.ymin),
            this.mergeDependencies(this.bounds.ymax),
            this.bounds.zmin && this.mergeDependencies(this.bounds.zmin),
            this.bounds.zmax && this.mergeDependencies(this.bounds.zmax),
            this._exports = [Qb]
        }
    }
      , Jm = class extends jb {
    }
      , Jb = class extends jb {
    }
    ;
    function LA(e) {
        let t = [];
        for (let n of e.assignmentMaps.assignments.keys())
            n.symbol.startsWith("idref_") || t.push(n);
        return {
            allDefinedQualifiedNames: t,
            multiplyDefined: [...e.assignmentMaps.multiplyDefined]
        }
    }
    function Kb({statement: e, moduleID: t}) {
        return e instanceof xo ? {
            type: 2
        } : _y(e) ? {
            type: 1,
            directlyDependsOnSelf: e._expression.getDependencies().includes(e._symbol),
            fnName: Gn(t, e._symbol)
        } : {
            type: 0
        }
    }
    function G$(e, t, n) {
        let {statement: r, id: o, moduleID: i} = t;
        if (r instanceof jm) {
            let s = n == null ? void 0 : n.get(o);
            if (s)
                return {
                    type: "simple",
                    meta: Kb(t),
                    exports: s,
                    dependencies: []
                }
        }
        if (r instanceof sa) {
            if (r.tableFrameID === void 0)
                throw new Error("Programming Error: TableColumn missing tableFrameID.");
            let s = r.header instanceof ze ? Gn(r.tableFrameID, r.header._symbol) : void 0
              , a = sM(r.tableFrameID, r.headerDependencies)
              , u = sM(r.tableFrameID, r.cellDependencies);
            return {
                type: "table-column",
                meta: Kb(t),
                exports: {
                    moduleID: i,
                    moduleExports: Ty(i, r.getLegalExports(e)),
                    tableExports: Ty(r.tableFrameID, r.getExports(e))
                },
                dependencies: {
                    headerIdent: s,
                    headerDependencies: a,
                    cellDependencies: u
                }
            }
        }
        return r instanceof km ? {
            type: "simple",
            meta: Kb(t),
            exports: [Gn(i, r._symbol)],
            dependencies: [r._importFrom]
        } : {
            type: "simple",
            isViewport: r instanceof Jm,
            meta: Kb(t),
            exports: Ty(i, r.getLegalExports(e)),
            dependencies: q$(t)
        }
    }
    function q$({statement: e, moduleID: t}) {
        if (e instanceof Gu) {
            let r = [];
            for (let o of e.getColumnStatementIds())
                r.push(Gn(e.tableFrameID, `idref_${o}`));
            for (let o of e.getDependencies())
                r.push(Gn(e.tableFrameID, o));
            return r
        }
        let n = ss(e) && e.tableRegressionData ? e.tableRegressionData.tableId : t;
        return Ty(n, e.getDependencies())
    }
    function Ry(e, t, n, r) {
        let o = z$(e, t, r)
          , i = e.parentFrameMap
          , s = H$(o, i);
        return U$(e, o, s, n)
    }
    function z$(e, t, n) {
        let r = {};
        for (let o of t.values()) {
            let i = G$(e.getPolicyContext(o.moduleID).policy, o, n);
            r[o.id] = i
        }
        return r
    }
    function SM(e, t, n) {
        var o, i;
        let r = e.assignments.getOrInsert(t, []);
        r.push(n),
        r.length > 1 && e.multiplyDefined.add(t),
        (i = (o = e.resolvedExports)[n]) != null || (o[n] = []),
        e.resolvedExports[n].push(t)
    }
    function H$(e, t) {
        let n = new Ip
          , r = new ho
          , o = {
            assignments: n,
            resolvedExports: {},
            resolvedDependencies: {},
            parentFrameMap: t,
            multiplyDefined: r
        }
          , i = new ho;
        for (let s of ue(e)) {
            let a = e[s];
            if (a.type === "simple") {
                for (let u of a.exports)
                    rt[u.symbol] || (i.add(u),
                    SM(o, u, s));
                o.resolvedDependencies[s] = a.dependencies
            }
        }
        for (let s of ue(e)) {
            let a = e[s];
            if (a.type !== "table-column")
                continue;
            for (let l of a.exports.moduleExports)
                rt[l.symbol] || i.has(l) || SM(o, l, s);
            for (let l of a.exports.tableExports) {
                let p = Gn(a.exports.moduleID, l.symbol);
                rt[l.symbol] || i.has(p) || SM(o, l, s)
            }
            let u = a.dependencies
              , c = u.headerIdent && o.assignments.get(u.headerIdent);
            o.resolvedDependencies[s] = c ? u.cellDependencies : u.headerDependencies
        }
        return o
    }
    function FA(e, t) {
        let {assignments: n, parentFrameMap: r} = e;
        for (; ; ) {
            let o = n.get(t);
            if (o)
                return o;
            let i = r.get(t.frameID);
            if (!i)
                return [];
            t = Gn(i, t.symbol)
        }
    }
    function U$(e, t, n, r) {
        let o = []
          , i = new Set
          , s = {}
          , a = new ho
          , u = {}
          , c = 0
          , l = []
          , p = [];
        for (let f of r)
            u.hasOwnProperty(f) || m(f);
        function m(f) {
            u[f] = u[f] || {};
            let h = u[f], x;
            h.id = f,
            h.index = c,
            h.lowlink = c,
            l.push(h),
            h.instack = !0,
            c++;
            let T = n.resolvedDependencies[f];
            for (let P of T) {
                let C = FA(n, P);
                for (let S of C)
                    u.hasOwnProperty(S) ? (x = u[S],
                    x.instack && (h.lowlink = Math.min(h.lowlink, x.index))) : (m(S),
                    x = u[S],
                    h.lowlink = Math.min(h.lowlink, x.lowlink))
            }
            if (h.lowlink === h.index)
                if (x = l.pop(),
                x.instack = !1,
                x === h)
                    d(h.id);
                else {
                    let P = [x.id];
                    for (; x = l.pop(),
                    x.instack = !1,
                    P.push(x.id),
                    x !== h; )
                        ;
                    y(P)
                }
        }
        function d(f) {
            p.push(f);
            let h = t[f];
            if (h.meta.type === 1) {
                let x = h.meta.fnName;
                !e.getPolicyContextForFrame(x.frameID).policy.assignmentForbidden(x.symbol) && h.meta.directlyDependsOnSelf && !n.multiplyDefined.has(x) && (s[f] = [f],
                a.add(x))
            }
        }
        function y(f) {
            let h = []
              , x = !0
              , T = []
              , P = new Set;
            for (let C = f.length - 1; C >= 0; C--) {
                let S = f[C]
                  , E = t[S];
                for (let M of n.resolvedExports[S])
                    h.push(M);
                P.add(S),
                p.push(S),
                E.meta.type === 1 && !n.multiplyDefined.has(E.meta.fnName) ? T.push(S) : x = !1,
                E.meta.type === 2 && i.add(S)
            }
            if (x) {
                for (let C of [...P])
                    s[C] = T;
                for (let C of h)
                    a.add(C)
            }
            o.push(h)
        }
        let g = new Set;
        for (let[f,h] of zR(t))
            if (h.type === "simple" && h.isViewport && n.resolvedDependencies[f]) {
                let x = k$(n, f);
                for (let T of x)
                    g.add(T)
            }
        return {
            resolved: p,
            cycles: o,
            recursiveFunctionGroups: s,
            recursiveFunctionSymbols: a,
            recursiveFunctionBaseCasesWithCycles: i,
            assignmentMaps: n,
            viewportTransitiveDependencies: g
        }
    }
    function k$(e, t) {
        let n = new Set
          , r = [t];
        for (; r.length > 0; ) {
            let o = r.pop()
              , i = e.resolvedDependencies[o];
            for (let s of i) {
                let a = FA(e, s);
                for (let u of a)
                    n.has(u) || (n.add(u),
                    r.push(u))
            }
        }
        return n
    }
    var Qm = class extends Z {
        constructor() {
            super(...arguments);
            this.type = "Add"
        }
    }
    ;
    var ex = class extends ze {
        constructor() {
            super(...arguments);
            this.type = "Ans"
        }
    }
    ;
    var Ln = class extends ct {
        constructor(t, n) {
            super(),
            t instanceof ze ? this._symbol = t._symbol : this._symbol = t,
            this.mergeDependencies(n),
            this._expression = n,
            this._exports = this.computeExports()
        }
        shouldExportAns() {
            return !0
        }
        computeExports() {
            let t = this._symbol
              , n = this.getDependencies();
            for (let r = 0; r < n.length; r++)
                if (n[r] === t)
                    return [];
            return [t]
        }
        isEquation(t, n) {
            let r = this._symbol
              , o = r === "x" || r === "y"
              , i = r === "r" || r === "z"
              , s = r === "rho"
              , a = n.getDependencies()
              , u = this.graphmodeDependencies(t, n);
            return s || i || o && a.includes("z") ? u.includes(r) : a.includes(r)
        }
        asEquation() {
            let t = new al(new dn(this._symbol),this._expression);
            return t.userData = this.userData,
            t.metaData = this.metaData,
            t
        }
        shouldPromoteToSlider(t) {
            if (this._expression.type !== "Constant")
                return !1;
            let n = this._expression.asValue();
            return typeof n != "number" || !isFinite(n) ? !1 : t.isValidSlider(this._symbol)
        }
    }
      , Km = class extends Ln {
        constructor() {
            super(...arguments);
            this.type = "Assignment"
        }
    }
    ;
    var Cp = class extends Z {
        constructor(n) {
            super(n);
            this.type = "AssignmentExpression";
            this._symbol = n[0]._symbol,
            this._lhs = n[0],
            this._rhs = n[1]
        }
    }
    ;
    var ll = class extends Z {
        constructor() {
            super(...arguments);
            this.type = "BareSeq"
        }
    }
    ;
    var ed = class extends Z {
        constructor() {
            super(...arguments);
            this.type = "BoxPlot";
            this._symbol = "boxplot"
        }
    }
    ;
    var Io = class extends Z {
        constructor() {
            super(...arguments);
            this.type = "Piecewise"
        }
    }
    ;
    function $$(e, t) {
        let n = ro[e[0]].direction === -1 ? new Jo([t[1], t[0]]) : new Jo([t[0], t[1]]);
        switch (e.length) {
        case 0:
            throw new Error("Programming Error: ComparatorChain must have at least one comparator");
        case 1:
            return n;
        default:
            return new Io([new pl(e.slice(1),t.slice(1)), n, new Vn(NaN)])
        }
    }
    var pl = class e extends Z {
        constructor(n, r) {
            super(r);
            this.symbols = n;
            this.type = "ComparatorChain";
            if (n.length < 1)
                throw "Programming Error: ComparatorChain must have at least one comparator.";
            if (r.length !== n.length + 1)
                throw "Programming Error: ComparatorChain must have one more arg than symbols";
            if (n.includes("=") && !n.every(o => o === "="))
                throw XS()
        }
        getRestrictedDifference() {
            return $$(this.symbols, this.args)
        }
        isInequality() {
            return !this.symbols.includes("=")
        }
        withArgsCoerced() {
            let n = new e(this.symbols,this.args.map(r => new Qn("coerceToReal",[r])));
            return n.userData = this.userData,
            n.metaData = this.metaData,
            n
        }
    }
    ;
    var vp = class extends Z {
        constructor(n) {
            let r = n.map(o => new dn("\\idref_{" + o + "}"));
            super(r);
            this.constructedObjectIds = n;
            this.type = "Construction";
            this._exports.push("construction")
        }
    }
    ;
    var td = class extends Z {
        constructor() {
            super(...arguments);
            this.type = "CrossMultiply"
        }
    }
    ;
    var Mp = class extends Z {
        constructor(n, r) {
            super(r);
            this.type = "Derivative";
            n instanceof ze ? this._symbol = n._symbol : this._symbol = new dn(n)._symbol,
            this.addDependency(this._symbol)
        }
    }
    ;
    var nd = class extends Z {
        constructor() {
            super(...arguments);
            this.type = "Divide"
        }
    }
    ;
    var Qo = class extends Z {
        constructor() {
            super(...arguments);
            this.type = "DotAccess"
        }
        registerDependencies() {
            if (super.registerDependencies(),
            this.args[1]instanceof ze) {
                let n = this.args[1]._symbol;
                ol(n) && this.addDependency("trigAngleMultiplier")
            }
        }
    }
    ;
    var ml = class extends Z {
        constructor() {
            super(...arguments);
            this.type = "DotMultiply"
        }
    }
    ;
    var rd = class extends Z {
        constructor() {
            super(...arguments);
            this.type = "DotPlot";
            this._symbol = "dotplot"
        }
    }
    ;
    var tx = class extends ct {
        constructor(n) {
            super();
            this.type = "DoubleInequality";
            let[r,o,i,s,a] = n;
            this.args = n,
            this._symbol = i._symbol,
            this._operators = [o, s],
            this._expressions = [r, a];
            let u = sl(ro[o].inclusive && ro[n[3]].inclusive, ro[n[1]].direction);
            this._indicator = kb(u, [new Qn("coerceToReal",[n[0]]), new Qn("coerceToReal",[n[4]])]),
            this.addDependency(this._symbol),
            this.mergeDependencies(this._expressions[0], this._expressions[1])
        }
        isInequality() {
            return !0
        }
        isShadeBetween() {
            return !0
        }
    }
      , nx = class extends tx {
    }
      , od = class extends tx {
    }
    ;
    var Ny = class extends Z {
    }
      , id = class extends Ny {
        constructor() {
            super(...arguments);
            this.type = "Exponent"
        }
    }
    ;
    var Dp = class extends Z {
        constructor(n, r) {
            super(r);
            this.type = "ExtendSeed";
            this.seed = r[0],
            this.userSeed = r[1],
            this.tag = n
        }
        asValue() {
            return this.seed.asValue() + "::" + this.tag + this.userSeed.asValue()
        }
    }
    ;
    var dl = class extends Z {
        constructor() {
            super(...arguments);
            this.type = "FunctionExponent"
        }
        registerDependencies() {
            if (super.registerDependencies(),
            this.args[0].type === "Identifier") {
                let n = this.args[0]._symbol;
                ol(n) && this.addDependency("trigAngleMultiplier")
            }
        }
    }
    ;
    var fl = class extends Z {
        constructor() {
            super(...arguments);
            this.type = "FunctionFactorial"
        }
        registerDependencies() {
            if (this.addDependency("factorial"),
            super.registerDependencies(),
            this.args[0].type === "Identifier") {
                let n = this.args[0]._symbol;
                ol(n) && this.addDependency("trigAngleMultiplier")
            }
        }
    }
    ;
    var sd = class extends Z {
        constructor() {
            super(...arguments);
            this.type = "Histogram";
            this._symbol = "histogram"
        }
    }
    ;
    var rx = class extends ct {
        constructor(n) {
            super();
            this.type = "Image";
            this.isImage = !0;
            this.center = n.center,
            this.radianAngle = n.radianAngle,
            this.width = n.width,
            this.height = n.height,
            this.opacity = n.opacity,
            this.mergeDependencies(this.center, this.radianAngle, this.width, this.height, this.opacity)
        }
    }
      , ox = class extends rx {
    }
      , ad = class extends rx {
        constructor(t) {
            super(t)
        }
    }
    ;
    var ud = class extends Z {
        constructor(n) {
            super(n, {
                skipRegisterDependencies: !0
            });
            this.type = "Integral";
            this._differential = n[0],
            this.registerDependencies()
        }
        registerDependencies() {
            for (let n = 1; n <= 3; n++)
                this.mergeDependenciesInScope("Integral", [this._differential._symbol], this.args[n])
        }
    }
    ;
    $r();
    function Xr(e, t) {
        return Ua(ix(e, t))
    }
    function ix(e, t) {
        let n = e.getInstruction(t);
        switch (n.type) {
        case 1:
            return n.value;
        default:
            throw new Error(`Unexpected opcode ${n.type}.`)
        }
    }
    function Ua(e) {
        if (Array.isArray(e))
            return e.map(Ua);
        switch (typeof e) {
        case "boolean":
        case "number":
        case "string":
            return e;
        case "object":
            if (fc(e)) {
                let t = {};
                for (let n of ue(e.updateRules)) {
                    let r = e.updateRules[n];
                    t[n] = {
                        value: Ua(r.value),
                        valueType: r.valueType
                    }
                }
                return {
                    type: "Action",
                    updateRules: t
                }
            } else
                return L(e);
        default:
            throw new Error(`Unexpected value: ${e}`)
        }
    }
    function cd(e) {
        return X(e.valueType)
    }
    function VA(e) {
        return e.type <= 3
    }
    function BA(e) {
        return e.type === 4
    }
    function de(e) {
        return e.type >= 8
    }
    function Po(e) {
        switch (e.type) {
        case 21:
        case 23:
        case 19:
        case 50:
        case 53:
            return !0;
        default:
            return !1
        }
    }
    function Bo(e) {
        switch (e.type) {
        case 20:
        case 22:
        case 24:
        case 51:
        case 54:
            return !0;
        default:
            return !1
        }
    }
    function sx(e) {
        switch (e.type) {
        case 20:
        case 22:
        case 24:
        case 51:
            return !0;
        default:
            return !1
        }
    }
    function oo(e, t) {
        let n = new Array(t);
        for (let o = 0; o < t; o++)
            n[o] = !1;
        n[t] = !0;
        let r = t;
        for (; r > 0; ) {
            r = 0;
            for (let o = t; o >= 0; o--) {
                if (!n[o])
                    continue;
                let i = e.getInstruction(o);
                if (de(i))
                    for (let s of e.getDirectDependencies(i))
                        s > o && !n[s] && s > r && (r = s),
                        n[s] = !0
            }
        }
        return n
    }
    function GA(e, t) {
        let n = new Array(t);
        for (let o = 0; o < t; o++)
            n[o] = !1;
        n[t] = !0;
        let r = t;
        for (; r > 0; ) {
            r = 0;
            for (let o = t; o >= 0; o--) {
                if (!n[o])
                    continue;
                let i = e.getInstruction(o);
                if (de(i))
                    if (i.type === 33)
                        n[i.args[1]] = !0,
                        n[i.args[2]] = !0;
                    else
                        for (let s of e.getDirectDependencies(i))
                            s > o && !n[s] && (r = s),
                            n[s] = !0
            }
        }
        return n
    }
    function Go(e, t) {
        var o;
        let n = []
          , r = [];
        for (let i = 0; i < t; i++)
            r.push(!1);
        r.push(!0);
        for (let i = t; i >= 0; i--) {
            if (!r[i])
                continue;
            let s = e.getInstruction(i);
            if (s.type === 2)
                n.push({
                    symbol: e.argNames[i],
                    scope: "free"
                });
            else if (Po(s))
                switch (s.type) {
                case 21:
                    n.push({
                        symbol: s.callData.indexSymbol,
                        scope: "integral"
                    });
                    break;
                case 19:
                    n.push({
                        symbol: s.callData.indexSymbol,
                        scope: s.callData.type
                    });
                    break;
                case 23:
                    if (((o = s.context) == null ? void 0 : o.type) === "list-comprehension")
                        for (let u of s.context.callData.inputListSymbols)
                            n.push({
                                symbol: u,
                                scope: "comprehension"
                            });
                    break;
                case 50:
                    for (let u of s.callData.parameterSymbols)
                        n.push({
                            symbol: u,
                            scope: "map"
                        });
                    break;
                case 53:
                    {
                        let u = e.getInstruction(s.args[0]);
                        for (let c of u.parameterSymbols)
                            n.push({
                                symbol: c,
                                scope: "recursive-function"
                            });
                        break
                    }
                default:
                    let a = s;
                    throw new Error(`Programming Error: unexpected loop instruction ${a.type}`)
                }
            else
                s.type === 3 && s.symbol && n.push({
                    symbol: s.symbol,
                    scope: "symbolic-var"
                });
            if (de(s))
                for (let a of e.getDirectDependencies(s))
                    r[a] = !0
        }
        return n.reverse()
    }
    function yl(e, t) {
        return qu(e, [t], 0, e.instructionsLength() - 1)
    }
    function qu(e, t, n, r) {
        let o = [];
        for (let s = n; s <= r; s++)
            o[s] = !1;
        for (let s of t)
            o[s] = !0;
        let i = Math.min(...t);
        for (let s = 0; s <= 1; s++) {
            let a = !1;
            for (let u = i + 1; u < e.instructionsLength(); u++) {
                let c = e.getInstruction(u);
                if (!de(c) || o[u])
                    continue;
                let l = !1;
                for (let p of e.getDirectDependencies(c))
                    if (o[p]) {
                        l = !0;
                        break
                    }
                if (o[u] = l,
                l && c.type === 20 && !o[c.args[0]]) {
                    let p = c.args[0]
                      , m = c.args.length - 1;
                    for (let d = 0; d < m; d++) {
                        let y = c.args[1 + d]
                          , g = p + 1 + d;
                        o[y] && (o[g] = !0,
                        a = !0)
                    }
                }
            }
            if (!a)
                break
        }
        return o
    }
    function qA(e) {
        if (e.isConstant())
            return;
        let t = [];
        for (let i = 0; i < e.getReturnIndex(); i++)
            e.getInstruction(i).type === 44 && t.push(i);
        if (t.length === 0)
            return;
        let n = oo(e, e.getReturnIndex())
          , r = [];
        for (let i = 0; i < e.argNames.length; i++)
            n[i] && r.push(i);
        let o = qu(e, r, 0, e.getReturnIndex());
        for (let i of t)
            if (n[i] && o[i])
                throw _v(Go(e, i))
    }
    function Br(e) {
        if (!xc(e))
            throw new Error("Programming error: expected an array but found " + typeof e)
    }
    function xc(e) {
        return Array.isArray(e)
    }
    function zA(e) {
        if (xc(e))
            for (let {compiled: t} of e)
                t && EM(t)
    }
    function Dne(e) {
        if (xc(e))
            for (let {compiled: t} of e)
                t && X$(t)
    }
    function EM(e) {
        delete e.fn
    }
    function X$(e) {
        e.fn = Oy(e.args, e.source, e.constants, e.executionMetadata)
    }
    function Oy(e, t, n, r) {
        let i = `var fn = (function(${e.join(",")}){"use strict"; ${t}});
fn.__meta = __meta;
return fn;
`;
        return new Function("BuiltIn","ErrorMsg","_C","__meta",i)(Lo, Et, n, r)
    }
    $r();
    function UA(e, t, n) {
        let r = ""
          , o = (e.instructionsLength() - 1).toString().length
          , i = 0
          , s = !1
          , a = oo(e, t);
        for (let u = 0; u < e.instructionsLength(); u++) {
            let c = e.getInstruction(u)
              , l = n.comments[u] || "";
            if (Bo(c) && (i -= 1),
            !a[u] && !n.printUnreferencedInstructions || c.type === 0)
                s || (r += `${HA(u, o)}: ${MM(2 * i)}...
`),
                s = !0;
            else {
                s = !1;
                let p = `${HA(u, o)}: ${MM(2 * i)}${_p(e, u)}`;
                l && (p += " ".repeat(Math.max(0, 36 - p.length)),
                p += `	# ${l}`),
                r += p + `
`
            }
            Po(c) && (i += 1)
        }
        return r
    }
    function _p(e, t) {
        let n = e.getInstruction(t);
        switch (n.type) {
        case 0:
            return So(n.type);
        case 2:
            return `${So(n.type)} ${Ke(n.valueType)} ${e.argNames[t]}`;
        case 3:
            return `${So(n.type)} ${Ke(n.valueType)}`;
        case 1:
            return `${So(n.type)} ${Ke(n.valueType)} ${vM(n.value)}`;
        case 37:
        case 42:
            return `${So(n.type)} ${Ke(n.valueType)} ${n.symbol} ${n.args.join(" ")}`;
        case 44:
            return `${So(n.type)} ${Ke(n.valueType)} ${n.tag} ${n.args.join(" ")}`;
        case 48:
            return `${So(n.type)} ${Ke(n.valueType)} ${n.args.join(" ")}`;
        case 16:
            return `${So(n.type)} ${Ke(n.valueType)} (${n.index}) ${n.args.join(" ")}`;
        case 50:
            return `${So(n.type)} ${Ke(n.valueType)} ${n.args.join(" ")} (${n.callData.parameterSymbols.join(",")})`;
        case 4:
            {
                let o = n.signature.argTypes.map(i => Ke(i)).join(", ");
                return `${So(n.type)} ${Ke(n.valueType)} ${n.symbol}(${o}) [group ${n.recursionGroup.join(" ")}]`
            }
        case 8:
        case 9:
        case 10:
        case 11:
        case 13:
        case 12:
        case 14:
        case 56:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 32:
        case 31:
        case 33:
        case 38:
        case 39:
        case 40:
        case 41:
        case 47:
        case 49:
        case 51:
        case 53:
        case 54:
        case 55:
        case 15:
            return `${So(n.type)} ${Ke(n.valueType)} ${n.args.join(" ")}`;
        default:
            let r = n;
            throw new Error(`Unexpected opcode ${r.type}`)
        }
    }
    function So(e) {
        switch (e) {
        case 0:
            return "Noop";
        case 1:
            return "Constant";
        case 8:
            return "Add";
        case 9:
            return "Subtract";
        case 10:
            return "Multiply";
        case 11:
            return "Divide";
        case 12:
            return "Exponent";
        case 13:
            return "RawExponent";
        case 14:
            return "Negative";
        case 56:
            return "Square";
        case 19:
            return "BeginLoop";
        case 20:
            return "EndLoop";
        case 21:
            return "BeginIntegral";
        case 22:
            return "EndIntegral";
        case 23:
            return "BeginBroadcast";
        case 24:
            return "EndBroadcast";
        case 25:
            return "Equal";
        case 26:
            return "Less";
        case 27:
            return "Greater";
        case 28:
            return "LessEqual";
        case 29:
            return "GreaterEqual";
        case 31:
            return "Or";
        case 32:
            return "And";
        case 33:
            return "Piecewise";
        case 38:
            return "List";
        case 39:
            return "ListAccess";
        case 40:
            return "DeferredListAccess";
        case 41:
            return "InboundsListAccess";
        case 37:
            return "NativeFunction";
        case 42:
            return "Distribution";
        case 2:
            return "LoadArg";
        case 47:
            return "BlockVar";
        case 48:
            return "BroadcastResult";
        case 3:
            return "SymbolicVar";
        case 44:
            return "ExtendSeed";
        case 49:
            return "Action";
        case 50:
            return "BeginMap";
        case 51:
            return "EndMap";
        case 4:
            return "FunctionHeader";
        case 53:
            return "BeginFunction";
        case 54:
            return "EndFunction";
        case 55:
            return "FunctionCall";
        case 15:
            return "Tuple";
        case 16:
            return "Slot";
        default:
            let t = e;
            throw new Error(`Unexpected opcode ${t.type}`)
        }
    }
    function vM(e) {
        if (Array.isArray(e))
            return `[${e.map(vM).join(",")}]`;
        switch (typeof e) {
        case "string":
            return e;
        case "boolean":
        case "number":
            return e.toString();
        case "object":
            if (fc(e)) {
                let t = [];
                for (let n of ue(e.updateRules))
                    t.push(`"${n}": ${vM(e.updateRules[n].value)}`);
                return `{${t.join(", ")}}`
            } else
                return `${e.n}/${e.d}`;
        default:
            throw new Error(`Unexpected value: ${e}`)
        }
    }
    function HA(e, t) {
        let n = e.toString();
        return MM(t - n.length) + n
    }
    function MM(e) {
        let t = "";
        for (let n = 0; n < e; n++)
            t += " ";
        return t
    }
    function On(e) {
        return `_${e}`
    }
    function ld(e) {
        return `_${e}_thunk_computed`
    }
    function pd(e) {
        return `_${e}_thunk_function`
    }
    function ax(e) {
        return `_${e}_next`
    }
    function kA(e) {
        return `_${e}_next1`
    }
    function DM(e, t) {
        return `_${e}_${t}`
    }
    function _M(e) {
        return `_${e}_inner`
    }
    function $A(e) {
        return `_${e}_cache`
    }
    function YA(e) {
        return `_${e}_key`
    }
    function ux(e) {
        return `_${e}_computationMetrics`
    }
    function ZA(e) {
        return `_${e}_out`
    }
    function XA(e) {
        return `_${e}_computationMetrics`
    }
    function WA(e) {
        return `_${e}_cacheEntry`
    }
    function jA(e) {
        return `_${e}_args`
    }
    function Ay(e, t) {
        return `_${e}_prev_${t}`
    }
    function JA(e) {
        return `_${e}_computationDepth`
    }
    function QA(e) {
        return `_${e}_computationCount`
    }
    function Ye(e) {
        return e.type === 1
    }
    function KA(e) {
        if (!Ye(e))
            throw new Error(`Programming error: expected constant instruction but found ${So(e.type)} instead.`)
    }
    var NM = class {
        constructor(t, n) {
            this.chunk = t;
            this.recursiveFunctionGroup = n;
            this.referencesFrom = {};
            this.referencesTo = {};
            this.baseCases = {};
            for (let c of Object.values(n))
                this.referencesFrom[c] = [],
                this.referencesTo[c] = [],
                this.baseCases[c] = [];
            let {dependsOnRecursiveCall: r, iterationParameterIndex: o, recursiveReferences: i} = Q$(this.chunk, this.recursiveFunctionGroup);
            for (let c of i)
                this.referencesFrom[c.from].push(c),
                this.referencesTo[c.to].push(c);
            this.iterationParameterIndex = o;
            let {baseCases: s, isEveryBranchRecursiveOrBaseCase: a, isUnconditionallyRecursive: u} = J$(t, n, r, o);
            this.isEveryBranchRecursiveOrBaseCase = a,
            this.isUnconditionallyRecursive = u;
            for (let c of s)
                this.baseCases[c.fn].push(c)
        }
        hasRecursiveReferences() {
            for (let t of Object.values(this.referencesFrom))
                if (t.length > 0)
                    return !0;
            return !1
        }
        getBaseCasesForFunction(t) {
            return this.baseCases[t]
        }
        getReferencesFrom(t) {
            return this.referencesFrom[t]
        }
        getReferencesTo(t) {
            return this.referencesTo[t]
        }
        getAllReferences() {
            let t = [];
            for (let n of Object.values(this.referencesFrom))
                t.push(...n);
            return t
        }
    }
    ;
    function j$(e, t, n) {
        if (t === void 0)
            return;
        let r = e.getInstruction(n)
          , o = e.getInstruction(r.args[0]);
        if (o.type !== 25)
            return;
        let[i,s] = o.args, a;
        if (i === t)
            a = s;
        else if (s === t)
            a = i;
        else
            return;
        let u = e.getInstruction(a);
        if (Ye(u) && u.valueType === b)
            return u.value
    }
    function J$(e, t, n, r) {
        let o = []
          , i = !0
          , s = !0;
        for (let a in t) {
            let u = t[a]
              , l = e.getInstruction(u).endIndex
              , m = e.getInstruction(l).args[0]
              , d = r !== void 0 ? m + r + 1 : void 0
              , y = {
                [l]: !0
            };
            for (let g = l; g > m; g--) {
                if (!y[g])
                    continue;
                let f = e.getInstruction(g);
                if (de(f)) {
                    if (f.type === 33) {
                        let h = f.args[1]
                          , x = f.args[2];
                        if (!n[h] || !n[x]) {
                            i = !1;
                            let P = j$(e, d, g);
                            P !== void 0 && !n[h] ? o.push({
                                fn: u,
                                argValue: P
                            }) : s = !1
                        }
                    }
                    for (let h of f.args)
                        y[h] = !0
                }
            }
        }
        return o.sort( (a, u) => L(a.argValue) - L(u.argValue)),
        {
            baseCases: o,
            isUnconditionallyRecursive: i,
            isEveryBranchRecursiveOrBaseCase: s
        }
    }
    var RM = Symbol("NON_ITERATIVE");
    function Q$(e, t) {
        let n = new Set(Object.values(t)), r = {}, o = [], i;
        for (let s in t) {
            let a = t[s]
              , c = e.getInstruction(a).endIndex
              , p = e.getInstruction(c).args[0]
              , m = oo(e, c);
            for (let d = p; d < c; d++) {
                let y = e.getInstruction(d);
                if (de(y) && m[d]) {
                    if (y.type === 55 && n.has(y.args[0])) {
                        r[d] = !0;
                        let g = OM(e, p, y);
                        g ? (g.iterationParameterIndex !== void 0 && (i !== void 0 && i !== g.iterationParameterIndex ? i = RM : i = g.iterationParameterIndex),
                        o.push(g.ref)) : i = RM
                    }
                    for (let g of e.getDirectDependencies(y))
                        if (r[g]) {
                            r[d] = !0;
                            break
                        }
                }
            }
        }
        return i === void 0 && Object.values(t).every(s => e.getInstruction(s).signature.argTypes.length === 1) && (i = 0),
        {
            dependsOnRecursiveCall: r,
            iterationParameterIndex: i === RM ? void 0 : i,
            recursiveReferences: o
        }
    }
    function OM(e, t, n) {
        let r = e.getInstruction(t), o, i;
        for (let s = 1; s < n.args.length; s++) {
            let a = n.args[s], u = e.getInstruction(a), c, l;
            if (u.type === 9 && o === void 0) {
                let d = e.getInstruction(u.args[1]);
                if (!(d.type === 1 && d.valueType === b))
                    return;
                l = L(d.value),
                c = u.args[0]
            } else
                l = 0,
                c = a;
            let p = e.getInstruction(c);
            if (!(p.type === 47 && p.args[0] === t && s === c - t) || l !== Math.floor(l) || l < 0)
                return;
            if (o === void 0)
                i = l,
                l !== 0 && (o = s - 1);
            else if (l !== 0)
                return
        }
        if (i !== void 0)
            return {
                ref: {
                    from: r.args[0],
                    to: n.args[0],
                    iterationParameterOffset: i
                },
                iterationParameterIndex: o
            }
    }
    function ew(e, t) {
        var c, l;
        let n = new NM(e,t)
          , r = {};
        for (let p in n.recursiveFunctionGroup) {
            let m = n.recursiveFunctionGroup[p]
              , d = n.getBaseCasesForFunction(m);
            if (d.length === 0)
                continue;
            let y = L(d[0].argValue)
              , g = 1;
            for (; g < d.length && L(d[g].argValue) === L(d[g - 1].argValue) + 1; )
                g++;
            let f = d.slice(g).map(h => L(h.argValue));
            r[p] = {
                min: y,
                consecutiveCount: g,
                additional: f
            }
        }
        let o = {}
          , i = -1 / 0
          , s = 1 / 0;
        if (n.iterationParameterIndex !== void 0 && n.isEveryBranchRecursiveOrBaseCase) {
            let p = new Map;
            for (let m of Object.values(n.recursiveFunctionGroup)) {
                let d = e.getInstruction(m).symbol
                  , y = -1 / 0;
                for (let g of n.getReferencesTo(m))
                    y = Math.max(y, g.iterationParameterOffset);
                if (isFinite(y) && (o[d] = y),
                y > 0) {
                    let g = r[e.getInstruction(m).symbol]
                      , f = (c = g == null ? void 0 : g.min) != null ? c : -1 / 0;
                    p.set(m, {
                        min: f + y,
                        max: f + ((l = g == null ? void 0 : g.consecutiveCount) != null ? l : 0)
                    })
                }
            }
            for (let {min: m, max: d} of p.values())
                i = Math.max(i, m),
                s = Math.min(s, d)
        }
        let a = {};
        for (let p in n.recursiveFunctionGroup) {
            let m = n.recursiveFunctionGroup[p]
              , d = e.getInstruction(m);
            a[p] = d.parameterSymbols
        }
        let u = {};
        for (let p in n.recursiveFunctionGroup) {
            let m = n.recursiveFunctionGroup[p]
              , d = e.getInstruction(m);
            u[p] = d.signature.argTypes.map( (y, g) => g === n.iterationParameterIndex && n.isEveryBranchRecursiveOrBaseCase && !n.isUnconditionallyRecursive ? 1 : 0)
        }
        if (n.iterationParameterIndex !== void 0 && isFinite(i) && i <= s) {
            let p = K$(n);
            return {
                canIterate: !0,
                parameterSymbols: a,
                baseCaseInfo: r,
                maxRecursiveCallOffsets: o,
                iterationParameterIndex: n.iterationParameterIndex,
                domainInfo: u,
                loopStart: i,
                order: p
            }
        } else
            return {
                canIterate: !1,
                parameterSymbols: a,
                baseCaseInfo: r,
                maxRecursiveCallOffsets: o,
                iterationParameterIndex: n.iterationParameterIndex,
                domainInfo: u
            }
    }
    function K$(e) {
        if (e.iterationParameterIndex === void 0)
            throw F("Programming error: no recursive parameter");
        let n = Object.values(e.recursiveFunctionGroup)
          , r = new Map
          , o = new Map
          , i = u => {
            let c = new Set;
            for (let l of e.getReferencesTo(u))
                l.iterationParameterOffset === 0 && c.add(l.from);
            return [...c]
        }
        ;
        n.forEach(u => {
            let c = i(u);
            r.set(u, c);
            for (let l of c)
                o.set(l, (o.get(l) || 0) + 1);
            o.has(u) || o.set(u, 0)
        }
        );
        let s = [];
        o.forEach( (u, c) => {
            u === 0 && s.push(c)
        }
        );
        let a = [];
        for (; s.length > 0; ) {
            let u = s.shift();
            a.push(u),
            (r.get(u) || []).forEach(l => {
                let p = l
                  , m = o.get(p) - 1;
                o.set(p, m),
                m === 0 && s.push(p)
            }
            )
        }
        if (a.length !== n.length)
            throw FS();
        return a
    }
    function cx(e, t) {
        let n;
        for (let s = t, a = 0; s > 0; s--) {
            let u = e.getInstruction(s);
            if (u.type === 53 && a === 0) {
                n = s;
                break
            }
            u.type === 54 && a++,
            u.type === 53 && a--
        }
        if (n === void 0)
            return !1;
        let r = e.getInstruction(t)
          , o = e.getInstruction(r.args[0])
          , i = e.getInstruction(n).args[0];
        return o.recursionGroup.includes(i)
    }
    function lx(e) {
        for (let t = 0; t < e.argCoeffs.length; t++)
            if (L(e.argCoeffs[t]) !== 0)
                return !1;
        return !0
    }
    var px = be(0, 1)
      , tw = be(1, 1);
    function mx(e) {
        if (e.op === "&&")
            return {
                op: "||",
                values: e.values.map(mx)
            };
        if (e.op === "||")
            return {
                op: "&&",
                values: e.values.map(mx)
            };
        switch (e.condition) {
        case ">0":
            return {
                op: "comparator",
                value: Ko._neg(e.value),
                condition: ">=0"
            };
        case ">=0":
            return {
                op: "comparator",
                value: Ko._neg(e.value),
                condition: ">0"
            };
        case "=0":
            return {
                op: "comparator",
                value: e.value,
                condition: "!=0"
            };
        case "!=0":
            return {
                op: "comparator",
                value: e.value,
                condition: "=0"
            }
        }
    }
    function AM(e, t) {
        let n = [];
        return e.op === "&&" ? n.push(...e.values) : n.push(e),
        t.op === "&&" ? n.push(...t.values) : n.push(t),
        {
            op: "&&",
            values: n
        }
    }
    var Ko;
    (c => {
        function e(l, p) {
            if (!(l === void 0 || p === void 0))
                return t(l, p)
        }
        c.add = e;
        function t(l, p) {
            let m = [];
            for (let d = 0; d < l.argCoeffs.length; d++)
                m.push(Pi(l.argCoeffs[d], p.argCoeffs[d]));
            return {
                argCoeffs: m,
                constantCoeff: Pi(l.constantCoeff, p.constantCoeff)
            }
        }
        c._add = t;
        function n(l, p) {
            if (!(l === void 0 || p === void 0))
                return r(l, p)
        }
        c.sub = n;
        function r(l, p) {
            let m = [];
            for (let d = 0; d < l.argCoeffs.length; d++)
                m.push(ki(l.argCoeffs[d], p.argCoeffs[d]));
            return {
                argCoeffs: m,
                constantCoeff: ki(l.constantCoeff, p.constantCoeff)
            }
        }
        c._sub = r;
        function o(l) {
            if (l !== void 0)
                return i(l)
        }
        c.neg = o;
        function i(l) {
            let p = [];
            for (let m = 0; m < l.argCoeffs.length; m++)
                p.push(Ii(l.argCoeffs[m]));
            return {
                argCoeffs: p,
                constantCoeff: Ii(l.constantCoeff)
            }
        }
        c._neg = i;
        function s(l, p) {
            if (l === void 0 || p === void 0)
                return;
            let m = lx(l)
              , d = lx(p);
            if (!m && !d)
                return;
            d || ([l,p] = [p, l]);
            let y = [];
            for (let g = 0; g < l.argCoeffs.length; g++)
                y.push(Zr(l.argCoeffs[g], p.constantCoeff));
            return {
                argCoeffs: y,
                constantCoeff: Zr(l.constantCoeff, p.constantCoeff)
            }
        }
        c.mul = s;
        function a(l, p) {
            if (l === void 0 || p === void 0 || !lx(p))
                return;
            let d = [];
            for (let y = 0; y < l.argCoeffs.length; y++)
                d.push(Fo(l.argCoeffs[y], p.constantCoeff));
            return {
                argCoeffs: d,
                constantCoeff: Fo(l.constantCoeff, p.constantCoeff)
            }
        }
        c.div = a;
        function u(l, p) {
            if (!(l === void 0 || p === void 0 || !lx(p)))
                return L(p.constantCoeff) === 0 ? {
                    argCoeffs: new Array(l.argCoeffs.length).fill(px),
                    constantCoeff: tw
                } : L(p.constantCoeff) === 1 ? l : void 0
        }
        c.pow = u
    }
    )(Ko || (Ko = {}));
    var dx = class {
        constructor(t, n, r, o) {
            this.chunk = t;
            this.coefficientTable = [];
            this.conditionTable = [];
            this.ZERO_COEFFS = new Array(n.length).fill(px),
            this.mask = qu(t, n, r, o);
            for (let i = 0; i < n.length; i++) {
                let s = [];
                for (let a = 0; a < n.length; a++)
                    s.push(i === a ? tw : px);
                this.coefficientTable[n[i]] = {
                    argCoeffs: s,
                    constantCoeff: px
                }
            }
        }
        coeffs(t) {
            let n = this.coefficientTable[t];
            if (n !== void 0)
                return n;
            let r, o = this.chunk.getInstruction(t);
            return o.type === 1 && o.valueType === b ? r = {
                argCoeffs: this.ZERO_COEFFS,
                constantCoeff: o.value
            } : this.mask[t] ? r = this._coeffs(t) : r = void 0,
            this.coefficientTable[t] = r,
            r
        }
        _coeffs(t) {
            let n = this.chunk.getInstruction(t);
            switch (n.type) {
            case 8:
                {
                    let[o,i] = n.args;
                    return Ko.add(this.coeffs(o), this.coeffs(i))
                }
            case 9:
                {
                    let[o,i] = n.args;
                    return Ko.sub(this.coeffs(o), this.coeffs(i))
                }
            case 14:
                {
                    let o = n.args[0];
                    return Ko.neg(this.coeffs(o))
                }
            case 10:
                {
                    let[o,i] = n.args;
                    return Ko.mul(this.coeffs(o), this.coeffs(i))
                }
            case 11:
                {
                    let[o,i] = n.args;
                    return Ko.div(this.coeffs(o), this.coeffs(i))
                }
            case 12:
            case 13:
                {
                    let[o,i] = n.args;
                    return Ko.pow(this.coeffs(o), this.coeffs(i))
                }
            case 26:
            case 28:
            case 27:
            case 29:
            case 33:
            case 0:
            case 23:
            case 2:
            case 1:
            case 25:
            case 32:
            case 31:
            case 15:
            case 16:
            case 38:
            case 39:
            case 40:
            case 41:
            case 37:
            case 42:
            case 21:
            case 22:
            case 19:
            case 20:
            case 24:
            case 48:
            case 47:
            case 3:
            case 44:
            case 49:
            case 50:
            case 51:
            case 4:
            case 53:
            case 54:
            case 55:
            case 56:
                return;
            default:
                let r = n;
                throw new Error(`Unexpected opcode ${r.type}`)
            }
        }
        condition(t) {
            let n = this.conditionTable[t];
            if (n !== void 0)
                return n;
            let r;
            return this.mask[t] ? r = this._condition(t) : r = void 0,
            this.conditionTable[t] = r,
            r
        }
        _condition(t) {
            let n = this.chunk.getInstruction(t);
            switch (n.type) {
            case 26:
                {
                    let[o,i] = n.args
                      , s = Ko.sub(this.coeffs(i), this.coeffs(o));
                    return s === void 0 ? void 0 : {
                        op: "comparator",
                        value: s,
                        condition: ">0"
                    }
                }
            case 28:
                {
                    let[o,i] = n.args
                      , s = Ko.sub(this.coeffs(i), this.coeffs(o));
                    return s === void 0 ? void 0 : {
                        op: "comparator",
                        value: s,
                        condition: ">=0"
                    }
                }
            case 27:
                {
                    let[o,i] = n.args
                      , s = Ko.sub(this.coeffs(o), this.coeffs(i));
                    return s === void 0 ? void 0 : {
                        op: "comparator",
                        value: s,
                        condition: ">0"
                    }
                }
            case 29:
                {
                    let[o,i] = n.args
                      , s = Ko.sub(this.coeffs(o), this.coeffs(i));
                    return s === void 0 ? void 0 : {
                        op: "comparator",
                        value: s,
                        condition: ">=0"
                    }
                }
            case 25:
                {
                    let[o,i] = n.args
                      , s = Ko.sub(this.coeffs(o), this.coeffs(i));
                    return s === void 0 ? void 0 : {
                        op: "comparator",
                        value: s,
                        condition: "=0"
                    }
                }
            case 32:
                {
                    let o = n.args.map(i => this.condition(i));
                    return o.some(i => i === void 0) ? void 0 : {
                        op: "&&",
                        values: o
                    }
                }
            case 31:
                {
                    let o = n.args.map(i => this.condition(i));
                    return o.some(i => i === void 0) ? void 0 : {
                        op: "||",
                        values: o
                    }
                }
            case 8:
            case 9:
            case 14:
            case 56:
            case 10:
            case 11:
            case 12:
            case 13:
            case 33:
            case 0:
            case 23:
            case 2:
            case 1:
            case 15:
            case 16:
            case 38:
            case 39:
            case 40:
            case 41:
            case 37:
            case 42:
            case 21:
            case 22:
            case 19:
            case 20:
            case 24:
            case 48:
            case 47:
            case 3:
            case 44:
            case 49:
            case 50:
            case 51:
            case 4:
            case 53:
            case 54:
            case 55:
                return;
            default:
                let r = n;
                throw new Error(`Unexpected opcode ${r.type}`)
            }
        }
    }
    ;
    function rw(e, t, n, r) {
        let o = t.reachConditions[n];
        if (o !== void 0)
            return ow(e, t, r, o)
    }
    function ow(e, t, n, r) {
        let o = t.argBlockvars;
        if (r.op === "||" || r.op === "&&") {
            let i = [];
            for (let s of r.values) {
                let a = ow(e, t, n, s);
                if (a === void 0)
                    return;
                i.push(a)
            }
            return i.length === 0 ? r.op === "&&" ? "true" : "false" : `(${i.join(r.op)})`
        }
        switch (r.condition) {
        case ">0":
        case ">=0":
            {
                let s = `(${nw(e, r.value, o)}${r.condition})`
                  , a = wM(e, r.value, o, n);
                return `(${s}&&${a})`
            }
        case "!=0":
            {
                let i = nw(e, r.value, o)
                  , s = `(${i}>0)`
                  , a = wM(e, r.value, o, n)
                  , u = `(${i}<0)`
                  , c = wM(e, Ko._neg(r.value), o, n);
                return `((${s}&&${a})||(${u}&&${c}))`
            }
        case "=0":
            return
        }
    }
    function wM(e, t, n, r) {
        let o = [];
        for (let i = 0; i < n.length; i++) {
            let s = L(t.argCoeffs[i])
              , a = e.referenceArg(n[i])
              , u = e.referenceArg(r[i]);
            s > 0 ? o.push(`${u}>=${a}`) : s < 0 && o.push(`${u}<=${a}`)
        }
        return o.length === 0 ? !0 : `(${o.join("&&")})`
    }
    function nw(e, t, n) {
        let r = "";
        for (let o = 0; o < n.length; o++) {
            let i = e.printValue({
                value: t.argCoeffs[o],
                valueType: b
            })
              , s = e.referenceArg(n[o]);
            r += `${i}*${s}+`
        }
        return r += e.printValue({
            value: t.constantCoeff,
            valueType: b
        }),
        `(${r})`
    }
    var ln;
    (r => (r.Noop = 0,
    r.Inline = 1,
    r.Block = 2))(ln || (ln = {}));
    function LM(e) {
        switch (e.type) {
        case ln.Noop:
            return "";
        case ln.Inline:
            return e.source + `;
`;
        case ln.Block:
            return e.source
        }
    }
    function iw(e, t, n) {
        if (e.glsl)
            throw F("GLSL function not implemented");
        let {chunk: r, referenced: o} = e
          , i = t.args[0]
          , s = r.getInstruction(i)
          , a = s.signature.argTypes;
        if (e.isTailFunction[i])
            return {
                type: ln.Noop,
                nextIdx: s.endIndex + 1
            };
        e.enterFunction(t, n, 0);
        let u = "";
        for (let c = 0; c < a.length; c++) {
            let l = n + c + 1;
            o[l] && (u += `${On(l)}=${DM(i, c)};
`)
        }
        return {
            type: ln.Block,
            source: e5(e, t, n, u),
            nextIdx: n + 1
        }
    }
    function e5(e, t, n, r) {
        let {chunk: o} = e
          , i = t.args[0]
          , s = o.getInstruction(i)
          , a = s.signature.argTypes
          , u = "";
        for (let d = 0; d < a.length; d++)
            d > 0 && (u += ","),
            u += DM(i, d);
        let c = _M(i)
          , l = $A(i)
          , p = YA(i)
          , m = ux(i);
        return `
    const ${p}=${a.length === 1 && s.signature.argTypes[0] === b ? "({fn, args}) => `${fn}:${args[0]}`" : "({fn, args}) => `${fn}:${JSON.stringify(args)}`"};

    const ${c}=((${l}, ${u}) => {
      ${md(e, n + 1, s.endIndex - 1)}
      const ${m} = {depth: 0, count: 0};
      const cache = ${l};
      ${r}
    `
    }
    function sw(e, t, n) {
        let r = n + 1
          , o = t.args[0]
          , s = e.chunk.getInstruction(o).args[0];
        if (e.isTailFunction[s])
            throw F("Unexpected tail recursive function");
        let a = t5(e, t)
          , {referenced: u} = e;
        return u[n] && (a += `${On(n)}=${e.referenceArg(t.args[0])};
`),
        e.exitFunction(),
        {
            type: ln.Block,
            source: a,
            nextIdx: r
        }
    }
    function t5(e, t) {
        let n = t.args[0]
          , r = e.chunk.getInstruction(n)
          , o = r.args[0]
          , i = ZA(o)
          , s = ux(o)
          , a = r.valueType;
        return `
${s}.count++;
${s}.depth++;
let ${i};
if ((${s}.depth > BuiltIn.RECURSIVE_DEPTH_LIMIT) || (${s}.count > BuiltIn.RECURSIVE_COMPUTATION_LIMIT)) {
  ${i}=BuiltIn.handleRecursionLimitExceeded(__meta, ${a});
} else {
  ${i}=${e.referenceArg(t.args[1])};
}
return BuiltIn.recursionSuccess(${i},${s});
});
`
    }
    function wy(e, t) {
        return `{ fn: ${e}, args: ${t} }`
    }
    function aw(e, t, n) {
        let r = n + 1
          , {chunk: o} = e
          , i = t.args[0]
          , s = o.getInstruction(i)
          , u = o.getInstruction(s.endIndex).args[0]
          , c = t.args.slice(1).map(f => e.referenceArg(f))
          , l = On(n)
          , p = jA(n)
          , m = XA(n)
          , d = WA(n)
          , y = o.getInstruction(u)
          , g = o.getInstruction(y.args[0]);
        if (cx(o, n)) {
            if (e.recursiveFunctionInfo.length < 1)
                throw F("Expected recursive function info");
            let f = e.recursiveFunctionInfo[e.recursiveFunctionInfo.length - 1]
              , h = ""
              , x = rw(e, f, n, t.args.slice(1));
            if (e.isTailFunction[i]) {
                let S = y.valueType;
                x && (h = `
if (${x}) {
            return BuiltIn.recursionDiverges(__meta, ${S});
          }`);
                let E = g.signature.argTypes
                  , M = h + `
`;
                M += "looping=true";
                for (let _ = 0; _ < E.length; _++) {
                    let U = ax(u + _ + 1);
                    M += `,
${U}=${c[_]}`
                }
                return h ? {
                    type: ln.Block,
                    source: M + `;
`,
                    nextIdx: r
                } : {
                    type: ln.Inline,
                    source: M,
                    nextIdx: r
                }
            } else if (f.executionMode === 1) {
                let S = o.getInstruction(o.getInstruction(f.fn).endIndex)
                  , E = OM(o, S.args[0], t);
                if (!E)
                    throw F("Expected valid iteration reference");
                let M = Ay(E.ref.to, E.ref.iterationParameterOffset);
                return {
                    type: ln.Inline,
                    source: `${l}=${M}`,
                    nextIdx: r
                }
            }
            x && (h = `
if (${x}) {
          return BuiltIn.SYMBOL_DIVERGES;
        }`);
            let T = ux(f.fn)
              , P = wy(i, p)
              , C = `
      const ${p} = ([${c.join(",")}]);
      ${h}
      const ${d} = cache.get(BuiltIn.recursionCacheKey(${P}));
      if (${d} === undefined) {
        return BuiltIn.recursionMissingCacheEntry(${P});
      }
      ${l} = ${d}[0];
      const ${m} = ${d}[1];
      if (${m}.count > ${T}.count) {
        ${T}.count = ${m}.count;
      }
      if (${m}.depth > ${T}.depth) {
        ${T}.depth = ${m}.depth;
      }
    `;
            return {
                type: ln.Block,
                source: C,
                nextIdx: r
            }
        } else {
            let f = `{${g.recursionGroup.map(P => `${P}: ${_M(P)}`).join(",")}}`
              , h = e.chunk.getRecursionStructure(y.args[0]);
            if (e.isTailFunction[i])
                return n5(e, t, n);
            if (h.canIterate)
                return r5(e, t, n, h, {
                    innerFunctionsMap: f
                });
            let x = wy(i, `[${c.join(",")}]`)
              , T = `${l}=BuiltIn.executeRecursiveFunction(
      __meta,
      ${f},
      ${y.valueType},
      ${x}
    )`;
            return {
                type: ln.Inline,
                source: T,
                nextIdx: r
            }
        }
    }
    var uw = Symbol("UPDATED_IN_BODY");
    function cw(e) {
        let t = "";
        for (let n of e) {
            let r = "declare"in n ? `let ${n.declare}` : On(n.reference)
              , o = n.initializeRHS;
            t += `${r}=${o};
`
        }
        return t
    }
    function lw(e) {
        let t = ""
          , n = "";
        for (let r of e) {
            let o = "declare"in r ? r.declare : On(r.reference);
            r.updateRHS !== uw && (t && (t += ",",
            n += ","),
            t += `${o}`,
            n += `${r.updateRHS}`)
        }
        return `[${t}]=[${n}]`
    }
    function n5(e, t, n) {
        let r = t.args[0]
          , o = e.chunk.getInstruction(r)
          , i = e.chunk.getInstruction(o.endIndex)
          , s = i.args[0]
          , a = e.chunk.getInstruction(s)
          , u = a.valueType
          , c = On(n)
          , l = [];
        e.enterFunction(a, s, 2);
        let p = fx(e, s, o.endIndex).source;
        e.exitFunction();
        let m = JA(n)
          , d = QA(n);
        l.push({
            declare: m,
            initializeRHS: "0",
            updateRHS: `${m}+1`
        }, {
            declare: d,
            initializeRHS: "0",
            updateRHS: `${d}+1`
        });
        for (let g = 1; g < t.args.length; g++) {
            let f = s + g;
            if (!e.referenced[f])
                continue;
            let h = ax(f);
            l.push({
                reference: f,
                initializeRHS: e.referenceArg(t.args[g]),
                updateRHS: h
            }, {
                declare: h,
                initializeRHS: void 0,
                updateRHS: uw
            })
        }
        let y = `${c}=(() => {
    ${md(e, s + 1, o.endIndex - 1)}

    let looping = true;
    ${cw(l)}
    while (looping) {
      looping = false;

      ${p}

      if (looping) {
        ${lw(l)}
      }

      if ((${m} > BuiltIn.RECURSIVE_DEPTH_LIMIT) || (${d} > BuiltIn.RECURSIVE_COMPUTATION_LIMIT)) {
        return BuiltIn.handleRecursionLimitExceeded(__meta, ${u});
      };
    }

    return ${e.referenceArg(i.args[1])}
  })()`;
        return {
            type: ln.Inline,
            source: y,
            nextIdx: n + 1
        }
    }
    function r5(e, t, n, r, o) {
        let i = t.args[0], s = e.chunk.getInstruction(i), a = e.chunk.getInstruction(s.endIndex), u = a.args[0], c = On(n), l = [], p = "", m, {iterationParameterIndex: d, loopStart: y, order: g} = r, f = r.maxRecursiveCallOffsets, h = u + d + 1, x = On(h), T = t.args[d + 1], P = `(${y})`, C = e.chunk.getInstruction(T), S = (C.type === 39 || C.type === 41) && e.chunk.getInstruction(C.args[1]).type === 23 ? C.args[0] : void 0, E = `(${e.referenceArg(T)})-${P}`, M, _;
        if (S !== void 0) {
            let w = e.referenceArg(S);
            M = `BuiltIn.listMax(
      (${w}).filter(
        x => isFinite(x) &&
        Math.floor(x - ${P}) === (x - ${P})
      )
    )`,
            _ = `BuiltIn.getBroadcastTargetElements(${w}).has(${x})`
        } else
            M = `(${e.referenceArg(T)})`,
            _ = "false";
        l.push({
            reference: h,
            initializeRHS: `(${P})`,
            updateRHS: `${x}+1`
        }),
        m = "";
        for (let w of g) {
            let B = e.chunk.getInstruction(w)
              , W = B.endIndex
              , oe = e.chunk.getInstruction(W)
              , te = oe.args[0]
              , st = e.chunk.getInstruction(te);
            for (let ye = 1; ye < t.args.length; ye++) {
                let ee = te + ye;
                if (!e.referenced[ee])
                    continue;
                let k = On(ee);
                ye === d + 1 ? m += `${k}=${e.referenceArg(h)};
` : p += `${k}=${e.referenceArg(t.args[ye])};
`
            }
            p += md(e, te + 1, B.endIndex - 1);
            let Tt = f[B.symbol];
            if (Tt !== void 0)
                for (let ye = 1; ye <= Tt; ye++) {
                    let ee = Ay(w, ye)
                      , k = ye === 1 ? e.referenceArg(oe.args[1]) : Ay(w, ye - 1)
                      , ne = t.args.slice(1).map( (At, Fi) => Fi === d ? y - ye : e.referenceArg(At))
                      , Ne = wy(w, `[${ne.join(",")}]`)
                      , _e = `BuiltIn.executeRecursiveFunction(
            __meta,
            ${o.innerFunctionsMap},
            ${st.valueType},
            ${Ne}
          )`
                      , gt = `(
          broadcastOutputMap
            ? (broadcastOutputMap[BuiltIn.recursionCacheKey(${Ne})] = ${_e})
            : ${_e}
        )`;
                    l.push({
                        declare: ee,
                        initializeRHS: gt,
                        updateRHS: k
                    })
                }
            e.enterFunction(st, te, 1),
            m += fx(e, te, B.endIndex).source,
            e.exitFunction(),
            m += `const ${Ay(w, 0)}=${e.referenceArg(oe.args[1])};
`
        }
        let U = t.args.slice(1).map(w => e.referenceArg(w))
          , Q = t.args.slice(1).map( (w, B) => B === d ? x : e.referenceArg(w))
          , K = `${c}=(() => {
    ${p}
    const broadcastOutputMap = ${S !== void 0 ? "__meta.iterativeRecursionOutputs" : "undefined"};

    ${cw(l)}

    const outerStackFrame = ${wy(i, `[${U.join(",")}]`)};

    if (broadcastOutputMap) {
        const cacheEntry = broadcastOutputMap[BuiltIn.recursionCacheKey(outerStackFrame)];
        if (cacheEntry !== undefined) {
          return cacheEntry;
        }
      }


    const targetLoopSteps = ${E}
    if (targetLoopSteps < 0 || Math.floor(targetLoopSteps) !== targetLoopSteps) {
      return BuiltIn.executeRecursiveFunction(
        __meta,
        ${o.innerFunctionsMap},
        ${s.valueType},
        outerStackFrame
      );
    }

    const loopEnd = ${M};

    let result;
    while (true) {
      ${m}

      result = ${e.referenceArg(a.args[1])};

      if (broadcastOutputMap && ${_}) {
        const key = BuiltIn.recursionCacheKey(${wy(i, `[${Q.join(",")}]`)});
        broadcastOutputMap[key] = result;
      }

      if (${x} < loopEnd) {
        ${lw(l)}
      } else {
        break;
      }
    }

    ${S === void 0 ? "return result;" : `const cached = broadcastOutputMap[BuiltIn.recursionCacheKey(outerStackFrame)];
          if (cached === undefined) {
            return BuiltIn.recursionDiverges(__meta, ${s.valueType});
          }
          return cached;
          `}
  })()`;
        return {
            type: ln.Inline,
            source: K,
            nextIdx: n + 1
        }
    }
    function yx(e) {
        let {chunk: t} = e
          , n = md(e, t.argNames.length, t.instructionsLength() - 1)
          , r = 0;
        for (; r < t.instructionsLength(); ) {
            let o = t.getInstruction(r)
              , i = FM(e, o, r);
            n += LM(i),
            r = i.nextIdx
        }
        return n += `return ${e.referenceArg(t.getReturnIndex())};`,
        n
    }
    function o5(e, t) {
        let {chunk: n} = e
          , r = []
          , o = e.thunkName(t)
          , i = e.thunkEnd(o)
          , s = ld(o)
          , a = pd(o)
          , u = ""
          , c = !1
          , l = !1;
        e.wantToInlineThunk(o) || (l = !0);
        let p = t;
        for (; p <= i; ) {
            let m = n.getInstruction(p)
              , d = p === t ? pw(e, m, p) : FM(e, m, p);
            switch (d.type) {
            case ln.Noop:
                break;
            case ln.Inline:
                c && (u += `,
`),
                u += d.source,
                c = !0;
                break;
            case ln.Block:
                c && (u += `;
`),
                c = !1,
                u += d.source,
                l = !0;
                break
            }
            r.push(u),
            p = d.nextIdx
        }
        if (u === "" && (u = "0",
        l = !1),
        l) {
            let m = `${s}=false;${a}=()=>{
${s}=true;

      ${u}${c ? ";" : ""}
    };
`;
            return {
                type: ln.Block,
                source: m,
                nextIdx: p
            }
        } else
            return e.inlineThunk(o, u),
            {
                type: ln.Noop,
                nextIdx: p
            }
    }
    function FM(e, t, n) {
        return e.isThunkBegin(n) ? o5(e, n) : pw(e, t, n)
    }
    function pw(e, t, n) {
        let r = n + 1;
        if (!e.referenced[n])
            return {
                type: ln.Noop,
                nextIdx: r
            };
        switch (t.type) {
        case 0:
        case 47:
        case 48:
        case 22:
        case 49:
        case 4:
            return {
                type: ln.Noop,
                nextIdx: r
            };
        case 21:
            if (e.glsl)
                throw zE();
            return s5(e, t, n);
        case 2:
            return e.inlineSource(n, e.chunk.argNames[n]),
            {
                type: ln.Noop,
                nextIdx: r
            };
        case 23:
            return {
                type: ln.Block,
                source: a5(e, t, n),
                nextIdx: r
            };
        case 24:
            return {
                type: ln.Block,
                source: u5(e, t, n),
                nextIdx: r
            };
        case 19:
            return {
                type: ln.Block,
                source: c5(e, t, n),
                nextIdx: r
            };
        case 20:
            return {
                type: ln.Block,
                source: l5(e, t, n),
                nextIdx: r
            };
        case 50:
            return {
                type: ln.Block,
                source: p5(e, t, n),
                nextIdx: r
            };
        case 51:
            return {
                type: ln.Block,
                source: m5(e, t, n),
                nextIdx: r
            };
        case 53:
            return iw(e, t, n);
        case 54:
            return sw(e, t, n);
        case 33:
            {
                let o = e.referenceArg(t.args[0])
                  , i = e.referencePiecewiseBranch(t.args[1])
                  , s = e.referencePiecewiseBranch(t.args[2]);
                if (!(i.thunkDependencies.some(p => e.isEarlyReturningThunk(p)) || s.thunkDependencies.some(p => e.isEarlyReturningThunk(p)))) {
                    let p = e.emitTernary(o, i.expression, s.expression, t);
                    return e.shouldInline(n) ? (e.inlineSource(n, `(${p})`),
                    {
                        type: ln.Noop,
                        nextIdx: r
                    }) : {
                        type: ln.Inline,
                        source: `${On(n)}=${p}`,
                        nextIdx: r
                    }
                }
                let u = On(n)
                  , c = p => {
                    if (p.length === 0)
                        return "";
                    let m = "";
                    for (let d of p) {
                        let y = e.inlinedThunks[d];
                        if (y !== void 0) {
                            let g = `(${y},void 0)`;
                            m !== "" ? m = `(${m}||${g})` : m = g
                        } else {
                            let g = ld(d)
                              , f = pd(d);
                            m !== "" && (m += "||"),
                            m += `(${g} ? undefined : ${f}())`
                        }
                    }
                    return m = "const earlyReturn =" + m,
                    m += `;
if (earlyReturn !== undefined) return earlyReturn;
`,
                    m
                }
                  , l = `if (${o}) {
          ${c(i.thunkDependencies)}${u} = ${i.rawExpression};
        } else {
          ${c(s.thunkDependencies)}${u} = ${s.rawExpression};
        }`;
                return {
                    type: ln.Block,
                    source: l,
                    nextIdx: r
                }
            }
        case 55:
            return aw(e, t, n);
        default:
            {
                let o = d5(e, t, n);
                return e.shouldInline(n) ? (e.inlineSource(n, `(${o})`),
                {
                    type: ln.Noop,
                    nextIdx: r
                }) : {
                    type: ln.Inline,
                    source: `${On(n)}=${o}`,
                    nextIdx: r
                }
            }
        }
    }
    function fx(e, t, n) {
        let {chunk: r, referenced: o} = e
          , i = ""
          , s = t + 1;
        for (; s < n; ) {
            if (!o[s]) {
                s = s + 1;
                continue
            }
            let a = r.getInstruction(s)
              , u = FM(e, a, s);
            i += LM(u),
            s = u.nextIdx
        }
        return {
            type: ln.Block,
            source: i,
            nextIdx: s
        }
    }
    function i5(e, t, n) {
        let {endIndex: r} = t
          , {chunk: o} = e
          , i = `function(${On(n)}) {
`
          , s = n + 1
          , a = r - 1;
        i += md(e, s, a),
        i += fx(e, n, r).source;
        let u = o.getInstruction(r);
        return i += `return ${e.referenceArg(u.args[1])};
}`,
        i
    }
    function s5(e, t, n) {
        let r = "BuiltIn.quad(";
        r += i5(e, t, n),
        r += `,${e.referenceArg(t.args[0])},${e.referenceArg(t.args[1])})`;
        let {endIndex: o} = t
          , i = o + 1;
        return e.shouldInline(i) ? (e.inlineSource(i, r),
        {
            type: ln.Noop,
            nextIdx: t.endIndex
        }) : {
            type: ln.Inline,
            source: `${On(o + 1)}=${r}`,
            nextIdx: t.endIndex
        }
    }
    function md(e, t, n) {
        let {chunk: r, referenced: o} = e
          , i = ""
          , s = !1;
        for (let a = t; a <= n; a++) {
            if (!e.glsl && e.isThunkBegin(a)) {
                let c = e.thunkName(a);
                i += `${s ? "," : "var "}${ld(c)}`,
                i += `,${pd(c)}`,
                s = !0
            }
            let u = r.getInstruction(a);
            if (!(u.type === 0 || u.type === 24 || u.type === 20 || !o[a])) {
                if (u.type === 21) {
                    let {endIndex: c} = u;
                    a = c,
                    e.shouldInline(c + 1) && a++;
                    continue
                }
                if (e.glsl && u.type === 4)
                    throw HE();
                if (!e.shouldInline(a) && (i += e.emitVarDeclaration(a, s),
                s = !0,
                u.type === 53)) {
                    let {endIndex: c} = u;
                    a = c - 1;
                    continue
                }
            }
        }
        return s && (i += `;
`),
        i
    }
    function a5(e, t, n) {
        let {glsl: r, chunk: o, referenced: i} = e
          , s = On(n)
          , a = o.getInstruction(t.endIndex)
          , u = e.referenceArg(t.args[0])
          , c = "";
        for (let p = 1; p < a.args.length; p++) {
            let m = t.endIndex + p;
            if (!i[m] || o.getInstruction(m).type !== 48)
                continue;
            let y = On(m);
            r || (c += `${y}=[];
`)
        }
        return r || (c += `if(${u}>${1e4}) throw ErrorMsg.maxListSize();
`),
        c += `for(${s}=1${r ? ".0" : ""};${s}<=${u};${s}++){
`,
        c
    }
    function u5(e, t, n) {
        let {glsl: r, chunk: o, referenced: i} = e
          , s = "";
        for (let a = 1; a < t.args.length; a++) {
            let u = n + a;
            if (u >= o.instructionsLength() || !i[u] || o.getInstruction(u).type !== 48)
                continue;
            let c = On(n + a)
              , l = e.referenceArg(t.args[a]);
            if (r) {
                let p = e.referenceArg(t.args[0]);
                s += `${c}[int(${p})-1]=${l};
`
            } else
                s += `${c}.push(${l});
`
        }
        return s += `}
`,
        s
    }
    function c5(e, t, n) {
        let {chunk: r, referenced: o} = e
          , i = On(n);
        e.beforeBeginLoop(t);
        let s = `${e.referenceArg(t.args[0])}`
          , a = `${e.referenceArg(t.args[1])}`
          , u = `if(${s}>${a}){
`;
        for (let c = 2; c < t.args.length; c++) {
            let l = t.endIndex + c - 1;
            if (l >= r.instructionsLength() || !o[l] || r.getInstruction(l).type !== 47)
                continue;
            let p = On(l);
            u += `${p}=${e.referenceArg(t.args[c])};
`
        }
        u += e.checkFiniteBounds(t, s, a),
        u += `}else{
`;
        for (let c = 2; c < t.args.length; c++) {
            let l = n + c - 1;
            if (!o[l] || r.getInstruction(l).type !== 47)
                continue;
            let p = On(l);
            u += `${p}=${e.referenceArg(t.args[c])};
`
        }
        return u += `${i}=${s};
`,
        u += "while (true) {",
        u
    }
    function l5(e, t, n) {
        let {chunk: r, referenced: o} = e
          , i = r.getInstruction(t.args[0])
          , s = `${e.referenceArg(i.args[1])}`
          , a = On(t.args[0])
          , u = `${a}++;`;
        u += `if (${a}<=${s}) {
`;
        let c = new Map
          , l = [];
        for (let p = 1; p < t.args.length; p++) {
            let m = t.args[0] + p;
            if (!o[m] || r.getInstruction(m).type !== 47)
                continue;
            let d = t.args[p];
            c.set(m, e.referenceArg(d)),
            l[d] = e.isDirectlyReferencedByName(d)
        }
        for (let[p,m] of c.entries())
            if (l[p]) {
                let d = kA(p);
                u += e.emitImmediateAssignment(p, d, m),
                c.set(p, d)
            }
        for (let[p,m] of c.entries())
            u += `${On(p)}=${m};
`;
        u += `} else {
`;
        for (let p = 1; p < t.args.length; p++) {
            let m = n + p;
            if (m >= r.instructionsLength() || !o[m] || r.getInstruction(m).type !== 47)
                continue;
            let d = On(m);
            u += `${d}=${e.referenceArg(t.args[p])};
`
        }
        return u += `break;
`,
        u += `}
}
`,
        u += `}
`,
        u
    }
    function p5(e, t, n) {
        let {glsl: r} = e;
        if (r)
            throw F("GLSL map not implemented yet");
        let o = On(t.endIndex + 1)
          , i = [];
        for (let a = 0; a < t.callData.parameterSymbols.length; a++) {
            let u = On(n + a + 1);
            i.push(u)
        }
        let s = i.join(",");
        return `${o}=(${s}) => {
`
    }
    function m5(e, t, n) {
        let r = `return ${e.referenceArg(t.args[1])}`;
        return r += `}
`,
        r
    }
    function d5(e, t, n) {
        switch (t.type) {
        case 1:
            return e.emitConstant(t);
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 31:
        case 32:
            return e.emitBinary(t, e.referenceArg(t.args[0]), e.referenceArg(t.args[1]));
        case 14:
            {
                let o = e.referenceArg(t.args[0]);
                return e.emitNeg(o)
            }
        case 56:
            {
                let o = e.referenceArg(t.args[0]);
                return e.emitSquare(o)
            }
        case 15:
            {
                let o = t.valueType;
                switch (o) {
                case R:
                case N:
                    return e.emitVec2(e.referenceArg(t.args[0]), e.referenceArg(t.args[1]));
                case G:
                    return e.emitVec3(e.referenceArg(t.args[0]), e.referenceArg(t.args[1]), e.referenceArg(t.args[2]));
                case Pt:
                    return e.emitVec3(e.referenceArg(t.args[0]), e.referenceArg(t.args[1]), e.referenceArg(t.args[2]));
                case $t:
                case wt:
                case Kt:
                case Qt:
                case Ht:
                case an:
                case Yt:
                case pn:
                case mn:
                case qn:
                case zn:
                    return e.emitVec(...t.args.map(s => e.referenceArg(s)));
                default:
                    let i = o;
                    throw new Error(`Unexpected tuple type ${i}`)
                }
            }
        case 16:
            {
                let o = e.chunk.getInstruction(t.args[0]).valueType;
                switch (o) {
                case R:
                case G:
                case N:
                case Pt:
                case $t:
                case wt:
                case Kt:
                case Qt:
                case Ht:
                case an:
                case Yt:
                case pn:
                case mn:
                case qn:
                case zn:
                    return e.emitVecAccess(e.referenceArg(t.args[0]), t.index);
                default:
                    let i = o;
                    throw new Error(`Unexpected tuple type ${i}`)
                }
            }
        case 38:
            return e.emitList(t.args.map(o => e.referenceArg(o)), t);
        case 40:
        case 42:
        case 3:
            throw new Error(`Programming Error: expect ${So(t.type)} to be removed before emitting code.`);
        case 39:
            {
                let o = t.valueType;
                return e.emitListAccess(e.referenceArg(t.args[0]), e.referenceArg(t.args[1]), e.printValue({
                    value: wo(o),
                    valueType: o
                }), t)
            }
        case 41:
            return e.emitInboundsListAccess(e.referenceArg(t.args[0]), e.referenceArg(t.args[1]));
        case 37:
            {
                let o = t.args.map(s => e.referenceArg(s))
                  , i = f5(e, t, n, o);
                return i != null ? i : e.emitNativeFunction(o, t)
            }
        case 44:
            return e.emitExtendSeed(e.referenceArg(t.args[0]), e.chunk.getInstruction(t.args[1]).valueType, e.referenceArg(t.args[1]), t.tag);
        case 2:
        case 0:
        case 21:
        case 22:
        case 19:
        case 20:
        case 23:
        case 24:
        case 47:
        case 48:
        case 49:
        case 50:
        case 51:
        case 53:
        case 54:
        case 33:
        case 55:
        case 4:
            throw new Error(`Unexpected opcode ${t.type}`);
        default:
            let r = t;
            throw new Error(`Unexpected opcode ${r.type}`)
        }
    }
    function f5(e, t, n, r) {
        if (e.glsl)
            return;
        if (n === e.chunk.getReturnIndex() && t.symbol === "coerceComplexToReal" || t.symbol === "peelableCoerceComplexToReal")
            return `BuiltIn.peelableCoerceComplexToReal(${r.join(",")},__meta)`;
        if (n === e.chunk.getReturnIndex() && t.symbol === "coerceComplexToRealWithTolerance" || t.symbol === "peelableCoerceComplexToRealWithTolerance")
            return `BuiltIn.peelableCoerceComplexToRealWithTolerance(${r.join(",")},__meta)`
    }
    function mw(e, t, n) {
        if (t.recursionGroup.length > 1)
            return !1;
        let r = t.endIndex
          , o = e.getInstruction(r)
          , [i,...s] = o.args;
        if (s.length !== 1)
            return !1;
        let u = e.getInstruction(i).args[0]
          , c = {};
        c[s[0]] = !1;
        for (let l = r - 1; l >= i; l--) {
            let p = e.getInstruction(l);
            if (de(p) && n[l]) {
                if (p.type === 33 && !c[l])
                    c[p.args[0]] = !0;
                else
                    for (let m of p.args)
                        c[m] = !0;
                if (p.type === 55 && p.args[0] === u && c[l])
                    return !1
            }
        }
        return !0
    }
    function dw(e, t, n, r) {
        let o = e.getInstruction(n.args[0]);
        if (o.recursionGroup.length > 1)
            return [];
        let i = o.endIndex
          , s = e.getInstruction(i)
          , a = new dx(e,r,t,i)
          , u = [];
        for (let l = 1; l < s.args.length; l++)
            u[s.args[l]] = {
                op: "&&",
                values: []
            };
        for (let l = i - 1; l > t; l--) {
            let p = u[l];
            if (p === void 0)
                continue;
            let m = e.getInstruction(l);
            if (de(m))
                if (m.type === 33) {
                    u[m.args[0]] = p;
                    let d = a.condition(m.args[0]);
                    d !== void 0 && (u[m.args[1]] = AM(p, d),
                    u[m.args[2]] = AM(p, mx(d)))
                } else
                    for (let d of m.args)
                        u[d] = p
        }
        let c = [];
        e: for (let l = i - 1; l >= t; l--) {
            let p = e.getInstruction(l);
            if (p.type !== 55)
                continue;
            let m = e.getInstruction(p.args[0]);
            if (l > m.endIndex)
                continue;
            let d = p.args.slice(1);
            if (d.length !== m.signature.argTypes.length)
                throw new Error("Programming error: Non-matching arg length");
            let y = u[l];
            if (y !== void 0) {
                if (y.op === "&&" && y.values.length === 0)
                    throw new Error("Programming error: Recursive call unconditionally executed");
                for (let g = 0; g < d.length; g++) {
                    if (e.getInstruction(d[g]).valueType !== b)
                        continue e;
                    let f = a.coeffs(d[g]);
                    if (f === void 0 || !y5(f, g) || L(f.argCoeffs[g]) < -1)
                        continue e
                }
                c[l] = y
            }
        }
        return c
    }
    function y5(e, t) {
        for (let n = 0; n < e.argCoeffs.length; n++)
            if (n !== t && L(e.argCoeffs[n]) !== 0)
                return !1;
        return !0
    }
    function fw(e, t) {
        let n = e.getReturnIndex()
          , r = new Array(n)
          , o = new Array(n).fill(!1);
        for (let s = 0; s <= n; s++) {
            let a = e.getInstruction(s);
            Po(a) || Bo(a) || a.type === 48 || a.type === 47 && e.getInstruction(a.args[0]).type !== 22 || a.type === 0 || a.type === 55 ? r[s] = 2 : r[s] = 0
        }
        r[n] === 0 && (r[n] = 1,
        o[n] = !0);
        let i = 0;
        for (let s = n; s >= 0; s--) {
            if (!t[s])
                continue;
            let a = e.getInstruction(s);
            if (a.type === 54 ? i++ : a.type === 53 && i--,
            !de(a))
                continue;
            if (a.type === 19 || a.type === 20 || a.type === 24 || a.type === 54 || a.type === 39 || a.type === 55)
                for (let c of a.args) {
                    let l = e.getInstruction(c);
                    r[c] === 0 && l.type === 1 && l.valueType === b ? (r[c] = 1,
                    o[c] = !0) : (r[c] = 2,
                    o[c] = !1)
                }
            else {
                for (let c of a.args)
                    switch (r[c]) {
                    case 0:
                        r[c] = 1,
                        o[c] = !0;
                        break;
                    case 1:
                    case 2:
                        r[c] = 2,
                        o[c] = !1;
                        break
                    }
                i > 0 && a.type === 33 && (r[s] = 2,
                o[s] = !1)
            }
        }
        return o
    }
    function g5(e, t) {
        if (e.size !== t.size)
            return !1;
        for (let n of e)
            if (!t.has(n))
                return !1;
        return !0
    }
    var gx = class {
        constructor(t, n, r) {
            this.chunk = t;
            this.referenced = n;
            this.shouldInline = r;
            this.thunkSets = [];
            this.thunkStarts = [];
            this.thunkEnds = [];
            this._isThunkEnd = [];
            this.piecewiseReferencedCount = [];
            this.dependencyThunkNames = [];
            this.parentFunctionStart = [];
            let o = t.getReturnIndex();
            for (let a = 0; a <= t.instructionsLength(); a++)
                this.thunkSets[a] = new Set;
            let i = t.argNames.length
              , s = [];
            for (let a = i; a <= t.getReturnIndex(); a++) {
                let u = t.getInstruction(a);
                this.parentFunctionStart[a] = s[s.length - 1],
                u.type === 53 ? s.push(a) : u.type === 54 && s.pop()
            }
            this.markThunkSets(i, o, [o], "always"),
            this.markThunks(i, o)
        }
        isThunkBegin(t) {
            return this.thunkStarts[t] === t
        }
        isThunkEnd(t) {
            return !!this._isThunkEnd[t]
        }
        containingThunkName(t) {
            return this.thunkStarts[t]
        }
        thunkEnd(t) {
            return this.thunkEnds[t]
        }
        isEarlyReturningThunk(t) {
            let n = this.parentFunctionStart[t];
            return this.isThunkBegin(t) && n !== void 0
        }
        dependencyThunkNamesForPiecewiseBranch(t) {
            return this.dependencyThunkNames[t]
        }
        wantToInlineThunk(t) {
            let n = this.thunkSets[t];
            if (n !== "always" && n.size === 1) {
                for (let r of n)
                    if (this.piecewiseReferencedCount[r] !== 1)
                        return !1;
                return !0
            }
            return !1
        }
        printChunkWithThunkInfo() {
            for (let t = 0; t <= this.chunk.getReturnIndex(); t++) {
                let n = this.thunkSets[t]
                  , r = n === "always" ? "always" : `{${[...n].sort().join(",")}}`;
                if (this.isThunkBegin(t) && (r += " beginThunk"),
                this.isThunkEnd(t))
                    r += " endThunk";
                else {
                    let o = this.containingThunkName(t);
                    o !== void 0 && (r += ` start:${o}`)
                }
                this.shouldInline[t] && (r += "	[inline]"),
                this.chunk.comments[t] = r
            }
            return this.chunk.print(this.chunk.getReturnIndex())
        }
        markThunkSets(t, n, r, o) {
            let {chunk: i, referenced: s, thunkSets: a, piecewiseReferencedCount: u} = this;
            for (let l of r)
                a[l] = "always";
            function c(l, p) {
                let m = a[l];
                if (m !== "always") {
                    if (p === "always") {
                        a[l] = p;
                        return
                    }
                    for (let d of p)
                        m.add(d)
                }
            }
            for (let l = n; l >= t; l--) {
                if (!s[l])
                    continue;
                let p = i.getInstruction(l);
                if (!de(p))
                    continue;
                let m = a[l];
                if (Bo(p)) {
                    let d = p.args[0];
                    this.markThunkSets(d + 1, l - 1, p.args.slice(1), m),
                    l = d + 1;
                    continue
                }
                for (let d = 0; d < p.args.length; d++) {
                    let y = p.args[d];
                    if (y < t)
                        c(y, o);
                    else if (d > 0 && p.type === 33) {
                        let g = a[y];
                        g !== "always" && g.add(y);
                        let f = u[y];
                        u[y] = (f != null ? f : 0) + 1
                    } else
                        c(y, m)
                }
            }
        }
        markThunks(t, n) {
            var a, u;
            let {chunk: r, thunkSets: o} = this, i, s;
            for (let c = t; c <= n; c = s) {
                let l = r.getInstruction(c), p = h5(this.chunk, l), m, d;
                if (p) {
                    let y = c + 1
                      , g = p.innerEndIndex - 1;
                    this.markThunks(y, g),
                    d = o[p.innerEndIndex],
                    s = p.outerEndIndex + 1,
                    m = this.thunkDecision(i, c, this.referenced[p.innerEndIndex], l.type === 21 && this.shouldInline[p.outerEndIndex], d)
                } else
                    d = o[c],
                    s = c + 1,
                    m = this.thunkDecision(i, c, this.referenced[c], this.shouldInline[c], d);
                if (i !== void 0 && m.shouldEndThunk && (this.markEndThunk(c - 1, i),
                i = void 0),
                m.shouldStartThunk && d !== "always") {
                    for (let y of d)
                        (u = (a = this.dependencyThunkNames)[y]) != null || (a[y] = []),
                        this.dependencyThunkNames[y].push(c);
                    i = {
                        start: c,
                        set: d
                    }
                }
                if (i !== void 0 && (this.thunkStarts[c] = i.start,
                p))
                    for (let y = p.innerEndIndex; y <= p.outerEndIndex; y++)
                        this.thunkStarts[y] = i.start
            }
            i !== void 0 && this.markEndThunk(n, i)
        }
        thunkDecision(t, n, r, o, i) {
            let s = this.chunk.getInstruction(n);
            if (s.type === 33 && (o = !1),
            o || !r)
                return {
                    shouldEndThunk: !1,
                    shouldStartThunk: !1
                };
            if (i === "always")
                return {
                    shouldEndThunk: t !== void 0,
                    shouldStartThunk: !1
                };
            let a = s.type === 1 || s.type === 47
              , u = i.size > 0 && !a
              , c = t !== void 0 && !g5(i, t.set);
            return {
                shouldEndThunk: c,
                shouldStartThunk: (c || t === void 0) && u
            }
        }
        markEndThunk(t, n) {
            let {referenced: r} = this;
            for (; t >= 0 && !r[t]; )
                t--;
            this._isThunkEnd[t] = !0,
            this.thunkEnds[n.start] = t
        }
    }
    ;
    function h5(e, t) {
        if (Po(t)) {
            let n = t.endIndex
              , r = e.getInstruction(n);
            if (r === void 0)
                return;
            if (sx(r))
                return {
                    outerEndIndex: n + r.args.length - 1,
                    innerEndIndex: n
                };
            if (r.type === 54)
                return {
                    outerEndIndex: n,
                    innerEndIndex: n
                }
        }
    }
    var dd = class {
        constructor(t, n) {
            this.chunk = t;
            this.glsl = n;
            this.inlinedSource = [];
            this.inlinedThunks = [];
            this.recursiveFunctionInfo = [];
            this.isTailFunction = [];
            let r = t.getReturnIndex();
            this.referenced = oo(t, r),
            this._shouldInline = fw(t, this.referenced),
            !this.glsl && t.computeNeedsThunking() && (this.thunks = new gx(t,this.referenced,this._shouldInline));
            for (let o = 0; o <= r; o++) {
                let i = t.getInstruction(o);
                if (i.type === 4) {
                    if (!this.referenced[o])
                        continue;
                    this.isTailFunction[o] = mw(t, i, this.referenced),
                    i.recursionGroup = i.recursionGroup.filter(s => this.referenced[s])
                }
            }
        }
        isThunkBegin(t) {
            return !!this.thunks && this.thunks.isThunkBegin(t)
        }
        isThunkEnd(t) {
            return !!this.thunks && this.thunks.isThunkEnd(t)
        }
        isEarlyReturningThunk(t) {
            return !!this.thunks && this.thunks.isEarlyReturningThunk(t) && this.inlinedThunks[t] === void 0
        }
        thunkName(t) {
            var n;
            return (n = this.thunks) == null ? void 0 : n.containingThunkName(t)
        }
        thunkEnd(t) {
            return this.thunks.thunkEnd(t)
        }
        shouldInline(t) {
            return this._shouldInline[t]
        }
        inlineSource(t, n) {
            this.inlinedSource[t] = n
        }
        wantToInlineThunk(t) {
            return !!this.thunks && this.thunks.wantToInlineThunk(t)
        }
        inlineThunk(t, n) {
            this.inlinedThunks[t] = n
        }
        referenceArg(t) {
            let n = this.inlinedSource[t];
            return n !== void 0 ? n : On(t)
        }
        isDirectlyReferencedByName(t) {
            return this.inlinedSource[t] === void 0
        }
        referencePiecewiseBranch(t) {
            var s;
            let n = this.referenceArg(t)
              , r = (s = this.thunks) == null ? void 0 : s.dependencyThunkNamesForPiecewiseBranch(t);
            if (!r || r.length === 0)
                return {
                    expression: n,
                    rawExpression: n,
                    thunkDependencies: []
                };
            let o = []
              , i = "";
            for (let a of r) {
                let u = this.inlinedThunks[a];
                if (u !== void 0)
                    i && (i += ","),
                    i += u;
                else {
                    let c = ld(a)
                      , l = pd(a)
                      , p = `${c}||${l}()`;
                    i && (i += ","),
                    i += `${p}`
                }
                o.push(a)
            }
            return {
                expression: "(" + i + "," + n + ")",
                rawExpression: n,
                thunkDependencies: o
            }
        }
        enterFunction(t, n, r) {
            let o = t.args[0]
              , i = this.chunk.getInstruction(o)
              , s = [];
            for (let u = 0; u < i.signature.argTypes.length; u++)
                s.push(n + u + 1);
            let a = dw(this.chunk, n, t, s);
            this.recursiveFunctionInfo.push({
                fn: o,
                argBlockvars: s,
                reachConditions: a,
                returnType: t.valueType,
                executionMode: r
            })
        }
        exitFunction() {
            this.recursiveFunctionInfo.pop()
        }
    }
    ;
    function hx(e) {
        let t = new VM(e)
          , n = yx(t);
        return t.finish(n)
    }
    var VM = class extends dd {
        constructor(n) {
            super(n, !1);
            this.constants = []
        }
        finish(n) {
            return {
                source: n,
                constants: this.constants
            }
        }
        printValue(n) {
            return yw(n.value)
        }
        beforeBeginLoop() {}
        checkFiniteBounds(n, r, o) {
            let i = `}else if(!isFinite(${o}-${r})){
`;
            for (let s = 2; s < n.args.length; s++) {
                let a = n.endIndex + s - 1;
                if (a >= this.chunk.instructionsLength() || !this.referenced[a])
                    continue;
                let u = this.chunk.getInstruction(a);
                if (u.type !== 47)
                    continue;
                let c = On(a);
                ra(u.valueType) ? i += `${c}=${this.printValue({
                    value: wo(u.valueType),
                    valueType: u.valueType
                })};
` : i += `throw new Error('Cannot set ${c} of type ${Ke(u.valueType)} to NaN value');
`
            }
            return i
        }
        emitConstant(n) {
            return n.valueType === b || n.valueType === Fe || n.valueType === R || n.valueType === G ? this.printValue(n) : (this.constants.push(Ua(n.value)),
            `_C[${this.constants.length - 1}]`)
        }
        emitNeg(n) {
            return `-${n}`
        }
        emitSquare(n) {
            return `(${n})**2`
        }
        emitTernary(n, r, o) {
            return `${n}?${r}:${o}`
        }
        emitVec2(n, r) {
            return `[${n},${r}]`
        }
        emitVec3(n, r, o) {
            return `[${n},${r},${o}]`
        }
        emitVec(...n) {
            return `[${n.join(",")}]`
        }
        emitVecAccess(n, r) {
            return `${n}[${r}]`
        }
        emitBinary(n, r, o) {
            switch (n.type) {
            case 8:
                return `${r}+${o}`;
            case 9:
                return `${r}-${o}`;
            case 10:
                return `${r}*${o}`;
            case 11:
                return `${r}/${o}`;
            case 12:
                return `BuiltIn.pow(${r},${o})`;
            case 13:
                return `Math.pow(${r},${o})`;
            case 25:
                return `${r}===${o}`;
            case 26:
                return `${r}<${o}`;
            case 28:
                return `${r}<=${o}`;
            case 27:
                return `${r}>${o}`;
            case 29:
                return `${r}>=${o}`;
            case 31:
                return `${r}||${o}`;
            case 32:
                return `${r}&&${o}`;
            default:
                throw new Error("Programming Error: invalid binary opcode.")
            }
        }
        emitList(n) {
            return `[${n.join(",")}]`
        }
        emitListAccess(n, r, o) {
            let i = `${n}.length`
              , s = `Math.floor(${r})`;
            return `(${s}>=1&&${s}<=${i})?${n}[${s}-1]:${o}`
        }
        emitInboundsListAccess(n, r) {
            return `${n}[${r}-1]`
        }
        emitNativeFunction(n, r) {
            let o = ir[r.symbol];
            return `${o.module}.${o.symbol}(${n.join(",")})`
        }
        emitExtendSeed(n, r, o, i) {
            let s = r === b ? o : `BuiltIn.serializeNonNumericSeedPart(${r},${o})`;
            return `${n}+'::${i}'+${s}`
        }
        emitVarDeclaration(n, r) {
            let o = r ? "," : "var ";
            return o += On(n),
            o
        }
        emitImmediateAssignment(n, r, o) {
            return `var ${r}=${o};`
        }
        emitFunctionCall(n, r, o, i) {
            return `${n}(${r}, ${o}, ${i.join(",")})`
        }
    }
    ;
    function yw(e) {
        if (Array.isArray(e))
            return `[${e.map(yw).join(",")}]`;
        switch (typeof e) {
        case "boolean":
        case "number":
            return e.toString();
        case "string":
            return `${JSON.stringify(e)}`;
        case "object":
            if (fc(e))
                throw new Error("Action values cannot be compiled");
            return L(e).toString();
        default:
            throw new Error(`Unexpected value: ${e}`)
        }
    }
    function bx(e) {
        let t = e.getInstruction(e.getReturnIndex());
        if (t.type !== 47)
            throw new Error(`Expected BlockVar, got ${t.type}`);
        let n = e.getInstruction(t.args[0]);
        if (n.type !== 51)
            throw new Error(`Expected EndMap, got ${n.type}`);
        let r = rr(t.valueType)
          , o = e.getInstruction(n.args[0]);
        if (o.type !== 50)
            throw new Error(`Expected BeginMap, got ${o.type}`);
        let i = [];
        for (let p of o.args) {
            let m = e.getInstruction(p);
            if (!Ye(m) || m.valueType !== b)
                throw F("Programming error: interval bounds must be constant numbers");
            i.push(L(m.value))
        }
        let s, a;
        r === zi || r === Hi || r === yo ? (s = ["t"],
        a = {
            type: "1d",
            min: i[0],
            max: i[1]
        }) : (s = ["u", "v"],
        a = {
            type: "2d",
            uMin: i[0],
            uMax: i[1],
            vMin: i[2],
            vMax: i[3]
        });
        let u = hx(e)
          , c = `
  const mapFn = (function() {
    "use strict";
    ${u.source}
  })();
  return mapFn(${s.join(",")});
`
          , l = {};
        return {
            args: s,
            source: c,
            constants: u.constants,
            executionMetadata: l,
            fn: Oy(s, c, u.constants, l),
            domain: a
        }
    }
    var An = class e extends ct {
        constructor(n) {
            super();
            this.type = "IRExpression";
            this.isError = !1;
            if (n.getError())
                throw new Error("Programming error: IRExpression should not be constructed with an error chunk");
            if (this.warning = n.getWarning(),
            this._chunk = n,
            this.valueType = n.getReturnType(),
            this.addDependencies(n.getLiveArgNames()),
            this.isList = X(this.valueType),
            this.isList && (this.length = this._chunk.getConstantListLength(),
            this.length === void 0))
                throw $v(n.getListLengthDependencies());
            qA(n);
            let r = n.isConstant();
            this.isConstant = r && (this.valueType === b || this.valueType === Fe),
            this.isTypedConstant = r,
            this.isEmptyAction = r && this.valueType === pt && Object.keys(n.asValue().updateRules).length === 0
        }
        shouldExportAns() {
            return !0
        }
        getCompiledFunction(n) {
            return wa(this.valueType) ? bx(this._chunk) : this._chunk.getCompiledFunction(n)
        }
        getRestrictedFunctionForGLSL(n, r) {
            return this._chunk.getRestrictedFunctionForGLSL(n, r)
        }
        polynomialOrder(n) {
            return this._chunk.polynomialOrder(n, {
                allowRestriction: !0,
                allowClosedBlockReferences: !1
            })
        }
        getPolynomialCoefficients(n) {
            let r = this._chunk.getPolynomialCoefficients(n)
              , o = r.chunk
              , i = r.coefficients
              , s = [];
            for (let a = 0; a < i.length; a++) {
                let u = o.copy();
                u.setReturnIndex(i[a]),
                u.fuseBroadcast(),
                s.push(new e(u))
            }
            return s
        }
        takeDerivative(n) {
            let r = this._chunk.copy().takeDerivative(n).fuseBroadcast();
            return new e(r)
        }
        gradient(n) {
            let r = this._chunk.copy().gradient(n).fuseBroadcast();
            return new e(r)
        }
        toImplicitBool() {
            let n = this._chunk.copy();
            return n.GreaterEqual([n.getReturnIndex(), n.Constant(0)]),
            n.fuseBroadcast(),
            new e(n)
        }
        interpretWithParameters(n) {
            let r, o = this._chunk.argNames;
            if (n.length === o.length)
                r = n;
            else {
                r = [];
                let i = this.getDependencies();
                for (let s = 0, a = 0; s < o.length; s++)
                    i[a] === o[s] ? (r.push(n[a]),
                    a += 1) : r.push(void 0)
            }
            return this._chunk.interpretWithParameters(r)
        }
        substituteConstantArguments(n) {
            return new e(this._chunk.substituteConstantArguments(n))
        }
        boundDomain(n) {
            return this._chunk.boundDomain(n)
        }
        asValue() {
            var n;
            if (this._chunk.isConstant())
                return this._chunk.asValue();
            if (this.isList) {
                let r = []
                  , o = Ua(wo(Qe(this.valueType)));
                for (let i = 0; i < ((n = this.length) != null ? n : 0); i++)
                    r.push(o);
                return r
            } else
                return Ua(wo(this.valueType))
        }
        asCompilerValue() {
            return this._chunk.asCompilerValue()
        }
        isNaN() {
            return typeof this.asValue() == "number" && isNaN(this.asValue())
        }
        findLinearSubset(n) {
            return this._chunk.findLinearSubset(n)
        }
        deriveRegressionRestrictions() {
            let n = this._chunk.deriveRegressionRestrictions();
            return n === this._chunk ? this : new e(n)
        }
        eachElement(n) {
            var r;
            for (let o = 0; o < ((r = this.length) != null ? r : 0); o++)
                n(this.elementAt(o), o)
        }
        mapElements(n) {
            var o;
            let r = [];
            for (let i = 0; i < ((o = this.length) != null ? o : 0); i++)
                r.push(n(this.elementAt(i), i));
            return r
        }
        elementAt(n) {
            let r = this._chunk.elementAt(n);
            return new e(r)
        }
        getCursorContext() {
            return this._chunk.getCursorContext()
        }
        getRecursiveFunctionMetadata() {
            let n = this._chunk.getInstruction(this._chunk.getReturnIndex());
            if (n.type === 55)
                return this._chunk.getRecursiveFunctionMetadata(n.args[0])
        }
        coerceToNumericIfPossible(n={}) {
            if (ae(this.valueType, Oe) || ae(this.valueType, Se) || ae(this.valueType, N)) {
                let r = this._chunk.copy()
                  , o = r.getReturnIndex();
                return r.coerceToNumericIfPossible(n) === o ? this : new e(r)
            } else
                return this
        }
        coerceToNumericIfPossibleWithTolerance() {
            return this.coerceToNumericIfPossible({
                withTolerance: !0
            })
        }
        slot(n) {
            let r = this._chunk.copy();
            return r.setReturnIndex(r.Slot(n, [r.getReturnIndex()])),
            new e(r)
        }
        getCompiledDerivative() {
            let n = this.getDependencies();
            return this.takeDerivative(n[0] || "x").getCompiledFunction()
        }
    }
    ;
    var $a = class extends Z {
        constructor(n) {
            super(n);
            this.type = "ListAccess";
            this.list = n[0],
            this.index = n[1]
        }
    }
    ;
    var Tc = class extends Z {
        constructor(n, r, o, i, s=[]) {
            super([n, r].concat(o), {
                skipRegisterDependencies: !0
            });
            this.shouldCoerceToList = i;
            this.parameters = s;
            this.type = "ListComprehension";
            this._index = n,
            this._body = r,
            this._inputLists = o,
            this.registerDependencies()
        }
        registerDependencies() {
            let n = [];
            for (let i of this._inputLists) {
                let s = i._symbol;
                n.push(s)
            }
            for (let i of this.parameters) {
                let s = i.identifier._symbol;
                n.push(s)
            }
            this.addOptionalDependencies(n);
            let o = [this._index._symbol, ...n];
            for (let i of this._inputLists)
                this.mergeDependenciesInScope("ListComprehension", o, i.args[1]);
            for (let i of this.parameters)
                this.mergeDependenciesInScope("ListComprehension", o, i.bounds[0]),
                this.mergeDependenciesInScope("ListComprehension", o, i.bounds[1]);
            this.mergeDependenciesInScope("ListComprehension", o, this._body)
        }
    }
    ;
    var xx = class extends Hn {
        constructor() {
            super(...arguments);
            this.type = "MixedNumber"
        }
    }
    ;
    var Ya = class extends Gs {
        constructor(n, r, o) {
            super(n);
            this.type = "MovablePoint";
            this.moveStrategy = r,
            this.defaultDragMode = o,
            this.valueType = R
        }
        asValue() {
            return [+this.args[0].asValue(), +this.args[1].asValue()]
        }
        asCompilerValue() {
            return [this.args[0].asCompilerValue(), this.args[1].asCompilerValue()]
        }
    }
    ;
    var fd = class extends Z {
        constructor() {
            super(...arguments);
            this.type = "Multiply"
        }
    }
    ;
    var yd = class extends Z {
        constructor() {
            super(...arguments);
            this.type = "Negative"
        }
    }
    ;
    var gd = class extends Z {
        constructor() {
            super(...arguments);
            this.type = "Norm"
        }
    }
    ;
    var hd = class extends Z {
        constructor() {
            super(...arguments);
            this.type = "Or"
        }
    }
    ;
    var bd = class extends Z {
        constructor() {
            super(...arguments);
            this.type = "PercentOf"
        }
    }
    ;
    var Rp = class extends Z {
        constructor(n, r) {
            super(r);
            this.type = "Prime";
            this.order = n
        }
    }
    ;
    var xd = class extends Z {
        constructor(t) {
            super(t, {
                skipRegisterDependencies: !0
            }),
            this._index = t[0],
            this.registerDependencies()
        }
        registerDependencies() {
            for (let t = 1; t <= 3; t++)
                this.mergeDependenciesInScope("RepeatedOperator", [this._index._symbol], this.args[t])
        }
    }
    ;
    var Td = class extends xd {
        constructor() {
            super(...arguments);
            this.type = "Product";
            this.in_place_operator = "*=";
            this.starting_value = 1
        }
        evaluateConstant(n) {
            let r = 1 + Math.round(n[1]) - Math.round(n[0]);
            return r <= 0 ? this.starting_value : Math.pow(n[2], r)
        }
        update(n, r) {
            return n * r
        }
    }
    ;
    var Np = class extends Z {
        constructor(n) {
            super(n);
            this.type = "Range";
            this.beginning = n[0],
            this.end = n[1]
        }
        isHalfEmpty() {
            return this.end && this.end.args && this.end.args.length === 0
        }
    }
    ;
    var Id = class extends Z {
        constructor() {
            super(...arguments);
            this.type = "Restriction"
        }
    }
    ;
    var Op = class extends Z {
        constructor(n) {
            typeof n != "string" && (n = "" + n);
            super([]);
            this.type = "Seed";
            this.isString = !0;
            this._stringValue = n
        }
        asValue() {
            return this._stringValue
        }
    }
    ;
    var Tx = class extends _n {
        constructor(n, r) {
            super(n, r);
            this.type = "SeededFunctionCall";
            this.seed = r[0]
        }
    }
    ;
    var Ix = class extends Ln {
        constructor(n, r) {
            super(new dn(n._symbol), n._expression);
            this.type = "Slider";
            this.setInputSpan(n._inputSpan),
            this.sliderAssignment = n,
            this.sliderMin = r.sliderMin,
            this.sliderMax = r.sliderMax,
            this.sliderSoftMin = r.sliderSoftMin,
            this.sliderSoftMax = r.sliderSoftMax,
            this.sliderStep = r.sliderStep,
            this.sliderIsPlayingOnce = r.sliderIsPlayingOnce,
            this.sliderMin && this.mergeDependencies(this.sliderMin),
            this.sliderMax && this.mergeDependencies(this.sliderMax),
            this.sliderStep && this.mergeDependencies(this.sliderStep)
        }
        shouldPromoteToSlider(n) {
            return !1
        }
        asAssignment() {
            return new Km(this._symbol,this._expression)
        }
    }
    ;
    var Px = class extends ct {
        constructor(n, r, o, i) {
            super();
            this.type = "SolvedEquation";
            this._symbol = n,
            this._expression = r,
            this.otherVariableSolutionData = o,
            this.mergeDependencies(r),
            this.branchMultiplier = i
        }
    }
    ;
    var Pd = class extends Z {
        constructor() {
            super(...arguments);
            this.type = "Stats";
            this._symbol = "stats"
        }
    }
    ;
    var zu = class extends Z {
        constructor(n, r) {
            super([n].concat(r), {
                skipRegisterDependencies: !0
            });
            this.type = "Substitution";
            this._body = n,
            this._assignments = r,
            this.registerDependencies()
        }
        registerDependencies() {
            let n = [];
            for (let r = 0; r < this._assignments.length; r++) {
                let o = this._assignments[r]
                  , i = o._lhs
                  , s = o._rhs;
                if (i instanceof ze) {
                    let a = o._symbol;
                    n.push(a),
                    this.mergeDependencies(s)
                } else if (i instanceof _n)
                    this.mergeDependencies(o);
                else
                    throw new Error(`Unexpected LHS in assignment expression: ${i.type}`);
                this.addSubstitutionDependencies(s.getDependencies())
            }
            this.addOptionalDependencies(n),
            this.mergeDependenciesInScope("Substitution", n, this._body)
        }
    }
    ;
    var Sd = class extends xd {
        constructor() {
            super(...arguments);
            this.type = "Sum";
            this.in_place_operator = "+=";
            this.starting_value = 0
        }
        evaluateConstant(n) {
            let r = 1 + Math.round(n[1]) - Math.round(n[0]);
            return r <= 0 ? this.starting_value : r * n[2]
        }
        update(n, r) {
            return n + r
        }
    }
    ;
    var Sx = class extends ct {
        constructor(n) {
            super();
            this.type = "Ticker";
            this.handler = n.handler,
            this.minStep = n.minStep,
            this.mergeDependencies(this.handler),
            this.mergeDependencies(this.minStep)
        }
    }
    ;
    var Ed = class extends Z {
        constructor(n) {
            super(n, {
                skipRegisterDependencies: !0
            });
            this.type = "UpdateRule";
            this._symbol = n[0]._symbol,
            this._expression = n[1],
            this.registerDependencies()
        }
        registerDependencies() {
            this.addUpdateSymbol(this._symbol),
            this.mergeDependencies(this._expression)
        }
    }
    ;
    var gl = class extends ct {
        constructor(n, r) {
            super();
            this.type = "CallAssignment";
            this._symbol = n._symbol,
            this.mergeDependencies(n, r),
            this._lhs = n,
            this._rhs = r
        }
        asComparator() {
            return new za([this._lhs, this._rhs])
        }
    }
    ;
    var Gr = "i"
      , Za = class extends Z {
        constructor() {
            super([]);
            this.type = "ImaginaryUnit"
        }
    }
    ;
    var Hu = class extends Z {
        constructor(n, r, o) {
            super(n);
            this.type = "MovableComplexNumber";
            this.moveStrategy = r,
            this.defaultDragMode = o,
            this.valueType = N
        }
        asValue() {
            return [+this.args[0].asValue(), +this.args[1].asValue()]
        }
        asCompilerValue() {
            return [this.args[0].asCompilerValue(), this.args[1].asCompilerValue()]
        }
    }
    ;
    var Xa = class extends Z {
        constructor(n, r) {
            super(r);
            this.type = "NamedCoordinateAccess";
            this.symbol = n
        }
    }
    ;
    function Rr(e) {
        switch (e.type) {
        case "IRExpression":
        case "MovablePoint":
        case "MovableComplexNumber":
            return {
                valueType: e.valueType,
                value: e.asValue()
            };
        default:
            return
        }
    }
    function Ex(e, t) {
        if (e.type === "Error")
            return [void 0, e.getError()];
        let n = Rr(e);
        return (n == null ? void 0 : n.valueType) !== t ? [void 0, void 0] : [n, void 0]
    }
    function dt(e) {
        if (cd(e)) {
            let r = []
              , o = Qe(e.valueType);
            for (let i of e.value)
                r.push(dt({
                    valueType: o,
                    value: i
                }));
            return new O.List(r)
        }
        let {value: t, valueType: n} = e;
        switch (n) {
        case b:
        case Fe:
            return new O.Constant(t);
        case _t:
            return new O.Seed(t);
        case N:
            return new O.Add([dt({
                valueType: b,
                value: t[0]
            }), new O.Multiply([dt({
                valueType: b,
                value: t[1]
            }), new O.ImaginaryUnit])]);
        case R:
            return new O.ParenSeq([dt({
                valueType: b,
                value: t[0]
            }), dt({
                valueType: b,
                value: t[1]
            })]);
        case G:
            return new O.ParenSeq([dt({
                valueType: b,
                value: t[0]
            }), dt({
                valueType: b,
                value: t[1]
            }), dt({
                valueType: b,
                value: t[2]
            })]);
        case en:
            return new O.FunctionCall("segment",[dt({
                valueType: G,
                value: t[0]
            }), dt({
                valueType: G,
                value: t[1]
            })]);
        case qe:
            return new O.FunctionCall("vector",[dt({
                valueType: G,
                value: t[0]
            }), dt({
                valueType: G,
                value: t[1]
            })]);
        case lr:
            return new O.FunctionCall("triangle",[dt({
                valueType: G,
                value: t[0]
            }), dt({
                valueType: G,
                value: t[1]
            }), dt({
                valueType: G,
                value: t[2]
            })]);
        case Lr:
            return new O.FunctionCall("sphere",[dt({
                valueType: G,
                value: t[0]
            }), dt({
                valueType: b,
                value: t[1]
            })]);
        case bn:
            return new O.FunctionCall("rgb",[dt({
                valueType: b,
                value: t[0]
            }), dt({
                valueType: b,
                value: t[1]
            }), dt({
                valueType: b,
                value: t[2]
            })]);
        case De:
            return new O.FunctionCall("polygon",[dt({
                valueType: zt,
                value: t
            })]);
        case Ee:
            return new O.FunctionCall("segment",[dt({
                valueType: R,
                value: t[0]
            }), dt({
                valueType: R,
                value: t[1]
            })]);
        case Ce:
            return new O.FunctionCall("line",[dt({
                valueType: R,
                value: t[0]
            }), dt({
                valueType: R,
                value: t[1]
            })]);
        case Ae:
            return new O.FunctionCall("ray",[dt({
                valueType: R,
                value: t[0]
            }), dt({
                valueType: R,
                value: t[1]
            })]);
        case Ie:
            return new O.FunctionCall("mathVector",[dt({
                valueType: R,
                value: t[0]
            }), dt({
                valueType: R,
                value: t[1]
            })]);
        case he:
            return new O.FunctionCall("circle",[dt({
                valueType: R,
                value: t[0]
            }), dt({
                valueType: b,
                value: t[1]
            })]);
        case ce:
            return new O.FunctionCall("arc",[dt({
                valueType: R,
                value: t[0]
            }), dt({
                valueType: R,
                value: t[1]
            }), dt({
                valueType: R,
                value: t[2]
            })]);
        case Oe:
            return new O.FunctionCall("angle",[dt({
                valueType: R,
                value: t[0]
            }), dt({
                valueType: b,
                value: t[1]
            }), dt({
                valueType: b,
                value: t[2]
            })]);
        case Se:
            return new O.FunctionCall("directedangle",[dt({
                valueType: R,
                value: t[0]
            }), dt({
                valueType: b,
                value: t[1]
            }), dt({
                valueType: b,
                value: t[2]
            })]);
        case cr:
            return new O.FunctionCall("tone",[dt({
                valueType: b,
                value: t[0]
            }), dt({
                valueType: b,
                value: t[1]
            })]);
        case pt:
        case we:
        case sn:
        case Pt:
        case pn:
        case mn:
        case $t:
        case wt:
        case Kt:
        case Qt:
        case Ht:
        case an:
        case Yt:
        case qn:
        case zn:
            throw new Error(`Programming error: cannot create parse node from valueType: ${Ke(n)}`);
        default:
            throw new Error(`Programming error: unexpected value: ${e}`)
        }
    }
    function b5(e) {
        if (!qs(e))
            return new Vn(NaN);
        let t = {
            value: e.asCompilerValue(),
            valueType: e.valueType
        };
        return t ? dt(t) : new Vn(NaN)
    }
    function x5(e) {
        if (!qs(e))
            return NaN;
        let t = Rr(e);
        if (!t)
            return NaN;
        switch (t.valueType) {
        case b:
            return t.value;
        case N:
            return t.value;
        default:
            throw F(`Unexpected type ${Ke(t.valueType)} in column.`)
        }
    }
    var Uu = class extends Yi {
        constructor(n, r) {
            super(n.map(b5));
            this.rawArgs = n;
            this.headerSymbol = r;
            this.type = "TableColumnValue";
            this.isIndependent = r !== void 0
        }
        asValueMixed() {
            return this.rawArgs.map(x5)
        }
    }
    ;
    var T5 = {
        Placeholder: Sp,
        Error: v,
        Constant: Vn,
        MixedNumber: xx,
        Identifier: dn,
        Ans: ex,
        ImaginaryUnit: Za,
        List: Zm,
        TableColumnValue: Uu,
        Range: Np,
        ListAccess: $a,
        DotAccess: Qo,
        Construction: vp,
        ParenSeq: il,
        MovableComplexNumber: Hu,
        MovablePoint: Ya,
        NamedCoordinateAccess: Xa,
        BareSeq: ll,
        Norm: gd,
        ComparatorChain: pl,
        DoubleInequality: nx,
        Sum: Sd,
        Product: Td,
        Integral: ud,
        AssignmentExpression: Cp,
        ListComprehension: Tc,
        FunctionCall: Qn,
        RecursiveFunctionBaseCase: xo,
        SeededFunctionCall: Tx,
        FunctionExponent: dl,
        FunctionFactorial: fl,
        Prime: Rp,
        Piecewise: Io,
        Restriction: Id,
        Derivative: Mp,
        UpdateRule: Ed,
        Substitution: zu,
        Histogram: sd,
        DotPlot: rd,
        BoxPlot: ed,
        Stats: Pd,
        Assignment: Km,
        AssignmentImport: km,
        FunctionDefinition: _r,
        CallAssignment: gl,
        Equation: al,
        Regression: jm,
        Image: ox,
        Ticker: Sx,
        Slider: Ix,
        RegressionParameter: ul,
        Viewport: Jm,
        Table: Gu,
        TableColumn: sa,
        SolvedEquation: Px,
        OptimizedRegression: $m,
        Seed: Op,
        ExtendSeed: Dp,
        IRExpression: An,
        Add: Qm,
        Subtract: Jo,
        Multiply: fd,
        DotMultiply: ml,
        CrossMultiply: td,
        Divide: nd,
        Exponent: id,
        Negative: yd,
        Or: hd,
        PercentOf: bd,
        "Comparator['<']": Ey,
        "Comparator['>']": vy,
        "Comparator['<=']": Cy,
        "Comparator['>=']": My,
        "Comparator['=']": za
    }
      , O = T5;
    var dI = {};
    cu(dI, {
        parse: () => mi,
        parseIdentifier: () => C_,
        setInput: () => NG
    });
    $r();
    var Ic;
    function gw(e) {
        Ic = e
    }
    function hw() {
        Ic && (Ic.cacheHits += 1)
    }
    function bw() {
        Ic && (Ic.cacheMisses += 1)
    }
    function xw() {
        Ic && (Ic.cacheWrites += 1)
    }
    function Tw() {
        Ic && (Ic.cacheReads += 1)
    }
    function BM(e, t) {
        let n = Math.round(1e6 * e) / 1e6;
        return Math.abs(n - e) < t ? n : e
    }
    function gse(e) {
        let t = !0
          , n = !0
          , r = !0;
        return e.hardMin !== void 0 && e.target < e.hardMin && (t = !1),
        e.hardMax !== void 0 && e.target > e.hardMax && (n = !1),
        e.step && Cx({
            target: e.target,
            step: e.step,
            hardMin: t ? e.hardMin : void 0,
            hardMax: n ? e.hardMax : void 0
        }) !== e.target && (r = !1),
        {
            min: t,
            max: n,
            step: r
        }
    }
    function Cx(e) {
        let {target: t, hardMin: n, hardMax: r, step: o} = e
          , i = 1e-10;
        if (n !== void 0 && r !== void 0 && (i = Math.min(i, Math.abs(r - n) / 1e3)),
        o && (i = Math.min(i, o / 10)),
        n !== void 0 && (n = BM(n, i)),
        r !== void 0 && (r = BM(r, i)),
        e.forceSliderToMax && r !== void 0 && (t = r),
        n > r || t <= n)
            return n;
        if (t >= r)
            return r;
        if (o) {
            let a = n !== void 0 ? n : 0
              , u = Math.round((t - a) / o);
            t = o * u + a
        }
        let s = BM(t, i);
        return (o || n === s || r === s) && (t = s),
        t <= n ? n : t >= r ? r : t
    }
    function Iw(e) {
        let {storedMax: t, sliderValue: n, hardMin: r, step: o} = e
          , i = e.is3d ? Yr.xmax : 10;
        if (t > i && (i = t),
        n > i && (i = n),
        r > i && (i = r),
        o) {
            let s = Cx({
                target: i,
                hardMin: r,
                hardMax: void 0,
                step: o
            });
            s >= i ? i = s : i = s + o
        }
        return i
    }
    var P5 = Ru;
    function S5(e) {
        let t = [];
        for (let n = 0; n < e.length; n++)
            t.push(se(e[n].valueType));
        return t
    }
    var Ap = !0;
    function Pw(e, t, n) {
        let r = t.length
          , o = t[0];
        if (r < n)
            throw el(e._symbol, {
                blockExport: Ap
            });
        if (!P5(o.valueType, [Y, He]))
            throw el(e._symbol, {
                blockExport: Ap
            });
        if (r > n)
            throw e.type === "BoxPlot" ? el(e._symbol, {
                blockExport: Ap
            }) : ZE(e._symbol, 2)
    }
    function vx(e, t) {
        switch (e.type) {
        case "Histogram":
        case "DotPlot":
            return Pw(e, t, 2);
        case "BoxPlot":
            return Pw(e, t, 1);
        case "Stats":
            {
                let n = t.length
                  , r = t[0];
                if (n === 0)
                    throw el(e._symbol, {
                        blockExport: Ap
                    });
                if (r.valueType === He)
                    throw $i(e._symbol, S5(t), {
                        blockExport: Ap
                    });
                if (r.valueType !== Y)
                    throw el(e._symbol, {
                        blockExport: Ap
                    });
                if (n > 1)
                    throw el(e._symbol, {
                        blockExport: Ap
                    });
                break
            }
        }
    }
    var Pc = {
        coerceToNumber: "all"
    };
    function pe(e, t, n, r={}) {
        if (e.type === "IRExpression" || e.type === "Error")
            return e;
        try {
            return Wa(e, t, n, r)
        } catch (o) {
            return o instanceof O.Error ? o : F(o)
        }
    }
    function Wa(e, t, n, r={}) {
        let o = ja(e, t, n, {
            coerceToNumber: r.coerceToNumber
        });
        if (o.isError)
            throw o;
        return o
    }
    function qM(e, t, n) {
        var a;
        let r = Wa(new O.Piecewise([e._indicator, new O.FunctionCall("coerceToReal",[e._expressions[0]]), new Vn(NaN)]), t, n)
          , o = Wa(new O.Piecewise([e._indicator, new O.FunctionCall("coerceToReal",[e._expressions[1]]), new Vn(NaN)]), t, n)
          , i = new od([r, e._operators[0], new dn(e._symbol), e._operators[1], o])
          , s = (a = r.warning) != null ? a : o.warning;
        return s && (i.warning = s),
        i
    }
    function Ly(e, t) {
        return e.type === "Error" ? e : t.indexOf(e.valueType) === -1 ? jf() : e
    }
    function zM(e, t, n) {
        let r = pe(e.center, t, n)
          , o = pe(e.radianAngle, t, n, Pc)
          , i = pe(e.width, t, n, Pc)
          , s = pe(e.height, t, n, Pc)
          , a = pe(e.opacity, t, n, Pc)
          , u = [R, zt, He]
          , c = [b, Y, He];
        return r = Ly(r, u),
        o = Ly(o, c),
        i = Ly(i, c),
        s = Ly(s, c),
        a = Ly(a, c),
        new ad({
            center: r,
            radianAngle: o,
            width: i,
            height: s,
            opacity: a
        })
    }
    function HM(e, t, n) {
        let r = pe(e.handler, t, n);
        !r.isError && r.valueType !== pt && (r = ey(se(r.valueType)));
        let o = r.getDependencies().filter(i => !(t.graphingEnabled() && t.validActionVariable(i)));
        return o.length && (r = xn(t.sliderVariables(o)).setDependencies(o)),
        new O.Ticker({
            handler: r,
            minStep: pe(e.minStep, t, n, Pc)
        })
    }
    function Sw(e, t, n) {
        let r = i => {
            try {
                let a = Wa(i, t, n, {
                    coerceToNumber: "all"
                });
                return a.isError,
                a
            } catch (s) {
                return s instanceof v ? s : F(s)
            }
        }
          , o = {
            xmin: r(e.bounds.xmin),
            xmax: r(e.bounds.xmax),
            ymin: r(e.bounds.ymin),
            ymax: r(e.bounds.ymax)
        };
        return e.bounds.zmin && (o.zmin = r(e.bounds.zmin)),
        e.bounds.zmax && (o.zmax = r(e.bounds.zmax)),
        new Jb(o)
    }
    function GM(e, t, n) {
        if (!t) {
            n.valids[e] = !0;
            return
        }
        let r = t.getDependencies();
        if (t.type === "Error")
            n.errors[e] = !0;
        else if (r.length > 0) {
            n.errors[e] = !0;
            for (let o = 0; o < r.length; o++)
                r[o] === n.exportedSymbol ? n.errors.cycle = !0 : n.missingVars.push(r[o])
        } else
            n.values[e] = +t.asValue();
        n.valids[e] = n.values[e] !== void 0 && isFinite(n.values[e]),
        n.valids[e] || (n.values[e] = void 0)
    }
    function Mx(e) {
        return e && e.valueType === Y && e.type === "List" && e.length === 1 && "args"in e && e.args ? e.args[0] : e
    }
    function wp(e, t, n) {
        let r = Wa(e._expression, t, n)
          , o = Mx(e.sliderMin && pe(e.sliderMin, t, n, Pc))
          , i = Mx(e.sliderMax && pe(e.sliderMax, t, n, Pc))
          , s = Mx(e.sliderStep && pe(e.sliderStep, t, n, Pc))
          , a = {
            exportedSymbol: e._symbol,
            errors: {},
            values: {},
            valids: {},
            missingVars: [],
            errMsg: void 0
        };
        if (GM("min", o, a),
        GM("max", i, a),
        GM("step", s, a),
        s && a.valids.step && (a.values.step === 0 ? delete a.values.step : a.values.step = Math.abs(a.values.step)),
        a.errors.cycle ? r = wC(a.exportedSymbol) : (a.errors.min || !a.valids.min ? a.errMsg = LC() : a.errors.max || !a.valids.max ? a.errMsg = FC() : (a.errors.step || !a.valids.step) && (a.errMsg = BC()),
        a.values.min > a.values.max && (a.valids.min = !1,
        a.valids.max = !1,
        a.errMsg || (a.errMsg = VC()))),
        r.type === "IRExpression" && r.isConstant) {
            let c = n.initialEvaluation && n.initialEvaluation.asValue() && e.sliderIsPlayingOnce
              , l = a.values.max
              , p = +r.asValue()
              , m = a.values.min
              , d = a.values.step;
            if (c && !isFinite(l)) {
                let h = Mx(e.sliderSoftMax && pe(e.sliderSoftMax, t, n, Pc));
                h && (l = Iw({
                    storedMax: +h.asValue(),
                    sliderValue: p,
                    step: d,
                    hardMin: m,
                    is3d: t.is3dProduct()
                }))
            }
            let y = Cx({
                target: p,
                hardMin: m,
                hardMax: l,
                step: d,
                forceSliderToMax: !!c
            })
              , g = op(y.toString())
              , f = isFinite(L(g)) ? g : y;
            r = Wa(new Vn(f), t, n)
        }
        return r.sliderInfo = a,
        r
    }
    function UM(e, t, n) {
        if (!n[e._symbol])
            throw Ga(e._symbol, t);
        let r = e.args.map(o => pe(o, t, n));
        if (r.length > 0) {
            if (r.length === 1 && r.push(pe(new O.Constant(1), t, n)),
            r[1].getDependencies().length)
                throw ly(e._symbol).setDependencies(r[1].getDependencies());
            if (r[1].valueType !== b)
                throw ly(e._symbol);
            let o = r[1].asValue();
            if (!isFinite(o) || o <= 0)
                throw ly(e._symbol)
        }
        return vx(e, r),
        new e.constructor(r)
    }
    function kM(e, t, n) {
        if (!n[e._symbol])
            throw Ga(e._symbol, t);
        let r = e.args.map(o => Wa(o, t, n));
        if (vx(e, r),
        r.length === 1 && (r[0].valueType === Y || r[0].valueType === He))
            return new O.BoxPlot(r);
        throw F("Failed to compile BoxPlot")
    }
    function qo(e, t, n, r, o) {
        try {
            return e(t, n, r, o)
        } catch (i) {
            return i instanceof v ? i : F(i)
        }
    }
    function $M(e, t, n) {
        if (!e._symbol || !n[e._symbol])
            throw Ga(e._symbol, t);
        let r = e.args.map(o => Wa(o, t, n));
        return vx(e, r),
        e.copyWithArgs(r)
    }
    function YM(e, t, n) {
        var s;
        let r = [];
        for (let a of e.columns) {
            let u = bc(a) && Ha(a.header) ? n[a.header._symbol] : void 0;
            u && Bu(u) ? r.push(u) : r.push(qo(Dx, a, t, n))
        }
        let o = 1;
        for (let a of r)
            Xm(a) && a.isList && (o = Math.max((s = a.length) != null ? s : 0, o));
        let i = [];
        for (let a of r)
            i.push(E5(a, o));
        return new Wb(i,e.calcColumns,e.regression,e.tableFrameID)
    }
    function E5(e, t) {
        if (To(e))
            return e;
        if (Bu(e))
            return e;
        if (Xm(e) && e.isList)
            return new O.TableColumnValue(e.mapElements(n => n),void 0);
        if (e.isTypedConstant) {
            let n = [];
            for (let r = 0; r < t; r++)
                n.push(e);
            return new Uu(n,void 0)
        } else
            return F(`Invalid column: expected an error, constant, or list but got:
 ${e.repr("", 1)}`)
    }
    function Dx(e, t, n) {
        var o, i, s, a;
        let r = e.header.tableError();
        if (r)
            throw iv(r);
        if (e.header instanceof ze) {
            let u = n[e.header._symbol];
            if (u && n.hasOwnProperty(e.header._symbol) && To(u))
                throw u
        }
        if (e.isFreeVariable(n)) {
            if (e.columnIndex === 0) {
                let c = e.header._symbol;
                if (!t.validFirstColumnVariable(c))
                    throw sv()
            }
            let u = [];
            for (let c = 0; c < e.values.length; c++) {
                let l = (i = (o = e.values[c]).tableError) == null ? void 0 : i.call(o);
                if (l) {
                    u.push(uy(l));
                    continue
                }
                let p = pe(e.values[c], t, n)
                  , m = (s = p.tableError) == null ? void 0 : s.call(p);
                p.isError ? u.push(p) : m ? u.push(uy(m)) : p.valueType === b || p.valueType === N ? u.push(p) : u.push(SE([se(p.valueType)]))
            }
            for (let c = 0; c < u.length; c++) {
                if (u[c].isError)
                    continue;
                let l = e.values[c] && e.values[c].tableError();
                if (l) {
                    u[c] = uy(l);
                    continue
                }
                let p = u[c].getDependencies();
                p.length && (u[c] = xn(p).setDependencies(p))
            }
            return new Uu(u,e.header._symbol)
        } else {
            let u = pe(e.header, t, n, {
                coerceToNumber: "all-except-complex"
            });
            if (!u.isError && u.valueType !== b && u.valueType !== Y && u.valueType !== N && u.valueType !== ke && u.valueType !== He)
                throw PE([se((a = u.valueType) != null ? a : Dn)]);
            if (u.getDependencies().length > 0)
                throw xn(u.getDependencies()).setDependencies(u.getDependencies());
            if (u.isError)
                throw u;
            return u
        }
    }
    function hl(e, t, n, r={}) {
        try {
            return C5(e, t, n, r)
        } catch (o) {
            return o instanceof v ? o : F(o)
        }
    }
    function C5(e, t, n, r={}) {
        switch (e.type) {
        case "IRExpression":
            return e;
        case "DoubleInequality":
            return qM(e, t, n);
        case "Error":
            return e;
        case "Image":
            return zM(e, t, n);
        case "Ticker":
            return HM(e, t, n);
        case "Slider":
            return wp(e, t, n);
        case "Table":
            return YM(e, t, n);
        case "TableColumn":
            return Dx(e, t, n);
        case "Histogram":
        case "DotPlot":
            return UM(e, t, n);
        case "BoxPlot":
            return kM(e, t, n);
        case "Stats":
            return $M(e, t, n);
        case "Regression":
        case "Placeholder":
            throw new Error("Unexpected placeholder or regression")
        }
        return Wa(e, t, n, r)
    }
    var Ew = {
        segment: !0,
        ray: !0,
        vector: !0,
        line: !0,
        circle: !0,
        arc: !0,
        polygon: !0,
        glider: !0,
        midpoint: !0,
        intersection: !0,
        strictintersection: !0,
        perpendicular: !0,
        parallel: !0,
        translate: !0,
        rotate: !0,
        dilate: !0,
        reflect: !0,
        apply: !0,
        segments: !0,
        vertices: !0,
        angle: !0,
        angles: !0,
        directedangle: !0,
        directedangles: !0,
        clockwise: !0,
        counterclockwise: !0,
        reflex: !0,
        start: !0,
        end: !0,
        anglebisector: !0
    };
    function Ja(e) {
        switch (e.type) {
        case "simple":
            return;
        case "list-access":
            return e.listIndex;
        case "polygon-edge":
            return Ja(e.polygon);
        case "arbitrary-expression":
            return;
        default:
            throw new Error(`Unexpected parent type: ${e.type}`)
        }
    }
    function ku(e) {
        switch (e.type) {
        case "simple":
        case "list-access":
            return e.identifier;
        case "polygon-edge":
            return ku(e.polygon);
        default:
            throw new Error(`Unexpected parent type: ${e.type}`)
        }
    }
    var Cd = {
        simple: e => ({
            type: "simple",
            identifier: e
        }),
        listAccess: (e, t) => ({
            type: "list-access",
            identifier: e,
            listIndex: t
        }),
        polygonEdge: (e, t) => ({
            type: "polygon-edge",
            polygon: {
                type: "simple",
                identifier: e
            },
            edgeIndex: t
        }),
        polygonListItemEdge: (e, t) => ({
            type: "polygon-edge",
            polygon: {
                type: "list-access",
                identifier: e,
                listIndex: t.listIndex
            },
            edgeIndex: t.edgeIndex
        }),
        arbitraryExpression: e => ({
            type: "arbitrary-expression",
            latex: e.getInputString()
        })
    };
    function v5(e) {
        return e !== void 0 && e in Ew
    }
    function Fy(e) {
        return v5(e) ? e === "rotate" || e === "dilate" || e === "translate" || e === "reflect" ? !0 : !1 : !1
    }
    function _x(e) {
        if (e instanceof $a && e.list instanceof ze && e.index instanceof Hn)
            return Cd.listAccess(e.list._symbol, e.index.asValue());
        if (e instanceof $a && e.list instanceof Qo && e.index instanceof Hn) {
            let t = e.list.args[0]
              , n = e.list.args[1];
            if (t instanceof ze && n instanceof ze && n._symbol === "segments")
                return Cd.polygonEdge(t._symbol, e.index.asValue());
            if (t instanceof $a && t.list instanceof ze && t.index instanceof Hn)
                return Cd.polygonListItemEdge(t.list._symbol, {
                    listIndex: t.index.asValue(),
                    edgeIndex: e.index.asValue()
                })
        }
        return e.type === "Identifier" ? Cd.simple(e._symbol) : Cd.arbitraryExpression(e)
    }
    function Rx(e) {
        let t = {}
          , n = e;
        if ((n instanceof Ln || n instanceof _r) && (t.identifier = n._symbol,
        n = n._expression),
        n instanceof $a && n.index instanceof Hn && (t.listAccess = n.index.asValue(),
        n = n.list),
        n instanceof _n) {
            let r = n._symbol
              , o = n.args[0]instanceof ze ? n.args[0]._symbol : void 0;
            if (Fy(r) && e instanceof _r && o && e._argSymbols.some(i => i === o))
                t.tree = {
                    symbol: r,
                    parents: n.args.slice(1).map(_x)
                };
            else if (Ew[r])
                t.tree = {
                    symbol: r,
                    parents: n.args.map(_x)
                };
            else {
                let i = Cd.simple(n._symbol);
                t.tree = {
                    symbol: "apply",
                    parents: [i, ...n.args.map(_x)]
                }
            }
        } else if (n instanceof Qo) {
            let r = n.args.map(_x);
            r.length === 2 && r[1] && r[1].type === "simple" && r[1].identifier === "segments" ? t.tree = {
                symbol: "segments",
                parents: [r[0]]
            } : r.length === 2 && r[1] && r[1].type === "simple" && r[1].identifier === "start" ? t.tree = {
                symbol: "start",
                parents: [r[0]]
            } : r.length === 2 && r[1] && r[1].type === "simple" && r[1].identifier === "end" && (t.tree = {
                symbol: "end",
                parents: [r[0]]
            })
        }
        return t
    }
    function Mw(e, t, n, r, o) {
        let i = ae(n, he) || ae(n, ce)
          , s = ae(o, he) || ae(o, ce);
        if (!i && !s)
            return;
        let a = vw(e, t, n)
          , u = vw(e, r, o)
          , c = a.filter(l => {
            let p = ku(l);
            return p ? u.some(m => $o(l, m)) && !!e.lookup(p) : !1
        }
        );
        for (let l of a)
            Cw(e, l, r) && c.every(p => !$o(l, p)) && c.push(l);
        for (let l of u)
            Cw(e, l, t) && c.every(p => !$o(l, p)) && c.push(l);
        if (c.length === 1)
            return c[0]
    }
    function Cw(e, t, n) {
        let r = ku(t)
          , o = r !== void 0 ? e.lookup(r) : void 0
          , i = o && e.getGeometryTree(o);
        return ((i == null ? void 0 : i.symbol) === "glider" || (i == null ? void 0 : i.symbol) === "intersection" || (i == null ? void 0 : i.symbol) === "strictintersection" || (i == null ? void 0 : i.symbol) === "midpoint") && (i == null ? void 0 : i.parents.some(s => {
            if (s.type === "arbitrary-expression")
                return !1;
            let a = ku(s);
            return a && e.resolvesTo(a, n) && (Ja(t) === void 0 || Ja(s) === void 0 || Ja(s) === Ja(t))
        }
        ))
    }
    function vw(e, t, n) {
        var i;
        let r = []
          , o = ((i = e.getGeometryTree(t)) == null ? void 0 : i.parents) || [];
        for (let s = 0; s < o.length; s++) {
            let a = o[s];
            if (ae(n, he) && s === 0 || a.type === "arbitrary-expression" || a.type === "polygon-edge")
                continue;
            let u = ku(a);
            if (!u)
                continue;
            let c = e.lookup(u);
            c && e.isPointOrListOfPoints(c) && r.push(a)
        }
        return r
    }
    function vd(e) {
        if (e.length === 0)
            return He;
        if (e.includes(N))
            return ke;
        let t = e[0];
        if (t !== b && ur(t, b))
            for (let n of e) {
                let r = Uc(t, n);
                r !== void 0 && (t = r)
            }
        return jn(t) ? $n(t) : nr
    }
    function Dw(e) {
        let t = [];
        for (let n of e)
            n !== He && t.push(rr(n));
        return vd(t)
    }
    var Nx = class e {
        constructor(t, n, r) {
            this.startIP = t;
            this.endIP = n;
            this.arr = r
        }
        static newFromRange(t, n) {
            return new e(t,n,new Uint16Array(n - t + 1))
        }
        clone() {
            return new e(this.startIP,this.endIP,this.arr.slice())
        }
        translateAddr(t) {
            if (t < this.startIP || t > this.endIP)
                throw new Error(`get(${t}) out of range for IPMapArray(${this.startIP}, ${this.endIP}).`);
            return t - this.startIP
        }
        get(t) {
            return this.arr[this.translateAddr(t)]
        }
        set(t, n) {
            this.arr[this.translateAddr(t)] = n
        }
    }
    ;
    var zo = class e {
        constructor(t, n, r, o=t, i) {
            this.oldChunk = t;
            this.oldStart = n;
            this.oldEnd = r;
            this.newChunk = o;
            if (r < n)
                throw new Error("End before start in ChunkCopyContext.");
            this.oldIPtoNewIP = i != null ? i : Nx.newFromRange(n, r)
        }
        clone() {
            return new e(this.oldChunk,this.oldStart,this.oldEnd,this.newChunk,this.oldIPtoNewIP.clone())
        }
        copyUntilEnd(t) {
            for (let n = this.oldStart; n <= this.oldEnd; n++) {
                let r = this.oldChunk.getInstruction(n)
                  , o = t(this.newChunk, r, n, this.oldChunk);
                this.markMappedIndex(n, o)
            }
        }
        markMappedIndex(t, n) {
            this.oldIPtoNewIP.set(t, n)
        }
        mapIndex(t) {
            return t < this.oldStart ? t : this.oldIPtoNewIP.get(t)
        }
        mapArgs(t) {
            let n = [];
            for (let r of t)
                n.push(this.mapIndex(r));
            return n
        }
        copyLeafOrFunctionHeader(t) {
            if (BA(t)) {
                let n = this.newChunk.FunctionHeader(t.symbol, t.valueType, t.signature, t.parameterSymbols);
                return this.functionHeaderCopied(t, n),
                n
            } else
                return this.newChunk.copyLeafInstruction(t)
        }
        functionHeaderCopied(t, n) {
            var i;
            (i = this.unpatchedHeaderMap) != null || (this.unpatchedHeaderMap = new Map);
            let r = t.recursionGroup[0]
              , o = this.unpatchedHeaderMap.get(r);
            if (o === void 0 && (o = [],
            this.unpatchedHeaderMap.set(r, o)),
            o.push(n),
            o.length === t.recursionGroup.length) {
                this.unpatchedHeaderMap.delete(r);
                for (let s of o)
                    this.newChunk.getInstruction(s).recursionGroup = o
            }
        }
    }
    ;
    function Wr(e, t) {
        let n = e.getInstruction(t);
        if (n.type !== 48)
            return t;
        let r = n.args[0]
          , o = e.getInstruction(r)
          , i = o.args[0]
          , s = !1;
        for (let c = i + 1; c < r; c++) {
            let l = e.getInstruction(c);
            if (l.type === 40 && l.args[1] === i) {
                s = !0;
                break
            }
        }
        if (!s)
            return t;
        let a = r + o.args.length - 1
          , u = new zo(e,i,a);
        return u.copyUntilEnd( (c, l) => {
            if (de(l)) {
                let p = u.mapArgs(l.args);
                return l.type === 40 ? c.InboundsListAccess(p) : c.copyInstructionWithArgs(l, p)
            } else
                return u.copyLeafOrFunctionHeader(l)
        }
        ),
        e.getReturnIndex()
    }
    function Qa(e, t, n) {
        let r = Un(e, t);
        if (r === void 0)
            throw new Error(`${n}
Non-constant instruction: "${_p(e, Pr(e, t))}"`);
        return r
    }
    function Un(e, t) {
        let n = Lp(e, t, void 0, void 0);
        if (!(n < 0))
            return n
    }
    function Lp(e, t, n, r) {
        var a;
        let o = n && n[t];
        if (o)
            return o;
        let i = e.getInstruction(t), s;
        switch (i.type) {
        case 38:
            s = i.args.length;
            break;
        case 1:
            s = i.value.length;
            break;
        case 48:
            {
                s = (a = i.constantLength) != null ? a : -1;
                break
            }
        }
        return s === void 0 && (n = n || {},
        s = M5(e, i, n, r || new Set)),
        n && (n[t] = s),
        s
    }
    function M5(e, t, n, r) {
        switch (t.type) {
        case 33:
            {
                let o = Lp(e, t.args[1], n, r)
                  , i = Lp(e, t.args[2], n, r);
                return o === i ? o : -1
            }
        case 37:
            switch (t.symbol) {
            case "elementsAt":
                return Lp(e, t.args[1], n, r);
            case "sortPerm":
            case "complexSortPerm":
                return Lp(e, t.args[0], n, r);
            case "shuffle":
                return Lp(e, t.args[1], n, r);
            default:
                return -1
            }
        case 55:
            {
                if (r && r.has(t.args[0]))
                    return -1;
                r.add(t.args[0]);
                let o = e.dereferenceFunctionHeader(t.args[0]);
                if (o !== void 0) {
                    let i = e.getInstruction(o);
                    return Lp(e, i.args[1], n, r)
                }
                return -1
            }
        default:
            {
                if (X(t.valueType))
                    return -1;
                throw new Error(`Programming Error: cannot find the list length of ${So(t.type)} ${se(t.valueType)}.`)
            }
        }
    }
    function Pr(e, t) {
        let n = e.getInstruction(t);
        if (!X(n.valueType))
            throw new Error(`Programming Error: cannot find the list length of ${e.printInstruction(t)}`);
        switch (n.type) {
        case 38:
            return e.Constant(n.args.length);
        case 1:
            return e.Constant(n.value.length);
        case 48:
            {
                let r = e.getInstruction(n.args[0]);
                return e.getInstruction(r.args[0]).args[0]
            }
        case 37:
            switch (n.symbol) {
            case "elementsAt":
                return Pr(e, n.args[1]);
            case "sortPerm":
            case "complexSortPerm":
                return Pr(e, n.args[0]);
            case "shuffle":
                return Pr(e, n.args[1])
            }
        }
        return e.NativeFunction("count", [t])
    }
    function Md(e, t) {
        let n = [];
        for (let s of t)
            X(e.getInstruction(s).valueType) && n.push(s);
        if (n.length === 0)
            return;
        if (n.length === 1)
            return Pr(e, n[0]);
        let r = [];
        for (let s of n)
            r.push(Un(e, s));
        let o, i = 1 / 0;
        for (let s = 0; s < r.length; s++) {
            let a = n[s]
              , u = r[s];
            if (u === void 0)
                return e.NativeFunction("listMin", [e.List(n.map(c => Pr(e, c)))]);
            u < i && (o = a,
            i = u)
        }
        return o !== void 0 ? Pr(e, o) : e.Constant(i)
    }
    var Vy = [Fr(b), Fr(b)]
      , ZM = [...Zi([[Pe, Pe], [N, N], [R, b], [b, R], [b, Ie], [b, qe], [Ie, b], [qe, b], [G, b], [b, G], [sn, Af], [Af, sn]]), St([sn, wf]), St([wf, sn])]
      , XM = {
        Negative: Zi([[Pe], [N], [R], [Ie], [qe], [G]]),
        Add: Zi([[Pe, Pe], [N, N], [R, R], [Ie, Ie], [qe, qe], [G, G]]),
        Subtract: Zi([[Pe, Pe], [N, N], [R, R], [Ie, Ie], [qe, qe], [G, G]]),
        Multiply: ZM,
        DotMultiply: [...Zi([[Ie, Ie], [qe, qe], [G, G]]), ...ZM],
        CrossMultiply: [...Zi([[qe, qe], [G, G]]), ...Zi([[Pe, Pe], [N, N], [R, b], [b, R], [Ie, b], [b, Ie], [qe, b], [b, qe], [sn, Af], [Af, sn]]), St([sn, wf]), St([wf, sn])],
        Divide: Zi([[Pe, Pe], [N, N], [R, b], [Ie, b], [qe, b], [G, b]]),
        Exponent: Zi([[Pe, Pe], [N, N]]),
        "Comparator['=']": [St(Vy)],
        "Comparator['>']": [St(Vy)],
        "Comparator['<']": [St(Vy)],
        "Comparator['>=']": [St(Vy)],
        "Comparator['<=']": [St(Vy)],
        ComparatorChain: Zi([{
            type: "variadic",
            initial: [b, b],
            rest: b
        }]),
        PercentOf: ZM,
        Norm: Zi([[b], [R], [G], [Ie], [qe]]),
        ListAccess: [St([Ui, Fr(xr.of([Fe, b]))])],
        Integral: Zi([[b, b, xr.of(gm, {
            coerceComplexToReal: !1
        })]])
    };
    function Zi(e) {
        return e.map(t => q(t))
    }
    function Ox(e, t, n) {
        if (t instanceof Yi) {
            let r = n.filter(i => i !== void 0);
            if (r.length === 0)
                return;
            let o = vd(r);
            return X(o) && o !== nr ? bl([St({
                type: "variadic",
                initial: [],
                rest: Qe(o)
            })], n) : []
        } else if (t instanceof _n || t instanceof Qo) {
            let r = t instanceof Qo ? t.args[1]._symbol : t._symbol;
            if (!r)
                return;
            let o = Py(e, r);
            return o ? bl(o, n) : void 0
        } else if (t instanceof Io) {
            let[r,o,i] = n
              , s = o !== void 0 && i !== void 0 ? mc(o, i) : void 0;
            !s && i === b && t.args[2]instanceof Hn && t.args[2].isNaN() && (i = void 0);
            let a;
            if (s !== void 0)
                a = s;
            else if (o !== void 0)
                a = o;
            else if (i !== void 0)
                a = i;
            else
                return;
            a = rr(a);
            let u = jn(a) ? Fr(a) : a;
            return bl([St([Fr(Fe), u, u])], [n[0], o, i])
        } else if (t instanceof ml) {
            let r = [...XM.DotMultiply, q([R, R])];
            return bl(r, n)
        } else if (t instanceof Gs) {
            let r = [St({
                type: "variadic",
                initial: [pt],
                rest: pt
            }), q([b, b]), q([b, b, b])];
            return bl(r, n)
        } else if (t instanceof ll) {
            let r = [St({
                type: "variadic",
                initial: [pt],
                rest: pt
            })]
              , o = n.filter(i => i !== void 0 && i !== b);
            if (o.length > 0) {
                let i = vd(o);
                X(i) && i !== nr && r.push(St({
                    type: "variadic",
                    initial: [],
                    rest: Qe(i)
                }))
            }
            return bl(r, n)
        } else if (t instanceof Xa) {
            let r = t.symbol, o;
            switch (r) {
            case "x":
            case "y":
                o = Zi([[R], [G]]);
                break;
            case "z":
                o = Zi([[G]]);
                break;
            case "p":
                o = Zi([[pn], [mn], [zn], [qn], ...mh.map(i => [i])]);
                break;
            default:
                {
                    let i = r;
                    throw new Error(`Programming Error: unexpected named coordinate: '${i}'.`)
                }
            }
            return bl(o, n)
        } else if (t.type in XM && n.some(r => r !== void 0)) {
            let r = XM[t.type];
            return r ? bl(r, n) : void 0
        }
    }
    function bl(e, t) {
        return e.filter(n => n.matches(t))
    }
    function Rw(e, t, n, r) {
        if (!Ow(e, n, r))
            return;
        let o = t.type;
        switch (o) {
        case "Comparator['>']":
        case "Comparator['<']":
        case "Comparator['>=']":
        case "Comparator['<=']":
            {
                e.setWarning(I("shared-calculator-error-complex-operation-undefined", {
                    symbol: $(t.operator)
                }));
                break
            }
        case "ComparatorChain":
            {
                let[i] = t.symbols;
                if (i === void 0 || i === "=")
                    break;
                e.setWarning(I("shared-calculator-error-complex-operation-undefined", {
                    symbol: $(i)
                }));
                break
            }
        case "ParenSeq":
            e.setWarning(I("shared-calculator-error-complex-point-coordinate"));
            break;
        case "Integral":
            switch (Aw(e, n, r)) {
            case 0:
                e.setWarning(I("shared-calculator-error-integral-lower-bound-type-error", {
                    symbol: se(e.getInstruction(n[0]).valueType)
                }));
                break;
            case 1:
                e.setWarning(I("shared-calculator-error-integral-upper-bound-type-error", {
                    symbol: se(e.getInstruction(n[1]).valueType)
                }));
                break;
            default:
                break
            }
            break;
        case "ListAccess":
            e.setWarning(I("shared-calculator-error-complex-list-access"));
            break;
        case "CrossMultiply":
        case "DotMultiply":
        case "Multiply":
        case "PercentOf":
            if (n.length !== 2)
                break;
            e.setWarning(I("shared-calculator-error-multiply-type-error", _w(e, n)));
            break;
        case "Divide":
            if (n.length !== 2)
                break;
            e.setWarning(I("shared-calculator-error-divide-type-error", _w(e, n)));
            break;
        case "Sum":
        case "Product":
        case "Range":
            break;
        case "DotAccess":
        case "FunctionCall":
        case "SeededFunctionCall":
            break;
        case "Comparator['=']":
        case "Add":
        case "Subtract":
        case "Exponent":
        case "Negative":
        case "Or":
        case "Piecewise":
        case "Restriction":
        case "List":
        case "TableColumnValue":
        case "Norm":
        case "BareSeq":
        case "NamedCoordinateAccess":
        case "Ans":
        case "Constant":
        case "ImaginaryUnit":
        case "Assignment":
        case "RecursiveFunctionBaseCase":
        case "MixedNumber":
        case "Identifier":
        case "AssignmentImport":
        case "Construction":
        case "ListComprehension":
        case "FunctionExponent":
        case "FunctionFactorial":
        case "Prime":
        case "Derivative":
        case "UpdateRule":
        case "Substitution":
        case "FunctionDefinition":
        case "Slider":
        case "RegressionParameter":
        case "Seed":
        case "ExtendSeed":
        case "Placeholder":
            break;
        default:
        }
    }
    function Nw(e, t, n, r, o) {
        if (t === "sort") {
            let i;
            if (r.length === 1)
                i = r[0];
            else if (r.length === 2)
                i = r[1];
            else
                return;
            ww(e.getInstruction(i)) && e.setWarning(I("shared-calculator-error-complex-sort", {
                symbol: $(n)
            }));
            return
        }
        if (Ow(e, r, o))
            switch (t) {
            case "factorial":
            case "erf":
            case "nCr":
            case "nPr":
                e.setWarning(I("shared-calculator-error-complex-operation-unimplemented", {
                    symbol: $(n)
                }));
                break;
            case "round":
                e.setWarning(I("shared-calculator-error-complex-round", {
                    symbol: $(n)
                }));
                break;
            default:
                e.setWarning(I("shared-calculator-error-complex-operation-undefined", {
                    symbol: $(n)
                }));
                break
            }
    }
    function Ow(e, t, n) {
        return Aw(e, t, n) !== -1
    }
    function Aw(e, t, n) {
        if (n.length === 0)
            return -1;
        let r = n[0];
        for (let o = 0; o < t.length; o++) {
            let i = t[o]
              , s = r.argTypeAtIndex(o);
            if (!(s === b || s === Y || typeof s == "object" && s.coerceComplexToReal))
                continue;
            let u = e.getInstruction(i);
            if (ww(u))
                return o
        }
        return -1
    }
    function ww(e) {
        if (e.type !== 1)
            return !1;
        switch (e.valueType) {
        case N:
            return L(e.value[1]) !== 0;
        case ke:
            return e.value.some(t => L(t[1]) !== 0);
        default:
            return !1
        }
    }
    function _w(e, t) {
        let n = e.getInstruction(t[0])
          , r = e.getInstruction(t[1]);
        return {
            symbol1: se(n.valueType),
            symbol2: se(r.valueType)
        }
    }
    function Fw(e, t, n, r, o, i) {
        var x, T, P, C;
        if (n = Ub(t, n),
        !Pp(n) && !Hm(n) || Fy(n))
            return;
        let s, a = !1, u = !1, c = 0, l = [], p = [], m = o.map(S => e.getInstruction(S).valueType), d = Pp(n) ? qa[n] : void 0;
        if (d && (a = d.isSeeded,
        s = void 0,
        l.push(...d.getSignatures(t)),
        c = (T = (x = d.defaultArguments) == null ? void 0 : x.length) != null ? T : 0,
        p = Ax(l, m, c),
        u = d.allowDotCall),
        p.length === 0 && (d != null && d.fallthroughUnlessDistribution) && m.length > 0 && ae(m[0], Rn))
            l = l.filter(S => {
                let E = S.argTypeAtIndex(0);
                return E === void 0 ? !1 : np(Rn, E)
            }
            ),
            p = [];
        else if (Hm(n) && p.length === 0) {
            let S = ir[n];
            s = S.tag,
            l.push(...TM(n)),
            c = (C = (P = S.defaultArguments) == null ? void 0 : P.length) != null ? C : 0,
            p = Ax(l, m, c),
            u = u || S.allowDotCall
        }
        let y = Math.min(...l.map(S => S.minArity))
          , g = Math.max(...l.map(S => {
            var E;
            return (E = S.maxArity) != null ? E : 1 / 0
        }
        ))
          , f = o
          , h = o;
        if (a && (h = f = o.slice(1),
        y -= 1,
        g -= 1),
        i) {
            if (!u)
                throw Kf(r);
            let S = e.getInstruction(f[0]).valueType;
            if (!X(S) && S !== en && S !== qe && S !== Rn && S !== cr && S !== pn && S !== mn && S !== Pt && S !== qn && S !== zn && !Ti(S) && (S === R || !_f(S)) && n !== "real" && n !== "imag")
                throw iE(r, se(S), {
                    blockExport: e.areAllArgsConstant([f[0]])
                });
            r = "." + r,
            h = f.slice(1),
            y -= 1,
            g -= 1
        }
        if ((t.isGeometryEnabled() || t.is3dPolicy()) && n === "length" && h.length === 1 && X(e.getInstruction(h[0]).valueType)) {
            let S = t.is3dPolicy() ? oE : rE;
            if (p.length === 0)
                throw S(r, Ka(e, h)[0], {
                    blockExport: e.areAllArgsConstant(h)
                });
            if (h.length === 1 && e.getInstruction(h[0]).valueType === He)
                throw S(r, Ka(e, h)[0], {
                    blockExport: e.areAllArgsConstant(h)
                })
        }
        if (p.length > 0) {
            Nw(e, n, r, o, p);
            return
        }
        throw WM(e, {
            symbol: n,
            errorSymbol: r,
            providedArgs: h,
            argsWithoutSeed: f,
            isDotCall: i,
            minArity: y,
            maxArity: g,
            defaultArgumentCount: c,
            builtInTag: s,
            signatures: l
        })
    }
    function WM(e, {symbol: t, errorSymbol: n, providedArgs: r, argsWithoutSeed: o, isDotCall: i, minArity: s, maxArity: a, defaultArgumentCount: u, builtInTag: c, signatures: l}) {
        if (c === "doubleReducer" && r.length === 2) {
            if (!X(e.getInstruction(r[0]).valueType) || !X(e.getInstruction(r[1]).valueType))
                throw cv(n, {
                    blockExport: e.areAllArgsConstant(r)
                })
        } else if (c === "parameterizedReducer" && !i && r.length === 2 && !X(e.getInstruction(r[0]).valueType))
            throw lv(n, {
                blockExport: e.areAllArgsConstant([r[0]])
            });
        if (t === "logbase" && r.length !== 2)
            return Ba("log", 1, r.length - 1, {
                includeUsageExample: !0
            });
        if (t === "random")
            return JE();
        if (r.length < s || r.length > a) {
            let {dotMinArityExampleArgs: g, dotMaxArityExampleArgs: f, minArityExampleArgs: h, maxArityExampleArgs: x} = D5(t), T, P;
            if (r.length < s ? (P = s - u,
            i && g ? T = n + g : h && (T = n + h)) : (P = a,
            i && f ? T = n + f : x && (T = n + x)),
            i && (c === "parameterizedReducer" || t === "pdf" || t === "cdf"))
                return Ba(n, P, r.length, {
                    includeUsageExample: !0,
                    usageExample: T
                });
            if (c === "reducer" && r.length === 0)
                return rC(n);
            if (c === "doubleReducer")
                return nC(n);
            if (c === "parameterizedReducer")
                return tC(n);
            if (c === "color")
                return KE(n);
            if (Pp(t))
                switch (t) {
                case "pdf":
                    return XE();
                case "cdf":
                    return r.length < s ? WE() : jE();
                case "tdist":
                case "length":
                case "round":
                case "floor":
                case "ceil":
                case "abs":
                case "sign":
                case "mod":
                case "gcd":
                case "lcm":
                case "min":
                case "max":
                case "midpoint":
                case "segment":
                case "vector":
                case "sphere":
                case "distance":
                case "circle":
                case "center":
                case "radius":
                case "glider":
                case "intersection":
                case "strictintersection":
                case "parallel":
                case "perpendicular":
                case "anglebisector":
                case "start":
                case "end":
                case "angle":
                case "directedangle":
                case "angles":
                case "directedangles":
                case "apply":
                case "translate":
                case "reflect":
                case "dilate":
                case "rotate":
                case "normaldist":
                case "poissondist":
                case "geodist":
                case "binomialdist":
                case "uniformdist":
                case "chisqdist":
                case "total":
                case "mean":
                case "median":
                case "stdev":
                case "stdevp":
                case "var":
                case "varp":
                case "covp":
                case "cov":
                case "corr":
                case "mad":
                case "quantile":
                case "sort":
                case "shuffle":
                case "join":
                case "unique":
                case "polygon":
                case "coterminal":
                case "coerceToReal":
                case "real":
                case "imag":
                case "conj":
                case "exp":
                case "sin":
                case "cos":
                case "tan":
                case "sinh":
                case "cosh":
                case "tanh":
                case "sec":
                case "csc":
                case "cot":
                case "sech":
                case "csch":
                case "coth":
                case "arccot":
                case "arcsinh":
                case "arccsch":
                case "arctan":
                case "nthroot":
                case "ztest":
                case "zproptest":
                case "ttest":
                case "null":
                case "chisqtest":
                case "chisqgof":
                case "score":
                case "conf":
                case "dof":
                case "estimate":
                case "stderr":
                case "pleft":
                case "pright":
                case "lower":
                case "upper":
                case "complexNthRoot":
                    return Lw(n, P, l, r.map(S => e.getInstruction(S).valueType), T);
                case "points":
                case "lines":
                case "circles":
                case "polygons":
                case "rays":
                case "vectors":
                case "arcs":
                    throw Mi(n);
                case "histogram":
                case "dotplot":
                case "boxplot":
                case "stats":
                case "det":
                case "inv":
                case "transpose":
                case "rref":
                case "trace":
                    throw F(`Unexpected arity error for ${t}`);
                default:
                    let C = t;
                    throw new Error(`Unexpected compiler function ${C}`)
                }
            return Lw(n, P, l, r.map(C => e.getInstruction(C).valueType), T)
        }
        if (t === "polygon" && r.length === 2 && e.getInstruction(r[0]).valueType === b && e.getInstruction(r[1]).valueType === b)
            return ry();
        let p = []
          , m = [];
        for (let g = 0; g < o.length; g++) {
            let f = o[g]
              , h = c !== void 0 && c !== "doubleReducer" && c !== "never-broadcast" && !(c === "parameterizedReducer" && g === 0) && t !== "polygon"
              , x = e.getInstruction(f).valueType;
            X(x) && h && (x = Qe(x)),
            p.push(x),
            m.push(se(x))
        }
        let d = e.areAllArgsConstant(o)
          , y = Vw(t);
        if (y && !Bw(t, l, p)) {
            let g = new v(y);
            return d ? g : g.allowExport()
        }
        return $i(n, m, {
            blockExport: d
        })
    }
    function Lw(e, t, n, r, o) {
        let i = Vw(e);
        return i && !Bw(e, n, r) ? new v(i) : Ba(e, t, r.length, {
            includeUsageExample: !i,
            usageExample: o
        })
    }
    function D5(e) {
        return Pp(e) ? qa[e] : Hm(e) ? ir[e] : {}
    }
    function Ax(e, t, n) {
        return e.filter(r => r.matches(t) && t.length + n >= r.minArity)
    }
    function Vw(e) {
        switch (e) {
        case "midpoint":
            return I("shared-calculator-error-required-arguments-midpoint");
        case "intersection":
            return I("shared-calculator-error-required-arguments-intersection");
        case "segment":
        case "line":
        case "ray":
        case "distance":
            return I("shared-calculator-error-required-arguments-points", {
                symbol: e,
                count: 2
            });
        case "parallel":
        case "perpendicular":
            return I("shared-calculator-error-required-arguments-perpendicular", {
                symbol: e
            });
        case "circle":
            return I("shared-calculator-error-required-arguments-circle");
        case "arc":
        case "angle":
        case "directedangle":
            return I("shared-calculator-error-required-arguments-points", {
                symbol: e,
                count: 3
            });
        case "triangle":
            return I("shared-calculator-error-required-arguments-triangle");
        case "polygon":
            return I("shared-calculator-error-required-arguments-polygon");
        case "glider":
            return I("shared-calculator-error-required-arguments-glider");
        case "vector":
            return I("shared-calculator-error-required-arguments-vector");
        case "length":
            return I("shared-calculator-error-required-arguments-length");
        case "area":
        case "perimeter":
        case "vertices":
        case "angles":
        case "directedangles":
        case "segments":
            return I("shared-calculator-error-required-arguments-area", {
                symbol: e
            });
        case "radius":
        case "center":
            return I("shared-calculator-error-required-arguments-radius", {
                symbol: e
            });
        case "anglebisector":
        case "coterminal":
            return I("shared-calculator-error-required-arguments-coterminal", {
                symbol: e
            });
        case "supplement":
            return I("shared-calculator-error-required-arguments-supplement");
        case "start":
        case "end":
            return I("shared-calculator-error-required-arguments-start", {
                symbol: e
            });
        case "dilate":
        case "rotate":
            return I("shared-calculator-error-required-arguments-dilate", {
                symbol: e
            });
        case "reflect":
            return I("shared-calculator-error-required-arguments-reflect");
        case "translate":
            return I("shared-calculator-error-required-arguments-translate");
        case "sphere":
            return I("shared-calculator-error-required-arguments-sphere")
        }
    }
    function Bw(e, t, n) {
        return e === "polygon" && (t = t.filter(o => o.maxArity !== 1)),
        t.some(o => o.maxArity === 0 || n.length < o.minArity ? !1 : n.every( (i, s) => {
            let a = o.argTypeAtIndex(s);
            return a === void 0 ? !0 : gh(i, a)
        }
        ))
    }
    function Ka(e, t) {
        let n = [];
        for (let r of t)
            n.push(se(e.getInstruction(r).valueType));
        return n
    }
    function xl(e, t) {
        let n = [];
        for (let r of t) {
            let o = e.getInstruction(r).valueType
              , i = rr(o);
            n.push(se(i))
        }
        return n
    }
    function xt(e, t, n) {
        return ae(e.getInstruction(t).valueType, n)
    }
    function eu(e, t, n, r) {
        var l, p;
        let o = n.type;
        if (o === "FunctionCall" || o === "SeededFunctionCall" || o === "DotAccess") {
            let m, d;
            if (n instanceof Qo && (n.args[1]instanceof ze || n.args[1]instanceof _n))
                m = n.args[1]._symbol,
                d = (l = n.args[1]._errorSymbol) != null ? l : m;
            else if (n instanceof _n)
                m = n._symbol,
                d = (p = n._errorSymbol) != null ? p : m;
            else
                return;
            if (m === "polygon" && t.polygonUnsupportedPreferTriangle())
                throw Nb();
            if (m === "length" && !t.isGeometryEnabled() && !t.is3dPolicy() && r.length === 0)
                throw eC();
            Fw(e, t, m, d, r, n instanceof Qo);
            return
        }
        let i = r.map(m => e.getInstruction(m).valueType)
          , s = Ox(t, n, i);
        if (!s)
            return;
        let a = Math.min(...s.map(m => m.minArity));
        if (s.length > 0 && r.length >= a) {
            Rw(e, n, r, s);
            return
        }
        let u = _5(o, i, {
            specifyPointDimensions: n instanceof Xa && n.symbol === "z"
        })
          , c = e.areAllArgsConstant(r);
        switch (o) {
        case "Add":
            throw qS(u, {
                blockExport: c
            });
        case "Subtract":
            throw zS(u, {
                blockExport: c
            });
        case "CrossMultiply":
            throw i.length === 2 && (ae(i[0], R) && ae(i[1], R) || ae(i[0], b) && ae(i[1], G) || ae(i[0], G) && ae(i[1], b)) ? HS(u, {
                blockExport: c
            }) : Jf(u, {
                blockExport: c
            });
        case "DotMultiply":
            throw Jf(u, {
                blockExport: c
            });
        case "Multiply":
            {
                if (t.is3dProduct() && i.length === 2) {
                    if (ae(i[0], G) && ae(i[1], G))
                        throw kS(u, {
                            blockExport: c
                        });
                    if (ae(i[0], R) && ae(i[1], R))
                        throw US(u, {
                            blockExport: c
                        })
                }
                throw Jf(u, {
                    blockExport: c
                })
            }
        case "Divide":
            throw $S(u, {
                blockExport: c
            });
        case "Exponent":
            throw YS(u, {
                blockExport: c
            });
        case "Negative":
            throw ZS(u, {
                blockExport: c
            });
        case "Comparator['=']":
        case "Comparator['>']":
        case "Comparator['<']":
        case "Comparator['>=']":
        case "Comparator['<=']":
        case "ComparatorChain":
            throw jS(u, {
                blockExport: c
            });
        case "Or":
            throw QS(u, {
                blockExport: c
            });
        case "Piecewise":
            throw ae(i[0], Fe) ? IE([se(e.getInstruction(r[1]).valueType), se(e.getInstruction(r[2]).valueType)], {
                blockExport: e.areAllArgsConstant([r[1], r[2]])
            }) : ib(u, {
                blockExport: e.areAllArgsConstant([r[0]])
            });
        case "Restriction":
            throw ib(u, {
                blockExport: c
            });
        case "List":
        case "TableColumnValue":
            {
                Gw(e, r);
                break
            }
        case "ListAccess":
            throw Qf(u, {
                blockExport: c
            });
        case "Norm":
            throw $i("abs", u, {
                blockExport: c
            });
        case "ParenSeq":
            {
                let m = i.indexOf(pt) !== -1
                  , d = i.some(g => g !== pt);
                if (m && d)
                    throw ab([se(i[0]), se(i[1])], {
                        blockExport: c
                    });
                if (i.length !== 2 && i.length !== 3) {
                    let g = t.is3dPolicy() ? 3 : 2;
                    throw sC(g)
                }
                let y = i.find(g => !ae(g, b));
                throw y !== void 0 ? KS(se(y), {
                    blockExport: c
                }) : F("Unexpected error type checking ParenSeq")
            }
        case "BareSeq":
            {
                if (i.length === 0)
                    throw oy();
                if (i.length === 1)
                    throw F("Length-1 BareSeq is impossible");
                let m = i[0]
                  , d = i.find(y => y !== m);
                if (d)
                    throw ab([se(m), se(d)], {
                        blockExport: c
                    });
                if (m === b)
                    throw r.length === 2 ? oC() : iC();
                Gw(e, r);
                break
            }
        case "NamedCoordinateAccess":
            throw eE(u, "." + n.symbol, {
                blockExport: c
            });
        case "Integral":
            {
                let[m,d,y] = i
                  , g = rr(m)
                  , f = rr(d);
                throw ur(g, b) ? ur(f, b) ? yE([se(y)], {
                    blockExport: c
                }) : fE([se(d)], {
                    blockExport: c
                }) : dE([se(m)], {
                    blockExport: c
                })
            }
        case "Ans":
        case "Constant":
        case "ImaginaryUnit":
        case "Assignment":
        case "RecursiveFunctionBaseCase":
        case "MixedNumber":
        case "Identifier":
        case "AssignmentImport":
        case "Construction":
        case "Range":
        case "Sum":
        case "Product":
        case "ListComprehension":
        case "FunctionExponent":
        case "FunctionFactorial":
        case "Prime":
        case "Derivative":
        case "UpdateRule":
        case "Substitution":
        case "FunctionDefinition":
        case "Slider":
        case "RegressionParameter":
        case "Seed":
        case "ExtendSeed":
        case "PercentOf":
        case "Placeholder":
            return;
        default:
            throw new Error(`Unexpected node type: ${o}`)
        }
    }
    function Gw(e, t) {
        if (t.length === 0)
            return;
        let n = e.getInstruction(t[0]).valueType;
        if (!jn(n))
            throw gp([se(n)], {
                blockExport: Ye(e.getInstruction(t[0]))
            });
        let r = e.areAllArgsConstant(t);
        for (let o of t) {
            let i = e.getInstruction(o).valueType;
            if (!jn(i))
                throw gp([se(i)], {
                    blockExport: r
                });
            if (i !== n)
                throw ty({
                    blockExport: r
                })
        }
    }
    function _5(e, t, n) {
        switch (e) {
        case "Add":
        case "Subtract":
        case "Multiply":
        case "Divide":
        case "Exponent":
        case "Negative":
        case "Comparator['<']":
        case "Comparator['>']":
        case "Comparator['=']":
        case "Comparator['<=']":
        case "Comparator['>=']":
        case "NamedCoordinateAccess":
            return t.map(r => se(r, n));
        case "ComparatorChain":
            {
                for (let r = 0; r < t.length; r++)
                    if (!ur(t[r], b) && !ur(t[r], Y))
                        return r === 0 ? [se(t[r]), se(t[r + 1])] : [se(t[r - 1]), se(t[r])];
                return t.map(r => se(r))
            }
        case "ListAccess":
        case "Constant":
        case "ImaginaryUnit":
        case "MixedNumber":
        case "Identifier":
        case "AssignmentImport":
        case "Ans":
        case "List":
        case "TableColumnValue":
        case "Range":
        case "Construction":
        case "ParenSeq":
        case "BareSeq":
        case "Norm":
        case "Sum":
        case "Product":
        case "Integral":
        case "ListComprehension":
        case "FunctionExponent":
        case "FunctionFactorial":
        case "Prime":
        case "Piecewise":
        case "Restriction":
        case "Derivative":
        case "UpdateRule":
        case "Substitution":
        case "Assignment":
        case "RecursiveFunctionBaseCase":
        case "FunctionDefinition":
        case "Slider":
        case "RegressionParameter":
        case "Seed":
        case "ExtendSeed":
        case "DotMultiply":
        case "CrossMultiply":
        case "Or":
        case "PercentOf":
            return t.map(r => se(r));
        case "Placeholder":
            throw new Error("Unexpected placeholder");
        default:
            throw new Error(`Unexpected node type: ${e}`)
        }
    }
    function qw(e, t) {
        var a;
        let n = e.getInstruction(t);
        if (!de(n))
            return;
        let r = St(jM(e, n).expectedTypes);
        if (n.type === 49) {
            for (let c of n.args) {
                let l = e.getInstruction(c).valueType;
                if (!ae(l, b) && !ae(l, N) && !ae(l, R) && !ae(l, G) && !ae(l, bn) && !ae(l, De) && !ae(l, Ee) && !ae(l, Ce) && !ae(l, Ae) && !ae(l, Ie) && !ae(l, he) && !ae(l, ce) && !ae(l, Oe) && !ae(l, cr) && !ae(l, Se))
                    throw DE(se(l))
            }
            let u = {};
            for (let c of n.symbols) {
                if (u[c])
                    throw RE(c);
                u[c] = !0
            }
            return
        }
        let o = !1;
        for (let u = 0; u < n.args.length; u++) {
            let c = e.getInstruction(n.args[u]).valueType
              , l = r.argTypeAtIndex(u);
            if (l === void 0 || !np(c, l)) {
                o = !0;
                break
            }
        }
        if (!o && n.args.length >= r.minArity && n.args.length <= ((a = r.maxArity) != null ? a : 1 / 0))
            return;
        let i = Ka(e, n.args)
          , s = e.areAllArgsConstant(n.args);
        switch (n.type) {
        case 32:
            throw JS(i, {
                blockExport: s
            });
        case 22:
        case 21:
        case 44:
        case 31:
        case 15:
        case 16:
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
        case 56:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 38:
        case 39:
        case 40:
        case 41:
        case 37:
        case 42:
        case 33:
        case 48:
        case 47:
        case 23:
        case 24:
        case 19:
        case 20:
        case 50:
        case 51:
        case 53:
        case 54:
        case 55:
            throw F(`Invalid argument types for opcode ${n.type}`);
        default:
            {
                let u = n;
                throw new Error(`Unexpected opcode: ${u.type}`)
            }
        }
    }
    function jM(e, t, n=!1) {
        switch (t.type) {
        case 8:
        case 9:
        case 10:
        case 11:
            return n && t.args.length > 0 && e.getInstruction(t.args[0]).valueType === R ? {
                expectedTypes: [R, R]
            } : {
                expectedTypes: [b, b]
            };
        case 12:
        case 13:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
            return {
                expectedTypes: [b, b]
            };
        case 14:
        case 56:
            return {
                expectedTypes: [b]
            };
        case 31:
            return {
                expectedTypes: [Fe, Fe]
            };
        case 32:
            return {
                expectedTypes: [Fe, Fe]
            };
        case 33:
            return {
                expectedTypes: [Fe, t.valueType, t.valueType]
            };
        case 15:
            return {
                expectedTypes: dc[t.valueType]
            };
        case 21:
            return {
                expectedTypes: [b, b]
            };
        case 22:
            {
                let r = e.getInstruction(t.args[1]).valueType;
                return hm(r) ? {
                    expectedTypes: [b, r]
                } : {
                    expectedTypes: [b, b]
                }
            }
        case 38:
            {
                let r = t.valueType
                  , o = Qe(r);
                return {
                    expectedTypes: {
                        type: "variadic",
                        initial: [],
                        rest: o
                    }
                }
            }
        case 39:
        case 40:
        case 41:
            return {
                expectedTypes: [nr, b]
            };
        case 37:
            {
                let r = t.symbol
                  , o = ir[r]
                  , i = o.argumentTypes;
                return o.tag === "reducer" && !R5(e, t.args) && Array.isArray(i) && typeof i[0] == "number" && X(i[0]) ? {
                    isReducerWithNoListArgs: !0,
                    expectedTypes: {
                        type: "variadic",
                        initial: [],
                        rest: Qe(i[0])
                    }
                } : {
                    expectedTypes: i
                }
            }
        case 44:
            {
                let r = e.getInstruction(t.args[1]).valueType;
                return {
                    expectedTypes: [_t, r]
                }
            }
        case 47:
            return {
                expectedTypes: t.args.map(r => e.getInstruction(r).valueType)
            };
        case 23:
            return {
                expectedTypes: [b]
            };
        case 19:
            return {
                expectedTypes: t.args.map(r => {
                    let o = e.getInstruction(r).valueType;
                    return o === Fe || (t.callData.type === "sum" ? hm(o) : xP(o)) ? o : b
                }
                )
            };
        case 50:
            {
                let r = t.callData.parameterSymbols.length
                  , o = [];
                for (let i = 0; i < r; i++)
                    o.push(b, b);
                return {
                    expectedTypes: o
                }
            }
        case 24:
        case 20:
        case 51:
            {
                let r = [b];
                for (let o = 1; o < t.args.length; o++)
                    r.push(e.getInstruction(t.args[o]).valueType);
                return {
                    expectedTypes: r
                }
            }
        case 42:
            return {
                expectedTypes: t.args.map( () => b)
            };
        case 48:
        case 49:
            return {
                expectedTypes: t.args.map(r => e.getInstruction(r).valueType)
            };
        case 53:
            return {
                expectedTypes: [t.valueType]
            };
        case 54:
            return {
                expectedTypes: t.args.map(r => e.getInstruction(r).valueType)
            };
        case 55:
            return {
                expectedTypes: t.args.map(r => e.getInstruction(r).valueType)
            };
        case 16:
            return {
                expectedTypes: [bP]
            };
        default:
            {
                let r = t;
                throw new Error(`Unexpected opcode: ${r.type}`)
            }
        }
    }
    function R5(e, t) {
        for (let n of t)
            if (X(e.getInstruction(n).valueType))
                return !0;
        return !1
    }
    var wx = (e, t, n, r) => {
        let o = []
          , i = !0;
        for (let f of t) {
            let h = e.getInstruction(f);
            Ye(h) || (i = !1);
            let x = h.valueType;
            if (x !== He)
                if (X(x))
                    o.push({
                        isList: !0,
                        index: f,
                        elementType: Qe(x)
                    });
                else if (jn(x))
                    o.push({
                        isList: !1,
                        index: f,
                        elementType: x
                    });
                else
                    throw $i(n, Ka(e, r), {
                        blockExport: e.areAllArgsConstant(t)
                    })
        }
        if (o.length === 0)
            return e.ConstantOfType(He, []);
        for (let f of o)
            if (f.elementType !== o[0].elementType)
                throw $i(n, Ka(e, r), {
                    blockExport: e.areAllArgsConstant(t)
                });
        if (i) {
            let f = [];
            for (let h of o) {
                let x = e.getInstruction(Wr(e, h.index));
                KA(x),
                h.isList ? f.push(...x.value) : f.push(x.value)
            }
            return e.ConstantOfType($n(o[0].elementType), f)
        }
        let s = e.Constant(0)
          , a = e.Constant(1)
          , u = {};
        for (let f of o)
            f.isList && u[f.index] === void 0 && (u[f.index] = Pr(e, f.index));
        let c = e.NativeFunction("total", o.map(f => f.isList ? u[f.index] : a))
          , l = e.BeginBroadcast([c])
          , p = s
          , m = []
          , d = [];
        for (let f of o) {
            let h = f.isList ? e.ListAccess([f.index, e.Subtract([l, p])]) : f.index;
            if (d.push(h),
            f !== o[o.length - 1]) {
                let x = f.isList ? u[f.index] : a;
                p = e.Add([p, x]),
                m.push(e.LessEqual([l, p]))
            }
        }
        let y = d[d.length - 1];
        for (let f = d.length - 2; f >= 0; f--)
            y = e.Piecewise([m[f], d[f], y]);
        let g = e.EndBroadcast([l, y]);
        return e.BroadcastResult($n(o[0].elementType), [g])
    }
    ;
    var aa = (e, t, n) => {
        var s;
        let r = e.getInstruction(n).valueType
          , o = rr(r)
          , i = e.Constant(0);
        return e.Piecewise([e.And([e.GreaterEqual([t.count, i]), e.GreaterEqual([(s = t.stdev) != null ? s : i, i])]), n, e.NanOfType(o)])
    }
      , Dd = (e, t, n) => {
        let r = e.getInstruction(n).valueType
          , o = rr(r)
          , i = e.Constant(0);
        return e.Piecewise([e.And([e.GreaterEqual([t.count, i]), e.LessEqual([t.successes, t.count])]), n, e.NanOfType(o)])
    }
      , zw = (e, t) => {
        let n = e.getInstruction(t).valueType
          , r = rr(n)
          , o = e.Constant(0)
          , i = e.Constant(1);
        return e.Piecewise([e.And([e.GreaterEqual([t, o]), e.LessEqual([t, i])]), t, e.NanOfType(r)])
    }
      , Lx = (e, t) => {
        let n = e.NativeFunction("normalcdf", [e.Constant(-1 / 0), e.Negative([e.NativeFunction("abs", [t])]), e.Constant(0), e.Constant(1)])
          , r = e.Subtract([e.Constant(1), n])
          , o = e.Constant(0)
          , i = e.Piecewise([e.LessEqual([t, o]), n, r])
          , s = e.Piecewise([e.Greater([t, o]), n, r]);
        return {
            p: e.Multiply([e.Constant(2), n]),
            pleft: i,
            pright: s
        }
    }
      , N5 = (e, t, n, r) => aa(e, t, e.Divide([e.Subtract([t.mean, r]), e.Divide([n, e.NativeFunction("sqrt", [t.count])])]))
      , O5 = (e, t, n, r, o, i) => aa(e, t, aa(e, r, e.Divide([e.Subtract([e.Subtract([t.mean, r.mean]), i]), e.NativeFunction("sqrt", [e.Add([e.Divide([e.Square([n]), t.count]), e.Divide([e.Square([o]), r.count])])])])))
      , A5 = (e, t, n) => {
        let r = e.Subtract([e.Constant(1), n]);
        return Dd(e, t, e.Divide([e.Subtract([e.Divide([t.successes, t.count]), n]), e.NativeFunction("sqrt", [e.Divide([e.Multiply([n, r]), t.count])])]))
    }
      , Fx = (e, t) => e.NativeFunction("invNorm", [e.Divide([e.Subtract([e.Constant(1), zw(e, t)]), e.Constant(2)])])
      , QM = (e, t) => {
        let n = e.Divide([t.successes, t.count])
          , r = e.Subtract([e.Constant(1), n]);
        return e.NativeFunction("sqrt", [e.Divide([e.Multiply([n, r]), t.count])])
    }
      , Hw = (e, t, n) => {
        let r = Fx(e, n)
          , o = e.Divide([t.successes, t.count])
          , i = QM(e, t)
          , s = e.Multiply([r, i]);
        return Dd(e, t, e.TupleOfType(Pt, {
            min: e.Add([o, s]),
            max: e.Subtract([o, s]),
            dof: e.NanOfType(b),
            standardError: i
        }))
    }
      , KM = (e, t, n) => {
        let r = e.Divide([t.successes, t.count])
          , o = e.Subtract([e.Constant(1), r])
          , i = e.Divide([n.successes, n.count])
          , s = e.Subtract([e.Constant(1), i]);
        return e.NativeFunction("sqrt", [e.Add([e.Divide([e.Multiply([r, o]), t.count]), e.Divide([e.Multiply([i, s]), n.count])])])
    }
      , Uw = (e, t, n, r) => {
        let o = Fx(e, r)
          , i = e.Divide([t.successes, t.count])
          , s = e.Divide([n.successes, n.count])
          , a = KM(e, t, n)
          , u = e.Multiply([o, a])
          , c = e.Subtract([i, s]);
        return Dd(e, t, Dd(e, n, e.TupleOfType(Pt, {
            min: e.Add([c, u]),
            max: e.Subtract([c, u]),
            dof: e.NanOfType(b),
            standardError: a
        })))
    }
      , w5 = (e, t, n, r) => {
        let o = e.Divide([t.successes, t.count])
          , i = e.Divide([n.successes, n.count])
          , s = e.Constant(1)
          , a = e.Divide([e.Add([t.successes, n.successes]), e.Add([t.count, n.count])])
          , u = e.Subtract([s, a])
          , c = e.Divide([e.Subtract([e.Subtract([o, i]), r]), e.NativeFunction("sqrt", [e.Multiply([e.Multiply([a, u]), e.Add([e.Divide([s, t.count]), e.Divide([s, n.count])])])])])
          , l = e.Divide([e.Subtract([e.Subtract([o, i]), r]), e.NativeFunction("sqrt", [e.Add([e.Divide([e.Multiply([o, e.Subtract([s, o])]), t.count]), e.Divide([e.Multiply([i, e.Subtract([s, i])]), n.count])])])]);
        return Dd(e, t, Dd(e, n, e.Piecewise([e.Equal([r, e.Constant(0)]), c, l])))
    }
      , L5 = (e, t, n) => aa(e, t, e.Divide([e.Subtract([t.mean, n]), e.Divide([t.stdev, e.NativeFunction("sqrt", [t.count])])]))
      , F5 = (e, t, n) => e.Divide([e.Subtract([t.estimate, n]), t.standardError])
      , e0 = (e, t, n) => e.NativeFunction("invT", [e.Divide([e.Subtract([e.Constant(1), zw(e, t)]), e.Constant(2)]), n])
      , t0 = (e, t) => e.Divide([t.stdev, e.NativeFunction("sqrt", [t.count])])
      , kw = (e, t, n) => {
        let r = e.Subtract([t.count, e.Constant(1)])
          , o = e0(e, n, r)
          , i = t0(e, t)
          , s = e.Multiply([o, i]);
        return aa(e, t, e.TupleOfType(Pt, {
            min: e.Add([t.mean, s]),
            max: e.Subtract([t.mean, s]),
            dof: r,
            standardError: i
        }))
    }
      , $w = (e, {estimate: t, dof: n, standardError: r}, o) => {
        let i = e0(e, o, n)
          , s = e.Multiply([i, r]);
        return e.TupleOfType(Pt, {
            min: e.Add([t, s]),
            max: e.Subtract([t, s]),
            standardError: r,
            dof: n
        })
    }
      , n0 = (e, t, n) => e.NativeFunction("sqrt", [e.Add([e.Divide([e.Square([t.stdev]), t.count]), e.Divide([e.Square([n.stdev]), n.count])])])
      , Yw = (e, t, n, r) => {
        let o = Vx(e, t, n)
          , i = e0(e, r, o)
          , s = n0(e, t, n)
          , a = e.Multiply([i, s])
          , u = e.Subtract([t.mean, n.mean]);
        return aa(e, t, aa(e, n, e.TupleOfType(Pt, {
            min: e.Add([u, a]),
            max: e.Subtract([u, a]),
            standardError: s,
            dof: o
        })))
    }
      , r0 = (e, t, n) => e.Divide([t, e.NativeFunction("sqrt", [n])])
      , Zw = (e, t, n, r) => {
        let o = Fx(e, r)
          , i = r0(e, n, t.count)
          , s = e.Multiply([o, i]);
        return aa(e, t, e.TupleOfType(Pt, {
            min: e.Add([t.mean, s]),
            max: e.Subtract([t.mean, s]),
            standardError: i,
            dof: e.NanOfType(b)
        }))
    }
      , o0 = (e, t, n, r, o) => e.NativeFunction("sqrt", [e.Add([e.Divide([e.Square([t]), n]), e.Divide([e.Square([r]), o])])])
      , Xw = (e, t, n, r, o, i) => {
        let s = Fx(e, i)
          , a = o0(e, n, t.count, o, r.count)
          , u = e.Multiply([s, a])
          , c = e.Subtract([t.mean, r.mean]);
        return aa(e, t, aa(e, r, e.TupleOfType(Pt, {
            min: e.Add([c, u]),
            max: e.Subtract([c, u]),
            standardError: a,
            dof: e.NanOfType(b)
        })))
    }
      , V5 = (e, t, n, r) => aa(e, t, aa(e, n, e.Divide([e.Subtract([e.Subtract([t.mean, n.mean]), r]), e.NativeFunction("sqrt", [e.Add([e.Divide([e.Square([t.stdev]), t.count]), e.Divide([e.Square([n.stdev]), n.count])])])])))
      , JM = (e, t, n) => {
        let r = e.NativeFunction("tcdf", [e.Constant(-1 / 0), e.Negative([e.NativeFunction("abs", [t])]), n, e.Constant(0), e.Constant(1)])
          , o = e.Subtract([e.Constant(1), r])
          , i = e.Constant(0)
          , s = e.Piecewise([e.LessEqual([t, i]), r, o])
          , a = e.Piecewise([e.Greater([t, i]), r, o]);
        return {
            p: e.Multiply([e.Constant(2), r]),
            pleft: s,
            pright: a
        }
    }
      , Ww = (e, t, n) => e.Divide([e.Square([e.Subtract([t, n])]), n])
      , jw = (e, t, n, r) => {
        let o = Un(e, t[0]);
        if (o === void 0)
            throw by(n);
        if (!(o > 1))
            throw Gb(n);
        for (let h = 1; h < t.length; h++) {
            let x = Un(e, t[h]);
            if (x === void 0)
                throw by(n);
            if (x !== o)
                throw Bb(n)
        }
        let s = e.Constant(o)
          , a = wx(e, t, n, r)
          , u = e.Piecewise([e.Less([a, e.Constant(0)]), e.NanOfType(b), a])
          , c = e.Constant(t.length)
          , l = e.Multiply([e.Subtract([s, e.Constant(1)]), e.Subtract([c, e.Constant(1)])])
          , p = e.NativeFunction("total", [u])
          , m = e.NativeFunction("chisqIndependenceRowTotals", [u, s, c])
          , d = e.NativeFunction("chisqIndependenceColTotals", [u, s, c])
          , y = e.NativeFunction("chisqIndependenceExpectedValues", [m, d])
          , g = Ww(e, u, y)
          , f = e.NativeFunction("total", [g]);
        return e.TupleOfType(zn, {
            p: e.NativeFunction("chisqcdf", [f, e.Constant(1 / 0), l]),
            score: f,
            dof: l,
            rows: s,
            columns: c,
            observed: u,
            contributions: g,
            expected: y,
            rowTotals: m,
            columnTotals: d,
            total: p
        })
    }
      , i0 = (e, t, n, r) => {
        let o = Un(e, t)
          , i = Un(e, n);
        if (o === void 0 || i === void 0)
            throw by(r);
        if (!(o > 1))
            throw Gb(r);
        if (o !== i)
            throw Bb(r);
        let a = e.Constant(0)
          , u = e.Piecewise([e.Less([t, a]), e.NanOfType(b), t])
          , c = e.Piecewise([e.Less([n, a]), e.NanOfType(b), n])
          , l = e.NativeFunction("total", [u])
          , p = e.NativeFunction("total", [c])
          , m = e.getInstruction(l)
          , d = e.getInstruction(p);
        if (m.type === 1 && d.type === 1 && m.valueType === b && d.valueType === b) {
            let h = m.value
              , x = d.value;
            un(h) && un(x) && L(h) !== L(x) && L(x) !== 1 && e.setWarning(I("shared-calculator-error-rescaled-observed"))
        }
        c = e.Piecewise([e.Equal([l, p]), c, e.Multiply([e.Divide([l, p]), c])]);
        let y = Ww(e, u, c)
          , g = e.NativeFunction("total", [y])
          , f = e.Subtract([e.NativeFunction("count", [u]), e.Constant(1)]);
        return e.TupleOfType(qn, {
            p: e.NativeFunction("chisqcdf", [g, e.Constant(1 / 0), f]),
            score: g,
            observed: u,
            expected: c,
            contributions: y,
            dof: f,
            total: l
        })
    }
      , Vx = (e, t, n) => {
        let r = e.Constant(2)
          , o = e.Constant(1)
          , i = e.Divide([e.Exponent([t.stdev, r]), t.count])
          , s = e.Divide([e.Exponent([n.stdev, r]), n.count])
          , a = e.Subtract([t.count, o])
          , u = e.Subtract([n.count, o]);
        return e.Divide([e.Exponent([e.Add([i, s]), r]), e.Add([e.Divide([e.Exponent([i, r]), a]), e.Divide([e.Exponent([s, r]), u])])])
    }
      , _d = (e, t) => {
        var r, o, i, s, a, u, c;
        let n = rr(e.getInstruction(t[0]).valueType);
        if (!Ti(n))
            throw new Error(`Unexpected arg type ${Ke(n)}`);
        switch (n) {
        case Qt:
            {
                let l = {
                    mean: e.NamedSlot("mean", [t[0]]),
                    count: e.NamedSlot("count", [t[0]])
                }
                  , p = e.NamedSlot("stdevp", [t[0]])
                  , m = (r = t[1]) != null ? r : e.Constant(0)
                  , d = N5(e, l, p, m);
                return e.TupleOfType(pn, {
                    ...Lx(e, d),
                    score: d,
                    hypothesis: m
                })
            }
        case Ht:
            {
                let l = {
                    mean: e.NamedSlot("mean1", [t[0]]),
                    count: e.NamedSlot("count1", [t[0]])
                }
                  , p = e.NamedSlot("stdevp1", [t[0]])
                  , m = {
                    mean: e.NamedSlot("mean2", [t[0]]),
                    count: e.NamedSlot("count2", [t[0]])
                }
                  , d = e.NamedSlot("stdevp2", [t[0]])
                  , y = (o = t[1]) != null ? o : e.Constant(0)
                  , g = O5(e, l, p, m, d, y);
                return e.TupleOfType(pn, {
                    ...Lx(e, g),
                    score: g,
                    hypothesis: y
                })
            }
        case an:
            {
                let l = {
                    successes: e.NamedSlot("successes", [t[0]]),
                    count: e.NamedSlot("count", [t[0]])
                }
                  , p = (i = t[1]) != null ? i : e.Constant(.5)
                  , m = A5(e, l, p);
                return e.TupleOfType(pn, {
                    ...Lx(e, m),
                    score: m,
                    hypothesis: p
                })
            }
        case Yt:
            {
                let l = {
                    successes: e.NamedSlot("successes1", [t[0]]),
                    count: e.NamedSlot("count1", [t[0]])
                }
                  , p = {
                    successes: e.NamedSlot("successes2", [t[0]]),
                    count: e.NamedSlot("count2", [t[0]])
                }
                  , m = (s = t[1]) != null ? s : e.Constant(0)
                  , d = w5(e, l, p, m);
                return e.TupleOfType(pn, {
                    ...Lx(e, d),
                    score: d,
                    hypothesis: m
                })
            }
        case $t:
            {
                let l = {
                    mean: e.NamedSlot("mean", [t[0]]),
                    stdev: e.NamedSlot("stdev", [t[0]]),
                    count: e.NamedSlot("count", [t[0]])
                }
                  , p = (a = t[1]) != null ? a : e.Constant(0)
                  , m = L5(e, l, p)
                  , d = e.NamedSlot("dof", [t[0]]);
                return e.TupleOfType(mn, {
                    ...JM(e, m, d),
                    score: m,
                    hypothesis: p,
                    dof: d
                })
            }
        case wt:
            {
                let l = {
                    mean: e.NamedSlot("mean1", [t[0]]),
                    stdev: e.NamedSlot("stdev1", [t[0]]),
                    count: e.NamedSlot("count1", [t[0]])
                }
                  , p = {
                    mean: e.NamedSlot("mean2", [t[0]]),
                    stdev: e.NamedSlot("stdev2", [t[0]]),
                    count: e.NamedSlot("count2", [t[0]])
                }
                  , m = (u = t[1]) != null ? u : e.Constant(0)
                  , d = e.NamedSlot("dof", [t[0]])
                  , y = V5(e, l, p, m);
                return e.TupleOfType(mn, {
                    hypothesis: m,
                    score: y,
                    ...JM(e, y, d),
                    dof: d
                })
            }
        case Kt:
            {
                let l = {
                    estimate: e.NamedSlot("pointEstimate", [t[0]]),
                    standardError: e.NamedSlot("standardError", [t[0]]),
                    dof: e.NamedSlot("dof", [t[0]])
                }
                  , p = (c = t[1]) != null ? c : e.Constant(0)
                  , m = F5(e, l, p);
                return e.TupleOfType(mn, {
                    ...JM(e, m, l.dof),
                    score: m,
                    hypothesis: p,
                    dof: e.NamedSlot("dof", [t[0]])
                })
            }
        }
    }
    ;
    function Fp(e, t, n) {
        let r = e.getInstruction(t);
        if (r.type === 1)
            switch (r.valueType) {
            case b:
                {
                    if (!(L(r.value) > 1))
                        throw _b(n);
                    return
                }
            case Y:
                for (let o of r.value)
                    if (!(L(o) > 1))
                        throw _b(n);
                return;
            default:
                return
            }
    }
    function Bx(e) {
        if (cd(e)) {
            let t = Qe(e.valueType);
            return e.value.some(n => io({
                valueType: t,
                value: n
            }))
        }
        return io(e)
    }
    function io({value: e, valueType: t}) {
        switch (t) {
        case b:
            return Xo(e);
        case sn:
            return e;
        case N:
        case R:
            {
                let[n,r] = e;
                return Xo(n) || Xo(r)
            }
        case G:
            {
                let[n,r,o] = e;
                return Xo(n) || Xo(r) || Xo(o)
            }
        case bn:
            {
                let[n,r,o] = e;
                return Xo(n) || Xo(r) || Xo(o)
            }
        case De:
            {
                for (let n of e)
                    if (io({
                        valueType: R,
                        value: n
                    }))
                        return !0;
                return !1
            }
        case Lr:
            {
                let[n,r] = e;
                return io({
                    valueType: G,
                    value: n
                }) || io({
                    valueType: b,
                    value: r
                })
            }
        case lr:
            {
                let[n,r,o] = e;
                return io({
                    valueType: G,
                    value: n
                }) || io({
                    valueType: G,
                    value: r
                }) || io({
                    valueType: G,
                    value: o
                })
            }
        case en:
        case qe:
            {
                let[n,r] = e;
                return io({
                    valueType: G,
                    value: n
                }) || io({
                    valueType: G,
                    value: r
                })
            }
        case Ee:
        case Ce:
        case Ae:
        case Ie:
            {
                let[n,r] = e;
                return io({
                    valueType: R,
                    value: n
                }) || io({
                    valueType: R,
                    value: r
                })
            }
        case he:
            {
                let[n,r] = e;
                return io({
                    valueType: R,
                    value: n
                }) || io({
                    valueType: b,
                    value: r
                })
            }
        case ce:
            {
                let[n,r,o] = e;
                return io({
                    valueType: R,
                    value: n
                }) || io({
                    valueType: R,
                    value: r
                }) || io({
                    valueType: R,
                    value: o
                })
            }
        case Oe:
        case Se:
            {
                let[n,r,o] = e;
                return io({
                    valueType: R,
                    value: n
                }) || io({
                    valueType: b,
                    value: r
                }) || io({
                    valueType: b,
                    value: o
                })
            }
        case Pt:
        case $t:
        case wt:
        case Kt:
        case Qt:
        case Ht:
        case an:
        case Yt:
        case pn:
        case mn:
            return e.some(Xo);
        case qn:
        case zn:
            return e.some(n => Array.isArray(n) ? n.some(Xo) : Xo(n));
        case pt:
            return Object.keys(e.updateRules).length === 0;
        case Fe:
        case _t:
        case we:
            return !1;
        case cr:
            {
                let[n,r] = e;
                return Xo(n) || Xo(r)
            }
        default:
            throw new Error("Type cannot contain a NaN value: " + se(t) + ".")
        }
    }
    function Jw(e, t, n) {
        let r = e.argNames.indexOf(t);
        if (r === -1)
            return 0;
        let o = Eo(e, r, n);
        return Pn(o, e.getReturnIndex())
    }
    function Eo(e, t, {allowRestriction: n, allowClosedBlockReferences: r}) {
        return {
            chunk: e,
            argIndex: t,
            orderTable: [],
            mask: yl(e, t),
            allowRestriction: n,
            allowClosedBlockReferences: r
        }
    }
    function Pn(e, t) {
        let n = e.orderTable[t];
        if (n !== void 0)
            return n;
        let r = B5(e, t);
        return e.orderTable[t] = r,
        r
    }
    function B5(e, t) {
        let {chunk: n, mask: r, argIndex: o, allowRestriction: i, allowClosedBlockReferences: s} = e;
        if (!s && n.isInClosedBlock(t))
            return 1 / 0;
        if (t === o)
            return 1;
        if (!r[t])
            return 0;
        let a = n.getInstruction(t);
        if (Po(a) || Bo(a))
            return 1 / 0;
        switch (a.type) {
        case 8:
        case 9:
        case 26:
        case 28:
        case 27:
        case 29:
            {
                let[c,l] = a.args;
                return Math.max(Pn(e, c), Pn(e, l))
            }
        case 10:
            {
                let[c,l] = a.args;
                return Pn(e, c) + Pn(e, l)
            }
        case 14:
            return Pn(e, a.args[0]);
        case 11:
            {
                let[c,l] = a.args;
                return Pn(e, l) > 0 ? 1 / 0 : Pn(e, c)
            }
        case 12:
        case 13:
            {
                let[c,l] = a.args
                  , p = n.getInstruction(l);
                if (Pn(e, c) === 0 && Pn(e, l) === 0)
                    return 0;
                if (p.type === 1) {
                    let m = L(p.value);
                    return m === Math.round(m) && m > 0 ? Pn(e, c) * m : 1 / 0
                } else
                    return 1 / 0
            }
        case 56:
            return 2 * Pn(e, a.args[0]);
        case 33:
            {
                let c = n.getInstruction(a.args[2]);
                return i && c.type === 1 && isNaN(L(c.value)) ? Pn(e, a.args[1]) : 1 / 0
            }
        case 16:
        case 37:
        case 2:
        case 0:
        case 1:
        case 25:
        case 32:
        case 31:
        case 15:
        case 38:
        case 39:
        case 40:
        case 41:
        case 42:
        case 48:
        case 47:
        case 3:
        case 44:
        case 49:
        case 4:
        case 55:
            return 1 / 0;
        default:
            let u = a;
            throw new Error(`Unexpected opcode ${u.type}`)
        }
    }
    function Qw(e, t) {
        let n = e.argNames.indexOf(t)
          , r = e.getReturnIndex()
          , o = ua(Eo(e, n, {
            allowRestriction: !0,
            allowClosedBlockReferences: !1
        }), r);
        if (Pn(o.orderCtx, r) > 2)
            throw new Error("Programming Error: cannot compute polynomial coefficients for polynomials of order greater than 2");
        let i = gr(o, r)
          , s = !1;
        for (let a = 0; a < e.instructionsLength(); a++)
            e.getInstruction(a).type === 33 && o.mask[a] && (s = !0);
        return {
            chunk: o.newChunk,
            coefficients: i,
            mappedArgIndex: n === -1 ? void 0 : o.valueMap.get(n),
            mappedReturnIndex: o.valueMap.get(r),
            isRestrictedPolynomial: s
        }
    }
    function ua(e, t) {
        let {chunk: n, argIndex: r} = e
          , o = oo(n, t);
        if (n.isInClosedBlock(r))
            throw new Error("Programming Error: cannot find polynomial coefficients of an instruction in a closed block");
        let i, s;
        r >= 0 && r < n.argNames.length ? (i = n.argNames.slice(),
        s = n.argTypes.slice(),
        i.splice(r, 1),
        s.splice(r, 1)) : (i = n.argNames,
        s = n.argTypes);
        let a = new $u({
            argNames: i,
            argTypes: s
        })
          , u = 0
          , c = n.instructionsLength() - 1
          , l = new zo(n,u,c,a);
        l.copyUntilEnd( (g, f, h) => {
            if (!(o[h] || (f.type === 47 || f.type === 48) && o[f.args[0]]))
                return h;
            if (f.type === 2)
                return h < r || r < 0 ? h : h === r ? g.SymbolicVar(n.argTypes[h]) : h - 1;
            if (de(f)) {
                let x = l.mapArgs(f.args);
                return g.copyInstructionWithArgs(f, x)
            } else
                return l.copyLeafOrFunctionHeader(f)
        }
        );
        let p = []
          , m = a.Constant(0)
          , d = a.Constant(1)
          , y = a.Constant(NaN);
        return {
            chunk: n,
            newChunk: a,
            orderCtx: e,
            coefficientTable: p,
            mask: e.mask,
            valueMap: l.oldIPtoNewIP,
            argIndex: r,
            zero: m,
            one: d,
            nan: y
        }
    }
    function gr(e, t) {
        let {newChunk: n, orderCtx: r, coefficientTable: o, mask: i, valueMap: s, argIndex: a, zero: u, one: c, nan: l} = e
          , p = o[t];
        if (p !== void 0)
            return p;
        let m;
        for (i[t] ? t === a ? m = [u, c] : Pn(r, t) > 2 ? m = [l] : m = G5(e, t) : m = [s.get(t)]; m.length > 1; ) {
            let d = n.getInstruction(m[m.length - 1]);
            if (d.type === 1 && L(d.value) === 0)
                m.pop();
            else
                break
        }
        if (m.length === 0)
            throw new Error("Programming Error: coefficients cannot be empty");
        return o[t] = m,
        m
    }
    function G5(e, t) {
        let n = e.chunk.getInstruction(t)
          , {newChunk: r} = e;
        switch (n.type) {
        case 8:
            {
                let[i,s] = n.args
                  , a = gr(e, i)
                  , u = gr(e, s)
                  , c = a.length - 1
                  , l = u.length - 1
                  , p = [];
                for (let m = 0; m <= Math.max(c, l); m++)
                    c >= m && l >= m ? p.push(r.Add([a[m], u[m]])) : p.push(c > l ? a[m] : u[m]);
                return p
            }
        case 9:
        case 26:
        case 28:
        case 27:
        case 29:
            {
                let[i,s] = n.args;
                (n.type === 26 || n.type == 28) && ([i,s] = [s, i]);
                let a = gr(e, i)
                  , u = gr(e, s)
                  , c = a.length - 1
                  , l = u.length - 1
                  , p = [];
                for (let m = 0; m <= Math.max(c, l); m++)
                    c >= m && l >= m ? p.push(r.Subtract([a[m], u[m]])) : p.push(c > l ? a[m] : r.Negative([u[m]]));
                return p
            }
        case 14:
            {
                let i = n.args[0]
                  , s = gr(e, i)
                  , a = [];
                for (let u = 0; u < s.length; u++)
                    a.push(r.Negative([s[u]]));
                return a
            }
        case 10:
            {
                let[i,s] = n.args
                  , a = gr(e, i)
                  , u = gr(e, s)
                  , c = a.length - 1
                  , l = u.length - 1
                  , p = [];
                for (let m = 0; m <= c; m++)
                    for (let d = 0; d <= l; d++) {
                        if (m + d > 2)
                            continue;
                        let y = r.Multiply([a[m], u[d]])
                          , g = p[m + d];
                        g === void 0 ? p[m + d] = y : p[m + d] = r.Add([g, y])
                    }
                return p
            }
        case 11:
            {
                let[i,s] = n.args
                  , a = gr(e, i)
                  , u = gr(e, s)
                  , c = [];
                for (let l = 0; l < a.length; l++)
                    c.push(r.Divide([a[l], u[0]]));
                return c
            }
        case 12:
        case 13:
            {
                let[i,s] = n.args
                  , a = gr(e, i)
                  , u = gr(e, s);
                if (a.length - 1 === 0)
                    return [r.RawExponent([a[0], u[0]])];
                let l = r.getInstruction(u[0]);
                switch (L(l.value)) {
                case 0:
                    return [r.Constant(1)];
                case 1:
                    return a;
                case 2:
                    return [r.Square([a[0]]), r.Multiply([r.Constant(2), r.Multiply([a[0], a[1]])]), r.Square([a[1]])]
                }
            }
        case 56:
            {
                let i = n.args[0]
                  , s = gr(e, i);
                return s.length - 1 === 0 ? [r.Square([s[0]])] : [r.Square([s[0]]), r.Multiply([r.Constant(2), r.Multiply([s[0], s[1]])]), r.Square([s[1]])]
            }
        case 33:
            return gr(e, n.args[1]);
        case 37:
        case 16:
        case 0:
        case 23:
        case 2:
        case 1:
        case 25:
        case 32:
        case 31:
        case 15:
        case 38:
        case 39:
        case 40:
        case 41:
        case 42:
        case 21:
        case 22:
        case 19:
        case 20:
        case 24:
        case 48:
        case 47:
        case 3:
        case 44:
        case 49:
        case 50:
        case 51:
        case 4:
        case 53:
        case 54:
        case 55:
            throw new Error(`Cannot find polynomial coefficients of opcode ${n.type} that depends on symbol.`);
        default:
            let o = n;
            throw new Error(`Unexpected opcode ${o.type}`)
        }
    }
    function Kw(e, t, n) {
        let r = e.argNames.indexOf(t);
        if (r === -1) {
            let s = e.getInstruction(n);
            return s.type === 1 ? eL(s) : Vr()
        }
        let o = Eo(e, r, {
            allowRestriction: !0,
            allowClosedBlockReferences: !1
        })
          , i = q5(o, n);
        return ei(i, n)
    }
    function q5(e, t) {
        let {chunk: n, mask: r} = e;
        return {
            chunk: n,
            mask: r,
            orderCtx: e,
            domainTable: [],
            index: t
        }
    }
    function ei(e, t) {
        let {domainTable: n} = e
          , r = n[t];
        if (r !== void 0)
            return r;
        let o = z5(e, t);
        return n[t] = o,
        o
    }
    function z5(e, t) {
        let {chunk: n, mask: r, orderCtx: o} = e
          , i = n.getInstruction(t);
        switch (i.type) {
        case 1:
            return eL(i);
        case 3:
        case 2:
            return i.valueType === b ? Fa() : Vr();
        case 0:
            return Vr();
        case 31:
            return Yf(ei(e, i.args[0]), ei(e, i.args[1]));
        case 32:
        case 8:
        case 9:
        case 10:
            return mr(ei(e, i.args[0]), ei(e, i.args[1]));
        case 11:
            {
                let s = mr(ei(e, i.args[0]), ei(e, i.args[1]))
                  , a = n.getInstruction(i.args[1]);
                return a.type === 1 && a.valueType === b && L(a.value) !== 0 ? s : mr(Vr(), s)
            }
        case 14:
        case 56:
            return ei(e, i.args[0]);
        case 15:
            {
                let s = i.valueType;
                switch (s) {
                case R:
                case G:
                    return H5(e, i.args);
                case N:
                    return Gx(e, i.args);
                case Pt:
                case pn:
                case mn:
                case $t:
                case wt:
                case Kt:
                case Qt:
                case Ht:
                case an:
                case Yt:
                case qn:
                case zn:
                    return Gx(e, i.args);
                default:
                    let a = s;
                    throw new Error(`Unexpected tuple type ${a}`)
                }
            }
        case 12:
        case 13:
        case 47:
        case 48:
        case 16:
        case 42:
        case 21:
        case 22:
        case 23:
        case 24:
        case 19:
        case 20:
        case 39:
        case 40:
        case 41:
        case 44:
        case 50:
        case 51:
        case 54:
        case 55:
            return Gx(e, i.args);
        case 4:
        case 53:
            return Vr();
        case 49:
            return Vr();
        case 38:
            return i.args.length === 1 ? ei(e, i.args[0]) : Vr();
        case 25:
            return Vr();
        case 33:
            return dA(ei(e, i.args[0]), ei(e, i.args[1]), ei(e, i.args[2]));
        case 26:
        case 27:
        case 28:
        case 29:
            {
                if (!r[t])
                    return Fa();
                let s = mr(ei(e, i.args[0]), ei(e, i.args[1]));
                if (Pn(o, t) > 1)
                    return mr(Vr(), s);
                let a = e.coefficientCtx;
                a === void 0 && (a = ua(o, e.index),
                e.coefficientCtx = a);
                let u = a.newChunk
                  , c = gr(a, t)
                  , [l,p] = c;
                if (!Ye(u.getInstruction(l)))
                    return mr(Vr(), s);
                let m = Xr(u, l);
                if (isNaN(m))
                    return wu();
                if (p === void 0)
                    return i.type === 28 || i.type === 29 ? m >= 0 ? s : wu() : m > 0 ? s : wu();
                {
                    let d = Xr(u, p);
                    return mr(s, Nm(m, d))
                }
            }
        case 37:
            switch (i.symbol) {
            case "restriction":
            case "restrictionToBoolean":
                return ei(e, i.args[0]);
            case "count":
                return Fa();
            default:
                return ir[i.symbol].noPeel ? Vr() : Gx(e, i.args)
            }
        }
    }
    function H5(e, t) {
        let n = Fa();
        for (let r of t)
            n = mr(n, ei(e, r));
        return n
    }
    function Gx(e, t) {
        let n = Vr();
        for (let r of t)
            n = mr(n, ei(e, r));
        return n
    }
    function eL(e) {
        if (cd(e) && e.value.length !== 1)
            return Vr();
        switch (e.valueType) {
        case b:
        case Y:
        case R:
        case zt:
        case G:
        case to:
            return Bx(e) ? wu() : Fa();
        case Fe:
            return e.value ? Fa() : wu();
        case yi:
            return e.value[0] ? Fa() : wu();
        default:
            return Vr()
        }
    }
    function tL(e) {
        let t = e.getReturnIndex()
          , n = e.getInstruction(t);
        if (!de(n))
            return t;
        let r = jM(e, n)
          , o = St(r.expectedTypes)
          , i = s0(e, n.args, [o]);
        if (r.isReducerWithNoListArgs) {
            let s = k5(e, i.didCoerce ? i.args : n.args)
              , a = $n(r.expectedTypes.rest);
            if (As(s, a)) {
                i.didCoerce ? e.replaceInstructionWithNoop(t) : e.popInstruction();
                let u = e.List(n.args);
                return e.copyInstructionWithArgs(n, [u])
            }
        } else
            i.didCoerce && (e.replaceInstructionWithNoop(t),
            e.copyInstructionWithArgs(n, i.args));
        return e.getReturnIndex()
    }
    function s0(e, t, n) {
        let r = !1
          , o = [];
        for (let i = 0; i < t.length; i++) {
            let s = Of(n, i)
              , a = t[i]
              , u = e.getInstruction(a).valueType
              , c = a;
            s.every(l => !As(u, l)) && (ae(s[0], b) ? c = Xi(e, a) : ae(s[0], N) && (c = U5(e, a))),
            c !== a && (r = !0),
            o.push(c)
        }
        return r ? {
            didCoerce: r,
            args: o
        } : {
            didCoerce: !1
        }
    }
    function Xi(e, t, n={}) {
        var o;
        let r = e.getInstruction(t);
        return r.valueType === He ? t : ae(r.valueType, Oe) ? rL(e, t) : ae(r.valueType, Se) ? nL(e, t) : ae(r.valueType, sn) ? e.Piecewise([e.NativeFunction("restrictionToBoolean", [t]), e.Constant(1), e.Constant(NaN)]) : ae(r.valueType, N) ? (o = n.peelableCoerce) != null && o ? e.NativeFunction(n.withTolerance ? "peelableCoerceComplexToRealWithTolerance" : "peelableCoerceComplexToReal", [t]) : e.NativeFunction(n.withTolerance ? "coerceComplexToRealWithTolerance" : "coerceComplexToReal", [t]) : t
    }
    function Vp(e, t) {
        let n = e.getInstruction(t);
        return n.valueType === He || ae(n.valueType, N) ? t : Xi(e, t)
    }
    function U5(e, t) {
        let n = e.getInstruction(t);
        if (n.valueType === He)
            return t;
        if (ae(n.valueType, b))
            return e.NativeFunction("coerceRealToComplex", [t]);
        if (ae(n.valueType, N))
            return t;
        if (ur(n.valueType, b) || ur(n.valueType, Y)) {
            let r = Xi(e, t);
            return e.NativeFunction("coerceRealToComplex", [r])
        }
        return t
    }
    function k5(e, t) {
        let n = e.getInstruction(t[0]).valueType;
        if (!jn(n))
            return nr;
        for (let r of t)
            if (e.getInstruction(r).valueType !== n)
                return nr;
        return $n(n)
    }
    function zx(e, t, n) {
        let r = e.getInstruction(n);
        if (de(r)) {
            for (let s of r.args)
                if (qx(e, s, n))
                    return !0
        }
        if (qx(e, n, n))
            return !0;
        let o = [!0];
        for (let s = n + 1; s < t; s++)
            o.push(!1);
        o.push(!0);
        let i = [t];
        for (; i.length; ) {
            let s = i.pop()
              , a = e.getInstruction(s);
            if (qx(e, s, n))
                return !0;
            if (de(a)) {
                for (let u of a.args)
                    if (u >= n)
                        o[u - n] || (i.push(u),
                        o[u - n] = !0);
                    else if (qx(e, u, n))
                        return !0
            }
        }
        return !1
    }
    function qx(e, t, n) {
        let r = e.getInstruction(t);
        return t < n ? r.type === 4 ? !1 : !Ye(r) : r.type === 50 ? !0 : r.type === 3
    }
    function By(e, t, n) {
        let r = e.getInstruction(t);
        if (X(r.valueType)) {
            let o = Un(e, t);
            if (n = Math.floor(n),
            isNaN(n) || n < 0 || o !== void 0 && n >= o) {
                let i = Qe(r.valueType);
                return e.NanOfType(i)
            }
            return r.type === 38 ? r.args[n] : r.type === 1 && X(r.valueType) ? e.ConstantOfType(Qe(r.valueType), r.value[n]) : o !== void 0 ? e.InboundsListAccess([t, e.Constant(n + 1)]) : e.ListAccess([t, e.Constant(n + 1)])
        } else
            throw new Error(`Cannot access elements of ${se(r.valueType)}`)
    }
    function Hx(e, t, n) {
        let r = e.getInstruction(t);
        if (n.length === 0)
            return e.ConstantOfType(r.valueType, []);
        if (r.type === 1 && X(r.valueType)) {
            let o = []
              , i = Qe(r.valueType);
            for (let s of n) {
                let a = Math.floor(s);
                isNaN(a) || a < 0 || a >= Qa(e, t, "Programming error: expected Constant list instruction to have constant length.") ? o.push(wo(i)) : o.push(r.value[a])
            }
            return e.ConstantOfType(r.valueType, o)
        } else if (r.type === 38) {
            let o = [];
            for (let i of n) {
                let s = Math.floor(i);
                if (isNaN(s) || s < 0 || s >= Qa(e, t, "Programming error: expected List instruction to have constant length.")) {
                    let a = Qe(r.valueType);
                    o.push(e.NanOfType(a))
                } else
                    o.push(r.args[s])
            }
            return e.List(o)
        } else {
            let o = []
              , i = !0
              , s = Un(e, t);
            for (let u of n) {
                let c = Math.floor(u);
                o.push(e.Constant(c + 1)),
                (isNaN(c) || c < 0 || s === void 0 || c >= s) && (i = !1)
            }
            let a = [t, e.List(o)];
            return i ? e.InboundsListAccess(a) : e.ListAccess(a)
        }
    }
    function a0(e, t) {
        return !un(e) && isNaN(e) || !un(t) && isNaN(t) ? [NaN, NaN] : [e, t]
    }
    function Ux(e) {
        return Zt(L(e[0]), L(e[1]))
    }
    function oL([e,t]) {
        return un(e) && un(t)
    }
    function iL(e, t) {
        if (!oL(e) || !oL(t))
            return jc(Ux(e), Ux(t));
        let[n,r] = e
          , [o,i] = t
          , s = Pi(Zr(o, o), Zr(i, i))
          , a = Pi(Zr(n, o), Zr(r, i))
          , u = ki(Zr(r, o), Zr(n, i))
          , c = Fo(a, s)
          , l = Fo(u, s);
        return !un(c) || !un(l) ? jc(Ux(e), Ux(t)) : a0(c, l)
    }
    function u0(e, t, n) {
        let r;
        return kx(t) ? r = l0(t, n) : r = aL(t, n),
        e.ConstantOfType(t, r)
    }
    function c0(e) {
        return kx(e) || sL(e)
    }
    function kx(e) {
        switch (e) {
        case He:
        case Y:
        case yi:
        case ke:
        case gu:
        case zt:
        case Tr:
        case hi:
        case mo:
        case fo:
        case xi:
        case bi:
        case Dr:
        case Ar:
        case wr:
        case to:
        case qi:
        case Zo:
        case ea:
        case Gi:
        case Ao:
        case hu:
        case bu:
        case Du:
        case _u:
        case xu:
        case Tu:
        case Cu:
        case Iu:
        case Pu:
        case Su:
        case Eu:
        case vu:
        case Mu:
        case Ks:
            return !0;
        default:
            return !1
        }
    }
    function sL(e) {
        switch (e) {
        case b:
        case Fe:
        case N:
        case sn:
        case R:
        case Ee:
        case he:
        case ce:
        case Ae:
        case Ie:
        case Ce:
        case De:
        case Oe:
        case Se:
        case G:
        case qe:
        case lr:
        case Lr:
        case en:
        case bn:
        case cr:
        case we:
        case pt:
        case Pt:
        case pn:
        case mn:
        case $t:
        case wt:
        case Kt:
        case Qt:
        case Ht:
        case an:
        case Yt:
        case zn:
        case qn:
        case _t:
            return !0;
        default:
            return !1
        }
    }
    function l0(e, t) {
        if (e === He)
            return [];
        let n = Qe(e);
        if (!sL(n))
            throw new Error(`Programming error: unexpected element type ${Ke(n)} for list type ${Ke(e)}.`);
        let r = [];
        for (let o = 0; o < t.length; o++) {
            let i = aL(n, t[o]);
            r.push(i)
        }
        return r
    }
    function aL(e, t) {
        if (e === b)
            return be(t, 1);
        if (e === R || e === N) {
            let[n,r] = t;
            return [be(n, 1), be(r, 1)]
        } else if (e === G) {
            let[n,r,o] = t;
            return [be(n, 1), be(r, 1), be(o, 1)]
        } else
            return t
    }
    function p0(e, t) {
        return Pi(e, t)
    }
    function m0(e, t) {
        return ki(e, t)
    }
    function d0(e, t) {
        return Zr(e, t)
    }
    function f0(e, t) {
        return Fo(e, t)
    }
    function Gy(e, t) {
        return L(e) === Math.E ? Math.exp(L(t)) : qN(e, t)
    }
    var Y5 = Gy;
    function y0(e) {
        return Ii(e)
    }
    function g0(e) {
        return Zr(e, e)
    }
    function Z5(e, t) {
        return t[e]
    }
    function h0(e, t) {
        return L(e) === L(t)
    }
    function b0(e, t) {
        return L(e) < L(t)
    }
    function x0(e, t) {
        return L(e) > L(t)
    }
    function T0(e, t) {
        return L(e) <= L(t)
    }
    function I0(e, t) {
        return L(e) >= L(t)
    }
    function cL(e, t) {
        return e || t
    }
    function lL(e, t) {
        return e && t
    }
    function X5(e, t, n) {
        let r = Math.floor(L(n)) - 1;
        return !isFinite(r) || r < 0 || r >= t.length ? wo(e) : t[r]
    }
    function P0(e, t, n, r) {
        un(r) && (r = L(r));
        let o = n === b || n === _t ? r : eS(n, r);
        return `${t}::${e}${o}`
    }
    function S0(e, t) {
        switch (e) {
        case "mod":
            return HN(t[0], t[1]);
        case "abs":
            return BN(t[0]);
        case "sqrt":
            return zN(t[0]);
        case "total":
            return MP(t[0]);
        case "mean":
            return UN(t[0]);
        case "count":
            return t[0].length;
        case "validateRangeLength":
            {
                let n = t[0]
                  , r = t[1]
                  , o = t[2]
                  , i = t[3]
                  , s = sS(n, r, o, i);
                if (s === 0)
                    throw cy();
                return s
            }
        case "validateSampleCount":
            {
                let n = Ua(t[0])
                  , r = aS(n);
                if (r === 0 && n !== 0)
                    throw Dv();
                return r
            }
        case "select":
        case "elementsAt":
        case "uniquePerm":
            {
                let n = ir[e];
                return Lo[n.symbol].apply(null, t)
            }
        case "complex":
            return a0(t[0], t[1]);
        case "complexDivide":
            return iL(t[0], t[1]);
        case "wirtingerEqualOrWarning":
            return t[1];
        default:
            {
                let n = ir[e];
                return (n.module === "Math" ? Math : Lo)[n.symbol].apply(null, Ua(t))
            }
        }
    }
    function E0(e, t) {
        let n = L(t[0][0])
          , r = L(t[1][0])
          , o = L(t[0][1])
          , i = L(t[1][1]);
        if (n !== r || o !== i) {
            let s = n - r
              , a = o - i;
            if (isNaN(s) || isNaN(a))
                return;
            let u = Math.abs(s) + Math.abs(a)
              , c = Math.abs(n) + Math.abs(o)
              , l = Math.abs(r) + Math.abs(i);
            if (u < 1e-14 * Math.max(c, l))
                return;
            e.setWarning(I("shared-calculator-error-complex-wirtinger-differs"))
        }
    }
    function C0(e, t) {
        let n = L(t[0][1]);
        SS(n) && e.setWarning(I("graphing-calculator-error-nan-blame-complex-coercion"))
    }
    function pL(e, t) {
        let n = Array(t + 1);
        return Dt(e, t, n)
    }
    function mL(e, t, n) {
        let r = Array(t + 1);
        for (let o = 0; o < n.length; o++)
            r[o] = n[o];
        return Dt(e, t, r)
    }
    function dL(e, t, n) {
        if (t.constantLength)
            return t.constantLength;
        let r = t.args[0]
          , i = e.getInstruction(r).args[0]
          , s = e.getInstruction(i);
        return L(Dt(e, s.args[0], n))
    }
    function fL(e, t, n, r) {
        let o = e.getInstruction(t)
          , i = dL(e, o, r);
        if (!isFinite(n) || n < 0 || n >= i)
            return wo(Qe(o.valueType));
        let s = o.args[0]
          , a = t - s
          , u = e.getInstruction(s)
          , c = u.args[0]
          , l = u.args[a];
        r[c] = n + 1;
        let p = Dt(e, l, r);
        for (let m = c; m <= s; m++)
            r[m] = void 0;
        return p
    }
    function W5(e, t, n) {
        let r = e.getInstruction(t)
          , o = r.args[0]
          , i = e.getInstruction(o).args[0];
        if (J5(e, i + 1, o - 1) && kx(r.valueType)) {
            let u = e.copy()
              , c = Rd(u);
            return l0(r.valueType, c)
        }
        let s = dL(e, r, n)
          , a = [];
        for (let u = s - 1; u >= 0; u--)
            a[u] = fL(e, t, u, n);
        return a
    }
    function yL(e, t, n) {
        let r = Dt(e, t.args[1], n)
          , o = t.args[0]
          , i = e.getInstruction(o);
        if (i.type === 48)
            return fL(e, o, L(r) - 1, n);
        if (i.type === 33) {
            let s = Dt(e, i.args[0], n);
            return yL(e, {
                ...t,
                args: [s ? i.args[1] : i.args[2], t.args[1]]
            }, n)
        } else {
            let s = Dt(e, t.args[0], n);
            return X5(t.valueType, s, r)
        }
    }
    function Dt(e, t, n) {
        let r = n[t];
        if (r !== void 0)
            return r;
        let o = j5(e, t, n);
        return typeof o == "number" && o === Math.floor(o) && (o = be(o, 1)),
        n[t] = o,
        o
    }
    function j5(e, t, n) {
        let r = e.getInstruction(t);
        switch (r.type) {
        case 1:
            return r.value;
        case 8:
            return p0(Dt(e, r.args[0], n), Dt(e, r.args[1], n));
        case 9:
            return m0(Dt(e, r.args[0], n), Dt(e, r.args[1], n));
        case 10:
            return d0(Dt(e, r.args[0], n), Dt(e, r.args[1], n));
        case 11:
            return f0(Dt(e, r.args[0], n), Dt(e, r.args[1], n));
        case 12:
            return Gy(Dt(e, r.args[0], n), Dt(e, r.args[1], n));
        case 13:
            return Y5(Dt(e, r.args[0], n), Dt(e, r.args[1], n));
        case 14:
            return y0(Dt(e, r.args[0], n));
        case 56:
            return g0(Dt(e, r.args[0], n));
        case 15:
            return r.args.map(i => Dt(e, i, n));
        case 16:
            return Z5(r.index, Dt(e, r.args[0], n));
        case 25:
            return h0(Dt(e, r.args[0], n), Dt(e, r.args[1], n));
        case 26:
            return b0(Dt(e, r.args[0], n), Dt(e, r.args[1], n));
        case 27:
            return x0(Dt(e, r.args[0], n), Dt(e, r.args[1], n));
        case 28:
            return T0(Dt(e, r.args[0], n), Dt(e, r.args[1], n));
        case 29:
            return I0(Dt(e, r.args[0], n), Dt(e, r.args[1], n));
        case 31:
            return Dt(e, r.args[0], n) || Dt(e, r.args[1], n);
        case 32:
            return Dt(e, r.args[0], n) && Dt(e, r.args[1], n);
        case 44:
            return P0(r.tag, Dt(e, r.args[0], n), e.getInstruction(r.args[1]).valueType, Dt(e, r.args[1], n));
        case 33:
            return Dt(e, r.args[0], n) ? Dt(e, r.args[1], n) : Dt(e, r.args[2], n);
        case 37:
            {
                let i = [];
                for (let s of r.args)
                    i.push(Dt(e, s, n));
                return r.symbol === "wirtingerEqualOrWarning" && E0(e, i),
                r.symbol === "peelableCoerceComplexToReal" && C0(e, i),
                S0(r.symbol, i)
            }
        case 38:
            {
                let i = [];
                for (let s of r.args)
                    i.push(Dt(e, s, n));
                return i
            }
        case 39:
        case 40:
        case 41:
            return yL(e, r, n);
        case 48:
            return W5(e, t, n);
        case 47:
            {
                let i = r.args[0]
                  , s = t - i
                  , u = e.getInstruction(i).args[s]
                  , c = uL(e, {
                    endIndex: i,
                    returnIndex: u,
                    resultIndex: t
                }, n);
                return Rd(c)
            }
        case 55:
            {
                let i = r.args[0]
                  , a = e.getInstruction(i).endIndex
                  , c = e.getInstruction(a).args[0]
                  , l = uL(e, {
                    endIndex: a,
                    returnIndex: c,
                    resultIndex: t
                }, n);
                return Rd(l)
            }
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
        case 42:
        case 0:
        case 2:
        case 3:
        case 49:
        case 50:
        case 51:
        case 4:
        case 53:
        case 54:
            throw new Error(`Programming Error: cannot interpret opcode ${r.type}`);
        default:
            let o = r;
            throw new Error(`Programming Error: unexpected opcode ${o.type}`)
        }
    }
    function uL(e, t, n) {
        let r = t.endIndex
          , o = t.returnIndex
          , i = t.resultIndex
          , s = e.getInstruction(r).args[0]
          , a = [];
        a[o] = !0;
        let u = o;
        e.getInstruction(i).type === 55 && (a[i] = !0,
        u = i);
        for (let y = u; y >= s; y--) {
            if (!a[y])
                continue;
            let g = e.getInstruction(y);
            if (de(g))
                for (let f of g.args)
                    f < s || f > r ? Dt(e, f, n) : a[f] = !0
        }
        let l = e.copy();
        l.unsafelyTruncate(s);
        for (let y = 0; y < s; y++) {
            let g = n[y]
              , f = e.getInstruction(y);
            if (g !== void 0) {
                let h = f.valueType;
                l.replaceInstructionWithConstant(y, {
                    type: 1,
                    valueType: h,
                    value: g
                })
            }
        }
        l.reopenAllBlocks();
        let p = i - 1
          , m = new zo(e,s,p,l);
        m.copyUntilEnd( (y, g) => {
            if (de(g)) {
                let f = m.mapArgs(g.args);
                return g.type === 40 ? y.InboundsListAccess(f) : y.copyInstructionWithArgs(g, f)
            } else
                return m.copyLeafOrFunctionHeader(g)
        }
        ),
        l.Noop();
        let d = e.getInstruction(i);
        if (d.type === 47)
            l.replaceInstructionWithBlockVarOrFunctionCall(l.getReturnIndex(), {
                type: 47,
                valueType: d.valueType,
                args: [m.mapIndex(r)]
            });
        else if (d.type === 55)
            l.replaceInstructionWithBlockVarOrFunctionCall(l.getReturnIndex(), {
                type: 55,
                valueType: d.valueType,
                args: m.mapArgs(d.args)
            });
        else
            throw new Error(`Programming error: unexpected opcode ${So(d.type)}`);
        return l
    }
    function J5(e, t, n) {
        let r = [];
        for (let i = 0; i <= t; i++)
            r.push(!1);
        let o = [];
        for (let i = t + 1; i <= n; i++)
            o.push(i);
        for (; o.length; ) {
            let i = o.pop();
            if (r[i])
                continue;
            r[i] = !0;
            let s = e.getInstruction(i);
            if (s.type === 55)
                return !0;
            if (de(s))
                for (let a of s.args)
                    r[a] || o.push(a)
        }
        return !1
    }
    function gL(e, t) {
        let n = [];
        for (let o = 0; o <= t; o++)
            n.push(!1);
        let r = [t];
        for (; r.length; ) {
            let o = r.pop();
            if (n[o])
                continue;
            n[o] = !0;
            let i = e.getInstruction(o);
            if (i.type === 4 && i.endIndex === -1)
                return !0;
            if (de(i))
                for (let s of i.args)
                    n[s] || r.push(s)
        }
        return !1
    }
    function Rd(e) {
        let t = e.getCompiledFunction();
        return t.executionMetadata.recursiveFunctionCache = new Pm,
        t.executionMetadata.iterativeRecursionOutputs = {},
        t.fn()
    }
    function bL(e) {
        if (e.instructionsLength() - 1 !== e.getReturnIndex())
            throw new Error("Programming Error: only the final instruction in a chunk can be constant collapsed");
        let t = e.getInstruction(e.getReturnIndex());
        if (!de(t))
            return e.getReturnIndex();
        switch (t.type) {
        case 8:
            {
                let r = e.getInstruction(t.args[0])
                  , o = e.getInstruction(t.args[1]);
                return r.type === 1 && o.type === 1 ? (e.popInstruction(),
                e.Constant(p0(r.value, o.value))) : r.type === 1 && L(r.value) === 0 ? (e.popInstruction(),
                t.args[1]) : o.type === 1 && L(o.value) === 0 ? (e.popInstruction(),
                t.args[0]) : e.getReturnIndex()
            }
        case 9:
            {
                let r = e.getInstruction(t.args[0])
                  , o = e.getInstruction(t.args[1]);
                return r.type === 1 && o.type === 1 ? (e.popInstruction(),
                e.Constant(m0(r.value, o.value))) : r.type === 1 && L(r.value) === 0 ? (e.popInstruction(),
                e.Negative([t.args[1]])) : o.type === 1 && L(o.value) === 0 ? (e.popInstruction(),
                t.args[0]) : e.getReturnIndex()
            }
        case 10:
            {
                let r = e.getInstruction(t.args[0])
                  , o = e.getInstruction(t.args[1]);
                return r.type === 1 && o.type === 1 ? (e.popInstruction(),
                e.Constant(d0(r.value, o.value))) : r.type === 1 && L(r.value) === 1 ? (e.popInstruction(),
                t.args[1]) : o.type === 1 && L(o.value) === 1 ? (e.popInstruction(),
                t.args[0]) : e.getReturnIndex()
            }
        case 11:
            {
                let r = e.getInstruction(t.args[0])
                  , o = e.getInstruction(t.args[1]);
                return r.type === 1 && o.type === 1 ? (e.popInstruction(),
                e.Constant(f0(r.value, o.value))) : o.type === 1 && L(o.value) === 1 ? (e.popInstruction(),
                t.args[0]) : e.getReturnIndex()
            }
        case 12:
            {
                let r = e.getInstruction(t.args[0])
                  , o = e.getInstruction(t.args[1]);
                if (r.type === 1 && o.type === 1)
                    return e.popInstruction(),
                    e.Constant(Gy(r.value, o.value));
                if (r.type === 1 && r.valueType === b) {
                    let i = L(r.value);
                    if (i === Math.E)
                        return e.popInstruction(),
                        e.NativeFunction("exp", [t.args[1]]);
                    if (i > 0)
                        return e.popInstruction(),
                        e.RawExponent(t.args)
                }
                if (o.type === 1 && o.valueType === b) {
                    let i = L(o.value);
                    if (i === 1)
                        return e.popInstruction(),
                        t.args[0];
                    if (i === Math.floor(i))
                        return e.popInstruction(),
                        e.RawExponent(t.args);
                    if (un(o.value)) {
                        let {n: s, d: a} = o.value;
                        if (a % 2 === 1) {
                            e.popInstruction();
                            let u = e.RawExponent([e.NativeFunction("abs", [t.args[0]]), t.args[1]]);
                            return s % 2 === 0 ? u : e.Multiply([e.NativeFunction("sign", [t.args[0]]), u])
                        }
                    }
                }
                return e.getReturnIndex()
            }
        case 13:
            {
                let r = e.getInstruction(t.args[0])
                  , o = e.getInstruction(t.args[1]);
                return r.type === 1 && o.type === 1 ? (e.popInstruction(),
                e.Constant(Gy(r.value, o.value))) : o.type === 1 && L(o.value) === 1 ? (e.popInstruction(),
                t.args[0]) : e.getReturnIndex()
            }
        case 14:
            {
                let r = e.getInstruction(t.args[0]);
                return r.type === 1 ? (e.popInstruction(),
                e.Constant(y0(r.value))) : e.getReturnIndex()
            }
        case 56:
            {
                let r = e.getInstruction(t.args[0]);
                return r.type === 1 ? (e.popInstruction(),
                e.Constant(g0(r.value))) : e.getReturnIndex()
            }
        case 25:
            {
                let r = e.getInstruction(t.args[0])
                  , o = e.getInstruction(t.args[1]);
                return r.type === 1 && o.type === 1 ? (e.popInstruction(),
                e.ConstantOfType(Fe, h0(r.value, o.value))) : e.getReturnIndex()
            }
        case 26:
            {
                let r = e.getInstruction(t.args[0])
                  , o = e.getInstruction(t.args[1]);
                return r.type === 1 && o.type === 1 ? (e.popInstruction(),
                e.ConstantOfType(Fe, b0(r.value, o.value))) : e.getReturnIndex()
            }
        case 27:
            {
                let r = e.getInstruction(t.args[0])
                  , o = e.getInstruction(t.args[1]);
                return r.type === 1 && o.type === 1 ? (e.popInstruction(),
                e.ConstantOfType(Fe, x0(r.value, o.value))) : e.getReturnIndex()
            }
        case 28:
            {
                let r = e.getInstruction(t.args[0])
                  , o = e.getInstruction(t.args[1]);
                return r.type === 1 && o.type === 1 ? (e.popInstruction(),
                e.ConstantOfType(Fe, T0(r.value, o.value))) : e.getReturnIndex()
            }
        case 29:
            {
                let r = e.getInstruction(t.args[0])
                  , o = e.getInstruction(t.args[1]);
                return r.type === 1 && o.type === 1 ? (e.popInstruction(),
                e.ConstantOfType(Fe, I0(r.value, o.value))) : e.getReturnIndex()
            }
        case 31:
            {
                let r = e.getInstruction(t.args[0])
                  , o = e.getInstruction(t.args[1]);
                return r.type === 1 && o.type === 1 ? (e.popInstruction(),
                e.ConstantOfType(Fe, cL(r.value, o.value))) : r.type === 1 ? (e.popInstruction(),
                r.value ? t.args[0] : t.args[1]) : o.type === 1 ? (e.popInstruction(),
                o.value ? t.args[1] : t.args[0]) : e.getReturnIndex()
            }
        case 32:
            {
                let r = e.getInstruction(t.args[0])
                  , o = e.getInstruction(t.args[1]);
                return r.type === 1 && o.type === 1 ? (e.popInstruction(),
                e.ConstantOfType(Fe, lL(r.value, o.value))) : r.type === 1 ? (e.popInstruction(),
                r.value ? t.args[1] : t.args[0]) : o.type === 1 ? (e.popInstruction(),
                o.value ? t.args[0] : t.args[1]) : e.getReturnIndex()
            }
        case 33:
            {
                let r = e.getInstruction(t.args[0]);
                return r.type === 1 ? (e.popInstruction(),
                r.value ? t.args[1] : t.args[2]) : e.getReturnIndex()
            }
        case 16:
            {
                let r = e.getInstruction(t.args[0])
                  , o = t.index;
                return r.type === 15 ? (e.popInstruction(),
                r.args[o]) : r.type === 1 ? (e.popInstruction(),
                e.ConstantOfType(t.valueType, r.value[o])) : e.getReturnIndex()
            }
        case 38:
        case 15:
            {
                if (hL(e, t.args)) {
                    e.popInstruction();
                    let r = [];
                    for (let o of t.args)
                        r.push(e.getInstruction(o).value);
                    return e.ConstantOfType(t.valueType, r)
                }
                return e.getReturnIndex()
            }
        case 39:
        case 41:
            {
                let r = t.args[0]
                  , o = e.getInstruction(r)
                  , i = e.getInstruction(t.args[1])
                  , s = Un(e, r);
                if (s === 0)
                    return e.popInstruction(),
                    e.NanOfType(t.valueType);
                if (o.type === 33 && i.type === 1) {
                    let a = t.type === 39 ? e.ListAccess([o.args[1], t.args[1]]) : e.InboundsListAccess([o.args[1], t.args[1]])
                      , u = t.type === 39 ? e.ListAccess([o.args[2], t.args[1]]) : e.InboundsListAccess([o.args[2], t.args[1]]);
                    return e.Piecewise([o.args[0], a, u])
                }
                if (o.type === 48) {
                    e.popInstruction();
                    let a = o.args[0], u = r - a, c = e.getInstruction(a), l = c.args[0], p, m;
                    if (t.type === 41)
                        p = t.args[1];
                    else if (i.type === 1 && i.valueType === b && s !== void 0) {
                        let g = L(i.value)
                          , f = Math.floor(g);
                        if (f < 1 || f > s)
                            return e.NanOfType(t.valueType);
                        p = g === f ? t.args[1] : e.Constant(f)
                    } else {
                        let g = e.Constant(1)
                          , h = e.getInstruction(l).args[0]
                          , x = e.NativeFunction("floor", [t.args[1]])
                          , T = e.GreaterEqual([x, g])
                          , P = e.LessEqual([x, h]);
                        p = e.Piecewise([T, e.Piecewise([P, x, h]), g]),
                        m = {
                            one: g,
                            lengthIndex: h,
                            roundedIndex: x,
                            greaterEqualIndex: T,
                            lessEqualIndex: P
                        }
                    }
                    if (c.args[u] < l)
                        return c.args[u];
                    let d = c.args[u]
                      , y = new zo(e,l,d);
                    if (y.copyUntilEnd( (g, f, h) => {
                        if (h === l)
                            return p;
                        if (de(f)) {
                            let x = y.mapArgs(f.args);
                            return f.type === 40 ? g.InboundsListAccess(x) : g.copyInstructionWithArgs(f, x)
                        } else
                            return y.copyLeafOrFunctionHeader(f)
                    }
                    ),
                    m) {
                        let {greaterEqualIndex: g, lessEqualIndex: f, lengthIndex: h, one: x} = m
                          , T = Qe(o.valueType)
                          , P = e.NanOfType(T)
                          , C = y.mapIndex(d)
                          , S = e.And([e.And([g, f]), e.GreaterEqual([h, x])]);
                        return e.Piecewise([S, C, P])
                    } else
                        return y.mapIndex(d)
                } else if (i.type === 1 && i.valueType === b)
                    if (o.type === 38) {
                        e.popInstruction();
                        let a = Math.floor(L(i.value)) - 1;
                        return isNaN(a) || a < 0 || a >= o.args.length ? e.NanOfType(t.valueType) : o.args[a]
                    } else if (o.type === 1) {
                        e.popInstruction();
                        let a = Math.floor(L(i.value)) - 1;
                        return isNaN(a) || a < 0 || a >= o.value.length ? e.NanOfType(t.valueType) : e.ConstantOfType(Qe(o.valueType), o.value[a])
                    } else
                        return e.getReturnIndex();
                else
                    return e.getReturnIndex()
            }
        case 47:
            {
                let r = e.getInstruction(t.args[0]);
                if (!Bo(r) || zx(e, e.getReturnIndex(), r.args[0]))
                    return e.getReturnIndex();
                if (c0(t.valueType)) {
                    let o = e.copy()
                      , i = Rd(o);
                    return e.popInstruction(),
                    u0(e, t.valueType, i)
                } else
                    throw new Error(`Constant collapsing a block with return type ${se(t.valueType)} is not implemented.`)
            }
        case 55:
            {
                let r = e.dereferenceFunctionHeader(t.args[0]);
                if (r === void 0 || !hL(e, t.args.slice(1)) || zx(e, r, t.args[0]))
                    return e.getReturnIndex();
                if (c0(t.valueType)) {
                    let o = e.copy()
                      , i = Rd(o);
                    return e.popInstruction(),
                    u0(e, t.valueType, i)
                } else
                    throw new Error(`Constant collapsing a function call with return type ${se(t.valueType)} is not implemented.`)
            }
        case 37:
            {
                let r = K5(e, t.args);
                if (r !== void 0)
                    return e.popInstruction(),
                    t.symbol === "wirtingerEqualOrWarning" && E0(e, r),
                    t.symbol === "peelableCoerceComplexToReal" && C0(e, r),
                    e.ConstantOfType(t.valueType, S0(t.symbol, r));
                switch (t.symbol) {
                case "peelableCoerceComplexToReal":
                    {
                        let o = e.getInstruction(t.args[0]);
                        if (o.type === 37) {
                            if (o.symbol === "complex") {
                                let i = e.getInstruction(o.args[1]);
                                if (i.type === 1 && i.valueType === b && L(i.value) === 0)
                                    return e.popInstruction(),
                                    o.args[0]
                            } else if (o.symbol === "coerceRealToComplex")
                                return e.popInstruction(),
                                o.args[0]
                        }
                        return e.getReturnIndex()
                    }
                case "complexPow":
                    {
                        let o = e.getInstruction(t.args[1]);
                        if (o.type === 1 && o.valueType === N) {
                            let[i,s] = o.value;
                            if (L(i) === 1 && L(s) === 0)
                                return e.popInstruction(),
                                t.args[0]
                        }
                        return e.getReturnIndex()
                    }
                case "count":
                    {
                        let o = Un(e, t.args[0]);
                        return o !== void 0 ? (e.popInstruction(),
                        e.Constant(o)) : e.getReturnIndex()
                    }
                case "select":
                    {
                        let o = Un(e, t.args[0]);
                        if (o !== void 0 && Ye(e.getInstruction(t.args[1]))) {
                            e.popInstruction();
                            let i = Xr(e, t.args[1])
                              , s = [];
                            for (let a = 0; a < Math.min(o, i.length); a++)
                                i[a] && s.push(a);
                            return Hx(e, t.args[0], s)
                        } else
                            return e.getReturnIndex()
                    }
                case "shuffle":
                    {
                        let o = t.args[0]
                          , i = t.args[1]
                          , s = Un(e, i);
                        if (s !== void 0 && Ye(e.getInstruction(o))) {
                            e.popInstruction();
                            let a = nS(Xr(e, o), s);
                            return Hx(e, i, a)
                        } else
                            return e.getReturnIndex()
                    }
                case "elementsAt":
                    {
                        let o = t.args[0]
                          , i = t.args[1];
                        if (Ye(e.getInstruction(i))) {
                            e.popInstruction();
                            let s = Xr(e, i);
                            return Hx(e, o, s)
                        }
                        return e.getReturnIndex()
                    }
                case "restrictionToBoolean":
                    {
                        let o = e.getInstruction(t.args[0]);
                        return Ye(o) ? (e.popInstruction(),
                        e.ConstantOfType(Fe, o.value)) : o.type === 37 && o.symbol === "restriction" ? (e.popInstruction(),
                        o.args[0]) : e.getReturnIndex()
                    }
                default:
                    return e.getReturnIndex()
                }
            }
        case 44:
            {
                let r = e.getInstruction(t.args[0])
                  , o = e.getInstruction(t.args[1]);
                return Ye(r) && Ye(o) ? e.ConstantOfType(_t, P0(t.tag, ix(e, t.args[0]), o.valueType, ix(e, t.args[1]))) : e.getReturnIndex()
            }
        case 48:
            {
                let r = e.getReturnIndex()
                  , o = Un(e, r);
                if (o !== void 0 && o === 0)
                    return e.popInstruction(),
                    e.ConstantOfType(t.valueType, []);
                let i = t.args[0]
                  , s = e.getInstruction(i)
                  , a = s.args[0]
                  , u = r - i
                  , c = s.args[u];
                if (!zx(e, c, a)) {
                    if (t.valueType === gi) {
                        if (o == null)
                            throw fy(Go(e, r));
                        let m = [];
                        for (let d = 0; d < o; d++) {
                            let y = e.InboundsListAccess([r, e.Constant(d + 1)]);
                            m.push(y)
                        }
                        return e.List(m)
                    }
                    if (gL(e, r))
                        return r;
                    e.fuseBroadcast(),
                    r = e.getReturnIndex();
                    let p = pL(e, r);
                    e.popInstruction(),
                    e.ConstantOfType(t.valueType, p)
                }
                return r
            }
        case 49:
            {
                for (let o of t.args)
                    if (!Ye(e.getInstruction(o)))
                        return e.getReturnIndex();
                e.popInstruction();
                let r = {};
                for (let o = 0; o < t.symbols.length; o++) {
                    let i = t.symbols[o]
                      , s = e.getInstruction(t.args[o]);
                    if (s.type === 48 && (s = e.getInstruction(Wr(e, t.args[o]))),
                    s.type !== 1)
                        throw new Error("Expected instruction to be constant");
                    Bx(s) || (r[i] = s)
                }
                return e.ConstantOfType(pt, {
                    type: "Action",
                    updateRules: r
                })
            }
        case 20:
        case 22:
        case 23:
        case 24:
        case 40:
        case 42:
        case 21:
        case 19:
        case 50:
        case 51:
        case 53:
        case 54:
            return e.getReturnIndex();
        default:
            let n = t;
            throw new Error(`Unexpected opcode ${n.type}`)
        }
    }
    function hL(e, t) {
        for (let n of t) {
            let r = e.getInstruction(n);
            if (!Ye(r))
                return !1
        }
        return !0
    }
    function K5(e, t) {
        let n = [];
        for (let r of t) {
            let o = e.getInstruction(r);
            if (Ye(o))
                n.push(o.value);
            else
                return
        }
        return n
    }
    function Nd(e, t, n) {
        switch (t.type) {
        case 8:
            return e.Add(n);
        case 9:
            return e.Subtract(n);
        case 10:
            return e.Multiply(n);
        case 11:
            return e.Divide(n);
        case 12:
            return e.Exponent(n);
        case 13:
            return e.RawExponent(n);
        case 14:
            return e.Negative(n);
        case 56:
            return e.Square(n);
        case 25:
            return e.Equal(n);
        case 26:
            return e.Less(n);
        case 27:
            return e.Greater(n);
        case 28:
            return e.LessEqual(n);
        case 29:
            return e.GreaterEqual(n);
        case 31:
            return e.Or(n);
        case 32:
            return e.And(n);
        case 33:
            return e.Piecewise(n);
        case 47:
            return e.BlockVar(t.valueType, n);
        case 48:
            return e.BroadcastResult(t.valueType, n);
        case 15:
            return e.TupleOfType(t.valueType, n);
        case 16:
            return e.Slot(t.index, n);
        case 37:
            return e.NativeFunction(t.symbol, n);
        case 42:
            return e.Distribution(t.symbol, n);
        case 21:
            return e.BeginIntegral(t.callData, n);
        case 22:
            return e.EndIntegral(n);
        case 23:
            return e.BeginBroadcast(n, t.context);
        case 24:
            return e.EndBroadcast(n);
        case 19:
            return e.BeginLoop(t.callData, n);
        case 20:
            return e.EndLoop(n);
        case 38:
            return e.List(n);
        case 39:
            return e.ListAccess(n);
        case 40:
            return e.DeferredListAccess(n);
        case 41:
            return e.InboundsListAccess(n);
        case 44:
            return e.ExtendSeed(t.tag, n);
        case 49:
            return e.Action(t.symbols, n);
        case 50:
            return e.BeginMap(t.callData, n);
        case 51:
            return e.EndMap(n);
        case 53:
            return e.BeginFunction(n);
        case 54:
            return e.EndFunction(n);
        case 55:
            return e.FunctionCall(n);
        default:
            let r = t;
            throw new Error(`Unexpected opcode ${r.type}`)
        }
    }
    function xL(e) {
        if (e.instructionsLength() - 1 !== e.getReturnIndex())
            throw new Error("Programming Error: only the final instruction in a chunk can be converted to broadcast");
        let t = e.getInstruction(e.getReturnIndex());
        if (!de(t))
            return e.getReturnIndex();
        switch (t.type) {
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 31:
        case 32:
        case 16:
        case 14:
        case 56:
        case 33:
            return Tl(e, t);
        case 15:
            return Tl(e, t, dc[t.valueType].map(r => !X(r)));
        case 42:
            return Wr(e, Tl(e, t));
        case 37:
            {
                let r = ir[t.symbol];
                switch (r.tag) {
                case "default":
                case "trig":
                case "trig2":
                case "inverseTrig":
                case "color":
                    return Tl(e, t);
                case "never-broadcast":
                    {
                        let o = []
                          , i = !1;
                        for (let s of t.args) {
                            let a = Wr(e, s);
                            a !== s ? (i = !0,
                            o.push(a)) : o.push(s)
                        }
                        return i ? e.copyInstructionWithArgs(t, o) : e.getReturnIndex()
                    }
                case "reducer":
                    if (eY(e, t.args))
                        if (t.args.length === 1) {
                            let o = t.args[0]
                              , i = Wr(e, o);
                            return i !== o ? e.copyInstructionWithArgs(t, [i]) : e.getReturnIndex()
                        } else
                            return Tl(e, t);
                    else
                        return e.getReturnIndex();
                case "doubleReducer":
                    {
                        if (t.args.length !== 2)
                            throw new Error("Programming error: double reducers must have two arguments");
                        let o = Wr(e, t.args[0])
                          , i = Wr(e, t.args[1]);
                        return o !== t.args[0] || i !== t.args[1] ? e.copyInstructionWithArgs(t, [o, i]) : e.getReturnIndex()
                    }
                case "parameterizedReducer":
                    {
                        if (t.args.length !== 2)
                            throw new Error("Programming error: double reducers must have two arguments");
                        let o = Wr(e, t.args[0]);
                        return o === t.args[0] ? Tl(e, t, [!1, !0]) : e.copyInstructionWithArgs(t, [o, t.args[1]])
                    }
                default:
                    {
                        let o = r.tag;
                        throw new Error(`Programming Error: unexpected tag ${o}`)
                    }
                }
            }
        case 39:
        case 40:
        case 41:
            return e.getInstruction(t.args[0]).valueType === He && X(e.getInstruction(t.args[1]).valueType) ? e.ConstantOfType(He, []) : Tl(e, t, [!1, !0]);
        case 55:
            {
                let o = e.getInstruction(t.args[0]).signature.argTypes.map(a => !X(a))
                  , i = [t.args[0]]
                  , s = !1;
                for (let a = 1; a < t.args.length; a++) {
                    let u = t.args[a]
                      , c = Wr(e, u);
                    c !== u ? (s = !0,
                    i.push(c)) : i.push(u)
                }
                return s ? e.copyInstructionWithArgs(t, i) : Tl(e, t, [!1, ...o])
            }
        case 21:
        case 22:
        case 19:
        case 20:
        case 50:
        case 51:
            return e.getReturnIndex();
        case 38:
        case 47:
        case 23:
        case 24:
        case 48:
        case 44:
        case 49:
        case 53:
        case 54:
            return e.getReturnIndex();
        default:
            let n = t;
            throw new Error(`Unexpected opcode ${n.type}`)
        }
    }
    function eY(e, t) {
        for (let n of t)
            if (X(e.getInstruction(n).valueType))
                return !0;
        return !1
    }
    function Tl(e, t, n) {
        let r = t.args
          , o = !1
          , i = [];
        for (let d = 0; d < r.length; d++) {
            if (n && !n[d])
                continue;
            let y = r[d]
              , g = e.getInstruction(y).valueType;
            X(g) && i.indexOf(y) === -1 && i.push(y),
            g === He && (o = !0)
        }
        if (i.length === 0)
            return e.getReturnIndex();
        if (t.type === 33 && i.indexOf(t.args[0]) == -1 && i.indexOf(t.args[1]) >= 0 && i.indexOf(t.args[2]) >= 0) {
            let d = Wr(e, t.args[1])
              , y = Wr(e, t.args[2]);
            return d !== t.args[1] || y !== t.args[2] ? Nd(e, t, [t.args[0], d, y]) : e.getReturnIndex()
        }
        e.popInstruction();
        let s = Md(e, i);
        if (s === void 0)
            throw new Error("Programming Error: expected minListLength to be defined for " + i.length + " lists");
        let a = s;
        if (Ye(e.getInstruction(a)) && Xr(e, a) === 0 && o)
            return e.ConstantOfType(He, []);
        let u = e.BeginBroadcast([a], {
            type: "implicit"
        })
          , c = [];
        for (let d of i)
            c.push(Yu(e, d, u));
        let l = [];
        for (let d = 0; d < r.length; d++) {
            let y = r[d];
            if (n && !n[d])
                l.push(y);
            else {
                let g = i.indexOf(y);
                l.push(g === -1 ? y : c[g])
            }
        }
        let p = e.copyInstructionWithArgs(t, l)
          , m = e.EndBroadcast([u, p]);
        return e.BroadcastResult($n(e.getInstruction(p).valueType), [m])
    }
    function Yu(e, t, n) {
        return e.getInstruction(t).type == 48 ? e.DeferredListAccess([t, n]) : e.InboundsListAccess([t, n])
    }
    function IL(e) {
        let t = e.getReturnIndex()
          , n = oo(e, t)
          , r = e.getInstruction(t);
        if (r.type !== 48)
            return e;
        let o = r.args[0]
          , i = t - o
          , s = e.getInstruction(o)
          , a = s.args[0]
          , u = s.args[i]
          , c = []
          , l = [];
        c.push(a);
        let p = Qa(e, e.getReturnIndex(), "Programming error: cannot optimize regression on non-constant-length list");
        l.push({
            range: p - 1,
            length: p
        });
        let m = !1
          , d = !1;
        for (let E = a + 1; E <= u; E++) {
            if (!n[E])
                continue;
            let M = e.getInstruction(E);
            if (Po(M) || Bo(M))
                return e;
            if (M.type === 39 || M.type === 41 || M.type === 40) {
                if (M.args[1] !== a)
                    continue;
                let _ = M.args[0];
                if (e.getInstruction(_).valueType !== Y || !Ye(e.getInstruction(_)))
                    continue;
                let U = Xr(e, _)
                  , Q = rY(U);
                if (!isFinite(Q.range))
                    continue;
                c.push(E),
                l.push(Q)
            } else
                TL(M) ? m = !0 : (M.type === 12 || M.type === 13) && (d = !0)
        }
        if (c.length === 0 || !d && !m)
            return e;
        let y = []
          , g = [];
        for (let E = 0; E < e.argNames.length; E++)
            g.push(E),
            y.push(Fa());
        let f = []
          , h = [];
        for (let E = 0; E <= u; E++)
            f.push(v0(e, g, f, E)),
            h.push(v0(e, c, h, E));
        for (let E = 0; E <= u; E++) {
            if (!n[E])
                continue;
            let M = e.getInstruction(E);
            if (M.type === 33) {
                let _ = f[E];
                for (let U = 0; U < _.length; U++)
                    if (_[U])
                        return e
            } else if (M.type === 12 || M.type === 13) {
                let _ = !1
                  , U = !1;
                for (let ee = 0; ee < c.length; ee++)
                    h[M.args[0]][ee] && (_ = !0),
                    h[M.args[1]][ee] && (U = !0);
                if (_ || !U)
                    continue;
                let Q = f[M.args[0]], K = 0, w;
                for (let ee = 0; ee < Q.length; ee++)
                    Q[ee] && (w = ee,
                    K += 1);
                if (K !== 1 || w === void 0)
                    continue;
                let B = g[w]
                  , W = Eo(e.copy().reopenFinalBlock(), B, {
                    allowRestriction: !1,
                    allowClosedBlockReferences: !1
                });
                if (Pn(W, M.args[0]) !== 1)
                    continue;
                let oe = ua(W, M.args[0])
                  , [te,st] = gr(oe, M.args[0]);
                if (st === void 0)
                    continue;
                let Tt = Xr(oe.newChunk, st)
                  , ye = Xr(oe.newChunk, te);
                y[w] = mr(y[w], Nm(ye, Tt))
            }
        }
        if (m) {
            let E = e.copy().reopenFinalBlock();
            for (let M = 0; M < c.length; M++) {
                let _ = Eo(E, c[M], {
                    allowRestriction: !1,
                    allowClosedBlockReferences: !1
                })
                  , U = ua(_, u);
                for (let Q = a + 1; Q <= u; Q++) {
                    if (!n[Q])
                        continue;
                    let K = E.getInstruction(Q);
                    if (TL(K)) {
                        let w = K.args[0];
                        if (Pn(_, w) !== 1)
                            continue;
                        let B = gr(U, w)[1];
                        if (B === void 0)
                            continue;
                        let W = nY(U.newChunk, B), oe, te = 0;
                        for (let gt = 0; gt < W.length; gt++)
                            W[gt] && (oe = gt,
                            te += 1);
                        if (te !== 1 || oe === void 0)
                            continue;
                        let st = Eo(U.newChunk, oe, {
                            allowRestriction: !1,
                            allowClosedBlockReferences: !1
                        });
                        if (Pn(st, B) !== 1)
                            continue;
                        let Tt = ua(st, B)
                          , [ye,ee] = gr(Tt, B);
                        if (ee === void 0 || !Ye(Tt.newChunk.getInstruction(ye)) || !Ye(Tt.newChunk.getInstruction(ee)))
                            continue;
                        let k = Xr(Tt.newChunk, ye)
                          , ne = Xr(Tt.newChunk, ee)
                          , Ne = iY(l[M])
                          , _e = oY(l[M]);
                        if (!isFinite(Ne) || Ne <= 0 || !isFinite(_e) || _e < 0 || Ne <= _e)
                            continue;
                        y[oe] = mr(y[oe], mr(Nm(-_e + k, ne), Nm(Ne - k, -ne)))
                    }
                }
            }
        }
        let x = !1;
        for (let E of y) {
            if (Ei(E) || !os(E))
                return e;
            (E.bounds[0] !== -1 / 0 || E.bounds[1] !== 1 / 0) && (x = !0)
        }
        if (!x)
            return e;
        let T = e.copy()
          , P = T.Constant(1)
          , C = T.Constant(NaN)
          , S = t;
        for (let E = 0; E < T.argNames.length; E++)
            S = tY(T, y[E], S, E, P, C);
        return T.fuseBroadcast(),
        T
    }
    function tY(e, t, n, r, o, i) {
        if (Ei(t) || !os(t) || t.bounds[0] === -1 / 0 && t.bounds[1] === 1 / 0)
            return n;
        let s = e.And([e.LessEqual([e.Constant(t.bounds[0]), r]), e.LessEqual([r, e.Constant(t.bounds[1])])]);
        return e.Multiply([n, e.Piecewise([s, o, i])])
    }
    function nY(e, t) {
        let n = [];
        for (let o = 0; o < e.argNames.length; o++)
            n.push(o);
        let r = [];
        for (let o = 0; o <= t; o++)
            r.push(v0(e, n, r, o));
        return r[t]
    }
    function TL(e) {
        return e.type === 37 && (e.symbol === "sin" || e.symbol === "cos")
    }
    function rY(e) {
        let t = 1 / 0
          , n = -1 / 0
          , r = e.length;
        for (let o of e)
            t = Math.min(t, o),
            n = Math.max(n, o);
        return {
            range: n - t,
            length: r
        }
    }
    function oY({range: e}) {
        return 1e-5 / e
    }
    function iY({range: e, length: t}) {
        let n = e / Math.min(t - 1, 31);
        return Math.PI / n
    }
    function v0(e, t, n, r) {
        let o = e.getInstruction(r)
          , i = sY(t.length);
        for (let s = 0; s < t.length; s++)
            if (t[s] === r)
                return i[s] = !0,
                i;
        if (!de(o))
            return i;
        for (let s of o.args) {
            let a = n[s];
            for (let u = 0; u < a.length; u++)
                i[u] = i[u] || a[u]
        }
        return i
    }
    function sY(e) {
        let t = [];
        for (let n = 0; n < e; n++)
            t.push(!1);
        return t
    }
    var ML = D0({
        sin: Xn("isinf(x) || isnan(x) ? NaN : dcg_isPiMultiple(abs(x)) ? 0.0 : sin(x)"),
        cos: Xn("isinf(x) || isnan(x) ? NaN : dcg_isOddHalfPiMultiple(abs(x)) ? 0.0 : cos(x)"),
        tan: Wi(fe`float a=abs(x);
    return isinf(x) || isnan(x) ? NaN
      : dcg_isPiMultiple(a) ? 0.0
      : dcg_isOddHalfPiMultiple(a) ? Infinity
      : tan(x);`),
        cot: Wi(fe`float a=abs(x);
      return isinf(x) || isnan(x) ? NaN
        : a < 0.03 ? 1.0/x - x/3.0
        : dcg_isPiMultiple(a) ? Infinity
        : dcg_isOddHalfPiMultiple(a) ? 0.0
        : 1.0 / tan(x);`),
        sec: Xn("isinf(x) || isnan(x) ? NaN : dcg_isOddHalfPiMultiple(abs(x)) ? Infinity: 1.0 / cos(x)"),
        csc: Wi(fe`float a=abs(x);
      return isinf(x) || isnan(x) ? NaN
        : a < 0.03 ? 1.0/x + x/6.0
        : dcg_isPiMultiple(a) ? Infinity
        : 1.0 / sin(x);`),
        arcsin: Wi(fe`if (isinf(x) || isnan(x)) { return NaN; }
    if (x == 1.0) { return dcg_PI/2.0; }
    if (x == -1.0) { return -dcg_PI/2.0; }
    if (x > 1.0 || x < -1.0) return NaN;
    float y0 = asin(x);
    return y0 + (x - sin(y0)) / cos(y0);`),
        arccos: Wi(fe`if (isinf(x) || isnan(x)) { return NaN; }
    if (x == 1.0) { return 0.0; }
    if (x == -1.0) { return dcg_PI; }
    if (x > 1.0 || x < -1.0) return NaN;
    float y0 = acos(x);
    return y0 + (cos(y0) - x) / sin(y0);`),
        arctan: qy(fe`isnan(x) || isnan(y) ? NaN
      : isinf(x) && isinf(y) ?
        (y > 0.0 ? 0.25 : 0.75) * sign(x) * dcg_PI
      : x == 0.0 && y == 0.0 ? y
      : atan(x, y)
    `),
        arccot: Xn("isnan(x) ? NaN : dcg_PI/2.0 - atan(x)"),
        arcsec: Xn("isnan(x) ? NaN : dcg_arccos(1.0/x)"),
        arccsc: Xn("isnan(x) ? NaN : dcg_arcsin(1.0/x)"),
        sinh: Xn("isinf(x) ? x : isnan(x) ? NaN : sinh(x)"),
        cosh: Xn("isinf(x) ? Infinity : isnan(x) ? NaN : cosh(x)"),
        tanh: Xn("abs(x) > 10.0 ? sign(x) : isnan(x) ? NaN : tanh(x)"),
        coth: Xn("abs(x) > 10.0 ? sign(x) : isnan(x) ? NaN : x == 0.0 ? Infinity : abs(x) < 0.03 ? 1.0/x + x/3.0 : 1.0/tanh(x)"),
        sech: Xn("isinf(x) ? 0.0 : isnan(x) ? NaN : 1.0/cosh(x)"),
        csch: Xn("isinf(x) ? 0.0 : isnan(x) ? NaN : x == 0.0 ? Infinity : abs(x) < 0.03 ? 1.0/x - x/6.0 : 1.0/sinh(x)"),
        arcsinh: Wi(fe`float a=abs(x);
      return isnan(x) ? NaN : sign(x) * (
        1.0 + x * x == 1.0
          ? dcg_log1p(a)
          : log(a + dcg_rtxsqpone(a))
      );`),
        arccosh: Xn("x < 1.0 || isnan(x) ? NaN : log(x + dcg_rtxsqmone(x))"),
        arctanh: Wi(fe`if (isnan(x) || abs(x) > 1.0) { return NaN; }
      if (x == 1.0) { return Infinity; }
      if (x == -1.0) { return -Infinity; }
      float y0 = 0.5*(dcg_log1p(x) - dcg_log1p(-x));
      float c = cosh(y0);
      return y0 + (x - tanh(y0)) * c * c;`),
        arccoth: Xn("isnan(x) ? NaN : abs(x) >= 1.0 ? dcg_arctanh(1.0/x) : NaN"),
        arcsech: Xn("isnan(x) ? NaN : 0.0 < x && x <= 1.0 ? dcg_arccosh(1.0/x) : x == 0.0 ? Infinity : NaN"),
        arccsch: Xn("isinf(x) ? 0.0 : isnan(x) ? NaN : dcg_arcsinh(1.0/x)"),
        sinpiSeries: Wi(fe`float xsq = x*x;
    return x*(dcg_PI-xsq*(5.167708-xsq*(2.549761-xsq*0.5890122)));`),
        sinpi: Wi(fe`if (isnan(x) || isinf(x)) { return NaN; }
    if (x==0.0) { return x; }
    if (x == floor(x)) { return x > 0.0 ? 0.0 : -0.0; }
    int i = int(dcg_round(2.0*x));
    float t = -0.5 * float(i) + x;
    float s = bool(i & 2) ? -1.0 : 1.0;
    float y = bool(i & 1) ? cos(dcg_PI * t) : dcg_sinpiSeries(t);
    return s*y;`),
        sincpi: Xn("isnan(x) ? NaN : isinf(x) ? 0.0 : x == 0.0 ? 1.0 : dcg_sinpi(x)/(dcg_PI*x);"),
        sqrt: Xn("isnan(x) ? NaN : x >= 0.0 ? sqrt(x) : NaN"),
        rtxsqpone: Xn("dcg_hypot(x, 1.0)"),
        rtxsqmone: Wi("float t = x*x; return isnan(x) || t < 1.0 ? NaN : t - 1.0 == t ? abs(x) : sqrt(t - 1.0);"),
        hypot: DL(fe`if (isnan(x) || isnan(y)) return NaN;
      if (isinf(x) || isinf(y)) return Infinity;
      x = abs(x);
      y = abs(y);
      float m = max(x,y);
      x /= m;
      y /= m;
      return m == 0.0 ? 0.0 : sqrt(x*x + y*y) * m;`),
        min: qy(fe`isnan(x) || isnan(y) ? NaN : min(x, y)`),
        max: qy(fe`isnan(x) || isnan(y) ? NaN : max(x, y)`),
        log: Xn("isnan(x) ? NaN : x > 0.0 ? log(x)*0.4342944819 : x == 0.0 ? -Infinity : NaN"),
        logbase: qy(fe`isnan(x) || isnan(y) ? NaN
      : y == 1.0 ?
        (
          x > 1.0 ? Infinity
          : x == 1.0 ? NaN
          : x < 0.0 ? NaN
          : -Infinity
        )
      : y > 0.0 ?
        (
          x > 0.0 ? log(x)/log(y)
          : x == 0.0 && !isinf(y) ? -Infinity
          : NaN
        )
      : NaN`),
        ln: Xn("isnan(x) ? NaN : x > 0.0 ? log(x) : x == 0.0 ? -Infinity : NaN"),
        exp: Xn("isnan(x) ? NaN : exp(x)"),
        floor: Xn("isnan(x) ? NaN : floor(x)"),
        ceil: Xn("isnan(x) ? NaN : ceil(x)"),
        round: Xn("isinf(x) || isnan(x) ? x : floor(0.5 + x)"),
        abs: Xn("isnan(x) ? NaN : abs(x)"),
        sign: Xn("isnan(x) ? NaN : sign(x)"),
        mod: qy("isinf(x) || isinf(y) || isnan(x) || isnan(y) || y == 0.0 ? NaN : mod(x, y)"),
        stirlingPrefactor: jr("float", "float x, float y", fe`if (isnan(x) || isnan(y)) { return NaN; }
    return pow(x/exp(1.0), y);`),
        stirlerrSeries: Wi(fe`float S0 = 0.083333336;
    float S1 = 0.0027777778;
    float S2 = 0.0007936508;
    float nn = x*x;
    return (S0-(S1-S2/nn)/nn)/x;`),
        factorialAsymptotic: Xn("dcg_stirlingPrefactor(x,x)*sqrt(2.0*dcg_PI*x)*exp(dcg_stirlerrSeries(x))"),
        factorialMinimax: Wi(fe`float n1 = 2.1618295;
    float n2 = 1.5849807;
    float n3 = 0.4026814;
    float d1 = 2.2390451;
    float d2 = 1.6824219;
    float d3 = 0.43668285;

    float n = 1.0 + x*(n1 + x*(n2 + x*n3));
    float d = 1.0 + x*(d1 + x*(d2 + x*d3));
    float xp1 = x+1.0;

    return dcg_stirlingPrefactor(xp1,x)*sqrt(xp1)*(n/d);
    `),
        factorialPositive: Xn(fe`(x>33.0)?Infinity:(x>8.0)?dcg_factorialAsymptotic(x):dcg_factorialMinimax(x);`),
        factorial: Wi(fe`if (isnan(x) || (isinf(x) && x < 0.0)) { return NaN; }
    bool isInteger = x == floor(x);
    if (x < 0.0) {
      if (isInteger) return Infinity;
      return 1.0 / (dcg_sincpi(x) * dcg_factorialPositive(-x));
    }
    float approx = dcg_factorialPositive(x);
    return isInteger ? dcg_round(approx) : approx;`),
        distance: jr("float", "vec2 a, vec2 b", fe`
      if (any(isnan(a)) || any(isnan(b))) return NaN;
      vec2 d = a-b;
      return dcg_hypot(d.x, d.y);`),
        distanceThreeD: jr("float", "vec3 a, vec3 b", fe`
      if (any(isnan(a)) || any(isnan(b))) return NaN;
      vec3 d = a-b;
      return dcg_hypot(dcg_hypot(d.x, d.y), d.z);`),
        hsv: jr("vec3", "float h, float s, float v", fe`if (isnan(h) || isnan(s) || isnan(v)) {discard;}
      vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
      if (isinf(h)) h = 0.0;
      vec3 p = abs(fract(h / 360.0 + K.xyz) * 6.0 - K.www);
      return vec3(clamp(v, 0.0, 1.0) * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), clamp(s, 0.0, 1.0)));`),
        rgb: jr("vec3", "float r, float g, float b", fe`if (isnan(r) || isnan(g) || isnan(b)) {discard;}
    return clamp(vec3(r,g,b),0.0,255.0)/255.0;`),
        erf: Wi(fe`if (isnan(x)) return NaN;
      float t = abs(x);
      float n = x*x;
      float r = -n;
      return sign(x) * (
        r < -750.0
          ? 1.0
          : t >= 0.065
          ? 1.0 - exp(r) * (
            t > 50000000.0
              ? r / t
              : t > 50.0
              ? (r * (n * (n + 4.5) + 2.0)) / (t * (n * (n + 5.0) + 3.75))
              : ((0.9999999999999999+t*(2.224574423459406+t*(2.444115549920689+
                t*(1.7057986861852539+t*(0.8257463703357973+
                  t*(0.28647031042892007+t*(0.07124513844341643+
                    t*(0.012296749268608364+t*(0.001347817214557592+
                      0.00007263959403471071*t))))))))
                )/(1.0+t*(3.352953590554884+t*(5.227518529742423+
                  t*(5.003720878235473+t*(3.266590890998987+
                    t*(1.5255421920765353+t*(0.5185887413188858+
                      t*(0.12747319185915415+t*(0.02185979575963238+
                        t*(0.0023889438122503674+0.00012875032817508128*t
                ))))))))))
              )
          )
          : t*(1.1283791670955126+r*(0.37612638903183754+
              r*(0.11283791670955126+r*(0.026866170645131252+
                0.005223977625442188*r))))
      );`),
        restriction: jr("bool", "bool x", "return x;"),
        restrictionToBoolean: jr("bool", "bool x", "return x;"),
        complex: jr("vec2", "float u, float v", fe`if (isnan(u) || isnan(v)) { return vec2(NaN, NaN); }
    return vec2(u,v);`),
        real: jr("float", "vec2 c", "return c.x;"),
        imag: jr("float", "vec2 c", "return c.y;"),
        arg: jr("float", "vec2 c", "return dcg_arctan(c.y,c.x);"),
        peelableCoerceComplexToReal: jr("float", "vec2 a", "return a.y == 0.0 ? a.x : NaN;"),
        coerceComplexToReal: jr("float", "vec2 a", "return a.y == 0.0 ? a.x : NaN;"),
        coerceRealToComplex: jr("vec2", "float x", "return isnan(x) ? vec2(NaN, NaN) : vec2(x, 0);"),
        complexSqrt: Di(fe`float u = z.x; float v = z.y;
    float r = sqrt(0.5 * (abs(u) + dcg_hypot(u, v)));
    if (r == 0.0 || isnan(v) || isinf(v)) return dcg_complex(r, v);
    if (u > 0.0) return dcg_complex(r, 0.5 * (v / r));
    if (v < 0.0) r = -r;
    return dcg_complex(0.5 * (v / r), r);`),
        complexDivide: jr("vec2", "vec2 a, vec2 b", fe`float u1 = a.x; float v1 = a.y;
      float u2 = b.x; float v2 = b.y;
      if (isnan(u1) || isnan(v1) || isnan(u2) || isnan(v2)) return vec2(NaN, NaN);
      if (isinf(u1) || isinf(v1)) return vec2(NaN, NaN);
      if (u2 == 0.0 && v2 == 0.0) return vec2(NaN, NaN);
      if (isinf(u2) || isinf(v2)) return vec2(0.0, 0.0);
      if (abs(v2) <= abs(u2)) {
        return dcg_subComplexDivide(a, b);
      } else {
        return dcg_conj(dcg_subComplexDivide(a.yx, b.yx));
      }`),
        wirtingerEqualOrWarning: jr("vec2", "vec2 a, vec2 b", "return b;"),
        complexLn: Di(fe`float u = z.x; float v = z.y;
      return dcg_complex(dcg_ln(dcg_hypot(u,v)), dcg_arctan(v,u));`),
        complexExp: Di(fe`float u = z.x; float v = z.y;
      if (isnan(u)) return vec2(NaN, NaN);
      float r = exp(u);
      return v == 0.0 ? vec2(r, 0.0) : dcg_complexFromPolarRounded(r, v);`),
        complexPow: jr("vec2", "vec2 z1, vec2 z2", fe`float u2 = z2.x; float v2 = z2.y;
      float u1 = z1.x; float v1 = z1.y;
      if (isnan(u1) || isnan(v1) || isnan(u2) || isnan(v2))
        return vec2(NaN, NaN);
      float r1 = dcg_hypot(u1, v1);
      float theta1 = dcg_arctan(v1, u1);
      float rOut = pow(r1, u2) * exp(-theta1 * v2);
      float thetaOut = log(r1) * v2 + theta1 * u2;
      if (!isinf(rOut)) {
        return dcg_complexFromPolarRounded(rOut, thetaOut);
      } else {
        return dcg_complexFromPolarRounded(
          exp(u2 * log(r1) - theta1 * v2),
          thetaOut
        );
      }
      `),
        complexSin: Di(fe`float u = z.x; float v = z.y;
      return dcg_complex(dcg_sin(u) * dcg_cosh(v), dcg_cos(u) * dcg_sinh(v));`),
        complexCos: Di(fe`float u = z.x; float v = z.y;
      return dcg_complex(dcg_cos(u) * dcg_cosh(v), -dcg_sin(u) * dcg_sinh(v));`),
        complexSinh: Di(fe`float u = z.x; float v = z.y;
      return dcg_complex(dcg_sinh(u) * dcg_cos(v), dcg_cosh(u) * dcg_sin(v));`),
        complexCosh: Di(fe`float u = z.x; float v = z.y;
      return dcg_complex(dcg_cosh(u) * dcg_cos(v), dcg_sinh(u) * dcg_sin(v));`),
        complexTanh: Di(fe`float u = z.x; float v = z.y;
      float tanv = dcg_tan(v); float tanhu = dcg_tanh(u);
      if (isnan(tanv) || isnan(tanhu)) return vec2(NaN, NaN);
      if (isinf(tanv)) return vec2(1.0 / tanhu, 0.0);

      float tanv2 = tanv * tanv;
      float secv2 = 1.0 + tanv2;
      float sinhu = dcg_sinh(u);
      float sinhu2 = sinhu * sinhu;
      float tanhu2 = tanhu * tanhu;
      return dcg_complex(
        (secv2 * tanhu) / (1.0 + tanv2 * tanhu2),
        tanv / (1.0 + secv2 * sinhu2)
      );`),
        complexTan: Di(fe`float u = z.x; float v = z.y;
      vec2 t = dcg_complexTanh(vec2(-v, u));
      return vec2(t.y, -t.x);`),
        complexSec: Di("return dcg_complexReciprocal(dcg_complexCos(z));"),
        complexCsc: Di("return dcg_complexReciprocal(dcg_complexSin(z));"),
        complexCot: Di("return dcg_complexReciprocal(dcg_complexTan(z));"),
        complexSech: Di("return dcg_complexReciprocal(dcg_complexCosh(z));"),
        complexCsch: Di("return dcg_complexReciprocal(dcg_complexSinh(z));"),
        complexCoth: Di("return dcg_complexReciprocal(dcg_complexTanh(z));"),
        complexLogbase: jr("vec2", "vec2 z, vec2 base", fe`
      float u = z.x; float v = z.y;
      float bu = base.x; float bv = base.y;
      if (any(isnan(z)) || any(isnan(base))) return vec2(NaN, NaN);
      if (bv == 0.0 && bu == 0.0) return vec2(NaN, NaN);
      if (u == 0.0 && v == 0.0) return vec2(-Infinity, 0);${""}
      return dcg_complexDivide(dcg_complexLn(z), dcg_complexLn(base));`),
        complexLog: Di("return dcg_complexLogbase(z, vec2(10.0,0.0));")
    });
    function jr(e, t, n) {
        return {
            type: "scalar",
            value: `${e} dcg_[[name_here]](${t}){ ${n} }`
        }
    }
    function Wi(e) {
        return jr("float", "float x", e)
    }
    function Xn(e) {
        return Wi(`return ${e};`)
    }
    function DL(e) {
        return jr("float", "float x, float y", e)
    }
    function qy(e) {
        return DL(`return ${e};`)
    }
    function Di(e) {
        return jr("vec2", "vec2 z", e)
    }
    function _i(e, {inType: t, outType: n, deps: r}={}) {
        let o = t != null ? t : s => `float[${s}]`
          , i = n != null ? n : () => "float";
        return {
            type: "reducer",
            value: s => `${i(s)} dcg_[[name_here]](${o(s)} L) { ${e(s)} }`,
            deps: r != null ? r : []
        }
    }
    function M0(e) {
        return {
            type: "double-reducer",
            value: (t, n) => {
                let r = Math.min(t, n)
                  , o = e(r);
                return `float dcg_[[name_here]](float[${t}] X, float[${n}] Y) { ${o} }`
            }
        }
    }
    var aY = D0({
        lcm: _i(e => fe`float g = abs(dcg_round(L[0]));
      if (isnan(g) || isinf(g)) return NaN;
      for (int i=1; i<${e}; i++) {
        float v = abs(dcg_round(L[i]));
        if (isnan(v) || isinf(v)) return NaN;
        if (g != 0.0)
          g *= dcg_round(v / dcg_gcd2(g, v));
      }
      return g;`),
        gcd: _i(e => fe`float g = abs(dcg_round(L[0]));
      if (isnan(g) || isinf(g)) return NaN;
      for (int i=1; i<${e}; i++) {
        float x = L[i];
        if (isnan(x) || isinf(x)) return NaN;
        g = dcg_gcd2(g, abs(dcg_round(x)));
      }
      return g;`),
        mean: _i(e => fe`float tot = 0.0;
      for (int i=0; i<${e}; i++) {
        float x = L[i];
        if (isnan(x) || (isinf(x) && x == -tot)) return NaN;
        tot += x;
      }
      return tot / ${e}.0;`),
        total: _i(e => fe`float tot = 0.0;
      for (int i=0; i<${e}; i++) {
        float x = L[i];
        if (isnan(x) || (isinf(x) && x == -tot)) return NaN;
        tot += x;
      }
      return tot;`),
        stdev: _i(e => SL(e, e - 1), {
            deps: ["mean"]
        }),
        stdevp: _i(e => SL(e, e), {
            deps: ["mean"]
        }),
        mad: _i(e => fe`float mean = dcg_mean(L);
      if (isnan(mean) || isinf(mean)) return NaN;
      float tot = 0.0;
      for (int i=0; i<${e}; i++) {
        tot += abs(L[i] - mean);
      }
      return tot / ${e}.0;`, {
            deps: ["mean"]
        }),
        listMin: _i(e => EL(e, "min")),
        listMax: _i(e => EL(e, "max")),
        argmin: _i(e => CL(e, "<")),
        argmax: _i(e => CL(e, ">=")),
        median: _i(e => e % 2 === 1 ? `return L[int(dcg_sortPerm(L)[${(e - 1) / 2}])];` : fe`float[${e}] perm = dcg_sortPerm(L);
          return 0.5*(L[int(perm[${e / 2}])]+L[int(perm[${e / 2 - 1}])]);`, {
            deps: ["sortPerm"]
        }),
        varp: _i(e => PL(e, e), {
            deps: ["mean"]
        }),
        var: _i(e => PL(e, e - 1), {
            deps: ["mean"]
        }),
        sortPerm: _i(e => {
            if (e > 100)
                throw hp();
            return fe`float[${e}] permFloat;
        float lastMin = -Infinity;
        int lastIndex = -1;
        for (int i=0; i<${e}; i++) {
          float currMin = NaN;
          int currIndex = ${e};
          int j;
          for (j=0; j<${e}; j++) {
            float e = L[j];
            float cmpLast = dcg_compareAscendingNaNLast(e, lastMin);
            float cmpCurr = dcg_compareAscendingNaNLast(currMin, e);
            if (
              (cmpLast > 0.0 || (cmpLast == 0.0 && j > lastIndex))
              && (cmpCurr > 0.0 || (cmpCurr == 0.0 && j < currIndex))
            ) {
              currMin = e;
              currIndex = j;
            }
          }
          permFloat[i] = float(currIndex);
          lastMin = currMin;
          lastIndex = currIndex;
        }
        return permFloat;`
        }
        , {
            outType: e => `float[${e}]`
        }),
        complexSortPerm: _i(e => {
            if (e > 100)
                throw hp();
            return fe`float[${e}] permFloat;
      vec2 lastMin = vec2(-Infinity,-Infinity);
      int lastIndex = -1;
      for (int i=0; i<${e}; i++) {
        vec2 currMin = vec2(NaN,NaN);
        int currIndex = ${e};
        int j;
        for (j=0; j<${e}; j++) {
          vec2 e = L[j];
          float cmpLast = dcg_compareComplexLexicographic(e, lastMin);
          float cmpCurr = dcg_compareComplexLexicographic(currMin, e);
          if (
            (cmpLast > 0.0 || (cmpLast == 0.0 && j > lastIndex))
            && (cmpCurr > 0.0 || (cmpCurr == 0.0 && j < currIndex))
          ) {
            currMin = e;
            currIndex = j;
          }
        }
        permFloat[i] = float(currIndex);
        lastMin = currMin;
        lastIndex = currIndex;
      }
      return permFloat;`
        }
        , {
            inType: e => `vec2[${e}]`,
            outType: e => `float[${e}]`
        })
    });
    function PL(e, t) {
        return t === 0 ? "return NaN;" : fe`float mean = dcg_mean(L);
    if (isnan(mean) || isinf(mean)) return NaN;
    float tot = 0.0;
    for (int i=0; i<${e}; i++) {
      float delta = L[i] - mean;
      tot += delta * delta;
    }
    return tot / ${t}.0;`
    }
    function SL(e, t) {
        return t === 0 ? "return NaN;" : fe`float mean = dcg_mean(L);
    if (isnan(mean) || isinf(mean)) return NaN;
    float tot = 0.0;
    for (int i=0; i<${e}; i++) {
      tot = dcg_hypot(tot, L[i] - mean);
    }
    return tot / ${_0(Math.sqrt(t))};`
    }
    function EL(e, t) {
        return fe`float m = L[0];
    if (isnan(m)) return NaN;
    for (int i=1; i<${e}; i++) {
      float x = L[i];
      if (isnan(x)) return NaN;
      m = ${t}(m, x);
    }
    return m;`
    }
    function CL(e, t) {
        return fe`if (isnan(L[0])) return 0.0;
    int arg = 0;
    float best = L[0];
    for (int i=1; i<${e}; i++) {
      float e = L[i];
      if (isnan(e)) return 0.0;
      if (e ${t} best) {
        arg = i;
        best = e;
      }
    }
    return float(arg + 1);`
    }
    var uY = D0({
        cov: M0(e => vL(e, e - 1)),
        covp: M0(e => vL(e, e)),
        corr: M0(e => fe`${_L(e)}
      float t1 = 0.0;
      float t2 = 0.0;
      float tc = 0.0;
      for (int i=0; i<${e}; i++) {
        float d1 = X[i] - m1;
        float d2 = Y[i] - m2;
        t1 = dcg_hypot(t1, d1);
        t2 = dcg_hypot(t2, d2);
        tc += d1 * d2;
      }
      return tc / (t1 * t2);`)
    })
      , cY = {
        type: "elementsAt",
        value: (e, t) => `${e}[${t}] dcg_elementsAt(${e}[${t}] X, float[${t}] Y) {
      ${e}[${t}] outList;
      for (int i=0; i<${t}; i++) {
        outList[i] = X[int(Y[i])];
      }
      return outList;
    }`
    }
      , lY = {
        ...ML,
        ...aY,
        ...uY,
        elementsAt: cY
    }
      , $x = lY;
    function pY(e, t) {
        switch (e.type) {
        case "scalar":
            return e.value.replace("[[name_here]]", t);
        case "reducer":
            {
                let n = e.value;
                return r => n(r).replace("[[name_here]]", t)
            }
        case "double-reducer":
            {
                let n = e.value;
                return (r, o) => n(r, o).replace("[[name_here]]", t)
            }
        default:
            return e.value
        }
    }
    function D0(e) {
        for (let[t,n] of Object.entries(e))
            n.type !== "omitted" && (n.value = pY(n, t));
        return e
    }
    function vL(e, t) {
        return fe`${_L(e)}
    float tot = 0.0;
    for (int i=0; i<${e}; i++) {
      tot += (X[i] - m1) * (Y[i] - m2);
    }
    return tot / ${t}.0;`
    }
    function _L(e) {
        return fe`float m1 = 0.0;
    for (int i=0; i<${e}; i++) {
      float x = X[i];
      if (isnan(x) || isinf(x)) return NaN;
      m1 += x;
    }
    m1 /= ${e}.0;
    float m2 = 0.0;
    for (int i=0; i<${e}; i++) {
      float y = Y[i];
      if (isnan(y) || isinf(y)) return NaN;
      m2 += y;
    }
    m2 /= ${e}.0;`
    }
    var mY = [fe`float dcg_rawpow(float x, float y) {
    if (isnan(x) || isnan(y)) return NaN;
    if (y==0.0) return 1.0;
    if (isinf(y)) {${""}
      float a = abs(x);
      if (a == 1.0) return NaN;
      if (y > 0.0) {
        return a > 1.0 ? Infinity : 0.0;
      } else {
        return a < 1.0 ? Infinity : 0.0;
      }
    }
    if (x > 0.0) return pow(x, y);
    else if (x == 0.0) {
      if (y > 0.0) return 0.0;
      else if (y == 0.0) return 1.0;
      else return Infinity;
    } else {
      float m = mod(y, 2.0);
      if (m == 1.0) return -pow(-x, y);
      else return pow(-x, y);
    }
  }`, fe`float dcg_pow(float x, float y) {
    if (isnan(x) || isnan(y)) return NaN;
    if (y==0.0) return 1.0;
    if (isinf(y)) {
      float a = abs(x);
      if (a == 1.0) return NaN;
      if (y > 0.0) {
        return a > 1.0 ? Infinity : 0.0;
      } else {
        return a < 1.0 ? Infinity : 0.0;
      }
    }
    if (x > 0.0) return pow(x,y);
    else if (x == 0.0) {
      if (y > 0.0) return 0.0;
      if (y == 0.0) return 1.0;
      if (y < 0.0) return Infinity;
    } else {
      float m = mod(y, 2.0);
      if (m == 0.0) return pow(-x, y);
      else if (m == 1.0) return -pow(-x, y);
      else {${""}
        vec2 a0 = vec2(0.0, 1.0);
        vec2 a1 = vec2(1.0, 0.0);
        float approx = y;
        for (int i=0; i<12; i+=1) {
          float whole = floor(approx);
          vec2 a = whole * a1 + a0;
          if (a.y > 100.0) break;
          a0 = a1; a1 = a;
          if (approx == whole) break;
          approx = 1.0 / (approx - whole);
        }${""}
        float r = a1.x / a1.y;
        float m = max(max(abs(y), abs(r)), 1.0);
        if (abs(mod(a1.y, 2.0) - 1.0) < 0.01 && abs((r - y)/y) < 0.00001) {
          return (mod(a1.x, 2.0) == 0.0 ? 1.0 : -1.0) * pow(-x, y);
        } else {
          return NaN;
        }
      }
    }
  }`, fe`float dcg_add(float x, float y) {
    return isnan(x) || isnan(y) ? NaN
      : isinf(x) && isinf(y) && x != y ? NaN
      : x + y;
  }`, fe`float dcg_sub(float x, float y) {
    return isnan(x) || isnan(y) ? NaN
      : isinf(x) && isinf(y) && x != -y ? NaN
      : x - y;
  }`, fe`float dcg_mul(float x, float y) {
    return isnan(x) || isnan(y) ? NaN
      : isinf(x) && y == 0.0 ? NaN
      : x == 0.0 && isinf(y) ? NaN
      : x * y;
  }`, fe`float dcg_div(float x, float y) {
    return isnan(x) || isnan(y) ? NaN
      : isinf(x) && isinf(y) ? NaN
      : x == 0.0 && y == 0.0 ? NaN
      : x / y;
  }`, fe`float dcg_neg(float x) {
    return isnan(x) ? NaN : -x;
  }`, fe`float dcg_square(float x) {
    return x*x;
  }`, fe`bool dcg_equal(float x, float y) {
    return isnan(x) || isnan(y) ? false : x == y;
  }`, fe`bool dcg_less(float x, float y) {
    return isnan(x) || isnan(y) ? false : x < y;
  }`, fe`bool dcg_lessEqual(float x, float y) {
    return isnan(x) || isnan(y) ? false : x <= y;
  }`, fe`bool dcg_greater(float x, float y) {
    return isnan(x) || isnan(y) ? false : x > y;
  }`, fe`bool dcg_greaterEqual(float x, float y) {
    return isnan(x) || isnan(y) ? false : x >= y;
  }`, fe`float dcg_gcd2(float u, float v) {
    for (int i=0; i<95; i++) {
      if (v == 0.0) break;
      u = mod(u, v);
      if (u == 0.0) break;
      v = mod(v, u);
    }
    return u+v;
  }`, fe`float dcg_log1p(float x) {
    return x - 0.5 * x * x == x ? x : log(1.0 + x);
  }`, fe`bool dcg_isPiMultiple(float absx) {
    if (absx > 1.0e5) return false;
    return floor(0.5 + dcg_PI_INV * absx) * dcg_PI == absx;
  }`, fe`bool dcg_isOddHalfPiMultiple(float absx) {
    if (absx > 1.0e5) return false;
    float n = floor(0.5 + 2.0 * dcg_PI_INV * absx);
    return mod(n, 2.0) == 1.0 && n * dcg_PI == 2.0 * absx;
  }`, "vec2 dcg_conj(vec2 a) { return vec2(a.x, -a.y); }", fe`vec2 dcg_subComplexDivide(vec2 a, vec2 b) {
    float u1 = a.x; float v1 = a.y;
    float u2 = b.x; float v2 = b.y;
    float r = v2 / u2;
    float t = 1.0 / (u2 + v2 * r);
    if (r == 0.0) {
      return dcg_complex((u1 + v2 * (v1 / u2)) * t, (v1 - v2 * (u1 / u2)) * t);
    } else {
      return dcg_complex((u1 + v1 * r) * t, (v1 - u1 * r) * t);
    }
  }`, fe`vec2 dcg_complexFromPolarRounded(float r, float theta) {
    if (isnan(r) || isnan(theta)) return vec2(NaN, NaN);
    if (r == 0.0) return vec2(0.0, 0.0);
    return dcg_complex(r * dcg_cos(theta), r * dcg_sin(theta));
  }`, fe`vec2 dcg_complexReciprocal(vec2 z) {
    return dcg_complexDivide(vec2(1.0,0.0), z);
  }`, fe`float dcg_compareAscendingNaNLast(float x, float y) {
    float diff = dcg_sub(x,y);
    return !isnan(diff) ? diff : float(isnan(x)) - float(isnan(y));
  }`, fe`float dcg_compareComplexLexicographic(vec2 x, vec2 y) {
    float realComparison = dcg_compareAscendingNaNLast(x.x, y.x);
    return realComparison != 0.0 ? realComparison : dcg_compareAscendingNaNLast(x.y, y.y);
  }`].join(`
`)
      , dY = `
  float dcg_round(float x);
  float dcg_hypot(float x, float y);
  float dcg_rtxsqpone(float x);
  float dcg_rtxsqmone(float x);
  float dcg_cos(float x);
  float dcg_sin(float x);
  float dcg_tan(float x);
  float dcg_tanh(float x);
  vec2 dcg_complex(float u, float v);
  vec2 dcg_complexDivide(vec2 a, vec2 b);
`
      , fY = Object.values(ML).map(e => e.value).join(`
`)
      , ece = fe`uniform float NaN;
    uniform float Infinity;
    #define dcg_PI 3.141592653589793
    #define dcg_PI_INV 0.3183098861837907
    ${dY}\n
    ${mY}\n
    ${fY}`;
    function fe(e, ...t) {
        let n = e[0];
        for (let r = 0; r < t.length; r++)
            n += t[r],
            n += e[r + 1];
        return yY(n)
    }
    function yY(e) {
        let t = e.split(`
`);
        if (/^\s/.test(t[0][0]))
            throw new Error("Programming error: Expected un-indented first line");
        if (t.length <= 1)
            return e;
        let n = Math.min(...t.slice(1).map(r => r.match(/^\s*/)[0].length));
        return t[0] + `
` + t.slice(1).map(r => r.slice(n)).join(`
`)
    }
    function as(e, t) {
        let n = new R0(e,t)
          , r = yx(n);
        return n.finish(r)
    }
    var R0 = class extends dd {
        constructor(n, r) {
            super(n, !0);
            this.maxUniforms = r;
            this.glsl = !0;
            this.shaderUniforms = [];
            this.definitions = {}
        }
        finish(n) {
            return {
                source: n,
                shaderFunctions: gY(this.chunk, this.definitions),
                shaderUniforms: this.shaderUniforms
            }
        }
        printValue(n) {
            let {value: r, valueType: o} = n;
            if (Array.isArray(r)) {
                if (r.length > 100)
                    throw hp();
                let i = X(o)
                  , s = rr(o)
                  , a = r.map(l => this.printValue({
                    value: l,
                    valueType: s
                })).join(",")
                  , u = zy(o)
                  , c = RL({
                    type: u,
                    arity: r.length
                });
                return this.definitions[c] = !0,
                (i ? "buildList" : u) + "(" + a + ")"
            }
            switch (typeof r) {
            case "boolean":
                return r.toString();
            case "number":
                return this.printFloatOrUniformGLSL(r);
            case "string":
                throw wm("random");
            case "object":
                if (o === pt)
                    throw new Error("Action values cannot be compiled");
                return this.printFloatOrUniformGLSL(L(r));
            default:
                throw new Error(`Unexpected value: ${r}`)
            }
        }
        printFloatOrUniformGLSL(n) {
            if (this.shaderUniforms.length >= this.maxUniforms)
                return _0(n);
            {
                let o = "_DCG_SC_" + this.shaderUniforms.length;
                return this.shaderUniforms.push(n),
                o
            }
        }
        beforeBeginLoop(n) {
            let r = this.chunk.getInstruction(n.args[0])
              , o = this.chunk.getInstruction(n.args[1])
              , i = n.callData.type === "sum";
            if (r.type !== 1) {
                let u = Go(this.chunk, n.args[0]);
                throw i ? ub(u) : cb(u)
            }
            if (o.type !== 1) {
                let u = Go(this.chunk, n.args[1]);
                throw i ? ub(u) : cb(u)
            }
            if (r.valueType !== b || o.valueType !== b)
                throw new Error("Programming error: non-number in summation bounds");
            let s = L(r.value)
              , a = L(o.value);
            if (!isFinite(a - s) || a - s >= 1e3)
                throw i ? UE() : kE()
        }
        checkFiniteBounds() {
            return ""
        }
        emitConstant(n) {
            return this.printValue(n)
        }
        emitNeg(n) {
            return `dcg_neg(${n})`
        }
        emitSquare(n) {
            return `dcg_square(${n})`
        }
        emitTernary(n, r, o, i) {
            return X(i.valueType) ? `dcg_ternary(${n},${r},${o})` : `${n}?${r}:${o}`
        }
        emitVec2(n, r) {
            return `vec2(${n},${r})`
        }
        emitVec3(n, r, o) {
            return `vec3(${n},${r},${o})`
        }
        emitVec(...n) {
            throw new Error("Unimplemented")
        }
        emitVecAccess(n, r) {
            return `${n}.${r === 0 ? "x" : r === 1 ? "y" : "z"}`
        }
        emitBinary(n, r, o) {
            switch (n.type) {
            case 8:
                return `dcg_add(${r},${o})`;
            case 9:
                return `dcg_sub(${r},${o})`;
            case 10:
                return `dcg_mul(${r},${o})`;
            case 11:
                return `dcg_div(${r},${o})`;
            case 12:
                return `dcg_pow(${r},${o})`;
            case 13:
                return `dcg_rawpow(${r},${o})`;
            case 25:
                return `dcg_equal(${r},${o})`;
            case 26:
                return `dcg_less(${r},${o})`;
            case 28:
                return `dcg_lessEqual(${r},${o})`;
            case 27:
                return `dcg_greater(${r},${o})`;
            case 29:
                return `dcg_greaterEqual(${r},${o})`;
            case 31:
                return `${r}||${o}`;
            case 32:
                return `${r}&&${o}`;
            default:
                throw new Error("Programming Error: invalid binary opcode.")
            }
        }
        emitList(n, r) {
            let o = RL({
                type: zy(r.valueType),
                arity: r.args.length
            });
            return this.definitions[o] = !0,
            `buildList(${n.join(",")})`
        }
        emitListAccess(n, r, o, i) {
            let s = Un(this.chunk, i.args[0]);
            if (s === void 0)
                throw Qc(Go(this.chunk, i.args[0]));
            let a = `int(${r})`;
            return `(${a}>=1&&${a}<=${s})?${n}[${a}-1]:${o}`
        }
        emitInboundsListAccess(n, r) {
            return `${n}[int(${r})-1]`
        }
        emitNativeFunction(n, r) {
            if (!$x[r.symbol])
                throw wm(r.symbol);
            return `dcg_${r.symbol}(${n.join(",")})`
        }
        emitExtendSeed() {
            throw wm("random")
        }
        emitVarDeclaration(n, r) {
            let o = r ? ";" : "";
            return o += N0(this.chunk, n) + " " + On(n),
            o
        }
        emitImmediateAssignment(n, r, o) {
            return `${N0(this.chunk, n)} ${r}=${o};`
        }
        emitFunctionCall() {
            throw wm("recursion")
        }
    }
    ;
    function lce(...e) {
        return Object.keys(Object.assign({}, ...e)).join(`
`)
    }
    function RL(e) {
        let {type: t, arity: n} = e
          , r = t + "[" + n + "]"
          , o = r + " buildList(";
        for (let i = 0; i < n - 1; i++)
            o += `${t} _${i}, `;
        o += `${t} _${n - 1}) {
`,
        o += r + ` a;
`;
        for (let i = 0; i < n; i++)
            o += `a[${i}] = _${i};
`;
        return o += `return a;
}
`,
        o
    }
    function gY(e, t) {
        let n = e.argNames.length
          , r = e.instructionsLength() - 1;
        for (let o = n; o <= r; o++) {
            let i = e.getInstruction(o);
            if (i.type === 33) {
                if (X(i.valueType)) {
                    let s = N0(e, o)
                      , a = `${s} dcg_ternary(bool x, ${s} y, ${s} z) { if (x) return y; return z; }`;
                    t[a] = !0
                }
            } else if (i.type === 37) {
                let s = $x[i.symbol];
                if ((s == null ? void 0 : s.type) === "reducer") {
                    let a = i.args[0]
                      , u = Un(e, a);
                    if (u === void 0)
                        throw Qc(Go(e, a));
                    for (let c of s.deps)
                        t[$x[c].value(u)] = !0;
                    t[s.value(u)] = !0
                } else if ((s == null ? void 0 : s.type) === "double-reducer") {
                    let a = i.args[0]
                      , u = i.args[1]
                      , c = Un(e, a)
                      , l = Un(e, u);
                    if (c === void 0)
                        throw Qc(Go(e, a));
                    if (l === void 0)
                        throw Qc(Go(e, u));
                    t[s.value(c, l)] = !0
                } else if ((s == null ? void 0 : s.type) === "elementsAt") {
                    let a = zy(Qe(i.valueType))
                      , u = i.args[1]
                      , c = Un(e, u);
                    if (c === void 0)
                        throw Qc(Go(e, u));
                    t[s.value(a, c)] = !0
                }
            }
        }
        return t
    }
    function _0(e) {
        let t = e.toString();
        return /^-?\d+$/.test(t) ? t + ".0" : t
    }
    function zy(e) {
        switch (rr(e)) {
        case Fe:
            return "bool";
        case b:
            return "float";
        case R:
        case N:
            return "vec2";
        case bn:
        case G:
            return "vec3";
        default:
            throw new Error("Unexpected type: " + Ke(e))
        }
    }
    function N0(e, t) {
        let n = e.getInstruction(t);
        if (X(n.valueType)) {
            let r = Un(e, t);
            if (r === void 0)
                throw Qc(Go(e, t));
            if (r > 100)
                throw hp();
            return `${zy(n.valueType)}[${r}]`
        } else
            return zy(n.valueType)
    }
    function pce(e) {
        let t = {}
          , n = "";
        if (e)
            for (let r = 0; r < e.length; r++) {
                let o = "_DCG_SC_" + r;
                t[o] = {
                    value: e[r]
                },
                n += "uniform float " + o + `;
`
            }
        return {
            uniforms: t,
            declarations: n
        }
    }
    function NL(e) {
        let t = []
          , n = [];
        for (let r = 0; r < e.argNames.length; r++) {
            let o = []
              , i = [];
            for (let s = 0; s < e.argNames.length; s++)
                o.push(e.argTypes[s] === b),
                i.push(r === s);
            n.push(i),
            t.push(o)
        }
        for (let r = e.argNames.length; r <= e.getReturnIndex(); r++)
            n.push(hY(e, n, r)),
            t.push(bY(e, n, t, r));
        return t[e.getReturnIndex()]
    }
    function hY(e, t, n) {
        let r = e.getInstruction(n)
          , o = TY(e.argNames.length);
        if (!de(r))
            return o;
        for (let i of r.args) {
            let s = t[i];
            for (let a = 0; a < s.length; a++)
                o[a] = o[a] || s[a]
        }
        return o
    }
    function bY(e, t, n, r) {
        let o = e.getInstruction(r);
        if (!de(o))
            return O0(e.argNames.length);
        switch (o.type) {
        case 8:
        case 9:
        case 14:
        case 15:
        case 16:
        case 38:
            {
                let s = O0(e.argNames.length);
                for (let a = 0; a < o.args.length; a++) {
                    let u = n[o.args[a]];
                    for (let c = 0; c < u.length; c++)
                        s[c] = s[c] && u[c]
                }
                return s
            }
        case 11:
            {
                let s = []
                  , a = n[o.args[0]]
                  , u = t[o.args[1]];
                for (let c = 0; c < a.length; c++)
                    s.push(a[c] && !u[c]);
                return s
            }
        case 10:
            {
                let s = n[o.args[0]].slice()
                  , a = n[o.args[1]].slice()
                  , u = t[o.args[0]]
                  , c = t[o.args[1]]
                  , l = 0
                  , p = 0;
                for (let m = 0; m < s.length; m++) {
                    let d = s[m] && !c[m]
                      , y = a[m] && !u[m];
                    s[m] = d,
                    a[m] = y,
                    d && (l += 1),
                    y && (p += 1)
                }
                return l >= p ? s : a
            }
        case 33:
            {
                let s = t[o.args[0]]
                  , a = n[o.args[1]]
                  , u = n[o.args[2]]
                  , c = [];
                for (let l = 0; l < s.length; l++)
                    c.push(!s[l] && a[l] && u[l]);
                return c
            }
        case 39:
        case 40:
        case 41:
            {
                let s = n[o.args[0]]
                  , a = t[o.args[1]]
                  , u = [];
                for (let c = 0; c < a.length; c++)
                    u.push(s[c] && !a[c]);
                return u
            }
        case 48:
            {
                let s = o.args[0]
                  , a = e.getInstruction(s)
                  , u = r - s;
                return n[a.args[u]]
            }
        case 37:
            return xY(e, o, t, n, r);
        case 56:
        case 12:
        case 13:
        case 26:
        case 28:
        case 27:
        case 29:
        case 25:
        case 32:
        case 31:
        case 42:
        case 21:
        case 22:
        case 19:
        case 20:
        case 23:
        case 24:
        case 47:
        case 44:
        case 49:
        case 50:
        case 51:
        case 53:
        case 54:
        case 55:
            {
                let s = t[r]
                  , a = [];
                for (let u of s)
                    a.push(!u);
                return a
            }
        default:
            let i = o;
            throw new Error(`Unexpected opcode ${i.type}`)
        }
    }
    function xY(e, t, n, r, o) {
        switch (t.symbol) {
        case "complex":
            {
                let i = O0(e.argNames.length);
                for (let s = 0; s < t.args.length; s++) {
                    let a = r[t.args[s]];
                    for (let u = 0; u < a.length; u++)
                        i[u] = i[u] && a[u]
                }
                return i
            }
        default:
            {
                let i = n[o]
                  , s = [];
                for (let a of i)
                    s.push(!a);
                return s
            }
        }
    }
    function TY(e) {
        let t = [];
        for (let n = 0; n < e; n++)
            t.push(!1);
        return t
    }
    function O0(e) {
        let t = [];
        for (let n = 0; n < e; n++)
            t.push(!0);
        return t
    }
    function kn(e, t, n) {
        switch (t) {
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
        case 56:
        case 21:
        case 19:
        case 23:
        case 50:
            return b;
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 31:
        case 32:
            return Fe;
        case 33:
            {
                let o = e.getInstruction(n[1]).valueType
                  , i = e.getInstruction(n[2]).valueType
                  , s = mc(o, i);
                return s === void 0 ? o : s
            }
        case 38:
            return vd(n.map(o => e.getInstruction(o).valueType));
        case 39:
        case 40:
        case 41:
            {
                let o = e.getInstruction(n[0]).valueType;
                return X(o) ? Qe(o) : Dn
            }
        case 44:
            return _t;
        case 49:
            return pt;
        case 55:
            return e.getInstruction(n[0]).valueType;
        case 1:
        case 2:
        case 37:
        case 42:
        case 47:
        case 48:
        case 3:
        case 0:
        case 24:
        case 22:
        case 20:
        case 51:
        case 4:
        case 53:
        case 54:
        case 15:
        case 16:
            return Dn;
        default:
            let r = t;
            throw new Error(`Unexpected opcode ${r}`)
        }
    }
    function OL(e) {
        if (e.instructionsLength() - 1 !== e.getReturnIndex())
            throw new Error("Programming Error: only the final instruction in a chunk can be lifted to numbers");
        let t = e.getInstruction(e.getReturnIndex());
        if (!de(t))
            return e.getReturnIndex();
        switch (t.type) {
        case 8:
            let[n,r] = t.args;
            return Nr(e, n) && Nr(e, r) ? (e.popInstruction(),
            e.NativeFunction("complex", [e.Add([e.Slot(0, [n]), e.Slot(0, [r])]), e.Add([e.Slot(1, [n]), e.Slot(1, [r])])])) : Nr(e, n) && Co(e, r) ? (e.popInstruction(),
            e.NativeFunction("complex", [e.Add([e.Slot(0, [n]), r]), e.Slot(1, [n])])) : Co(e, n) && Nr(e, r) ? (e.popInstruction(),
            e.NativeFunction("complex", [e.Add([n, e.Slot(0, [r])]), e.Slot(1, [r])])) : Il(e, n) && Il(e, r) ? (e.popInstruction(),
            e.TupleOfType(R, [e.Add([e.Slot(0, [n]), e.Slot(0, [r])]), e.Add([e.Slot(1, [n]), e.Slot(1, [r])])])) : Pl(e, n) && Pl(e, r) ? (e.popInstruction(),
            e.TupleOfType(G, [e.Add([e.Slot(0, [n]), e.Slot(0, [r])]), e.Add([e.Slot(1, [n]), e.Slot(1, [r])]), e.Add([e.Slot(2, [n]), e.Slot(2, [r])])])) : Sc(e, t.args) ? (e.popInstruction(),
            Sl(e, [e.Add([ti(e, n), ti(e, r)]), tu(e, t.args[0])])) : e.getReturnIndex();
        case 9:
            {
                let[i,s] = t.args;
                return Nr(e, i) && Nr(e, s) ? (e.popInstruction(),
                e.NativeFunction("complex", [e.Subtract([e.Slot(0, [i]), e.Slot(0, [s])]), e.Subtract([e.Slot(1, [i]), e.Slot(1, [s])])])) : Nr(e, i) && Co(e, s) ? (e.popInstruction(),
                e.NativeFunction("complex", [e.Subtract([e.Slot(0, [i]), s]), e.Slot(1, [i])])) : Co(e, i) && Nr(e, s) ? (e.popInstruction(),
                e.NativeFunction("complex", [e.Subtract([i, e.Slot(0, [s])]), e.Negative([e.Slot(1, [s])])])) : Il(e, i) && Il(e, s) ? (e.popInstruction(),
                e.TupleOfType(R, [e.Subtract([e.Slot(0, [i]), e.Slot(0, [s])]), e.Subtract([e.Slot(1, [i]), e.Slot(1, [s])])])) : Pl(e, i) && Pl(e, s) ? (e.popInstruction(),
                e.TupleOfType(G, [e.Subtract([e.Slot(0, [i]), e.Slot(0, [s])]), e.Subtract([e.Slot(1, [i]), e.Slot(1, [s])]), e.Subtract([e.Slot(2, [i]), e.Slot(2, [s])])])) : Sc(e, t.args) ? (e.popInstruction(),
                Sl(e, [e.Subtract([ti(e, i), ti(e, s)]), tu(e, i)])) : e.getReturnIndex()
            }
        case 14:
            {
                let[i] = t.args;
                return Nr(e, i) ? (e.popInstruction(),
                e.NativeFunction("complex", [e.Negative([e.Slot(0, [i])]), e.Negative([e.Slot(1, [i])])])) : Il(e, i) ? (e.popInstruction(),
                e.TupleOfType(R, [e.Negative([e.Slot(0, [i])]), e.Negative([e.Slot(1, [i])])])) : Pl(e, i) ? (e.popInstruction(),
                e.TupleOfType(G, [e.Negative([e.Slot(0, [i])]), e.Negative([e.Slot(1, [i])]), e.Negative([e.Slot(2, [i])])])) : Sc(e, t.args) ? (e.popInstruction(),
                Sl(e, [e.Negative([ti(e, i)]), tu(e, i)])) : e.getReturnIndex()
            }
        case 10:
            {
                let[i,s] = t.args;
                if (Nr(e, i) && Nr(e, s)) {
                    e.popInstruction();
                    let a = e.Slot(0, [i])
                      , u = e.Slot(1, [i])
                      , c = e.Slot(0, [s])
                      , l = e.Slot(1, [s]);
                    return e.NativeFunction("complex", [e.Subtract([e.Multiply([a, c]), e.Multiply([u, l])]), e.Add([e.Multiply([a, l]), e.Multiply([c, u])])])
                } else {
                    if (Nr(e, i) && Co(e, s))
                        return e.popInstruction(),
                        e.NativeFunction("complex", [e.Multiply([e.Slot(0, [i]), s]), e.Multiply([e.Slot(1, [i]), s])]);
                    if (Co(e, i) && Nr(e, s))
                        return e.popInstruction(),
                        e.NativeFunction("complex", [e.Multiply([i, e.Slot(0, [s])]), e.Multiply([i, e.Slot(1, [s])])]);
                    if (Hy(e, i) && Hy(e, s))
                        return e.popInstruction(),
                        e.NativeFunction("restriction", [e.And([e.NativeFunction("restrictionToBoolean", [i]), e.NativeFunction("restrictionToBoolean", [s])])]);
                    if (Hy(e, i) || Hy(e, s)) {
                        let a, u;
                        Hy(e, i) ? (a = i,
                        u = s) : (a = s,
                        u = i);
                        let c = e.getInstruction(u).valueType;
                        return ra(c) ? (e.popInstruction(),
                        e.Piecewise([e.NativeFunction("restrictionToBoolean", [a]), u, e.NanOfType(c)])) : e.getReturnIndex()
                    } else
                        return Il(e, i) && Co(e, s) ? (e.popInstruction(),
                        e.TupleOfType(R, [e.Multiply([e.Slot(0, [i]), s]), e.Multiply([e.Slot(1, [i]), s])])) : Co(e, i) && Il(e, s) ? (e.popInstruction(),
                        e.TupleOfType(R, [e.Multiply([i, e.Slot(0, [s])]), e.Multiply([i, e.Slot(1, [s])])])) : Sc(e, [i]) && Co(e, s) ? (e.popInstruction(),
                        Sl(e, [e.Multiply([ti(e, i), s]), tu(e, i)])) : Co(e, i) && Sc(e, [s]) ? (e.popInstruction(),
                        Sl(e, [e.Multiply([i, ti(e, s)]), tu(e, s)])) : Pl(e, i) && Co(e, s) ? (e.popInstruction(),
                        e.TupleOfType(G, [e.Multiply([e.Slot(0, [i]), s]), e.Multiply([e.Slot(1, [i]), s]), e.Multiply([e.Slot(2, [i]), s])])) : Co(e, i) && Pl(e, s) ? (e.popInstruction(),
                        e.TupleOfType(G, [e.Multiply([i, e.Slot(0, [s])]), e.Multiply([i, e.Slot(1, [s])]), e.Multiply([i, e.Slot(2, [s])])])) : e.getReturnIndex()
                }
            }
        case 11:
            {
                let[i,s] = t.args;
                return Nr(e, i) && Nr(e, s) ? (e.popInstruction(),
                e.NativeFunction("complexDivide", [i, s])) : Nr(e, i) && Co(e, s) ? (e.popInstruction(),
                e.NativeFunction("complex", [e.Divide([e.Slot(0, [i]), s]), e.Divide([e.Slot(1, [i]), s])])) : Co(e, i) && Nr(e, s) ? (e.popInstruction(),
                e.NativeFunction("complexDivide", [e.NativeFunction("complex", [i, e.Constant(0)]), s])) : Il(e, i) && Co(e, s) ? (e.popInstruction(),
                e.TupleOfType(R, [e.Divide([e.Slot(0, [i]), s]), e.Divide([e.Slot(1, [i]), s])])) : Sc(e, [i]) && Co(e, s) ? (e.popInstruction(),
                Sl(e, [e.Divide([ti(e, i), s]), tu(e, i)])) : Pl(e, i) && Co(e, s) ? (e.popInstruction(),
                e.TupleOfType(G, [e.Divide([e.Slot(0, [i]), s]), e.Divide([e.Slot(1, [i]), s]), e.Divide([e.Slot(2, [i]), s])])) : e.getReturnIndex()
            }
        case 25:
            {
                let[i,s] = t.args;
                if (Nr(e, i) && Nr(e, s)) {
                    e.popInstruction();
                    let a = e.Slot(0, [i])
                      , u = e.Slot(0, [s])
                      , c = e.Slot(1, [i])
                      , l = e.Slot(1, [s]);
                    return e.And([e.Equal([a, u]), e.Equal([c, l])])
                } else if (Co(e, i) && Nr(e, s)) {
                    e.popInstruction();
                    let a = i
                      , u = e.Slot(0, [s])
                      , c = e.Constant(0)
                      , l = e.Slot(1, [s]);
                    return e.And([e.Equal([a, u]), e.Equal([c, l])])
                } else if (Nr(e, i) && Co(e, s)) {
                    e.popInstruction();
                    let a = e.Slot(0, [i])
                      , u = s
                      , c = e.Slot(1, [i])
                      , l = e.Constant(0);
                    return e.And([e.Equal([a, u]), e.Equal([c, l])])
                } else
                    return e.getReturnIndex()
            }
        case 28:
        case 29:
            {
                let[i,s] = t.args;
                if (Nr(e, i) && Nr(e, s)) {
                    e.popInstruction();
                    let a = t.type === 28 ? e.Less(t.args) : e.Greater(t.args);
                    return e.Or([a, e.Equal(t.args)])
                } else
                    return e.getReturnIndex()
            }
        case 12:
        case 56:
        case 13:
        case 26:
        case 27:
        case 32:
        case 31:
        case 15:
        case 33:
        case 16:
        case 37:
        case 42:
        case 39:
        case 40:
        case 41:
        case 21:
        case 22:
        case 19:
        case 20:
        case 38:
        case 47:
        case 23:
        case 24:
        case 48:
        case 44:
        case 49:
        case 50:
        case 51:
        case 53:
        case 54:
        case 55:
            return e.getReturnIndex();
        default:
            let o = t;
            throw new Error(`Unexpected opcode ${o.type}`)
        }
    }
    function Il(e, t) {
        return e.getInstruction(t).valueType === R
    }
    function Pl(e, t) {
        return e.getInstruction(t).valueType === G
    }
    function Co(e, t) {
        return e.getInstruction(t).valueType === b
    }
    function Nr(e, t) {
        return e.getInstruction(t).valueType === N
    }
    function Hy(e, t) {
        return e.getInstruction(t).valueType === sn
    }
    function Sc(e, t) {
        return t.every(n => xt(e, n, Ie)) || t.every(n => xt(e, n, qe))
    }
    function Sl(e, t) {
        return zs(e, t, "mathVector", Uy("mathVector", "mathVectorThreeD"))
    }
    function tu(e, t) {
        return zs(e, [t], "start", [{
            match: [Ie],
            build: () => e.NativeFunction("basePointFromVector", [t])
        }, {
            match: [qe],
            build: () => e.NativeFunction("basePointFromVectorThreeD", [t])
        }])
    }
    function ti(e, t) {
        return zs(e, [t], "displacement", [{
            match: [Ie],
            build: () => e.NativeFunction("vectorDisplacementAsPoint", [t])
        }, {
            match: [qe],
            build: () => e.NativeFunction("vectorThreeDDisplacementAsPoint", [t])
        }])
    }
    function Uy(e, t) {
        return [{
            match: [R, R],
            build: (n, r) => n.NativeFunction(e, r)
        }, {
            match: [G, G],
            build: (n, r) => n.NativeFunction(t, r)
        }]
    }
    var A = {
        X_OR_Y: "X_OR_Y",
        SINGLE_POINT: "SINGLE_POINT",
        POINT_LIST: "POINT_LIST",
        PARAMETRIC: "PARAMETRIC",
        POLAR: "POLAR",
        IMPLICIT: "IMPLICIT",
        POLYGON: "POLYGON",
        HISTOGRAM: "HISTOGRAM",
        DOTPLOT: "DOTPLOT",
        BOXPLOT: "BOXPLOT",
        STATS: "STATS",
        VECTOR2D: "VECTOR2D",
        POINT3D: "POINT3D",
        POINT3D_LIST: "POINT3D_LIST",
        TRIANGLE3D: "TRIANGLE3D",
        SEGMENT3D: "SEGMENT3D",
        VECTOR3D: "VECTOR3D",
        SPHERE3D: "SPHERE3D",
        CURVE3D_xyz_t: "CURVE3D_xyz_t",
        SURFACE_xyz_uv: "SURFACE_xyz_uv",
        SURFACE_z_r\u03B8: "SURFACE_z_r\u03B8",
        SURFACE_r_\u03B8z: "SURFACE_r_\u03B8z",
        SURFACE_r_\u03B8\u03C6: "SURFACE_r_\u03B8\u03C6",
        SURFACE_r_\u03B8z_AMBIGUOUS: "SURFACE_r_\u03B8z_AMBIGUOUS",
        SURFACE_AMBIGUOUS: "SURFACE_AMBIGUOUS",
        SURFACE_CONSTANT_AMBIGUOUS: "SURFACE_CONSTANT_AMBIGUOUS",
        SURFACE: "SURFACE",
        IMPLICIT_SURFACE: "IMPLICIT_SURFACE",
        IMPLICIT_SURFACE_AMBIGUOUS: "IMPLICIT_SURFACE_AMBIGUOUS",
        SLICE: "SLICE",
        SLICE_r\u03B8z_at_z: "SLICE_r\u03B8z_at_z",
        SLICE_zr\u03B8_at_r: "SLICE_zr\u03B8_at_r",
        SLICE_zr\u03B8_at_\u03B8: "SLICE_zr\u03B8_at_\u03B8",
        SLICE_zr\u03B8_at_xyz: "SLICE_zr\u03B8_at_xyz",
        SLICE_r\u03B8\u03C6_at_\u03B8: "SLICE_r\u03B8\u03C6_at_\u03B8",
        SLICE_r\u03B8\u03C6_at_\u03C6: "SLICE_r\u03B8\u03C6_at_\u03C6",
        SLICE_r\u03B8\u03C6_at_xyz: "SLICE_r\u03B8\u03C6_at_xyz",
        SLICE_xyz_uv: "SLICE_xyz_uv"
    }
      , IY = {
        X_OR_Y: {
            points: !1,
            lines: !0,
            fill: !1
        },
        SINGLE_POINT: {
            points: !0,
            lines: !1,
            fill: !1
        },
        POINT_LIST: {
            points: !0,
            lines: !1,
            fill: !1
        },
        PARAMETRIC: {
            points: !1,
            lines: !0,
            fill: !1
        },
        POLAR: {
            points: !1,
            lines: !0,
            fill: !1
        },
        IMPLICIT: {
            points: !1,
            lines: !0,
            fill: !1
        },
        POLYGON: {
            points: !1,
            lines: !0,
            fill: !0
        },
        HISTOGRAM: {
            points: !1,
            lines: !0,
            fill: !0
        },
        DOTPLOT: {
            points: !0,
            lines: !1,
            fill: !1
        },
        BOXPLOT: {
            points: !1,
            lines: !0,
            fill: !1
        },
        STATS: {
            points: !1,
            lines: !1,
            fill: !1
        },
        VECTOR2D: {
            points: !1,
            lines: !0,
            fill: !1
        },
        POINT3D: {
            points: !0,
            lines: !1,
            fill: !1
        },
        POINT3D_LIST: {
            points: !0,
            lines: !1,
            fill: !1
        },
        CURVE3D_xyz_t: {
            points: !1,
            lines: !0,
            fill: !1
        },
        SLICE: {
            points: !1,
            lines: !0,
            fill: !1
        },
        SLICE_r\u03B8z_at_z: {
            points: !1,
            lines: !0,
            fill: !1
        },
        SLICE_zr\u03B8_at_r: {
            points: !1,
            lines: !0,
            fill: !1
        },
        SLICE_zr\u03B8_at_\u03B8: {
            points: !1,
            lines: !0,
            fill: !1
        },
        SLICE_zr\u03B8_at_xyz: {
            points: !1,
            lines: !0,
            fill: !1
        },
        SLICE_r\u03B8\u03C6_at_\u03B8: {
            points: !1,
            lines: !0,
            fill: !1
        },
        SLICE_r\u03B8\u03C6_at_\u03C6: {
            points: !1,
            lines: !0,
            fill: !1
        },
        SLICE_r\u03B8\u03C6_at_xyz: {
            points: !1,
            lines: !0,
            fill: !1
        },
        SLICE_xyz_uv: {
            points: !1,
            lines: !0,
            fill: !1
        },
        SEGMENT3D: {
            points: !1,
            lines: !0,
            fill: !1
        },
        VECTOR3D: {
            points: !1,
            lines: !0,
            fill: !1
        },
        SPHERE3D: {
            points: !1,
            lines: !0,
            fill: !1
        },
        SURFACE_xyz_uv: {
            points: !1,
            lines: !0,
            fill: !1
        },
        SURFACE_z_r\u03B8: {
            points: !1,
            lines: !0,
            fill: !1
        },
        SURFACE_r_\u03B8z: {
            points: !1,
            lines: !0,
            fill: !1
        },
        SURFACE_r_\u03B8\u03C6: {
            points: !1,
            lines: !0,
            fill: !1
        },
        SURFACE_r_\u03B8z_AMBIGUOUS: {
            points: !1,
            lines: !0,
            fill: !1
        },
        SURFACE: {
            points: !1,
            lines: !0,
            fill: !1
        },
        TRIANGLE3D: {
            points: !1,
            lines: !0,
            fill: !1
        },
        SURFACE_AMBIGUOUS: {
            points: !1,
            lines: !0,
            fill: !1
        },
        SURFACE_CONSTANT_AMBIGUOUS: {
            points: !1,
            lines: !0,
            fill: !1
        },
        IMPLICIT_SURFACE: {
            points: !1,
            lines: !0,
            fill: !1
        },
        IMPLICIT_SURFACE_AMBIGUOUS: {
            points: !1,
            lines: !0,
            fill: !1
        }
    };
    function A0(e, t, n) {
        var o, i, s, a, u, c;
        if (e === void 0)
            return {
                points: !1,
                lines: !1,
                fill: !1
            };
        let r = IY[e];
        switch (e) {
        case A.SINGLE_POINT:
            return {
                points: !0,
                lines: !1,
                fill: !1
            };
        case A.POINT_LIST:
        case A.POINT3D_LIST:
        case A.DOTPLOT:
            return {
                points: (o = t.points) != null ? o : r.points,
                lines: (i = t.lines) != null ? i : r.lines,
                fill: !1
            };
        case A.POINT3D:
            return {
                points: (s = t.points) != null ? s : r.points,
                lines: !1,
                fill: !1
            };
        case A.PARAMETRIC:
        case A.POLYGON:
        case A.X_OR_Y:
        case A.VECTOR2D:
        case A.POLAR:
        case A.IMPLICIT:
        case A.HISTOGRAM:
        case A.BOXPLOT:
        case A.STATS:
        case A.CURVE3D_xyz_t:
            return {
                points: !1,
                lines: (a = t.lines) != null ? a : r.lines,
                fill: (u = t.fill) != null ? u : r.fill
            };
        case A.TRIANGLE3D:
        case A.SPHERE3D:
        case A.SURFACE:
        case A.SURFACE_r_\u03B8z:
        case A.SURFACE_z_r\u03B8:
        case A.SURFACE_r_\u03B8\u03C6:
        case A.SURFACE_xyz_uv:
        case A.IMPLICIT_SURFACE:
        case A.SURFACE_AMBIGUOUS:
        case A.SURFACE_CONSTANT_AMBIGUOUS:
        case A.SURFACE_r_\u03B8z_AMBIGUOUS:
        case A.IMPLICIT_SURFACE_AMBIGUOUS:
        case A.SEGMENT3D:
        case A.VECTOR3D:
        case A.SLICE:
        case A.SLICE_r\u03B8z_at_z:
        case A.SLICE_zr\u03B8_at_r:
        case A.SLICE_zr\u03B8_at_\u03B8:
        case A.SLICE_zr\u03B8_at_xyz:
        case A.SLICE_r\u03B8\u03C6_at_\u03B8:
        case A.SLICE_r\u03B8\u03C6_at_\u03C6:
        case A.SLICE_r\u03B8\u03C6_at_xyz:
        case A.SLICE_xyz_uv:
            return {
                points: !1,
                lines: (c = t.lines) != null ? c : r.lines,
                fill: !1
            };
        default:
            n && n(e);
            let l = e;
            return A0(e, t) || l
        }
    }
    function AL(e) {
        if (e === void 0)
            return !1;
        switch (e) {
        case A.SINGLE_POINT:
        case A.POINT_LIST:
        case A.PARAMETRIC:
        case A.POLYGON:
        case A.X_OR_Y:
        case A.VECTOR2D:
        case A.POLAR:
        case A.IMPLICIT:
        case A.SURFACE:
        case A.SURFACE_AMBIGUOUS:
        case A.SURFACE_CONSTANT_AMBIGUOUS:
        case A.SURFACE_r_\u03B8z:
        case A.SURFACE_r_\u03B8z_AMBIGUOUS:
        case A.SURFACE_z_r\u03B8:
        case A.SURFACE_r_\u03B8\u03C6:
        case A.SURFACE_xyz_uv:
        case A.IMPLICIT_SURFACE:
        case A.IMPLICIT_SURFACE_AMBIGUOUS:
        case A.CURVE3D_xyz_t:
        case A.SLICE:
        case A.SLICE_r\u03B8z_at_z:
        case A.SLICE_zr\u03B8_at_r:
        case A.SLICE_zr\u03B8_at_\u03B8:
        case A.SLICE_zr\u03B8_at_xyz:
        case A.SLICE_r\u03B8\u03C6_at_\u03B8:
        case A.SLICE_r\u03B8\u03C6_at_\u03C6:
        case A.SLICE_r\u03B8\u03C6_at_xyz:
        case A.SLICE_xyz_uv:
        case A.SEGMENT3D:
        case A.VECTOR3D:
        case A.SPHERE3D:
        case A.POINT3D:
        case A.POINT3D_LIST:
        case A.TRIANGLE3D:
            return !0;
        case A.HISTOGRAM:
        case A.BOXPLOT:
        case A.DOTPLOT:
        case A.STATS:
            return !1;
        default:
            return e
        }
    }
    function wL(e) {
        return e === A.SURFACE_r_\u03B8\u03C6 || e === A.SLICE_r\u03B8\u03C6_at_\u03B8 || e === A.SLICE_r\u03B8\u03C6_at_\u03C6 || e === A.SLICE_r\u03B8\u03C6_at_xyz
    }
    function LL(e) {
        return e === A.SURFACE_z_r\u03B8 || e === A.SLICE_zr\u03B8_at_r || e === A.SLICE_zr\u03B8_at_\u03B8 || e === A.SLICE_zr\u03B8_at_xyz
    }
    function FL(e) {
        return e === A.SURFACE_r_\u03B8z || e === A.SURFACE_r_\u03B8z_AMBIGUOUS || e === A.SLICE_r\u03B8z_at_z
    }
    function Zu(e) {
        return e >= 100
    }
    function VL(e, t) {
        switch (e) {
        case 106:
            return 200;
        case 107:
            return 201;
        case 108:
            return 202;
        case 103:
            return 214;
        case 130:
            return 215;
        case 112:
            return 209;
        case 113:
            return 210;
        case 110:
            switch (t) {
            case "z":
                return 206;
            case "theta":
                return 205;
            case "x":
            case "y":
            case "r":
            case "_implicit":
                return 211;
            default:
                return 10
            }
        case 109:
            switch (t) {
            case "r":
                return 203;
            case "theta":
                return 204;
            case "x":
            case "y":
            case "z":
            case "_implicit":
                return 213;
            default:
                return 10
            }
        case 111:
            switch (t) {
            case "theta":
                return 207;
            case "phi":
                return 208;
            case "x":
            case "y":
            case "z":
            case "rho":
            case "_implicit":
                return 212;
            default:
                return 10
            }
        default:
            return 10
        }
    }
    function w0(e) {
        switch (e) {
        case 123:
        case 122:
        case 121:
        case 120:
        case 124:
        case 126:
        case 127:
            return !0;
        default:
            return !1
        }
    }
    function El(e) {
        return e === 26 || e === 4
    }
    function Pce(e) {
        return El(e) || e === 3 || e === 25
    }
    var {sin: PY, cos: SY} = Math
      , it = class e {
        constructor(t=0, n=0, r=0) {
            this.x = t;
            this.y = n;
            this.z = r
        }
        copy(t) {
            return this.x = t.x,
            this.y = t.y,
            this.z = t.z,
            this
        }
        set(t, n, r) {
            return this.x = t,
            this.y = n,
            this.z = r,
            this
        }
        clone() {
            return new e(this.x,this.y,this.z)
        }
        equals(t) {
            return t.x === this.x && t.y === this.y && t.z === this.z
        }
        isZero() {
            return this.x === 0 && this.y === 0 && this.z === 0
        }
        isFinite() {
            return isFinite(this.x) && isFinite(this.y) && isFinite(this.z)
        }
        subVectors(t, n) {
            return this.x = t.x - n.x,
            this.y = t.y - n.y,
            this.z = t.z - n.z,
            this
        }
        addVectors(t, n) {
            return this.x = t.x + n.x,
            this.y = t.y + n.y,
            this.z = t.z + n.z,
            this
        }
        multiply(t) {
            return this.x *= t,
            this.y *= t,
            this.z *= t,
            this
        }
        magnitude() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        }
        normalize() {
            return this.multiply(1 / this.magnitude()),
            this
        }
        cross(t) {
            return this.crossVectors(this, t)
        }
        crossVectors(t, n) {
            let r = t.x
              , o = t.y
              , i = t.z
              , s = n.x
              , a = n.y
              , u = n.z;
            return this.x = o * u - i * a,
            this.y = i * s - r * u,
            this.z = r * a - o * s,
            this
        }
        dot(t) {
            return this.x * t.x + this.y * t.y + this.z * t.z
        }
        rotateAroundAxis(t, n) {
            let r = EY(t, n);
            return new e(r[0] * this.x + r[1] * this.y + r[2] * this.z,r[3] * this.x + r[4] * this.y + r[5] * this.z,r[6] * this.x + r[7] * this.y + r[8] * this.z)
        }
    }
    ;
    function EY(e, t) {
        let n = e.x
          , r = e.y
          , o = e.z
          , i = PY(t)
          , s = SY(t)
          , a = 1 - s;
        return [a * n * n + s, a * n * r + i * o, a * n * o - i * r, a * r * n - i * o, a * r * r + s, a * r * o + i * n, a * o * n + i * r, a * o * r - i * n, a * o * o + s]
    }
    function Od(e, t, n, r, o, i, s) {
        let[a,u,c] = [new it, new it, new it]
          , [l,p,m] = [new it, new it, new it]
          , [d,y] = [new it, new it];
        for (let g = 0; g < e.length / 3; g++) {
            let f = e[3 * g]
              , h = e[3 * g + 1]
              , x = e[3 * g + 2];
            a.set(t[3 * f], t[3 * f + 1], t[3 * f + 2]),
            u.set(t[3 * h], t[3 * h + 1], t[3 * h + 2]),
            c.set(t[3 * x], t[3 * x + 1], t[3 * x + 2]),
            l.set(n[3 * f], n[3 * f + 1], n[3 * f + 2]),
            p.set(n[3 * h], n[3 * h + 1], n[3 * h + 2]),
            m.set(n[3 * x], n[3 * x + 1], n[3 * x + 2]),
            d.subVectors(c, a),
            y.subVectors(a, u);
            let T = d.cross(y).normalize();
            if (!(l.dot(T) > s && p.dot(T) > s && m.dot(T) > s) || l.dot(p) < 0 || l.dot(m) < 0 || p.dot(m) < 0) {
                let C = t.length / 3;
                e[3 * g] = C,
                e[3 * g + 1] = C + 1,
                e[3 * g + 2] = C + 2,
                t.push(a.x, a.y, a.z),
                t.push(u.x, u.y, u.z),
                t.push(c.x, c.y, c.z),
                n.push(T.x, T.y, T.z),
                n.push(T.x, T.y, T.z),
                n.push(T.x, T.y, T.z),
                r.push(r[2 * f], r[2 * f + 1]),
                r.push(r[2 * h], r[2 * h + 1]),
                r.push(r[2 * x], r[2 * x + 1]);
                let S = o;
                if (o > 0) {
                    for (let E = 0; E < S; E++)
                        i.push(i[S * f + E]);
                    for (let E = 0; E < S; E++)
                        i.push(i[S * h + E]);
                    for (let E = 0; E < S; E++)
                        i.push(i[S * x + E])
                }
            }
        }
    }
    function Zx(e) {
        let {triangles: t, normalDirHints: n} = e.triangulate()
          , {extraAttrCount: r} = e
          , o = e.getVertexCount()
          , i = new Array(o)
          , s = new Array(o * 3)
          , a = []
          , u = !1
          , c = new Array(o * 3)
          , l = new Array(o * 2)
          , p = new Array(o * r)
          , m = []
          , d = 0;
        function y(f) {
            let h = e.getVertex(f);
            if (!h)
                return null;
            let x = n[f]
              , T = x ? e.hintedNormal(f, x) : e.getNormal(f);
            T ? (c[3 * d] = T[0],
            c[3 * d + 1] = T[1],
            c[3 * d + 2] = T[2]) : (a[d] = !0,
            u = !0,
            c[3 * d] = 0,
            c[3 * d + 1] = 0,
            c[3 * d + 2] = 0),
            s[3 * d] = h[0],
            s[3 * d + 1] = h[1],
            s[3 * d + 2] = h[2];
            let P = e.getUV(f);
            if (l[2 * d] = P[0],
            l[2 * d + 1] = P[1],
            r > 0)
                for (let C = 0; C < r; C++)
                    p[r * d + C] = e.getExtraAttr(f, C);
            return d++
        }
        function g(f) {
            let h = i[f];
            return h === void 0 ? i[f] = y(f) : h
        }
        for (let f = 0; f < t.length; f += 3) {
            let h = t[f]
              , x = t[f + 1]
              , T = t[f + 2]
              , P = g(h)
              , C = g(x)
              , S = g(T);
            if (P === null || C === null || S === null)
                continue;
            m.push(P, C, S);
            let E = a[P]
              , M = a[C]
              , _ = a[S];
            if (E || M || _) {
                let U = s
                  , Q = c
                  , K = new it(U[3 * P],U[3 * P + 1],U[3 * P + 2])
                  , w = new it(U[3 * C],U[3 * C + 1],U[3 * C + 2])
                  , B = new it(U[3 * S],U[3 * S + 1],U[3 * S + 2])
                  , W = new it().subVectors(B, K)
                  , oe = new it().subVectors(K, w)
                  , te = W.cross(oe);
                if (!te.isFinite())
                    continue;
                E && (Q[3 * P + 0] += te.x,
                Q[3 * P + 1] += te.y,
                Q[3 * P + 2] += te.z),
                M && (Q[3 * C + 0] += te.x,
                Q[3 * C + 1] += te.y,
                Q[3 * C + 2] += te.z),
                _ && (Q[3 * S + 0] += te.x,
                Q[3 * S + 1] += te.y,
                Q[3 * S + 2] += te.z)
            }
        }
        if (s.length = d * 3,
        c.length = d * 3,
        l.length = d * 2,
        u)
            for (let f = 0; f < d; f++) {
                if (!a[f])
                    continue;
                let h = c[3 * f]
                  , x = c[3 * f + 1]
                  , T = c[3 * f + 2]
                  , P = Math.sqrt(h * h + x * x + T * T);
                c[3 * f] = h / P,
                c[3 * f + 1] = x / P,
                c[3 * f + 2] = T / P
            }
        return Od(m, s, c, l, r, p, 0),
        {
            positions: s,
            normals: c,
            faces: m,
            uvs: l,
            resolved: !0,
            extraAttrs: p
        }
    }
    var V0 = class {
        constructor({resolution: t, uRange: n, vRange: r, du: o, dv: i, extraAttrCount: s}) {
            this.normalDirHints = [];
            this.isVertexAtCreaseCache = [];
            this.triangles = [];
            this.edgeVertices = new Map;
            this.edgeNormalVertices = new Map;
            this.finiteVertices = new Map;
            this.resolution = t,
            this.uRange = n,
            this.vRange = r,
            this.du = o,
            this.dv = i,
            this.extraAttrCount = s,
            this.duSquared = o * o,
            this.dvSquared = i * i
        }
        addVertex(t) {
            return this.normalDirHints.push(void 0),
            this.isVertexAtCreaseCache.push(void 0),
            this._addVertex(t)
        }
        jumpAlongEdge(t, n) {
            let r = 0;
            if (t > n) {
                let u = t;
                t = n,
                n = u,
                r = 1
            }
            let o = n * n + t
              , i = this.edgeVertices.get(o);
            if (i === null)
                return;
            if (i !== void 0)
                return [i[r], i[1 - r]];
            let s = this.findJumpBetweenTwoSamples(t, n);
            if (s === void 0) {
                this.edgeVertices.set(o, null);
                return
            }
            let a = [this.addVertex(s[0]), this.addVertex(s[1])];
            return this.edgeVertices.set(o, a),
            [a[r], a[1 - r]]
        }
        edgeNormalFeature(t, n) {
            let r = 0;
            if (t > n) {
                let u = t;
                t = n,
                n = u,
                r = 1
            }
            let o = n * n + t
              , i = this.edgeNormalVertices.get(o);
            if (i !== void 0)
                return this.flipEdgeNormalFeature(i, r);
            let s = this.findCreaseBetweenTwoSamples(t, n)
              , a = s === null ? null : s.type === "high-curvature" ? {
                type: "high-curvature",
                pos: this.addVertex(s.pos)
            } : {
                type: "crease",
                left: this.addVertex(s.left),
                right: this.addVertex(s.right)
            };
            return this.edgeNormalVertices.set(o, a),
            this.flipEdgeNormalFeature(a, r)
        }
        flipEdgeNormalFeature(t, n) {
            return (t == null ? void 0 : t.type) === "crease" ? {
                type: "crease",
                left: n === 0 ? t.left : t.right,
                right: n === 0 ? t.right : t.left
            } : t
        }
        findCreaseBetweenTwoSamples(t, n) {
            let i = this.getUV(t)
              , s = this.getUV(n)
              , a = this.getNormal(t)
              , u = this.getNormal(n)
              , c = x => {
                var P;
                let T = Mr(i, s, x);
                return (P = this.fn(T).normal) != null ? P : [NaN, NaN, NaN]
            }
            ;
            if (!a || !u)
                return null;
            let l = s[0] - i[0]
              , p = s[1] - i[1]
              , m = this.du
              , d = this.dv
              , y = (Math.abs(m * l) + Math.abs(d * p)) / (l * l + p * p)
              , g = eh(0, a, 1, u, c, .01, 2 * y, .9);
            if (g === void 0)
                return null;
            if (typeof g == "number")
                return g < y || g > 1 - y ? null : {
                    type: "high-curvature",
                    pos: this.fn(Mr(i, s, g))
                };
            let f = g[0]
              , h = g[1];
            return f < y || h > 1 - y ? null : (f -= y,
            h += y,
            f <= 1e-8 && (f = 1e-8),
            h >= 1 - 1e-8 && (h = 1 - 1e-8),
            {
                type: "crease",
                left: this.fn(Mr(i, s, f)),
                right: this.fn(Mr(i, s, h))
            })
        }
        isVertexAtCrease(t) {
            let n = this.isVertexAtCreaseCache[t];
            if (n !== void 0)
                return n;
            let r = this._isVertexAtCrease(t);
            return this.isVertexAtCreaseCache[t] = r,
            r
        }
        finiteAlongEdge(t, n) {
            if (t > n) {
                let a = t;
                t = n,
                n = a
            }
            let r = n * n + t
              , o = this.finiteVertices.get(r);
            if (o !== void 0)
                return o;
            let i = this.findFiniteBetweenTwoSamples(t, n);
            if (i === void 0)
                return;
            let s = this.addVertex(i);
            return this.finiteVertices.set(r, s),
            s
        }
        pushTriangle(t, n, r) {
            this.isDegenerate(t, n, r) || this.triangles.push(t, n, r)
        }
        getTriangles() {
            return this.triangles
        }
    }
      , CY = 1e-4
      , vY = .99
      , wd = .9999;
    function L0(e, t) {
        return !e || !t ? !0 : e[0] * t[0] + e[1] * t[1] + e[2] * t[2] < vY
    }
    var B0 = class extends V0 {
        hintVec(t, n) {
            let r = this.getUV(t)
              , o = this.getUV(n);
            return Q1(J1(o, r), CY)
        }
        hintNormal1(t, n, r) {
            let o = this.hintVec(t, n)
              , i = this.hintVec(t, r);
            this.normalDirHints[t] = [o, i]
        }
        hintNormals2(t, n) {
            let r = this.hintVec(t, n)
              , o = F0(r);
            this.normalDirHints[t] = [Yx(r), o],
            this.normalDirHints[n] = [o, Yx(o)]
        }
        hintNormals2Finite(t, n) {
            let r = this.hintVec(t, n)
              , o = Yx(r);
            this.normalDirHints[t] = this.normalDirHints[n] = [o, F0(o)]
        }
        hintNormalFirstBad(t, n) {
            let r = this.hintVec(t, n);
            this.normalDirHints[t] = [Yx(r), F0(r)]
        }
        hintNormalSecondBad(t, n) {
            let r = this.hintVec(n, t);
            this.normalDirHints[n] = [DY(r), MY(r)]
        }
    }
      , G0 = class extends B0 {
        oneJump(t, n, r, o) {
            let i = o[0]
              , s = o[1];
            this.pushTriangle(i, r, t),
            this.pushTriangle(s, n, r),
            this.hintNormalFirstBad(i, r),
            this.hintNormalSecondBad(r, s)
        }
        oneJumpOneExtra(t, n, r, o, i) {
            let s = o[0]
              , a = o[1];
            this.pushTriangle(s, r, t),
            this.pushTriangle(s, i, r),
            this.pushTriangle(a, n, i),
            this.hintNormalFirstBad(s, r),
            this.hintNormalSecondBad(r, a)
        }
        oneJumpOneExtra2(t, n, r, o, i) {
            let s = o[0]
              , a = o[1];
            this.pushTriangle(a, n, r),
            this.pushTriangle(a, r, i),
            this.pushTriangle(s, i, t),
            this.hintNormalFirstBad(s, r),
            this.hintNormalSecondBad(r, a)
        }
        oneJumpTwoExtra(t, n, r, o, i, s) {
            let a = o[0]
              , u = o[1];
            this.pushTriangle(a, s, t),
            this.pushTriangle(a, i, s),
            this.pushTriangle(i, r, s),
            this.pushTriangle(u, n, i)
        }
        twoJumps(t, n, r, o, i) {
            let s = o[0]
              , a = o[1]
              , u = i[0]
              , c = i[1];
            this.pushTriangle(s, r, t),
            this.pushTriangle(s, c, r),
            this.pushTriangle(a, n, u),
            this.hintNormals2(s, c),
            this.hintNormals2(u, a)
        }
        twoJumpsOneExtraPoint(t, n, r, o, i, s) {
            let a = o[0]
              , u = o[1]
              , c = i[0]
              , l = i[1];
            this.pushTriangle(a, s, t),
            this.pushTriangle(a, l, s),
            this.pushTriangle(l, r, s),
            this.pushTriangle(u, n, c),
            this.hintNormals2(a, l),
            this.hintNormals2(c, u)
        }
        oneExtraPoint(t, n, r, o) {
            this.pushTriangle(o, r, t),
            this.pushTriangle(o, n, r)
        }
        oneExtraPointOneVertexCrease(t, n, r, o) {
            let i = this.copyVertex(r);
            this.pushTriangle(o, i, t),
            this.pushTriangle(o, n, i),
            this.hintNormal1(i, t, n)
        }
        twoExtraPoints(t, n, r, o, i) {
            this.pushTriangle(o, r, t),
            this.pushTriangle(o, i, r),
            this.pushTriangle(o, n, i)
        }
        threeExtraPoints(t, n, r, o, i, s) {
            this.pushTriangle(o, s, t),
            this.pushTriangle(o, i, s),
            this.pushTriangle(o, n, i),
            this.pushTriangle(i, r, s)
        }
        oneEdgeJumpOneVertexCrease(t, n, r, o) {
            let i = o[0]
              , s = o[1]
              , a = this.copyVertex(r)
              , u = this.copyVertex(r);
            this.pushTriangle(i, a, t),
            this.pushTriangle(s, n, u),
            this.hintNormals2(u, s),
            this.hintNormals2(i, a)
        }
        threeVertexCrease(t, n, r) {
            let o = this.copyVertex(t)
              , i = this.copyVertex(n)
              , s = this.copyVertex(r);
            this.pushTriangle(o, i, s),
            this.hintNormals2(o, i),
            this.hintNormalFirstBad(s, o)
        }
        twoVertexCrease(t, n, r) {
            let o = this.copyVertex(t)
              , i = this.copyVertex(n);
            this.pushTriangle(o, i, r),
            this.hintNormals2(o, i)
        }
        oneVertexCrease(t, n, r) {
            let o = this.copyVertex(t);
            this.pushTriangle(o, n, r),
            this.hintNormal1(o, n, r)
        }
        pushTrianglesBasedOnJumps(t, n, r) {
            let o = this.jumpAlongEdge(t, n)
              , i = this.jumpAlongEdge(n, r)
              , s = this.jumpAlongEdge(r, t);
            if (o && i && s) {
                let f = this.getUV(t)
                  , h = this.getUV(n)
                  , x = this.getUV(r)
                  , T = this.addVertex(this.fn(Mr(f, Mr(h, x, .5), 1e-4)))
                  , P = this.addVertex(this.fn(Mr(h, Mr(x, f, .5), 1e-4)))
                  , C = this.addVertex(this.fn(Mr(x, Mr(f, h, .5), 1e-4)))
                  , S = this.jumpAlongEdge(T, P)
                  , E = this.jumpAlongEdge(P, C)
                  , M = this.jumpAlongEdge(C, T);
                if (S && E && M)
                    return;
                t = T,
                n = P,
                r = C,
                o = S,
                i = E,
                s = M
            }
            let a = this.getNormal(t), u = this.getNormal(n), c = this.getNormal(r), l = this.isVertexAtCrease(t), p = this.isVertexAtCrease(n), m = this.isVertexAtCrease(r), d, y, g;
            if (!l && !p && !o && L0(a, u)) {
                let f = this.edgeNormalFeature(t, n);
                f !== null && (f.type === "high-curvature" ? d = f.pos : o = [f.left, f.right])
            }
            if (!p && !m && !i && L0(u, c)) {
                let f = this.edgeNormalFeature(n, r);
                f !== null && (f.type === "high-curvature" ? y = f.pos : i = [f.left, f.right])
            }
            if (!m && !l && !s && L0(c, a)) {
                let f = this.edgeNormalFeature(r, t);
                f !== null && (f.type === "high-curvature" ? g = f.pos : s = [f.left, f.right])
            }
            o && i ? g ? this.twoJumpsOneExtraPoint(t, n, r, o, i, g) : this.twoJumps(t, n, r, o, i) : i && s ? d ? this.twoJumpsOneExtraPoint(n, r, t, i, s, d) : this.twoJumps(n, r, t, i, s) : s && o ? y ? this.twoJumpsOneExtraPoint(r, t, n, s, o, y) : this.twoJumps(r, t, n, s, o) : o ? m ? this.oneEdgeJumpOneVertexCrease(t, n, r, o) : y && g ? this.oneJumpTwoExtra(t, n, r, o, y, g) : y ? this.oneJumpOneExtra(t, n, r, o, y) : g ? this.oneJumpOneExtra2(t, n, r, o, g) : this.oneJump(t, n, r, o) : i ? l ? this.oneEdgeJumpOneVertexCrease(n, r, t, i) : g && d ? this.oneJumpTwoExtra(n, r, t, i, g, d) : g ? this.oneJumpOneExtra(n, r, t, i, g) : d ? this.oneJumpOneExtra2(n, r, t, i, d) : this.oneJump(n, r, t, i) : s ? p ? this.oneEdgeJumpOneVertexCrease(r, t, n, s) : d && y ? this.oneJumpTwoExtra(r, t, n, s, d, y) : d ? this.oneJumpOneExtra(r, t, n, s, d) : y ? this.oneJumpOneExtra2(r, t, n, s, y) : this.oneJump(r, t, n, s) : l && p && m ? this.threeVertexCrease(t, n, r) : l && p ? this.twoVertexCrease(t, n, r) : p && m ? this.twoVertexCrease(n, r, t) : m && l ? this.twoVertexCrease(r, t, n) : l ? y ? this.oneExtraPointOneVertexCrease(n, r, t, y) : this.oneVertexCrease(t, n, r) : p ? g ? this.oneExtraPointOneVertexCrease(r, t, n, g) : this.oneVertexCrease(n, r, t) : m ? d ? this.oneExtraPointOneVertexCrease(t, n, r, d) : this.oneVertexCrease(r, t, n) : d && y && g ? this.threeExtraPoints(t, n, r, d, y, g) : d && y ? this.twoExtraPoints(t, n, r, d, y) : y && g ? this.twoExtraPoints(n, r, t, y, g) : g && d ? this.twoExtraPoints(r, t, n, g, d) : d ? this.oneExtraPoint(t, n, r, d) : y ? this.oneExtraPoint(n, r, t, y) : g ? this.oneExtraPoint(r, t, n, g) : this.pushTriangle(t, n, r)
        }
        oneNonFinite(t, n, r) {
            let o = this.finiteAlongEdge(n, r)
              , i = this.finiteAlongEdge(t, r);
            i !== void 0 && o !== void 0 && (this.pushTrianglesBasedOnJumps(o, t, n),
            this.pushTrianglesBasedOnJumps(o, i, t),
            this.hintNormals2Finite(o, i))
        }
        twoNonFinite(t, n, r) {
            let o = this.finiteAlongEdge(t, n)
              , i = this.finiteAlongEdge(t, r);
            o !== void 0 && i !== void 0 && (this.pushTrianglesBasedOnJumps(t, o, i),
            this.hintNormals2Finite(o, i))
        }
        pushTriangles(t, n, r) {
            let o = this.allowVertex(t)
              , i = this.allowVertex(n)
              , s = this.allowVertex(r);
            o && i && s ? this.pushTrianglesBasedOnJumps(t, n, r) : o && i ? this.oneNonFinite(t, n, r) : i && s ? this.oneNonFinite(n, r, t) : s && o ? this.oneNonFinite(r, t, n) : o ? this.twoNonFinite(t, n, r) : i ? this.twoNonFinite(n, r, t) : s && this.twoNonFinite(r, t, n)
        }
    }
      , Ad = class extends G0 {
        triangulate() {
            let t = this.resolution
              , {uRange: n, vRange: r, fn: o} = this
              , i = [n.min, r.min]
              , s = [n.max, r.max]
              , a = t - 1
              , u = new Array(t * t);
            u[0] = this.addVertex(o(i));
            for (let c = 1; c <= a; c++)
                u[c] = this.addVertex(o(Qg(i, s, [c / a, 0]))),
                u[t * c] = this.addVertex(o(Qg(i, s, [0, c / a])));
            for (let c = 1; c <= a; c++)
                for (let l = 1; l <= a; l++) {
                    let p = u[(l - 1) * t + (c - 1)]
                      , m = u[l * t + (c - 1)]
                      , d = u[(l - 1) * t + c]
                      , y = this.addVertex(o(Qg(i, s, [c / a, l / a])));
                    u[l * t + c] = y,
                    (c + l) % 2 === 0 ? (this.pushTriangles(p, y, m),
                    this.pushTriangles(p, d, y)) : (this.pushTriangles(p, d, m),
                    this.pushTriangles(d, y, m))
                }
            return {
                triangles: this.getTriangles(),
                normalDirHints: this.normalDirHints
            }
        }
    }
    ;
    function MY(e) {
        let t = e[0] * Math.SQRT1_2
          , n = e[1] * Math.SQRT1_2;
        return [t + n, n - t]
    }
    function Yx(e) {
        let t = e[0] * Math.SQRT1_2
          , n = e[1] * Math.SQRT1_2;
        return [t - n, t + n]
    }
    function DY(e) {
        return [e[1], -e[0]]
    }
    function F0(e) {
        return [-e[1], e[0]]
    }
    var Be = class {
        constructor(t, n) {
            this.min = t;
            this.max = n
        }
        get width() {
            return this.max - this.min
        }
    }
    ;
    var q0 = class extends Ad {
        constructor(n, r, o, i, s, a=[0, 1, 2]) {
            let u = r.width / 1e8
              , c = o.width / 1e8;
            super({
                resolution: s,
                uRange: r,
                vRange: o,
                du: u,
                dv: c,
                extraAttrCount: 0
            });
            this.vertices = [];
            this.fn = n => {
                let r = this._fn(n)
                  , o = this.tangentInForcedDf(n, [this.du, 0], r)
                  , i = this.tangentInForcedDf(n, [0, this.dv], r)
                  , s = mm([this.du, 0, o], [0, this.dv, i]);
                return {
                    uv: n,
                    f: r,
                    normal: [s[this.perm0], s[this.perm1], s[this.perm2]],
                    dfEast: o,
                    dfNorth: i
                }
            }
            ;
            this._fn = l => n(l[0], l[1]),
            this.paddedOutputDomain = new Be(i.min - 5 * i.width,i.max + 5 * i.width),
            this.jumpTolerance = i.width / 1e3,
            this.perm0 = a[0],
            this.perm1 = a[1],
            this.perm2 = a[2]
        }
        getVertexCount() {
            return this.vertices.length
        }
        getUV(n) {
            return this.vertices[n].uv
        }
        getNormal(n) {
            return this.vertices[n].normal
        }
        _addVertex(n) {
            return this.vertices.push(n) - 1
        }
        copyVertex(n) {
            return this.addVertex(this.vertices[n])
        }
        getF(n) {
            return this.vertices[n].f
        }
        getDfNorth(n) {
            return this.vertices[n].dfNorth
        }
        getDfEast(n) {
            return this.vertices[n].dfEast
        }
        tangentInForcedDf(n, r, o) {
            let i = gf(n, r);
            return this._fn(i) - o
        }
        tangentInForced(n, r, o) {
            let i = gf(n, r);
            return [r[0], r[1], this._fn(i) - o]
        }
        getExtraAttr() {
            throw new Error("Unexpected getExtraAttr call in explicit-surface.ts")
        }
        _isVertexAtCrease(n) {
            let r = this.getUV(n)
              , o = this.getDfEast(n)
              , i = this.getDfNorth(n)
              , s = this.getF(n)
              , a = this.tangentInForcedDf(r, [-this.du, 0], s);
            if ((-this.duSquared + a * o) / Math.sqrt((this.duSquared + a * a) * (this.duSquared + o * o)) > -wd)
                return !0;
            let l = this.tangentInForcedDf(r, [0, -this.dv], s);
            return (-this.dvSquared + i * l) / Math.sqrt((this.dvSquared + i * i) * (this.dvSquared + l * l)) > -wd
        }
        hintedNormal(n, r) {
            let o = this.getUV(n)
              , i = this.getF(n)
              , s = mm(this.tangentInForced(o, r[0], i), this.tangentInForced(o, r[1], i));
            return dm(...s) ? [s[this.perm0], s[this.perm1], s[this.perm2]] : this.getNormal(n)
        }
        getVertex(n) {
            if (!this.allowVertex(n))
                return;
            let r = this.getF(n)
              , o = this.getUV(n);
            return [this.perm0 === 2 ? r : o[this.perm0], this.perm1 === 2 ? r : o[this.perm1], this.perm2 === 2 ? r : o[this.perm2]]
        }
        findJumpBetweenTwoSamples(n, r) {
            let o = this.getUV(n)
              , i = this.getF(n)
              , s = 0
              , a = this.getUV(r)
              , u = this.getF(r)
              , c = 1
              , l = m => this._fn(Mr(o, a, m));
            if (!isFinite(i) || !isFinite(u))
                return;
            let p = lN(s, i, c, u, l, this.jumpTolerance);
            if (p)
                return [this.fn(Mr(o, a, Rs(p[0], 0, 1e-5))), this.fn(Mr(o, a, Rs(p[1], 1, 1e-5)))]
        }
        findFiniteBetweenTwoSamples(n, r) {
            let o = this.getUV(n)
              , i = this.getF(n)
              , s = this.getUV(r)
              , a = this.getF(r)
              , u = p => {
                let m = this._fn(p);
                return m < this.paddedOutputDomain.min || m > this.paddedOutputDomain.max ? NaN : m
            }
              , c = p => u(Mr(o, s, p))
              , l = Yo(0, this.paddedOutputDomain.min < i && i < this.paddedOutputDomain.max ? i : NaN, 1, this.paddedOutputDomain.min < a && a < this.paddedOutputDomain.max ? a : NaN, c);
            if (l !== void 0)
                return this.fn(Mr(o, s, l))
        }
        allowVertex(n) {
            let r = this.getF(n);
            return this.paddedOutputDomain.min < r && r < this.paddedOutputDomain.max
        }
        isDegenerate(n, r, o) {
            let i = this.getUV(n)
              , s = this.getUV(r)
              , a = this.getUV(o)
              , u = this.uRange.width * 1e-6
              , c = this.vRange.width * 1e-6;
            return Math.abs(i[0] - s[0]) < u && Math.abs(i[1] - s[1]) < c || Math.abs(s[0] - a[0]) < u && Math.abs(s[1] - a[1]) < c || Math.abs(a[0] - i[0]) < u && Math.abs(a[1] - i[1]) < c
        }
    }
    ;
    function Xx(e, t, n, r, o, i=[0, 1, 2]) {
        let s = new q0(e,t,n,r,o,i);
        return Zx(s)
    }
    var Hs = class {
        constructor(t) {
            this.xtolerance = t.xtolerance || t.tolerance || 0,
            this.ytolerance = t.ytolerance || t.tolerance || 0,
            this.ztolerance = t.ztolerance || t.tolerance || 0,
            this.map = t.map,
            this.segments = [],
            this.segment = [],
            this.pivotPoint = void 0,
            this.pendingPoint = void 0
        }
        colinear(t, n, r) {
            let o = this.map(t)
              , i = this.map(n)
              , s = this.map(r)
              , a = Qs(s[0], s[1], s[2] || 0, o[0], o[1], o[2] || 0, i[0], i[1], i[2] || 0);
            if (a < 1)
                return !1;
            let u = [o[0] + a * (i[0] - o[0]), o[1] + a * (i[1] - o[1]), o.length === 3 ? o[2] + a * (i[2] - o[2]) : 0];
            return Math.abs(s[0] - u[0]) <= this.xtolerance && Math.abs(s[1] - u[1]) <= this.ytolerance && (o.length === 2 || Math.abs(s[2] - u[2]) <= this.ztolerance)
        }
        addPoint(t) {
            if (this.dimensions = t.length,
            this.xtolerance < 0 && this.ytolerance < 0 && (this.dimensions === 2 || this.ztolerance < 0)) {
                this.segment.push.apply(this.segment, t);
                return
            }
            if (!this.segment.length) {
                this.segment.push.apply(this.segment, t);
                return
            }
            let n = this.dimensions === 2 ? [this.segment[this.segment.length - 2], this.segment[this.segment.length - 1]] : [this.segment[this.segment.length - 3], this.segment[this.segment.length - 2], this.segment[this.segment.length - 1]];
            if (!(t[0] === n[0] && t[1] === n[1] && t[2] === n[2])) {
                if (!this.pivotPoint || !this.pendingPoint) {
                    this.pivotPoint = t,
                    this.pendingPoint = t;
                    return
                }
                (!this.colinear(n, this.pivotPoint, t) || _s(n[0] - t[0], n[1] - t[1], (n[2] || 0) - (t[2] || 0)) < _s(n[0] - this.pendingPoint[0], n[1] - this.pendingPoint[1], (n[2] || 0) - (this.pendingPoint[2] || 0))) && (this.flushPending(),
                this.pivotPoint = t),
                this.pendingPoint = t
            }
        }
        flushPending() {
            this.pendingPoint && (this.segment.push.apply(this.segment, this.pendingPoint),
            this.pivotPoint = void 0,
            this.pendingPoint = void 0)
        }
        breakSegment() {
            this.flushPending(),
            this.segment.length > (this.dimensions || 2) && this.segments.push(this.segment),
            this.segment = []
        }
        getSegments() {
            return this.breakSegment(),
            this.segments
        }
        finish() {
            return {
                segments: this.getSegments(),
                resolved: !0
            }
        }
    }
    ;
    var GL = 5
      , _Y = Math.pow(2, 14)
      , {abs: ca} = Math;
    function Zy(e, t) {
        let n = RY(e, t);
        return {
            segments: n.contours.strokeSegments,
            fillSegments: n.contours.fillSegments,
            resolved: n.quadTree.resolved
        }
    }
    function RY(e, t) {
        let n = Math.pow(2, -GL)
          , r = BL(t, n)
          , o = BL(t, 2 * n)
          , i = NY(e, r, o)
          , s = BY(i.root, e, r)
          , a = UY(s, e, r);
        return {
            paddedDomain: r,
            rootDomain: o,
            quadTree: i,
            triangles: s,
            contours: a
        }
    }
    function Fd(e, t, n) {
        return {
            x: e,
            y: t,
            z: n
        }
    }
    function Cl(e, t, n) {
        return {
            x: e,
            y: t,
            isZero: n
        }
    }
    function Wx(e, t, n) {
        return {
            vertices: [e, t, n],
            visited: !1,
            next: void 0
        }
    }
    function BL(e, t) {
        let {mathToPixels: n} = e
          , r = n.interpolateX(e.xmin, e.xmax, -t)
          , o = n.interpolateX(e.xmax, e.xmin, -t)
          , i = n.interpolateY(e.ymin, e.ymax, -t)
          , s = n.interpolateY(e.ymax, e.ymin, -t);
        return {
            ...e,
            xmin: r,
            ymin: i,
            xmax: o,
            ymax: s
        }
    }
    function ky(e, t) {
        return {
            depth: e,
            vertices: t,
            children: void 0,
            center: void 0
        }
    }
    function z0(e, t, n) {
        e.center = qL(e.vertices[0], e.vertices[1], e.vertices[2], e.vertices[3], t, n)
    }
    function NY(e, t, n) {
        let r = OY(e, n)
          , o = []
          , i = [];
        i.push(r);
        let s = 1
          , a = !0;
        e: for (; i.length; ) {
            let u = o;
            o = i,
            i = u;
            let c;
            for (; c = o.pop(); )
                if (wY(c, e, t)) {
                    if (AY(c, e, t),
                    !c.children) {
                        a = !1;
                        break e
                    }
                    if (i.push(c.children[0]),
                    i.push(c.children[1]),
                    i.push(c.children[2]),
                    i.push(c.children[3]),
                    s += 3,
                    s >= _Y) {
                        a = !1;
                        break e
                    }
                } else
                    z0(c, e, t)
        }
        for (let u = 0; u < o.length; u++)
            z0(o[u], e, t);
        for (let u = 0; u < i.length; u++)
            z0(i[u], e, t);
        return {
            root: r,
            resolved: a
        }
    }
    function OY(e, t) {
        let n = t.xmin
          , r = t.xmax
          , o = t.ymin
          , i = t.ymax;
        return ky(0, [Ld(n, i, e), Ld(r, i, e), Ld(r, o, e), Ld(n, o, e)])
    }
    function AY(e, t, n) {
        let r = e.depth + 1
          , o = e.vertices[0]
          , i = e.vertices[1]
          , s = e.vertices[2]
          , a = e.vertices[3]
          , u = ni(o, i, t, n)
          , c = ni(i, s, t, n)
          , l = ni(s, a, t, n)
          , p = ni(a, o, t, n)
          , m = ni(o, s, t, n);
        e.children = [ky(r, [o, u, m, p]), ky(r, [u, i, c, m]), ky(r, [m, c, s, l]), ky(r, [p, m, l, a])]
    }
    function wY(e, t, n) {
        if (e.depth < GL)
            return !0;
        if (FY(e, n) || LY(e, n))
            return !1;
        let r = e.vertices[0]
          , o = e.vertices[1]
          , i = e.vertices[2]
          , s = e.vertices[3];
        if (isNaN(r.z) && isNaN(o.z) && isNaN(i.z) && isNaN(s.z))
            return !1;
        if (isNaN(r.z) || isNaN(o.z) || isNaN(i.z) || isNaN(s.z))
            return !0;
        let a = qL(r, o, i, s, t, n)
          , u = Wu(r, o, t, n)
          , c = Wu(o, i, t, n)
          , l = Wu(i, s, t, n)
          , p = Wu(s, r, t, n);
        return Ml(r, u, t, n) || Ml(o, u, t, n) || Ml(o, c, t, n) || Ml(i, c, t, n) || Ml(i, l, t, n) || Ml(s, l, t, n) || Ml(s, p, t, n) || Ml(r, p, t, n) || vl(r, u, a, t, n) || vl(u, o, a, t, n) || vl(o, c, a, t, n) || vl(c, i, a, t, n) || vl(i, l, a, t, n) || vl(l, s, a, t, n) || vl(s, p, a, t, n) || vl(p, r, a, t, n)
    }
    function vl(e, t, n, r, o) {
        if (e.z > 0 == t.z > 0 && t.z > 0 == n.z > 0)
            return !1;
        let i = 0;
        isFinite(e.z) && (i = Math.max(i, Math.abs(e.z))),
        isFinite(t.z) && (i = Math.max(i, Math.abs(t.z))),
        isFinite(n.z) && (i = Math.max(i, Math.abs(n.z)));
        let s = 32 * Number.EPSILON * i, a, u, c, l;
        if (e.z > 0 == t.z > 0) {
            if (a = ni(e, t, r, o),
            a.z > 0 != e.z > 0)
                return !0;
            u = Xu(e, n, r, o, s),
            c = Xu(t, n, r, o, s),
            l = Xu(a, n, r, o, s)
        } else if (t.z > 0 == n.z > 0) {
            if (a = ni(t, n, r, o),
            a.z > 0 != t.z > 0)
                return !0;
            u = Xu(t, e, r, o, s),
            c = Xu(n, e, r, o, s),
            l = Xu(a, e, r, o, s)
        } else {
            if (a = ni(n, e, r, o),
            a.z > 0 != n.z > 0)
                return !0;
            u = Xu(n, t, r, o, s),
            c = Xu(e, t, r, o, s),
            l = Xu(a, t, r, o, s)
        }
        let {mathToPixels: p, map3d: m} = o;
        if (m) {
            let d = m(l.x, l.y)
              , y = m(u.x, u.y)
              , g = m(c.x, c.y);
            return W1(d[0], d[1], d[2], y[0], y[1], y[2], g[0], g[1], g[2]) > o.tolerance
        } else {
            let[d,y] = p.mapCoordinatePair([l.x, l.y])
              , [g,f] = p.mapCoordinatePair([u.x, u.y])
              , [h,x] = p.mapCoordinatePair([c.x, c.y]);
            return X1(d, y, g, f, h, x) > o.tolerance
        }
    }
    function Ml(e, t, n, r) {
        if (isNaN(e.z) && isNaN(t.z))
            return !1;
        if (isNaN(e.z) || isNaN(t.z))
            return e.z > 0 || t.z > 0;
        let i = 4 * ni(e, t, n, r).z - t.z - 3 * e.z
          , s = 1e-4
          , a = (n((1 - s) * e.x + s * t.x, (1 - s) * e.y + s * t.y) - e.z) / s
          , u = Math.max(Math.abs(e.z), Math.abs(t.z));
        return Math.abs(i - a) > .125 * u
    }
    function LY(e, t) {
        let {mathToPixels: n, map3d: r, tolerance: o} = t;
        if (r)
            return !1;
        {
            let[i,s] = n.mapCoordinatePair([e.vertices[1].x, e.vertices[1].y])
              , [a,u] = n.mapCoordinatePair([e.vertices[0].x, e.vertices[0].y])
              , [c,l] = n.mapCoordinatePair([e.vertices[3].x, e.vertices[3].y]);
            if (ca(i - a) < 10 * o || ca(u - l) < 10 * o)
                return !0
        }
        return !1
    }
    function FY(e, t) {
        return e.vertices[0].x < t.xmin || e.vertices[0].y > t.ymax || e.vertices[2].x > t.xmax || e.vertices[2].y < t.ymin
    }
    function Vd(e, t) {
        return e.x < t.xmin || e.x > t.xmax || e.y < t.ymin || e.y > t.ymax
    }
    function Ld(e, t, n) {
        return Fd(e, t, n(e, t))
    }
    function ni(e, t, n, r) {
        let {mathToPixels: o} = r;
        return Ld(o.interpolateX(e.x, t.x, .5), o.interpolateY(e.y, t.y, .5), n)
    }
    function Wu(e, t, n, r) {
        if (Vd(e, r) || Vd(t, r))
            return ni(e, t, n, r);
        if (isNaN(e.z) || isNaN(t.z))
            return VY(e, t, n, r);
        if (e.z > 0 != t.z > 0)
            return ni(e, t, n, r);
        let o = .01
          , i = n((1 - o) * e.x + o * t.x, (1 - o) * e.y + o * t.y) - e.z
          , s = t.z - n(o * e.x + (1 - o) * t.x, o * e.y + (1 - o) * t.y);
        return isNaN(i) || isNaN(s) || i > 0 == s > 0 ? ni(e, t, n, r) : zL(Fd(e.x, e.y, i), Fd(t.x, t.y, s), n, r)
    }
    function qL(e, t, n, r, o, i) {
        let s = Wu(e, n, o, i);
        return e.z > 0 == n.z > 0 && s.z > 0 != e.z > 0 || (s = Wu(t, r, o, i),
        t.z > 0 == r.z > 0 && s.z > 0 != t.z > 0) ? s : ni(e, n, o, i)
    }
    function zL(e, t, n, r) {
        if (isNaN(e.z))
            return t;
        if (isNaN(t.z))
            return e;
        if (!isFinite(e.z) && !isFinite(t.z))
            return ni(e, t, n, r);
        if (isFinite(e.z))
            if (isFinite(t.z)) {
                let o = 1 - e.z / t.z
                  , i = 1 - t.z / e.z;
                return Ld(e.x / o + t.x / i, e.y / o + t.y / i, n)
            } else
                return e;
        else
            return t
    }
    function Xu(e, t, n, r, o) {
        let {mathToPixels: i, map3d: s} = r
          , a = e.x
          , u = t.x
          , c = e.y
          , l = t.y
          , p = e.z
          , m = t.z;
        if (Vd(e, r) || Vd(t, r)) {
            let d = ni(e, t, n, r);
            return Cl(d.x, d.y, !1)
        }
        if (s) {
            let[d,y,g] = s(a, c)
              , [f,h,x] = s(u, l);
            for (; ca(d - f) > r.tolerance || ca(y - h) > r.tolerance || ca(g - x) > r.tolerance; ) {
                let T = .5 * (a + u)
                  , P = .5 * (c + l)
                  , C = n(T, P);
                if (C > 0 == p > 0 ? (a = T,
                c = P,
                p = C) : (u = T,
                l = P,
                m = C),
                (T === a || T === u) && (P === c || P === l))
                    break;
                [d,y,g] = s(a, c),
                [f,h,x] = s(u, l)
            }
        } else {
            let[d,y] = i.mapCoordinatePair([a, c])
              , [g,f] = i.mapCoordinatePair([u, l]);
            for (; ca(d - g) > r.tolerance || ca(y - f) > r.tolerance; ) {
                let h = .5 * (a + u)
                  , x = .5 * (c + l)
                  , T = n(h, x);
                T > 0 == p > 0 ? (a = h,
                c = x,
                p = T) : (u = h,
                l = x,
                m = T),
                [d,y] = i.mapCoordinatePair([a, c]),
                [g,f] = i.mapCoordinatePair([u, l])
            }
        }
        if (isNaN(p))
            return Cl(u, l, !1);
        if (isNaN(m))
            return Cl(a, c, !1);
        {
            let d = Math.abs(p)
              , y = Math.abs(m);
            if (d < o && y > 100 * o)
                return 1 / d >= y ? Cl(a, c, !0) : Cl(u, l, !1);
            if (y < o && d > 100 * o)
                return 1 / y >= d ? Cl(u, l, !0) : Cl(a, c, !1);
            let g = zL(Fd(a, c, p), Fd(u, l, m), n, r)
              , f = p === 0 || m === 0 || g.z === 0 || g.z >= p == m >= g.z && Math.abs(g.z) < 1e250;
            return Cl(g.x, g.y, f)
        }
    }
    function VY(e, t, n, r) {
        let {mathToPixels: o, map3d: i} = r;
        if (isNaN(e.z) === isNaN(t.z))
            return ni(e, t, n, r);
        if (isNaN(e.z)) {
            let p = e;
            e = t,
            t = p
        }
        let s = e.x
          , a = t.x
          , u = e.y
          , c = t.y
          , l = e.z;
        if (i) {
            let[p,m,d] = i(s, u)
              , [y,g,f] = i(a, c);
            for (; ca(p - y) > r.tolerance || ca(m - g) > r.tolerance || ca(d - f) > r.tolerance || isNaN(p) || isNaN(y); ) {
                let h = .5 * (s + a)
                  , x = .5 * (u + c)
                  , T = n(h, x);
                if (isNaN(T) === isNaN(l) ? (s = h,
                u = x,
                l = T) : (a = h,
                c = x),
                (h === s || h === a) && (x === u || x === c))
                    break;
                [p,m,d] = i(s, u),
                [y,g,f] = i(a, c)
            }
        } else {
            let[p,m] = o.mapCoordinatePair([s, u])
              , [d,y] = o.mapCoordinatePair([a, c]);
            for (; ca(p - d) > r.tolerance || ca(m - y) > r.tolerance; ) {
                let g = .5 * (s + a)
                  , f = .5 * (u + c)
                  , h = n(g, f);
                isNaN(h) === isNaN(l) ? (s = g,
                u = f,
                l = h) : (a = g,
                c = f),
                [p,m] = o.mapCoordinatePair([s, u]),
                [d,y] = o.mapCoordinatePair([a, c])
            }
        }
        return Fd(s, u, l)
    }
    function BY(e, t, n) {
        let r = {
            triangles: [],
            edgeCache: {},
            domain: n,
            fn: t
        };
        return $y(e, r),
        r.triangles
    }
    function $y(e, t) {
        e.children && ($y(e.children[0], t),
        $y(e.children[1], t),
        $y(e.children[2], t),
        $y(e.children[3], t),
        Dl(e.children[0], e.children[1], t),
        Dl(e.children[3], e.children[2], t),
        _l(e.children[1], e.children[2], t),
        _l(e.children[0], e.children[3], t))
    }
    function Dl(e, t, n) {
        e.children && t.children ? (Dl(e.children[1], t.children[0], n),
        Dl(e.children[2], t.children[3], n)) : e.children ? (Dl(e.children[1], t, n),
        Dl(e.children[2], t, n)) : t.children ? (Dl(e, t.children[0], n),
        Dl(e, t.children[3], n)) : GY(e, t, n)
    }
    function _l(e, t, n) {
        e.children && t.children ? (_l(e.children[2], t.children[1], n),
        _l(e.children[3], t.children[0], n)) : e.children ? (_l(e.children[2], t, n),
        _l(e.children[3], t, n)) : t.children ? (_l(e, t.children[1], n),
        _l(e, t.children[0], n)) : qY(e, t, n)
    }
    function GY(e, t, n) {
        if (!e.center || !t.center)
            return;
        let r, o;
        e.depth >= t.depth ? (r = Wu(e.vertices[1], e.vertices[2], n.fn, n.domain),
        o = Qx(e.vertices[1], t.center, e.vertices[2], e.center, r)) : (r = Wu(t.vertices[0], t.vertices[3], n.fn, n.domain),
        o = Qx(t.vertices[0], t.center, t.vertices[3], e.center, r)),
        HL(o, n.edgeCache, n.domain);
        for (let i = 0; i < 4; i++)
            n.triangles.push(o[i])
    }
    function qY(e, t, n) {
        if (!e.center || !t.center)
            return;
        let r, o;
        e.depth >= t.depth ? (r = Wu(e.vertices[3], e.vertices[2], n.fn, n.domain),
        o = Qx(e.vertices[2], t.center, e.vertices[3], e.center, r)) : (r = Wu(t.vertices[1], t.vertices[0], n.fn, n.domain),
        o = Qx(t.vertices[1], t.center, t.vertices[0], e.center, r)),
        HL(o, n.edgeCache, n.domain);
        for (let i = 0; i < 4; i++)
            n.triangles.push(o[i])
    }
    function Qx(e, t, n, r, o) {
        return [Wx(e, o, t), Wx(t, o, n), Wx(n, o, r), Wx(r, o, e)]
    }
    function Yy(e, t, n) {
        return e.z > 0 && !Vd(e, n) && (!(t.z > 0) || Vd(t, n))
    }
    function jx(e, t) {
        return "" + e.x + "," + e.y + "," + t.x + "," + t.y
    }
    function HL(e, t, n) {
        Jx(e[0], e[1], e[2], jx(e[1].vertices[2], e[1].vertices[0]), t, n),
        Jx(e[1], e[2], e[3], jx(e[2].vertices[0], e[2].vertices[2]), t, n),
        Jx(e[2], e[3], e[0], jx(e[3].vertices[2], e[3].vertices[0]), t, n),
        Jx(e[3], e[0], e[1], jx(e[0].vertices[0], e[0].vertices[2]), t, n)
    }
    function Jx(e, t, n, r, o, i) {
        let s = t.vertices[0]
          , a = t.vertices[1]
          , u = t.vertices[2];
        Yy(a, u, i) && (t.next = n),
        Yy(s, a, i) && (t.next = e),
        Yy(u, s, i) && HY(t, r, o),
        Yy(s, u, i) && zY(t, r, o)
    }
    function zY(e, t, n) {
        n[t] ? n[t].next = e : n[t] = e
    }
    function HY(e, t, n) {
        n[t] ? e.next = n[t] : n[t] = e
    }
    function UY(e, t, n) {
        let {tolerance: r, mathToPixels: o, map3d: i} = n, s;
        if (i) {
            let a = {
                tolerance: r,
                map: u => i(u[0], u[1])
            };
            s = {
                fillAccumulator: new Hs(a),
                strokeAccumulator: new Hs(a),
                fn: t,
                domain: n
            }
        } else {
            let a = {
                tolerance: r,
                map: u => o.mapCoordinatePair(u)
            };
            s = {
                fillAccumulator: new Hs(a),
                strokeAccumulator: new Hs(a),
                fn: t,
                domain: n
            }
        }
        for (let a = 0; a < e.length; a++) {
            let u = e[a];
            u.next && !u.visited && kY(u, s)
        }
        return {
            strokeSegments: s.strokeAccumulator.finish().segments,
            fillSegments: s.fillAccumulator.finish().segments
        }
    }
    function kY(e, t) {
        for (; ; ) {
            let n = e.vertices[0]
              , r = e.vertices[1]
              , o = e.vertices[2]
              , i = 0;
            isFinite(n.z) && (i = Math.max(i, Math.abs(n.z))),
            isFinite(r.z) && (i = Math.max(i, Math.abs(r.z))),
            isFinite(o.z) && (i = Math.max(i, Math.abs(o.z)));
            let s = 32 * Number.EPSILON * i;
            if (H0(n, r, t, s),
            H0(r, o, t, s),
            H0(o, n, t, s),
            e.visited || !e.next)
                break;
            e.visited = !0,
            e = e.next
        }
        t.strokeAccumulator.breakSegment(),
        t.fillAccumulator.breakSegment()
    }
    function H0(e, t, n, r) {
        if (Yy(e, t, n.domain)) {
            let o = Xu(e, t, n.fn, n.domain, r);
            n.fillAccumulator.addPoint([o.x, o.y]),
            o.isZero ? n.strokeAccumulator.addPoint([o.x, o.y]) : n.strokeAccumulator.breakSegment()
        }
    }
    function U0(e, t) {
        return {
            type: "linear",
            s: e,
            t
        }
    }
    function UL(e, t) {
        return {
            type: "logarithmic",
            s: e,
            t
        }
    }
    function kL(e, t) {
        return {
            type: "exponential",
            s: e,
            t
        }
    }
    function k0() {
        return U0(1, 0)
    }
    function $Y([e,t], [n,r]) {
        let o = (r - n) / (t - e)
          , i = (n + r) / 2 - o * (t + e) / 2;
        return U0(o, i)
    }
    function YY([e,t], [n,r]) {
        let o = (r - n) / (Math.log(t) - Math.log(e))
          , i = (Math.log(t) * n - Math.log(e) * r) / (Math.log(t) - Math.log(e));
        return UL(o, i)
    }
    function ZY([e,t], [n,r]) {
        let o = (Math.log(r) - Math.log(n)) / (t - e)
          , i = (t * Math.log(n) - e * Math.log(r)) / (t - e);
        return kL(o, i)
    }
    function $0(e, t, n) {
        switch (e) {
        case "linear":
            return $Y(t, n);
        case "logarithmic":
            return YY(t, n);
        case "exponential":
            return ZY(t, n);
        default:
            {
                let r = e;
                throw new Error("Unexpected scale type: " + r)
            }
        }
    }
    function Y0({type: e, s: t, t: n}, r) {
        switch (e) {
        case "linear":
            return t * r + n;
        case "logarithmic":
            return t * Math.log(r) + n;
        case "exponential":
            return Math.exp(t * r + n);
        default:
            let o = e;
            throw new Error("Unexpected scale type: " + o)
        }
    }
    function Z0(e, t, n, r) {
        switch (e) {
        case "linear":
            return XY(t, n, r);
        case "logarithmic":
            return Math.pow(t, 1 - r) * Math.pow(n, r);
        case "exponential":
            return r === 0 ? t : r === 1 ? n : Math.log((1 - r) * Math.exp(t) + r * Math.exp(n));
        default:
            let o = e;
            throw new Error("Unexpected scale type: " + o)
        }
    }
    function XY(e, t, n) {
        return (1 - n) * e + n * t
    }
    function X0({type: e, s: t, t: n}) {
        switch (e) {
        case "linear":
            return U0(1 / t, -n / t);
        case "logarithmic":
            return kL(1 / t, -n / t);
        case "exponential":
            return UL(1 / t, -n / t);
        default:
            let r = e;
            throw new Error("Unexpected scale type: " + r)
        }
    }
    function W0(e) {
        switch (e) {
        case "linear":
            return "linear";
        case "logarithmic":
            return "exponential";
        case "exponential":
            return "logarithmic";
        default:
            let t = e;
            throw new Error("Unexpected scale type: " + t)
        }
    }
    function Kx({width: e, height: t}) {
        return {
            left: 0,
            right: e,
            top: 0,
            bottom: t
        }
    }
    function eT({xmin: e, xmax: t, ymin: n, ymax: r}) {
        return {
            left: e,
            right: t,
            bottom: n,
            top: r
        }
    }
    var Rl = class e {
        constructor(t, n) {
            this.xScale = t,
            this.yScale = n
        }
        static fromRects(t, n, {xAxisScale: r, yAxisScale: o}) {
            return new e($0(r, [t.left, t.right], [n.left, n.right]),$0(o, [t.bottom, t.top], [n.bottom, n.top]))
        }
        static fromRectsInverse(t, n, {xAxisScale: r, yAxisScale: o}) {
            return e.fromRects(n, t, {
                xAxisScale: W0(r),
                yAxisScale: W0(o)
            })
        }
        inverse() {
            return new e(X0(this.xScale),X0(this.yScale))
        }
        mapX(t) {
            return Y0(this.xScale, t)
        }
        mapY(t) {
            return Y0(this.yScale, t)
        }
        mapPoint({x: t, y: n}) {
            return {
                x: this.mapX(t),
                y: this.mapY(n)
            }
        }
        mapCoordinatePair([t,n]) {
            return [this.mapX(t), this.mapY(n)]
        }
        mapRect({top: t, bottom: n, left: r, right: o}) {
            return {
                left: this.mapX(r),
                right: this.mapX(o),
                bottom: this.mapY(n),
                top: this.mapY(t)
            }
        }
        interpolateX(t, n, r) {
            return Z0(this.xScale.type, t, n, r)
        }
        interpolateY(t, n, r) {
            return Z0(this.yScale.type, t, n, r)
        }
        dangerouslyGetXScaleFactor() {
            if (this.xScale.type !== "linear")
                throw new Error(`Cannot get scale factor a '${this.xScale.type}' scale`);
            return this.xScale.s
        }
        dangerouslyGetYScaleFactor() {
            if (this.yScale.type !== "linear")
                throw new Error(`Cannot get scale factor a '${this.yScale.type}' scale`);
            return this.yScale.s
        }
    }
    ;
    function tT(e, t, n, r) {
        let o = [], i = [], s = [], a = [], {xmin: u, xmax: c, ymin: l, ymax: p, zmin: m, zmax: d} = n, y, g, f;
        switch (r) {
        case "z":
            y = {
                xmin: u,
                xmax: c,
                ymin: l,
                ymax: p
            },
            g = (P, C) => [P[C], P[C + 1], m, P[C], P[C + 1], d],
            f = (P, C) => e(P, C, 0);
            break;
        case "y":
            y = {
                xmin: u,
                xmax: c,
                ymin: m,
                ymax: d
            },
            g = (P, C) => [P[C], l, P[C + 1], P[C], p, P[C + 1]],
            f = (P, C) => e(P, 0, C);
            break;
        case "x":
            y = {
                xmin: m,
                xmax: d,
                ymin: l,
                ymax: p
            },
            g = (P, C) => [u, P[C + 1], P[C], c, P[C + 1], P[C]],
            f = (P, C) => e(0, C, P);
            break
        }
        let h = Kx({
            width: 500,
            height: 500
        })
          , x = {
            ...y,
            mathToPixels: Rl.fromRects(eT(y), h, {
                xAxisScale: "linear",
                yAxisScale: "linear"
            }),
            tolerance: la
        }
          , T = Zy(f, x);
        for (let P of T.segments)
            for (let C = 0; C < P.length / 2; C++) {
                let[S,E,M,_,U,Q] = g(P, 2 * C);
                if (o.push(S, E, M, _, U, Q),
                s.push(S, E, _, U),
                t) {
                    let K = t(S, E, M)
                      , w = t(_, U, Q);
                    i.push(K[0], K[1], K[2]),
                    i.push(w[0], w[1], w[2])
                } else
                    i.push(0, 0, 0),
                    i.push(0, 0, 0);
                if (C > 0) {
                    let K = o.length / 3 - 4;
                    a.push(K, K + 1, K + 2),
                    a.push(K + 2, K + 1, K + 3)
                }
            }
        return Od(a, o, i, s, 0, [], .7),
        {
            positions: o,
            normals: i,
            faces: a,
            uvs: s,
            resolved: T.resolved,
            extraAttrs: []
        }
    }
    var nT = [[1, 2, 4, 21, 20, 18], [0, 1, 3, 20, 19, 18], [2, 6, 7, 25, 21, 18], [5, 6, 8, 25, 22, 18], [5, 9, 11, 23, 22, 18], [0, 9, 10, 23, 19, 18], [10, 12, 14, 24, 23, 19], [3, 12, 13, 24, 20, 19], [4, 13, 15, 24, 21, 20], [15, 7, 16, 25, 24, 21], [11, 17, 14, 24, 23, 22], [17, 8, 16, 25, 24, 22]]
      , so = [0, 1, 0, 2, 0, 3, 1, 2, 2, 3, 0, 4, 0, 7, 3, 7, 4, 7, 0, 5, 1, 5, 4, 5, 1, 6, 2, 6, 5, 6, 3, 6, 6, 7, 4, 6, 0, 8, 1, 8, 2, 8, 3, 8, 4, 8, 5, 8, 6, 8, 7, 8]
      , YL = [[0, 2, 3, 8], [0, 1, 2, 8], [0, 3, 7, 8], [0, 4, 7, 8], [0, 4, 5, 8], [0, 1, 5, 8], [1, 5, 6, 8], [1, 2, 6, 8], [2, 3, 6, 8], [3, 6, 7, 8], [4, 5, 6, 8], [4, 6, 7, 8]]
      , ZL = [[0, 0, 0], [0, 1, 0], [1, 1, 0], [1, 0, 0], [0, 0, 1], [0, 1, 1], [1, 1, 1], [1, 0, 1], [.5, .5, .5]]
      , j0 = [[1, 2, 4], [4, 20, 21], [2, 18, 21], [1, 18, 20], [0, 1, 3], [3, 19, 20], [0, 18, 19], [2, 6, 7], [7, 21, 25], [6, 18, 25], [5, 6, 8], [8, 22, 25], [5, 18, 22], [5, 9, 11], [11, 22, 23], [9, 18, 23], [0, 9, 10], [10, 19, 23], [10, 12, 14], [14, 23, 24], [12, 19, 24], [3, 12, 13], [13, 20, 24], [4, 13, 15], [15, 21, 24], [15, 7, 16], [16, 24, 25], [11, 17, 14], [17, 22, 24], [17, 8, 16]]
      , J0 = [];
    for (let e = 0; e < 30; e++) {
        let t = j0[e]
          , n = new Set;
        for (let r of t)
            n.add(so[r * 2]),
            n.add(so[r * 2 + 1]);
        J0[e] = [...n]
    }
    var XL = [[0, 3, 2, 1], [4, 6, 3, 5], [7, 2, 9, 8], [10, 12, 9, 11], [13, 12, 15, 14], [16, 6, 15, 17], [18, 17, 20, 19], [21, 5, 20, 22], [23, 1, 22, 24], [25, 24, 8, 26], [27, 14, 28, 19], [29, 28, 11, 26]]
      , jY = 1 << 31
      , JY = 1 << 30
      , $L = 1 << 24
      , Bp = 1 << 24
      , Us = 1 << 24
      , pa = 65536
      , ma = 256
      , da = 1;
    function WL(e, t, n) {
        return n * pa + t * ma + e * da
    }
    var QY = {
        0: 0 * $L,
        1: ma,
        2: da + ma,
        3: da,
        4: pa,
        5: ma + pa,
        6: da + ma + pa,
        7: da + pa,
        8: 8 * $L
    };
    function jL(e, t) {
        return jY + e + QY[t]
    }
    var KY = {
        3: 2 * Us + ma,
        4: 0 * Us + da,
        7: 5 * Us + da,
        8: 2 * Us + pa,
        10: 5 * Us + ma,
        11: 0 * Us + pa,
        12: 6 * Us + ma,
        13: 5 * Us + da + ma,
        14: 2 * Us + ma + pa,
        15: 9 * Us + da,
        16: 0 * Us + da + pa,
        17: 1 * Us + pa
    };
    function Xy(e, t) {
        var n;
        return JY + e + ((n = KY[t]) != null ? n : Us * t)
    }
    var eZ = {
        18: 10 * Bp + ma,
        21: 7 * Bp + ma,
        23: 16 * Bp + da,
        25: 13 * Bp + da,
        27: 4 * Bp + pa,
        29: 0 * Bp + pa
    };
    function Q0(e, t) {
        var n;
        return e + ((n = eZ[t]) != null ? n : Bp * t)
    }
    var Bd = class {
        constructor(t, n, r, o, i) {
            this.PAConstructor = t;
            this.x = n;
            this.y = r;
            this.z = o;
            this.gridsize = i;
            this.i = 0;
            this.j = 0;
            this.k = 0;
            this.cubeVertex = new Array(9);
            this.cubeVertexValue = new this.PAConstructor(9);
            if (i > 250)
                throw new Error("Programming Error: resolution should be clamped well below 250.");
            this.size = new it(this.x.width / i,this.y.width / i,this.z.width / i)
        }
        loopOverUnitCubes(t) {
            let n = this.gridsize
              , r = n + 1
              , o = new rT(this.x.min,this.y.min,this.z.min,this.size.x,this.size.y,this.size.z,n + 1,n + 1,n + 1)
              , i = new rT(this.x.min + this.size.x / 2,this.y.min + this.size.y / 2,this.z.min + this.size.z / 2,this.size.x,this.size.y,this.size.z,n,n,n)
              , s = o.setupArray(this.PAConstructor)
              , a = o.setupArray(this.PAConstructor)
              , u = i.setupArray(this.PAConstructor);
            this.evaluateArray(a, o, 0);
            for (let c = 0; c < n; c++) {
                this.k = c,
                [s,a] = [a, s],
                this.evaluateArray(a, o, c + 1),
                this.evaluateArray(u, i, c);
                for (let l = 0; l < n; l++) {
                    this.j = l;
                    for (let p = 0; p < n; p++) {
                        this.i = p;
                        let m = l * r + p;
                        this.cubeVertexValue.setFrom(0, s, m),
                        this.cubeVertexValue.setFrom(1, s, m + r),
                        this.cubeVertexValue.setFrom(2, s, m + r + 1),
                        this.cubeVertexValue.setFrom(3, s, m + 1),
                        this.cubeVertexValue.setFrom(4, a, m),
                        this.cubeVertexValue.setFrom(5, a, m + r),
                        this.cubeVertexValue.setFrom(6, a, m + r + 1),
                        this.cubeVertexValue.setFrom(7, a, m + 1),
                        this.cubeVertexValue.setFrom(8, u, l * n + p),
                        t()
                    }
                }
            }
        }
        evaluateArray(t, n, r) {
            let o = n.z0 + r * n.dz;
            for (let i = 0; i < n.numX; i++)
                for (let s = 0; s < n.numY; s++) {
                    let a = n.x0 + i * n.dx
                      , u = n.y0 + s * n.dy;
                    this.setAt(t, s * n.numX + i, a, u, o)
                }
        }
        setVertexPositions() {
            for (let t = 0; t < 9; t++) {
                let n = ZL[t];
                this.cubeVertex[t] = [this.x.min + (this.i + n[0]) * this.size.x, this.y.min + (this.j + n[1]) * this.size.y, this.z.min + (this.k + n[2]) * this.size.z]
            }
        }
    }
      , rT = class {
        constructor(t, n, r, o, i, s, a, u, c) {
            this.x0 = t;
            this.y0 = n;
            this.z0 = r;
            this.dx = o;
            this.dy = i;
            this.dz = s;
            this.numX = a;
            this.numY = u;
            this.numZ = c
        }
        setupArray(t) {
            return new t(this.numX * this.numY)
        }
    }
    ;
    var oT = class {
        constructor(t) {
            this.length = t;
            this.n = 1;
            this.buffer = new Float64Array(t)
        }
        set(t, n) {
            this.buffer[t] = n
        }
        get(t) {
            return this.buffer[t]
        }
        setFrom(t, n, r) {
            if (n.n !== this.n)
                throw new Error("Programming Error: Mismatched dimensions");
            this.set(t, n.get(r))
        }
    }
      , iT = class {
        constructor(t) {
            this.length = t;
            this.n = 2;
            this.buffer = new Float64Array(t * 2)
        }
        set(t, n, r) {
            this.buffer[t * 2] = n,
            this.buffer[t * 2 + 1] = r
        }
        getX(t) {
            return this.buffer[t * 2]
        }
        getY(t) {
            return this.buffer[t * 2 + 1]
        }
        setFrom(t, n, r) {
            if (n.n !== this.n)
                throw new Error("Programming Error: Mismatched dimensions");
            this.set(t, n.getX(r), n.getY(r))
        }
    }
    ;
    function Wy(e, t, n, r, o, i=100) {
        if (isFinite(r) || ([r,o] = [o, r],
        [t,n] = [n, t]),
        isFinite(o))
            return K0(e, t, n, r, o, i);
        for (; ; ) {
            let s = Ns(t, n, .5)
              , a = e(...s);
            if (a === 0)
                return s;
            if (!isFinite(a))
                n = s,
                o = a;
            else if (r < 0 == a < 0)
                t = s,
                r = a;
            else
                return n = s,
                o = a,
                K0(e, t, n, r, o, i);
            if (i *= .5,
            i < 1)
                return
        }
    }
    function JL(e, t, n, r, o, i=100) {
        if (isFinite(r) || ([r,o] = [o, r],
        [t,n] = [n, t]),
        !isFinite(o))
            for (; ; ) {
                let s = Ns(t, n, .5)
                  , a = e(...s);
                if (a === 0)
                    return {
                        posNeg: s
                    };
                if (!isFinite(a))
                    n = s,
                    o = a;
                else if (r < 0 == a < 0)
                    t = s,
                    r = a;
                else if (r > 0) {
                    n = s,
                    o = a;
                    break
                } else
                    return {
                        posNeg: eD(e, s, t, a, r, i),
                        posNaN: tZ(e, s, n, i)
                    };
                if (i *= .5,
                i < 1) {
                    let u = Ns(t, n, .5);
                    return r > 0 ? {
                        posNaN: u
                    } : {}
                }
            }
        return {
            posNeg: K0(e, t, n, r, o, i)
        }
    }
    function K0(e, t, n, r, o, i) {
        return r > 0 ? eD(e, t, n, r, o, i) : eD(e, n, t, o, r, i)
    }
    function eD(e, t, n, r, o, i) {
        let s = r - o;
        for (; ; ) {
            let a = Ns(t, n, .5)
              , u = e(...a);
            if (u < 0)
                n = a,
                o = u;
            else if (u > 0)
                t = a,
                r = u;
            else
                return u === 0 ? a : void 0;
            if (i *= .5,
            i < 1) {
                if (r - o < .1 * s)
                    return Ns(t, n, .5);
                if (i < 1e-6)
                    return
            }
        }
    }
    function tZ(e, t, n, r) {
        for (; ; ) {
            let o = Ns(t, n, .5)
              , i = e(...o);
            if (!isFinite(i))
                n = o;
            else if (i >= 0)
                t = o;
            else
                return;
            if (r *= .5,
            r < 1)
                return Ns(t, n, .5)
        }
    }
    var Jy = 50;
    function Gp(e) {
        return e !== void 0 && e !== 0
    }
    function nZ(e) {
        return Gp(e.posNeg) || Gp(e.posNaN)
    }
    var jy = {};
    function tD(e=jy, t=jy, n=jy) {
        return {
            edge0: e,
            edge1: t,
            edge2: n
        }
    }
    function QL(e, t, n, r, {isInequality: o}) {
        return new nD(e,t,new Be(n.xmin,n.xmax),new Be(n.ymin,n.ymax),new Be(n.zmin,n.zmax),r,{
            isInequality: o
        }).fullLoopOverUnitCubes()
    }
    var nD = class extends Bd {
        constructor(n, r, o, i, s, a, {isInequality: u}) {
            super(oT, o, i, s, a);
            this.f = n;
            this.gradient = r;
            this.cubeEdge = new Array(26);
            this.face = tD();
            this.cubeHasCrossing = !1;
            this.allNormalsFromGradient = !0;
            this.normalFromGradient = [];
            this.edgesMaybeCross = 0;
            this.positions = [];
            this.uvs = [];
            this.normals = [];
            this.triangles = [];
            this.isInequality = u,
            this.sheet = Array((a + 1) * (a + 1)),
            this.strip = Array(a + 1);
            for (let c = 0; c < (a + 1) * (a + 1); c++)
                this.sheet[c] = tD();
            for (let c = 0; c < a + 1; c++)
                this.strip[c] = tD()
        }
        setAt(n, r, o, i, s) {
            let a = this.f(o, i, s);
            n.set(r, a)
        }
        fullLoopOverUnitCubes() {
            this.positions = [],
            this.normals = [],
            this.triangles = [],
            this.loopOverUnitCubes(this.onEachCube.bind(this));
            let {uvs: n, positions: r, normals: o} = this;
            if (!this.allNormalsFromGradient)
                for (let i = 0; i < o.length / 3; i++) {
                    if (this.normalFromGradient[i])
                        continue;
                    let s = o[3 * i]
                      , a = o[3 * i + 1]
                      , u = o[3 * i + 2]
                      , c = Math.sqrt(s * s + a * a + u * u);
                    o[3 * i] = s / c,
                    o[3 * i + 1] = a / c,
                    o[3 * i + 2] = u / c
                }
            return Od(this.triangles, this.positions, o, n, 0, [], .7),
            {
                positions: r,
                normals: o,
                faces: this.triangles,
                uvs: n,
                resolved: !0,
                extraAttrs: []
            }
        }
        onEachCube() {
            this.edgesMaybeCross = 0,
            this.cubeHasCrossing = !1;
            for (let n = 0; n < 26; n++) {
                let r = this.cubeVertexValue.get(so[n * 2])
                  , o = this.cubeVertexValue.get(so[n * 2 + 1]);
                (r === 0 || o === 0) && (this.cubeHasCrossing = !0),
                !(r > 0 && o > 0 || r < 0 && o < 0) && (isFinite(r) || isFinite(o)) && (this.edgesMaybeCross |= 1 << n)
            }
            this.edgesMaybeCross && (this.setVertexPositions(),
            this.setEdges()),
            this.saveEdges(),
            this.cubeHasCrossing && this.generateTriangles()
        }
        setEdges() {
            let {i: n, j: r, k: o, gridsize: i} = this
              , s = this.sheet[(n + 0) * (i + 1) + r + 0]
              , a = this.sheet[(n + 1) * (i + 1) + r + 0]
              , u = this.sheet[(n + 0) * (i + 1) + r + 1]
              , c = 0;
            o > 0 && (this.cubeEdge[0] = s.edge0,
            this.cubeEdge[1] = s.edge1,
            this.cubeEdge[2] = s.edge2,
            this.cubeEdge[3] = u.edge2,
            this.cubeEdge[4] = a.edge0,
            c |= 31),
            r > 0 && (this.cubeEdge[5] = this.strip[n].edge0,
            this.cubeEdge[6] = this.strip[n].edge1,
            this.cubeEdge[7] = this.strip[n + 1].edge0,
            this.cubeEdge[8] = this.strip[n].edge2,
            c |= 480,
            o == 0 && (this.cubeEdge[2] = s.edge2,
            c |= 4)),
            n > 0 && (this.cubeEdge[9] = this.face.edge0,
            this.cubeEdge[10] = this.face.edge1,
            this.cubeEdge[11] = this.face.edge2,
            c |= 3584,
            o == 0 && (this.cubeEdge[0] = s.edge0,
            c |= 1),
            r == 0 && (this.cubeEdge[5] = this.strip[n].edge0,
            c |= 32));
            for (let l = 0; l < 26; l++) {
                if (~this.edgesMaybeCross >> l & 1) {
                    this.cubeEdge[l] = jy;
                    continue
                }
                if (c >> l & 1) {
                    !this.cubeHasCrossing && (this.cubeEdge[l].posNeg || this.cubeEdge[l].posNaN) && (this.cubeHasCrossing = !0);
                    continue
                }
                let p = this.findSurfaceCrossingEDI(so[l * 2], so[l * 2 + 1]);
                this.cubeEdge[l] = p,
                nZ(p) && (this.cubeHasCrossing = !0)
            }
        }
        saveEdges() {
            let {i: n, j: r, k: o, gridsize: i} = this;
            o < i - 1 && (this.sheet[(n + 0) * (i + 1) + r + 0].edge0 = this.cubeEdge[11],
            this.sheet[(n + 0) * (i + 1) + r + 0].edge1 = this.cubeEdge[17],
            this.sheet[(n + 0) * (i + 1) + r + 0].edge2 = this.cubeEdge[8]),
            r < i - 1 && (this.strip[n].edge0 = this.cubeEdge[10],
            this.strip[n].edge1 = this.cubeEdge[12],
            this.strip[n].edge2 = this.cubeEdge[14]),
            n < i - 1 && (this.face.edge0 = this.cubeEdge[15],
            this.face.edge1 = this.cubeEdge[13],
            this.face.edge2 = this.cubeEdge[16]),
            o == 0 && (this.sheet[(n + 0) * (i + 1) + r + 1].edge2 = this.cubeEdge[3],
            this.sheet[(n + 1) * (i + 1) + r + 0].edge0 = this.cubeEdge[4]),
            r == 0 && (this.strip[n + 1].edge0 = this.cubeEdge[7]),
            r == i - 1 && (this.sheet[n * (i + 1) + i].edge2 = this.cubeEdge[14]),
            n == i - 1 && (this.sheet[(i + 0) * (i + 1) + r].edge0 = this.cubeEdge[16],
            this.strip[i].edge0 = this.cubeEdge[13])
        }
        findSurfaceCrossingEDI(n, r) {
            let o = this.cubeVertexValue.get(n)
              , i = this.cubeVertexValue.get(r);
            if (o === 0 || i === 0)
                return jy;
            let s = this.cubeVertex[n]
              , a = this.cubeVertex[r];
            if (this.isInequality) {
                let {posNeg: u, posNaN: c} = JL(this.f, s, a, o, i);
                return {
                    posNeg: u !== void 0 ? this.pushPositionWithGradient(...u) : void 0,
                    posNaN: c !== void 0 ? this.pushPositionNoGradient(...c) : void 0
                }
            } else {
                let u = Wy(this.f, s, a, o, i);
                return {
                    posNeg: u !== void 0 ? this.pushPositionWithGradient(...u) : void 0
                }
            }
        }
        pushPositionWithGradient(n, r, o) {
            if (!(isFinite(n) && isFinite(r) && isFinite(o)))
                return 0;
            let[i,s,a] = this.computeGradient(n, r, o)
              , u = Math.sqrt(i * i + s * s + a * a);
            return i /= -u,
            s /= -u,
            a /= -u,
            dm(i, s, a) ? (this.normalFromGradient.push(!0),
            this._pushPositionAndNormal(n, r, o, i, s, a)) : this.pushPositionNoGradient(n, r, o)
        }
        pushPositionNoGradient(n, r, o) {
            return isFinite(n) && isFinite(r) && isFinite(o) ? (this.allNormalsFromGradient = !1,
            this.normalFromGradient.push(!1),
            this._pushPositionAndNormal(n, r, o, 0, 0, 0)) : 0
        }
        _pushPositionAndNormal(n, r, o, i, s, a) {
            return this.positions.push(n, r, o),
            this.uvs.push((n - this.x.min) / this.x.width, (r - this.y.min) / this.y.width),
            this.normals.push(i, s, a),
            this.positions.length / 3
        }
        computeGradient(n, r, o) {
            let i = NaN
              , s = NaN
              , a = NaN;
            if (this.gradient && ([i,s,a] = this.gradient(n, r, o),
            isFinite(i) && isFinite(s) && isFinite(a)))
                return [i, s, a];
            let u = .001 * Math.min(this.size.x, this.size.y, this.size.z)
              , c = this.f(n, r, o);
            if (isFinite(i) || (i = (this.f(n + u, r, o) - c) / u),
            isFinite(i) || (i = (c - this.f(n - u, r, o)) / u),
            isFinite(s) || (s = (this.f(n, r + u, o) - c) / u),
            isFinite(s) || (s = (c - this.f(n, r - u, o)) / u),
            isFinite(a) || (a = (this.f(n, r, o + u) - c) / u),
            isFinite(a) || (a = (c - this.f(n, r, o - u)) / u),
            isFinite(i) && isFinite(s) && isFinite(a))
                return [i, s, a];
            let l = NaN
              , p = NaN
              , m = NaN
              , d = NaN
              , y = NaN
              , g = NaN
              , f = u / 2;
            return (!isFinite(i) || !isFinite(s)) && (l = (this.f(n + f, r + f, o) - c) / u,
            isFinite(l) || (l = (c - this.f(n - f, r - f, o)) / u),
            p = (this.f(n + f, r - f, o) - c) / u,
            isFinite(p) || (p = (c - this.f(n - f, r + f, o)) / u),
            isFinite(l) && isFinite(p) && (isFinite(i) || (i = l + p),
            isFinite(s) || (s = l - p))),
            (!isFinite(s) || !isFinite(a)) && (m = (this.f(n, r + f, o + f) - c) / u,
            isFinite(m) || (m = (c - this.f(n, r - f, o - f)) / u),
            d = (this.f(n, r + f, o - f) - c) / u,
            isFinite(d) || (d = (c - this.f(n, r - f, o + f)) / u),
            isFinite(m) && isFinite(d) && (isFinite(s) || (s = m + d),
            isFinite(a) || (a = m - d))),
            (!isFinite(a) || !isFinite(i)) && (y = (this.f(n + f, r, o + f) - c) / u,
            isFinite(y) || (y = (c - this.f(n - f, r, o - f)) / u),
            g = (this.f(n - f, r, o + f) - c) / u,
            isFinite(g) || (g = (c - this.f(n + f, r, o - f)) / u),
            isFinite(y) && isFinite(g) && (isFinite(i) || (i = y - g),
            isFinite(a) || (a = y + g))),
            [i, s, a]
        }
        generateTriangles() {
            for (let n = 0; n < 12; n++) {
                let r = nT[n]
                  , o = []
                  , i = 0
                  , s = YL[n]
                  , a = 0
                  , u = s[0]
                  , c = Math.abs(this.cubeVertexValue.get(u));
                c > a && isFinite(c) && (a = c);
                let l = s[1]
                  , p = Math.abs(this.cubeVertexValue.get(l));
                p > a && isFinite(p) && (a = p);
                let m = s[2]
                  , d = Math.abs(this.cubeVertexValue.get(m));
                d > a && isFinite(d) && (a = d);
                let y = s[3]
                  , g = Math.abs(this.cubeVertexValue.get(y));
                g > a && isFinite(g) && (a = g);
                let f = a * Number.EPSILON * 32;
                if (c <= f) {
                    i |= 35;
                    let x = this.pushPositionWithGradient(...this.cubeVertex[u]);
                    x !== void 0 && o.push(x)
                }
                if (p <= f) {
                    i |= 21;
                    let x = this.pushPositionWithGradient(...this.cubeVertex[l]);
                    x !== void 0 && o.push(x)
                }
                if (d <= f) {
                    i |= 14;
                    let x = this.pushPositionWithGradient(...this.cubeVertex[m]);
                    x !== void 0 && o.push(x)
                }
                if (g <= f) {
                    i |= 56;
                    let x = this.pushPositionWithGradient(...this.cubeVertex[y]);
                    x !== void 0 && o.push(x)
                }
                if (o.length === 4)
                    continue;
                let h;
                for (let x = 0; x < 4; x++) {
                    let T = s[x];
                    if (this.cubeVertexValue.get(T) > f) {
                        h = this.cubeVertex[T];
                        break
                    }
                }
                if (h === void 0 && this.isInequality)
                    for (let x = 0; x < 6; x++) {
                        if (i >> x & 1)
                            continue;
                        let {posNeg: T, posNaN: P} = this.cubeEdge[r[x]];
                        if (Gp(T) && Gp(P)) {
                            h = Ns(this.positions.slice((T - 1) * 3, T * 3), this.positions.slice((P - 1) * 3, P * 3), .5);
                            break
                        }
                    }
                if (h === void 0)
                    for (let x = 0; x < 4; x++) {
                        let T = s[x];
                        if (!isFinite(this.cubeVertexValue.get(T))) {
                            h = this.cubeVertex[T];
                            break
                        }
                    }
                if (h === void 0 && i && o.length > 0) {
                    let x;
                    for (let T = 0; T < 4; T++) {
                        let P = s[T];
                        if (this.cubeVertexValue.get(P) < -f) {
                            x = this.cubeVertex[P];
                            break
                        }
                    }
                    if (x) {
                        let T = o[0]
                          , P = this.positions.slice((T - 1) * 3, T * 3);
                        h = Ns(x, P, 2)
                    }
                }
                if (h !== void 0) {
                    if (this.isInequality) {
                        let x = []
                          , T = []
                          , P = !1;
                        for (let C = 0; C < 6; C++) {
                            if (i >> C & 1)
                                continue;
                            let {posNeg: S, posNaN: E} = this.cubeEdge[r[C]]
                              , M = Gp(S)
                              , _ = Gp(E);
                            M && x.push(S),
                            _ && T.push(E),
                            M && _ && (P = !0)
                        }
                        if (P) {
                            x.push(...o),
                            this.pushTriangleFromCorners(T, h),
                            this.pushTriangleFromCorners(x, h);
                            continue
                        }
                    }
                    for (let x = 0; x < 6; x++) {
                        if (i >> x & 1)
                            continue;
                        let {posNeg: T, posNaN: P} = this.cubeEdge[r[x]]
                          , C = T || P;
                        Gp(C) && o.push(C)
                    }
                    this.pushTriangleFromCorners(o, h)
                }
            }
        }
        pushTriangleFromCorners(n, r) {
            if (n.length >= 3) {
                let o = n[0] - 1
                  , i = n[1] - 1
                  , s = n[2] - 1;
                this.pushTriangle(o, i, s, r)
            }
            if (n.length == 4) {
                let o = n[0] - 1
                  , i = n[2] - 1
                  , s = n[3] - 1;
                this.pushTriangle(o, i, s, r)
            }
        }
        pushTriangle(n, r, o, i) {
            this.allNormalsFromGradient || this.fixBadNormals(n, r, o, i),
            this.checkWindingOrder(n, r, o) && ([r,o] = [o, r]),
            this.triangles.push(n, r, o)
        }
        fixBadNormals(n, r, o, i) {
            let s = !this.normalFromGradient[n]
              , a = !this.normalFromGradient[r]
              , u = !this.normalFromGradient[o];
            if (!(s || a || u))
                return;
            let c = this.positions
              , l = this.normals
              , p = new it(c[3 * n],c[3 * n + 1],c[3 * n + 2])
              , m = new it(c[3 * r],c[3 * r + 1],c[3 * r + 2])
              , d = new it(c[3 * o],c[3 * o + 1],c[3 * o + 2])
              , y = new it().subVectors(d, p)
              , g = new it().subVectors(p, m)
              , f = y.cross(g)
              , h = new it().subVectors(p, new it(...i));
            f.dot(h) < 0 && f.multiply(-1),
            f.isFinite() && (s && (l[3 * n + 0] += f.x,
            l[3 * n + 1] += f.y,
            l[3 * n + 2] += f.z),
            a && (l[3 * r + 0] += f.x,
            l[3 * r + 1] += f.y,
            l[3 * r + 2] += f.z),
            u && (l[3 * o + 0] += f.x,
            l[3 * o + 1] += f.y,
            l[3 * o + 2] += f.z))
        }
        checkWindingOrder(n, r, o) {
            let i = this.positions
              , s = this.normals
              , a = i[3 * o] - i[3 * n]
              , u = i[3 * o + 1] - i[3 * n + 1]
              , c = i[3 * o + 2] - i[3 * n + 2]
              , l = i[3 * n] - i[3 * r]
              , p = i[3 * n + 1] - i[3 * r + 1]
              , m = i[3 * n + 2] - i[3 * r + 2]
              , d = u * m - c * p
              , y = c * l - a * m
              , g = a * p - u * l
              , f = s[3 * n]
              , h = s[3 * n + 1]
              , x = s[3 * n + 2];
            return d * f + y * h + g * x < 0
        }
    }
    ;
    var {floor: rZ} = Math;
    function rD(e) {
        let t = [];
        for (let n of e)
            t.push(...n),
            t.push(NaN, NaN, NaN);
        return t
    }
    function qp(e, t, n, r) {
        (n === void 0 || isNaN(n)) && (n = iD(t.min, t.max)),
        n = pr(rZ(n), 2, 2e3);
        let {xmin: o, xmax: i, ymin: s, ymax: a, zmin: u, zmax: c} = r.viewport;
        u != null || (u = Yr.zmin),
        c != null || (c = Yr.zmax);
        let l = sT(e, {
            min: t.min,
            max: t.max,
            nInitialSamples: n,
            xtolerance: (i - o) / 1e3,
            ytolerance: (a - s) / 1e3,
            ztolerance: (c - u) / 1e3,
            map: p => p
        });
        return rD(l.segments)
    }
    function oD(e, t, n, r) {
        let o = r.degreeMode ? Math.PI / 180 : 1;
        return qp(i => {
            let s = e(i)
              , a = s[0]
              , u = s[1]
              , c = s[2];
            return [a * Yn(u * o), a * Nn(u * o), c]
        }
        , t, n, r)
    }
    function KL(e, t, n, r) {
        let o = r.degreeMode ? Math.PI / 180 : 1;
        return qp(i => {
            let s = e(i)
              , a = s[0]
              , u = s[1]
              , c = s[2];
            return [a * Nn(c * o) * Yn(u * o), a * Nn(c * o) * Nn(u * o), a * Yn(c * o)]
        }
        , t, n, r)
    }
    function oF(e, t, n, r) {
        let o = oZ(e, t, n, r);
        return rD(o)
    }
    function oZ(e, t, n, r) {
        return new cD(e,t,new Be(n.xmin,n.xmax),new Be(n.ymin,n.ymax),new Be(n.zmin,n.zmax),r).run()
    }
    var iZ = {}
      , cD = class extends Bd {
        constructor(n, r, o, i, s, a) {
            super(iT, o, i, s, a);
            this.f = n;
            this.g = r;
            this.vertexFGZs = {};
            this.vertexZeroF = {};
            this.vertexZeroG = {};
            this.threshF = 0;
            this.threshG = 0;
            this.cubeID = 0;
            this.edgesMaybeCrossF = 0;
            this.edgesMaybeCrossG = 0;
            this.tetEdgeCrossings = new Array(26);
            this.edgeFGZs = new Array(26);
            this.edgeCrossings = new Map;
            this.allFGZs = new Map
        }
        setAt(n, r, o, i, s) {
            let a = this.f(o, i, s)
              , u = this.g(o, i, s);
            n.set(r, a, u)
        }
        run() {
            return this.loopOverUnitCubes(this.onEachCube.bind(this)),
            this.traceCurves()
        }
        onEachCube() {
            this.cubeID = WL(this.i, this.j, this.k),
            this.pruneEdges(),
            this.edgesMaybeCrossF && this.edgesMaybeCrossG && (this.setVertexPositions(),
            this.setVertexZeros(),
            this.setEdgeCrossings(),
            this.insertCurveSegmentsFromCube())
        }
        pruneEdges() {
            this.edgesMaybeCrossF = 0,
            this.edgesMaybeCrossG = 0;
            for (let n = 0; n < 26; n++) {
                let r = so[n * 2]
                  , o = so[n * 2 + 1]
                  , i = this.cubeVertexValue.getX(r)
                  , s = this.cubeVertexValue.getY(r)
                  , a = this.cubeVertexValue.getX(o)
                  , u = this.cubeVertexValue.getY(o);
                !(i > 0 && a > 0 || i < 0 && a < 0) && (isFinite(i) || isFinite(a)) && (this.edgesMaybeCrossF |= 1 << n),
                !(s > 0 && u > 0 || s < 0 && u < 0) && (isFinite(s) || isFinite(u)) && (this.edgesMaybeCrossG |= 1 << n)
            }
        }
        setVertexZeros() {
            let n = 0
              , r = 0;
            for (let s = 0; s < 9; s++) {
                let a = this.cubeVertexValue.getX(s)
                  , u = this.cubeVertexValue.getY(s)
                  , c = Math.abs(a)
                  , l = Math.abs(u);
                c > n && isFinite(c) && (n = c),
                l > r && isFinite(c) && (r = l)
            }
            let o = this.threshF = n * Number.EPSILON * 32
              , i = this.threshG = r * Number.EPSILON * 32;
            for (let s = 0; s < 9; s++) {
                let a = this.cubeVertexValue.getX(s)
                  , u = this.cubeVertexValue.getY(s)
                  , c = Math.abs(a)
                  , l = Math.abs(u);
                if (this.vertexZeroF[s] = c <= o,
                this.vertexZeroG[s] = l <= i,
                c <= o && l <= i) {
                    let p = this.cubeVertex[s]
                      , m = this.createFGZ(jL(this.cubeID, s), p);
                    this.vertexFGZs[s] = m
                } else
                    this.vertexFGZs[s] = void 0
            }
        }
        getEdgeCrossings(n) {
            let r = this.edgesMaybeCrossF >> n & 1
              , o = this.edgesMaybeCrossG >> n & 1;
            if (!r && !o)
                return iZ;
            let i = Xy(this.cubeID, n)
              , s = this.edgeCrossings.get(i);
            if (s !== void 0)
                return s;
            let a = this.getEdgeCrossingsUncached(n, r, o);
            return this.edgeCrossings.set(i, a),
            a
        }
        getEdgeCrossingsUncached(n, r, o) {
            let i = so[n * 2]
              , s = so[n * 2 + 1]
              , a = this.cubeVertexValue.getX(i)
              , u = this.cubeVertexValue.getY(i)
              , c = this.cubeVertexValue.getX(s)
              , l = this.cubeVertexValue.getY(s)
              , p = this.cubeVertex[i]
              , m = this.cubeVertex[s]
              , d = !r || a === 0 || c === 0 ? void 0 : Wy(this.f, p, m, a, c)
              , y = !o || u === 0 || l === 0 ? void 0 : Wy(this.g, p, m, u, l)
              , g = this.threshF;
            !d && y && Math.abs(a) <= g && Math.abs(c) <= g && Math.abs(this.f(y[0], y[1], y[2])) <= g && (d = y);
            let f = this.threshG;
            return !y && d && Math.abs(u) <= f && Math.abs(l) <= f && Math.abs(this.g(d[0], d[1], d[2])) <= f && (y = d),
            {
                f: d,
                g: y
            }
        }
        getTriangleCrossing(n) {
            let r = Q0(this.cubeID, n)
              , o = this.allFGZs.get(r);
            if (o !== void 0)
                return o;
            let i = this.getTriangleCrossingUncached(n);
            return this.allFGZs.set(r, i),
            i
        }
        createFGZ(n, r) {
            let o = this.allFGZs.get(n);
            if (o)
                return o;
            let i = {
                id: n,
                pos: r,
                connections: [],
                visited: !1
            };
            return this.allFGZs.set(n, i),
            i
        }
        getTriangleCrossingUncached(n) {
            let r = []
              , o = []
              , i = J0[n];
            for (let a = 0; a < 3; a++) {
                let u = i[a];
                if (this.vertexFGZs[u])
                    return null;
                this.vertexZeroF[u] && r.push(this.cubeVertex[u]),
                this.vertexZeroG[u] && o.push(this.cubeVertex[u])
            }
            let s = j0[n];
            for (let a = 0; a < 3; a++) {
                let u = s[a]
                  , c = this.tetEdgeCrossings[u];
                if (this.edgeFGZs[u] || !c)
                    continue;
                let l = c.f
                  , p = c.g
                  , m = so[2 * u]
                  , d = so[2 * u + 1];
                l && !this.vertexZeroF[m] && !this.vertexZeroF[d] && r.push(l),
                p && !this.vertexZeroG[m] && !this.vertexZeroG[d] && o.push(p)
            }
            if (r.length === 2 && o.length === 2) {
                let a = sZ(r[0], r[1], o[0], o[1]);
                return a ? {
                    id: Q0(this.cubeID, n),
                    pos: a,
                    connections: [],
                    visited: !1
                } : null
            } else
                return null
        }
        setEdgeCrossings() {
            for (let n = 0; n < 26; n++) {
                let r = this.getEdgeCrossings(n)
                  , o = r.f
                  , i = r.g
                  , s = so[n * 2]
                  , a = so[n * 2 + 1];
                if (this.vertexFGZs[s] || this.vertexFGZs[a])
                    this.tetEdgeCrossings[n] = void 0,
                    this.edgeFGZs[n] = void 0;
                else if (o && this.vertexZeroG[s] && this.vertexZeroG[a]) {
                    let u = this.createFGZ(Xy(this.cubeID, n), o);
                    this.edgeFGZs[n] = u,
                    this.tetEdgeCrossings[n] = void 0
                } else if (i && this.vertexZeroF[s] && this.vertexZeroF[a]) {
                    let u = this.createFGZ(Xy(this.cubeID, n), i);
                    this.edgeFGZs[n] = u,
                    this.tetEdgeCrossings[n] = void 0
                } else if (o && i && lc(o, i) < 1e-8) {
                    let u = this.createFGZ(Xy(this.cubeID, n), o);
                    this.edgeFGZs[n] = u,
                    this.tetEdgeCrossings[n] = void 0
                } else
                    this.edgeFGZs[n] = void 0,
                    this.tetEdgeCrossings[n] = r
            }
        }
        insertCurveSegmentsFromCube() {
            for (let n = 0; n < 12; n++)
                this.insertCurveSegmentsFromTetrahedron(n)
        }
        insertCurveSegmentsFromTetrahedron(n) {
            let r = []
              , o = XL[n];
            for (let l = 0; l < 4; l++) {
                let p = this.getTriangleCrossing(o[l]);
                p && r.push(p)
            }
            let i = []
              , s = nT[n];
            for (let l = 0; l < 6; l++) {
                let p = this.edgeFGZs[s[l]];
                p && i.push(p)
            }
            let a = []
              , u = [so[s[0] * 2], so[s[0] * 2 + 1], so[s[3] * 2], so[s[3] * 2 + 1]];
            for (let l of u) {
                let p = this.vertexFGZs[l];
                p && a.push(p)
            }
            let c = [...a, ...i, ...r];
            switch (c.length) {
            case 0:
            case 1:
                break;
            case 2:
                this.connectCrossings(c[0], c[1]);
                break;
            case 3:
                r.length === 2 && this.connectCrossings(r[0], r[1]);
                break;
            case 4:
                r.length === 4 && (this.connectCrossings(r[0], r[1]),
                this.connectCrossings(r[2], r[3]));
                break;
            default:
                throw new Error("Programming error: 5 is impossible.")
            }
        }
        connectCrossings(n, r) {
            n.connections.some(o => o.id === r.id) || r.connections.some(o => o.id === n.id) || n.connections.length >= 2 || r.connections.length >= 2 || (n.connections.push(r),
            r.connections.push(n))
        }
        traceCurves() {
            let n = {
                xtolerance: this.size.x * .1,
                ytolerance: this.size.y * .1,
                ztolerance: this.size.z * .1,
                map: o => o
            }
              , r = new Hs(n);
            for (let o of this.allFGZs.values())
                o && !o.visited && o.connections.length === 1 && this.traceCurve(r, o);
            for (let o of this.allFGZs.values())
                o && !o.visited && this.traceCurve(r, o);
            return r.finish().segments
        }
        traceCurve(n, r) {
            let o = r;
            for (; ; ) {
                n.addPoint(r.pos),
                r.visited = !0;
                let i;
                for (let s of r.connections)
                    s.visited || (i = s);
                if (!i)
                    break;
                r = i
            }
            o.connections.length === 2 && n.addPoint(o.pos),
            n.breakSegment()
        }
    }
      , [aT,eF,sD] = [new it, new it, new it]
      , tF = new it
      , [aD,uD,nF] = [new it, new it, new it]
      , [uT,rF,cT] = [new it, new it, new it];
    function sZ(e, t, n, r) {
        aT.set(e[0], e[1], e[2]),
        eF.set(t[0], t[1], t[2]),
        sD.set(n[0], n[1], n[2]),
        tF.set(r[0], r[1], r[2]),
        aD.subVectors(eF, aT),
        uD.subVectors(tF, sD),
        nF.subVectors(sD, aT),
        uT.crossVectors(aD, uD),
        rF.crossVectors(nF, uD);
        let o = uT.dot(rF) / uT.dot(uT);
        return 0 <= o && o <= 1 ? (cT.addVectors(aT, aD.multiply(o)),
        [cT.x, cT.y, cT.z]) : null
    }
    var iF = 80;
    var lD = class extends Ad {
        constructor(n, r, o, i, s, a) {
            let u = o.width / 1e8
              , c = i.width / 1e8;
            super({
                resolution: s,
                uRange: o,
                vRange: i,
                du: u,
                dv: c,
                extraAttrCount: a
            });
            this.vertices = [];
            this.fn = n => {
                let r = this._fn(n)
                  , o = this.tangentInForced(n, [this.du, 0], r)
                  , i = this.tangentInForced(n, [0, this.dv], r)
                  , s = mm(o, i);
                return {
                    uv: n,
                    f: r,
                    normal: s,
                    dfEast: o,
                    dfNorth: i
                }
            }
            ;
            this._fn = l => n(l[0], l[1]),
            this.xmin = r.xmin * 6 - r.xmax * 5,
            this.xmax = r.xmax * 6 - r.xmin * 5,
            this.ymin = r.ymin * 6 - r.ymax * 5,
            this.ymax = r.ymax * 6 - r.ymin * 5,
            this.zmin = r.zmin * 6 - r.zmax * 5,
            this.zmax = r.zmax * 6 - r.zmin * 5,
            this.distThresh = ((r.xmax - r.xmin) * 1e-6) ** 2
        }
        getVertexCount() {
            return this.vertices.length
        }
        getUV(n) {
            return this.vertices[n].uv
        }
        getNormal(n) {
            return this.vertices[n].normal
        }
        _addVertex(n) {
            return this.vertices.push(n) - 1
        }
        copyVertex(n) {
            return this.addVertex(this.vertices[n])
        }
        getF(n) {
            return this.vertices[n].f
        }
        getDfNorth(n) {
            return this.vertices[n].dfNorth
        }
        getDfEast(n) {
            return this.vertices[n].dfEast
        }
        insidePaddedDomain(n) {
            return this.zmin <= n[2] && n[2] <= this.zmax && this.ymin <= n[1] && n[1] <= this.ymax && this.xmin <= n[0] && n[0] <= this.xmax
        }
        tangentInForced(n, r, o) {
            let i = gf(n, r);
            return nP(this._fn(i), o)
        }
        _isVertexAtCrease(n) {
            let r = this.getUV(n)
              , o = this.getDfEast(n)
              , i = this.getDfNorth(n)
              , s = this.getF(n)
              , a = this.tangentInForced(r, [-this.du, 0], s);
            if (rP(a, o) / Math.sqrt(pm(a) * pm(o)) > -wd)
                return !0;
            let c = this.tangentInForced(r, [0, -this.dv], s);
            return rP(i, c) / Math.sqrt(pm(i) * pm(c)) > -wd
        }
        hintedNormal(n, r) {
            let o = this.getUV(n)
              , i = this.getF(n)
              , s = mm(this.tangentInForced(o, r[0], i), this.tangentInForced(o, r[1], i));
            return dm(...s) ? s : this.getNormal(n)
        }
        getVertex(n) {
            if (this.allowVertex(n))
                return this.getF(n)
        }
        getExtraAttr(n, r) {
            return this.vertices[n].f[3 + r]
        }
        findJumpBetweenTwoSamples(n, r) {
            let o = this.getUV(n)
              , i = this.getF(n)
              , s = 0
              , a = this.getUV(r)
              , u = this.getF(r)
              , c = 1
              , l = d => this._fn(Mr(o, a, d));
            if (!isFinite(i[0]) || !isFinite(i[1]) || !isFinite(i[2]) || !isFinite(u[0]) || !isFinite(u[1]) || !isFinite(u[2]))
                return;
            let m = eh(s, i, c, u, l, (this.xmax - this.xmin) * 1e-6, 0, 0);
            if (m)
                return [this.fn(Mr(o, a, Rs(m[0], 0, 1e-5))), this.fn(Mr(o, a, Rs(m[1], 1, 1e-5)))]
        }
        clip(n) {
            return this.insidePaddedDomain(n) ? n : [NaN, NaN, NaN]
        }
        findFiniteBetweenTwoSamples(n, r) {
            let o = this.getUV(n)
              , i = this.getF(n)
              , s = this.getUV(r)
              , a = this.getF(r)
              , u = l => this.clip(this._fn(Mr(o, s, l)))
              , c = Kg(0, this.clip(i), 1, this.clip(a), u);
            if (c !== void 0)
                return this.fn(Mr(o, s, c))
        }
        allowVertex(n) {
            return this.insidePaddedDomain(this.getF(n))
        }
        isDegenerate(n, r, o) {
            let i = this.getF(n)
              , s = this.getF(r);
            if (lc(i, s) < this.distThresh)
                return !0;
            let a = this.getF(o);
            return lc(s, a) < this.distThresh || lc(i, a) < this.distThresh
        }
    }
    ;
    function Qy(e, t, n, r, o, i) {
        let s = new lD(e,t,n,r,o,i);
        return Zx(s)
    }
    function sF(e) {
        return aZ(e) || pT(e) || aF(e)
    }
    function aZ(e) {
        return e === 3
    }
    function lT(e, t, n, r) {
        return e.is3dPolicy() && pT(t.graphMode) ? Ky(t, n, r != null ? r : 1) : t
    }
    function pT(e) {
        switch (e) {
        case 1:
        case 2:
        case 6:
        case 8:
        case 5:
            return !0;
        default:
            return !1
        }
    }
    function Ky(e, t, n, r=0) {
        var s;
        let o = uF(e, t, r)
          , i = Gd(o, t.viewport, n);
        return {
            graphMode: 128,
            guid: Do(),
            points: i,
            resolved: e.resolved,
            color: e.color,
            compiled: e.compiled,
            thickness: (s = e.lineWidth) != null ? s : 1
        }
    }
    function dD(e, t, n) {
        return e.is3dPolicy() && aF(t.graphMode) ? uZ(t, n) : t
    }
    function aF(e) {
        switch (e) {
        case 17:
        case 24:
            return !0;
        default:
            return !1
        }
    }
    function uZ(e, t) {
        var r;
        let n = uF(e, t);
        return {
            graphMode: e.graphMode === 17 ? 119 : e.graphMode === 24 ? 129 : 128,
            guid: Do(),
            points: cZ(n),
            color: e.color,
            thickness: (r = e.lineWidth) != null ? r : 1
        }
    }
    function cZ(e) {
        let t = [];
        for (let[n,r,o] of e)
            t.push(n, r, o);
        return t
    }
    function uF(e, t, n=0) {
        function r(i, s) {
            if (e.graphMode === 1)
                return [s, i];
            if (e.graphMode === 6) {
                let a = t.degreeMode ? i * Math.PI / 180 : i;
                return [s * Math.cos(a), s * Math.sin(a)]
            } else
                return [i, s]
        }
        let o = [];
        for (let i = 0; i < e.segments.length; i++) {
            let s = e.segments[i];
            for (let a = 0; a < s.length / 2; a++) {
                let[u,c] = r(s[2 * a], s[2 * a + 1]);
                o.push([u, c, n])
            }
            i < e.segments.length - 1 && o.push([NaN, NaN, 0])
        }
        return o
    }
    function Gd(e, t, n) {
        if (t.zmin === void 0 || t.zmax === void 0)
            return [];
        let {xmin: r, xmax: o, ymin: i, ymax: s, zmin: a, zmax: u} = t
          , c = o - r
          , l = s - i
          , p = u - a
          , m = n / 200
          , d = []
          , y = 1e-4;
        for (let h = 0; h < e.length; h++) {
            let x = e[h];
            if (isFinite(x[0]) && isFinite(x[1]) && isFinite(x[2])) {
                let T = d[d.length - 1];
                T !== void 0 && Math.abs(x[0] - T[0]) < y * c && Math.abs(x[1] - T[1]) < y * l && Math.abs(x[2] - T[2]) < y * p || d.push(x)
            } else
                d.push(void 0)
        }
        let g = []
          , f = d.length;
        for (let h = 0; h < f; h++) {
            let x = d[h];
            if (!x) {
                g.push(NaN, NaN, NaN);
                continue
            }
            let[T,P,C] = x
              , S = d[h - 1]
              , E = d[h + 1];
            if (S && E) {
                let[M,_,U] = S
                  , [Q,K,w] = E
                  , B = (T - M) / c
                  , W = (Q - T) / c
                  , oe = (P - _) / l
                  , te = (K - P) / l
                  , st = (C - U) / p
                  , Tt = (w - C) / p
                  , ye = Wo(B, oe, st)
                  , ee = Wo(W, te, Tt);
                if ((W * B + te * oe + Tt * st) / (ye * ee) < .7 && ye > m && ee > m) {
                    let ne = .5 * (m / ye)
                      , Ne = .5 * (m / ee)
                      , _e = fa(M, T, 1 - ne)
                      , gt = fa(_, P, 1 - ne)
                      , At = fa(U, C, 1 - ne)
                      , Fi = fa(T, Q, Ne)
                      , Cr = fa(P, K, Ne)
                      , Cs = fa(C, w, Ne);
                    g.push(_e, gt, At),
                    g.push(fa(_e, T, .5), fa(gt, P, .5), fa(At, C, .5)),
                    g.push(T, P, C),
                    g.push(fa(T, Fi, .5), fa(P, Cr, .5), fa(C, Cs, .5)),
                    g.push(Fi, Cr, Cs)
                } else
                    g.push(T, P, C)
            } else
                g.push(T, P, C)
        }
        return g
    }
    function fa(e, t, n) {
        return (1 - n) * e + n * t
    }
    function mD(e, t) {
        let n = t != null ? t : {};
        if (!Array.isArray(e))
            return () => e;
        let r = Object.keys(n).length === 0 ? e : e.filter( (o, i) => !n[i]);
        return o => r[o]
    }
    function cF(e) {
        var i, s;
        let t = e.droppedIndices
          , n = mD((i = e.pointSize) != null ? i : 1, t)
          , r = mD(e.color, t)
          , o = mD((s = e.pointOpacity) != null ? s : 1, t);
        return e.segments[0].map( ([a,u], c) => ({
            graphMode: 114,
            position: [a, u, 0],
            radius: .02 * n(c),
            guid: Do(),
            color: r(c),
            fillOpacity: o(c)
        }))
    }
    var ps = {
        pointsOfInterest: !0,
        plotSingleVariableImplicitEquations: !0,
        plotImplicits: !0,
        plotInequalities: !0,
        sliders: !0
    };
    function fD(e) {
        return Math.abs(e) < 5e-8
    }
    var eg = class extends Hs {
        constructor(t, n, r) {
            let {tolerance: o, mathToPixels: i} = t;
            super({
                tolerance: o,
                map: s => i.mapCoordinatePair(s)
            }),
            this.fn = n,
            this.mappedFn = s => i.mapY(n(s)),
            this.derivative = r,
            this.poiData = {
                zeros: {
                    x: [],
                    y: []
                },
                intercept: {
                    x: [],
                    y: []
                },
                extrema: {
                    x: [],
                    y: []
                }
            },
            this.zeroBuffer = [],
            this.extremumBuffer = []
        }
        getPOI() {
            return ps.pointsOfInterest ? (this.poiData.intercept = this.findIntercept(this.fn),
            this.poiData) : {
                zeros: {
                    x: [],
                    y: []
                },
                intercept: {
                    x: [],
                    y: []
                },
                extrema: {
                    x: [],
                    y: []
                }
            }
        }
        addPoint(t) {
            this.segment.length === 0 && fD(t[1]) && (this.poiData.zeros.x.push(t[0]),
            this.poiData.zeros.y.push(t[1])),
            this.updateZeroBuffer(t),
            this.updateExtremumBuffer(t),
            super.addPoint(t)
        }
        updateZeroBuffer(t) {
            let[n,r] = this.map ? this.map(t) : t;
            if (!isFinite(n) || !isFinite(r)) {
                this.zeroBuffer.length = 0;
                return
            }
            switch (this.zeroBuffer.length) {
            case 0:
                {
                    if (fD(t[1]))
                        return;
                    this.zeroBuffer.push(t);
                    return
                }
            case 1:
                if (t[1] === 0) {
                    this.zeroBuffer.push(t);
                    return
                } else if (t[1] > 0 != this.zeroBuffer[0][1] > 0) {
                    let o = uP(this.zeroBuffer[0][0], this.zeroBuffer[0][1], t[0], t[1], this.fn);
                    o && (this.poiData.zeros.x.push(o[0]),
                    this.poiData.zeros.y.push(o[1])),
                    this.zeroBuffer.length = 0,
                    this.zeroBuffer.push(t);
                    return
                } else {
                    this.zeroBuffer.length = 0,
                    this.zeroBuffer.push(t);
                    return
                }
            case 2:
                {
                    if (t[1] === 0)
                        return;
                    if (t[1] > 0 != this.zeroBuffer[0][1] > 0) {
                        let o = bf(this.zeroBuffer[0][0], this.zeroBuffer[0][1], this.zeroBuffer[1][0], this.zeroBuffer[1][1], t[0], t[1], this.fn);
                        o && (this.poiData.zeros.x.push(o[0]),
                        this.poiData.zeros.y.push(o[1])),
                        this.zeroBuffer.length = 0,
                        this.zeroBuffer.push(t);
                        return
                    } else {
                        this.zeroBuffer.length = 0,
                        this.zeroBuffer.push(t);
                        return
                    }
                }
            }
        }
        updateExtremumBuffer(t) {
            let[n,r] = this.map ? this.map(t) : t;
            if (!isFinite(n) || !isFinite(r)) {
                this.extremumBuffer.length = 0;
                return
            }
            switch (this.extremumBuffer.length) {
            case 0:
                {
                    this.extremumBuffer.push(t);
                    return
                }
            case 1:
                {
                    t[1] === this.extremumBuffer[0][1] && (this.extremumBuffer.length = 0),
                    this.extremumBuffer.push(t);
                    return
                }
            case 2:
                if (t[1] === this.extremumBuffer[1][1]) {
                    this.extremumBuffer.push(t);
                    return
                } else if (t[1] > this.extremumBuffer[1][1] != this.extremumBuffer[1][1] > this.extremumBuffer[0][1]) {
                    let o = this.bisectExtremumUsingDerivative(this.extremumBuffer[0][0], this.extremumBuffer[0][1], this.extremumBuffer[1][0], this.extremumBuffer[1][1], t[0], t[1]);
                    o && (this.poiData.extrema.x.push(o[0]),
                    this.poiData.extrema.y.push(o[1]),
                    !fm(this.extremumBuffer[0][0], this.mappedFn(this.extremumBuffer[0][0]), o[0], this.mappedFn(o[0]), t[0], this.mappedFn(t[0]), this.mappedFn, this.ytolerance) && o[0] > this.segment[this.segment.length - 2] && (this.pendingPoint = o)),
                    this.extremumBuffer.shift(),
                    this.extremumBuffer.push(t);
                    return
                } else {
                    this.extremumBuffer.shift(),
                    this.extremumBuffer.push(t);
                    return
                }
            case 3:
                {
                    if (t[1] === this.extremumBuffer[1][1])
                        return;
                    if (t[1] > this.extremumBuffer[1][1] != this.extremumBuffer[1][1] > this.extremumBuffer[0][1]) {
                        let o, i = .5 * (this.extremumBuffer[1][0] + this.extremumBuffer[2][0]), s = this.fn(i);
                        s === this.extremumBuffer[1][1] ? o = bf(this.extremumBuffer[0][0], this.extremumBuffer[0][1], this.extremumBuffer[1][0], this.extremumBuffer[1][1], t[0], t[1], this.fn) : o = this.bisectExtremumUsingDerivative(this.extremumBuffer[1][0], this.extremumBuffer[1][1], i, s, this.extremumBuffer[2][0], this.extremumBuffer[2][1]),
                        o && (this.poiData.extrema.x.push(o[0]),
                        this.poiData.extrema.y.push(o[1])),
                        this.extremumBuffer.shift(),
                        this.extremumBuffer.shift(),
                        this.extremumBuffer.push(t);
                        return
                    } else {
                        this.extremumBuffer.shift(),
                        this.extremumBuffer.shift(),
                        this.extremumBuffer.push(t);
                        return
                    }
                }
            }
        }
        bisectExtremumUsingDerivative(t, n, r, o, i, s) {
            let a;
            if (this.derivative) {
                let u = this.derivative(t)
                  , c = this.derivative(i);
                if (!isNaN(u) && !isNaN(c) && (o > n && u > 0 && c < 0 || o < n && u < 0 && c > 0)) {
                    let l = uP(t, u, i, c, this.derivative);
                    l && (a = [l[0], this.fn(l[0])])
                }
            }
            return a || (a = cN(t, n, r, o, i, s, this.fn)),
            a
        }
        breakSegment() {
            this.zeroBuffer.length = 0,
            this.extremumBuffer.length = 0,
            this.flushPending(),
            this.segment.length > 2 && (this.segments.push(this.segment),
            fD(this.segment[this.segment.length - 1]) && (this.poiData.zeros.x.push(this.segment[this.segment.length - 2]),
            this.poiData.zeros.y.push(this.segment[this.segment.length - 1]))),
            this.segment = []
        }
        findIntercept(t) {
            if (!t)
                return {
                    x: [],
                    y: []
                };
            let n = t(0);
            return isFinite(n) ? {
                x: [0],
                y: [t(0)]
            } : {
                x: [],
                y: []
            }
        }
        finish() {
            return {
                segments: this.getSegments(),
                resolved: !0,
                poi: this.getPOI()
            }
        }
    }
    ;
    var {floor: lF} = Math
      , pF = 1e4
      , mT = 5
      , mF = (e, t, n) => ({
        x: e,
        y: t,
        z: n
    })
      , dF = (e, t, n) => ({
        x: n,
        y: e,
        z: t
    })
      , fF = (e, t, n) => ({
        x: e,
        y: n,
        z: t
    })
      , dT = class {
        constructor() {
            this.xmin = Yr.xmin;
            this.xmax = Yr.xmax;
            this.ymin = Yr.ymin;
            this.ymax = Yr.ymax;
            this.zmin = Yr.zmin;
            this.zmax = Yr.zmax
        }
    }
      , lZ = 0;
    function Do() {
        return "result_" + lZ++
    }
    var fT;
    (n => (n.None = void 0,
    n.ComplexCoercion = "ComplexCoercion"))(fT || (fT = {}));
    function pZ() {
        return {
            zeros: {
                x: [],
                y: []
            },
            extrema: {
                x: [],
                y: []
            },
            intercept: {
                x: [],
                y: []
            }
        }
    }
    function xF(e) {
        return {
            graphMode: 15,
            error: e,
            segments: []
        }
    }
    function gD(e, t) {
        let n = e[0] + t.min * e[1]
          , r = e[0] + t.max * e[1]
          , o = {
            zeros: {
                x: [],
                y: []
            },
            intercept: {
                x: [],
                y: []
            },
            extrema: {
                x: [],
                y: []
            }
        };
        if (!isFinite(n) || !isFinite(r))
            return {
                segments: [],
                poi: o,
                resolved: !0
            };
        let i = [[t.min, n, t.max, r]]
          , s = -e[0] / e[1];
        return !isNaN(s) && s >= t.min && s <= t.max && (o.zeros.x.push(s),
        o.zeros.y.push(0)),
        0 >= t.min && 0 <= t.max && (o.intercept.x.push(0),
        o.intercept.y.push(e[0])),
        {
            segments: i,
            poi: o,
            resolved: !0
        }
    }
    function mZ(e, t) {
        let n = gD(e[0], t)
          , r = gD(e[1], t);
        return n.segments.length && r.segments.length && n.segments[0].length === 4 && r.segments[0].length === 4 ? {
            segments: [[n.segments[0][1], r.segments[0][1], n.segments[0][3], r.segments[0][3]]],
            resolved: !0
        } : {
            segments: [],
            resolved: !0
        }
    }
    function dZ(e, t) {
        let n = e(t);
        return {
            segments: [[...n, ...n]],
            resolved: !0
        }
    }
    function yF(e, t, n) {
        let {mappedFn: r, jumpTolerance: o, screen: i} = n
          , [s,a] = e
          , [u,c] = t
          , l = ac(s, u)
          , p = r(l)
          , m = i.height;
        if (!(a < 0 && c < 0 && (a >= p || c >= p)) && !(a > m && c > m && (a <= p || c <= p)))
            return fm(s, a, l, p, u, c, r, o)
    }
    var yD = (e, t, n) => {
        let {fn: r, mappedFn: o, jumpTolerance: i, accumulator: s} = n;
        if (!isFinite(i) || i <= 0)
            return;
        let a = yF(e, t, n);
        if (!a)
            return;
        let u = (t[0] - e[0]) / 10, c = [-u, u], l;
        for (let p = 0; p < c.length; p++) {
            let m = e[0] + c[p]
              , d = o(m);
            isFinite(d) || ([m,d] = e,
            m = e[0],
            d = e[1]);
            let y = t[0] + c[p]
              , g = o(y);
            if (isFinite(g) ? l = y : [y,g] = t,
            yF([m, d], [y, g], n)) {
                let[f,h] = a;
                s.addPoint([f, r(f)]),
                s.breakSegment(),
                s.addPoint([h, r(h)]);
                return
            }
        }
        return l
    }
      , hD = class {
        constructor(t, n, r) {
            let o = i => n.mathToPixels.mapY(t(i));
            this.derivative = r,
            this.accumulator = new eg(n,t,r),
            this.fn = t,
            this.mathToPixels = n.mathToPixels,
            this.mappedFn = o,
            this.jumpTolerance = n.tolerance || 0,
            this.screen = n.screen
        }
    }
    ;
    function gF(e, t, n, r) {
        let o = n
          , i = e(o)
          , s = t.mapY(i);
        return r > 0 && !isFinite(s) && (o = n + r,
        i = e(o),
        s = t.mapY(i)),
        r > 0 && !isFinite(s) && (o = n - r,
        i = e(o),
        s = t.mapY(i)),
        [o, i, s]
    }
    function xD(e, t, n) {
        let r = new hD(e,t,n)
          , {mathToPixels: o, mappedFn: i} = r
          , s = t.nInitialSamples
          , [a,u,c] = gF(e, o, t.min, 0);
        isFinite(c) && r.accumulator.addPoint([a, u]);
        for (let l = 1; l < s; l++) {
            let p = o.interpolateX(t.min, t.max, l / (s - 1))
              , m = l === s - 1 ? 0 : Math.abs(a - p) / 10
              , [d,y,g] = gF(e, o, p, m);
            if (isFinite(g) && isFinite(c)) {
                let f = yD([a, c], [d, g], r);
                f !== void 0 && (d = f,
                y = e(d),
                g = o.mapY(y)),
                r.accumulator.addPoint([d, y])
            } else if (isFinite(g) && !isFinite(c)) {
                let f = Yo(a, c, d, g, i);
                if (f !== void 0) {
                    f !== d && r.accumulator.addPoint([f, e(f)]);
                    let h = yD([f, i(f)], [d, g], r);
                    h !== void 0 && (d = h,
                    y = e(d),
                    g = o.mapY(y)),
                    r.accumulator.addPoint([d, y])
                }
            } else if (!isFinite(g) && isFinite(c)) {
                let f = Yo(a, c, d, g, i);
                if (f !== void 0) {
                    let h = yD([a, c], [f, i(f)], r);
                    h !== void 0 && (f = h),
                    f !== a && r.accumulator.addPoint([f, e(f)]),
                    r.accumulator.breakSegment()
                }
            }
            a = d,
            u = y,
            c = g
        }
        return r.accumulator.finish()
    }
    function TF(e) {
        let {fn: t, min: n, max: r} = e
          , o = Math.floor(n)
          , i = Math.ceil(r)
          , s = !0;
        i - o + 1 > pF && (i = o + (pF - 1),
        s = !1);
        let a = [];
        for (let u = o; u <= i; u++) {
            let c = t(u);
            !isFinite(u) || !isFinite(c) || a.push([u, c])
        }
        return {
            segments: a,
            resolved: s
        }
    }
    function fZ(e, t, n, r) {
        let o = t.min, i = t.max - t.min, s = t.rtoleranceMath, a = Math.floor(i / (Math.PI / n)), u, c, l;
        function p(m, d) {
            let y = d % 2 === 0 ? 1 : -1;
            if (!r && y === -1)
                return !1;
            let g = d * (Math.PI / n)
              , f = [o, o + 1, o + 2, o + 3]
              , h = !1;
            for (let x = 0, T = f.length; x < T; x++) {
                let P = m(f[x])
                  , C = m(f[x] + g);
                if (isFinite(P) && isFinite(C) && (h = !0),
                isFinite(P) !== isFinite(C) || Math.abs(P - y * C) > s)
                    return !1
            }
            return !!h
        }
        for (u = 1; u <= a; u++)
            if (p(e, u)) {
                for (l = u,
                c = 2; c * u <= a; c++)
                    p(e, c * u) || (l = void 0);
                if (l)
                    break
            }
        return l ? l * (Math.PI / n) : null
    }
    function IF(e) {
        return [e[1] * Math.cos(e[0]), e[1] * Math.sin(e[0])]
    }
    function sT(e, t) {
        if (t.max < t.min)
            return {
                segments: [],
                resolved: !0
            };
        if (t.parameterTransform) {
            let p = t.parameterTransform
              , m = e;
            e = d => m(p(d))
        }
        let {xtolerance: n, ytolerance: r, ztolerance: o, map: i} = t
          , s = new Hs({
            xtolerance: n,
            ytolerance: r,
            ztolerance: o,
            map: i
        })
          , a = 10
          , u = t.min
          , c = e(u);
        isFinite(c[0]) && isFinite(c[1]) && s.addPoint(c);
        let l = t.nInitialSamples;
        for (let p = 1; p < l; p++) {
            let m = p / (l - 1)
              , d = (1 - m) * t.min + m * t.max
              , y = e(d);
            tg(e, u, c, d, y, a, s, t.screen),
            u = d,
            c = y
        }
        return s.finish()
    }
    function yZ(e, t) {
        if (e.length !== t.length)
            return !1;
        for (let n = 0; n < e.length; n++)
            if (e[n] !== t[n])
                return !1;
        return !0
    }
    function tg(e, t, n, r, o, i, s, a) {
        if (r === t)
            return;
        let {xtolerance: u, ytolerance: c, ztolerance: l, map: p} = s
          , m = ac(t, r)
          , d = e(m)
          , y = p(n)
          , g = p(o)
          , f = p(d)
          , h = isFinite(y[0]) && isFinite(y[1]) && (y.length === 2 || isFinite(y[2]))
          , x = isFinite(g[0]) && isFinite(g[1]) && (g.length === 2 || isFinite(g[2]))
          , T = isFinite(f[0]) && isFinite(f[1]) && (f.length === 2 || isFinite(f[2]));
        if (i === 0 || m === t || m === r) {
            s.breakSegment(),
            x && s.addPoint(o);
            return
        }
        if (!(!h && !x)) {
            if (h !== x) {
                let P = t
                  , C = r
                  , S = n
                  , E = o;
                for (; t !== m && m !== r; )
                    T == h ? (t = m,
                    n = d,
                    y = f,
                    h = T) : (r = m,
                    o = d,
                    g = f,
                    x = T),
                    m = t + (r - t) / 2,
                    d = e(m),
                    f = p(d),
                    T = isFinite(f[0]) && isFinite(f[1]) && (f.length === 2 || isFinite(f[2]));
                h ? (tg(e, P, S, t, n, i - 1, s, a),
                s.breakSegment()) : (s.breakSegment(),
                s.addPoint(o),
                tg(e, r, o, C, E, i - 1, s, a));
                return
            }
            if (h && T && x) {
                let P = yZ(y, g)
                  , C = Qs(f[0], f[1], f[2] || 0, y[0], y[1], y[2] || 0, g[0], g[1], g[2] || 0)
                  , S = C > .2 && C < .8 && Math.abs(f[0] - (y[0] + C * (g[0] - y[0]))) <= u && Math.abs(f[1] - (y[1] + C * (g[1] - y[1]))) <= c && (y.length === 2 || Math.abs(f[2] - (y[2] + C * (g[2] - y[2]))) <= l);
                if (P || S || a && gZ(y, f, g, a)) {
                    s.addPoint(o);
                    return
                }
            }
            tg(e, t, n, m, d, i - 1, s, a),
            tg(e, m, d, r, o, i - 1, s, a)
        }
    }
    function gZ(e, t, n, {width: r, height: o}) {
        return e[0] < 0 && n[0] < 0 && (e[0] >= t[0] || n[0] >= t[0]) || e[0] > r && n[0] > r && (e[0] <= t[0] || n[0] <= t[0]) || e[1] < 0 && n[1] < 0 && (e[1] >= t[1] || n[1] >= t[1]) || e[1] > o && n[1] > o && (e[1] <= t[1] || n[1] <= t[1])
    }
    function hZ() {
        return Ts({
            positions: [],
            normals: [],
            faces: [],
            uvs: [],
            resolved: !0,
            extraAttrs: []
        })
    }
    function TD(e, t, n, r, o, {isInequality: i}) {
        let s = e.fn, a;
        return t && !t.includes("z") ? a = tT(s, n, r, "z") : t && !t.includes("x") ? a = tT(s, n, r, "x") : t && !t.includes("y") ? a = tT(s, n, r, "y") : a = QL(s, n, r, o, {
            isInequality: i
        }),
        Ts(a)
    }
    function hF(e, t, n, r, o) {
        let i = Qy(e, t, n, r, o, 0);
        return Ts(i)
    }
    function bZ(e, t, n) {
        let r = e.fn
          , o = Xx( (i, s) => r(i, s), new Be(t.xmin,t.xmax), new Be(t.ymin,t.ymax), new Be(t.zmin,t.zmax), n);
        return Ts(o)
    }
    function xZ(e, t, n) {
        let r = e.fn
          , o = Xx( (i, s) => r(i, s), new Be(t.ymin,t.ymax), new Be(t.zmin,t.zmax), new Be(t.xmin,t.xmax), n, [2, 0, 1]);
        return Ts(o)
    }
    function TZ(e, t, n) {
        let r = e.fn
          , o = Xx( (i, s) => r(s, i), new Be(t.zmin,t.zmax), new Be(t.xmin,t.xmax), new Be(t.ymin,t.ymax), n, [1, 2, 0]);
        return Ts(o)
    }
    function IZ(e, t, n, r, o, i) {
        let s = i ? Math.PI / 180 : 1
          , a = e.fn
          , u = Qy( (c, l) => [c * Yn(l * s), c * Nn(l * s), a(c, l)], t, n, r, o, 0);
        return Ts(u)
    }
    function PZ(e, t, n, r, o, i) {
        let s = i ? Math.PI / 180 : 1
          , a = e.fn
          , u = Qy( (c, l) => {
            let p = a(c, l);
            return [p * Yn(c * s), p * Nn(c * s), l, p]
        }
        , t, n, r, o, 1);
        return Ts(u)
    }
    function SZ(e, t, n, r, o, i) {
        let s = i ? Math.PI / 180 : 1
          , a = e.fn
          , u = Qy( (c, l) => {
            let p = a(c, l);
            return [p * Nn(l * s) * Yn(c * s), p * Nn(l * s) * Nn(c * s), p * Yn(l * s), p]
        }
        , t, n, r, o, 1);
        return Ts(u)
    }
    function Ts(e) {
        let {positions: t, normals: n, faces: r, uvs: o, extraAttrs: i, resolved: s} = e;
        return {
            guid: Do(),
            positions: new Float32Array(t),
            normals: new Float32Array(n),
            faces: new Uint32Array(r),
            uvs: new Float32Array(o),
            resolved: s,
            extraAttrs: new Float32Array(i)
        }
    }
    function bF(e) {
        for (let t of e)
            if (t !== 0)
                return !1;
        return !0
    }
    function PF(e, t) {
        let {min: n, max: r, mathToPixels: o, nInitialSamples: i} = t
          , s = o.interpolateX(n, r, 0)
          , a = e(s)
          , u = bF(a)
          , c = !1
          , l = [];
        for (let p = 1; p < i; p++) {
            let m = o.interpolateX(n, r, p / (i - 1))
              , d = e(m)
              , y = bF(d);
            if (u) {
                s = m,
                a = d,
                y || (u = !1);
                continue
            }
            if (y) {
                c ? (u = !0,
                c = !1) : c = !0;
                continue
            }
            let g = uN(s, a, m, d, e);
            g !== void 0 && l.push(g),
            s = m,
            a = d
        }
        return l
    }
    function SF(e) {
        if (!e)
            return !1;
        let t = e.viewport.xmin
          , n = e.viewport.xmax
          , r = e.viewport.ymin
          , o = e.viewport.ymax;
        return !(!isFinite(t) || !isFinite(n) || n <= t || !isFinite(r) || !isFinite(o) || o <= r || !isFinite(e.screen.width) || e.screen.width <= 0 || !isFinite(e.screen.height) || e.screen.height <= 0)
    }
    function iD(e, t) {
        let n = t - e;
        return 1 + Math.ceil(n / (n / 1e3))
    }
    var la = .001
      , Ol = new Rl(k0(),k0());
    function Hp(e, t, n) {
        var Q, K, w, B, W, oe, te, st, Tt;
        let {viewport: r, screen: o, xAxisScale: i, yAxisScale: s, degreeMode: a} = e
          , u = a ? Math.PI / 180 : 1
          , c = e.viewport.xmin
          , l = e.viewport.xmax
          , p = e.viewport.ymin
          , m = e.viewport.ymax
          , d = (Q = e.viewport.zmin) != null ? Q : Yr.zmin
          , y = (K = e.viewport.zmax) != null ? K : Yr.zmax
          , g = ((w = t.domain) == null ? void 0 : w.type) === "2d"
          , {uMin: f, uMax: h, vMin: x, vMax: T} = ((B = t.domain) == null ? void 0 : B.type) === "2d" ? t.domain : {
            uMin: 0,
            uMax: 1,
            vMin: 0,
            vMax: 1
        }
          , P = t.lineWidth;
        if (t.willConvertTo3D || P > 3) {
            let ye = t.willConvertTo3D ? 200 : e.screen.width
              , ee = P * (l - c) / ye
              , k = t.willConvertTo3D ? 200 : e.screen.height
              , ne = P * (m - p) / k;
            c -= ee,
            l += ee,
            p -= ne,
            m += ne
        }
        let S = 1 / 4, E = t.domainBound, M, _ = Rl.fromRects(eT(r), Kx(o), {
            xAxisScale: i,
            yAxisScale: s
        }), U = {
            xmin: c,
            xmax: l,
            ymin: p,
            ymax: m,
            zmin: d,
            zmax: y
        };
        switch (t.graphMode) {
        case 1:
            switch (M = mr(is([p, m]), E),
            M.type) {
            case "empty":
                return !1;
            case "interval":
                p = M.bounds[0],
                m = M.bounds[1]
            }
            let ye = Math.max(mT, 1 + Math.ceil(Math.abs(_.mapY(m) - _.mapY(p)) / S))
              , ee = new Rl(_.yScale,_.xScale);
            return {
                min: p,
                max: m,
                tolerance: S,
                nInitialSamples: ye,
                mathToPixels: ee,
                screen: {
                    width: o.height,
                    height: o.width
                }
            };
        case 2:
            {
                switch (M = mr(is([c, l]), E),
                M.type) {
                case "empty":
                    return !1;
                case "interval":
                    c = M.bounds[0],
                    l = M.bounds[1]
                }
                let k = Math.max(mT, 1 + Math.ceil(Math.abs(_.mapX(l) - _.mapX(c)) / S));
                return {
                    min: c,
                    max: l,
                    tolerance: S,
                    nInitialSamples: k,
                    mathToPixels: _,
                    screen: o
                }
            }
        case 6:
            {
                let k = e.degreeMode ? Math.PI / 180 : 1;
                if (((W = t.domain) == null ? void 0 : W.type) !== "1d")
                    throw new Error("Expected polar graph to have domain");
                let {min: ne, max: Ne} = t.domain;
                switch (M = mr(is([ne, Ne]), E),
                M.type) {
                case "empty":
                    return !1;
                case "interval":
                    ne = M.bounds[0],
                    Ne = M.bounds[1]
                }
                let _e = Math.max(mT, 1 + Math.min(Math.ceil(k * Math.abs(Ne - ne) / (2 * Math.PI) * 1e3), 12e3))
                  , gt = Math.abs(_.mapX(l) - _.mapX(c))
                  , At = Math.abs(_.mapY(m) - _.mapY(p))
                  , Fi = Math.hypot(gt, At)
                  , Cs = Math.hypot(l - c, m - p) / Fi
                  , vs = {
                    min: ne,
                    max: Ne,
                    screen: o,
                    nInitialSamples: _e,
                    xtolerance: S,
                    ytolerance: S,
                    rtoleranceMath: Cs,
                    map: ([js,Lc]) => _.mapCoordinatePair(IF([k * js, Lc]))
                };
                if (!t.domain.isExplicit) {
                    let js = fZ(n, vs, k, t.operator === "=");
                    js && (vs.max = vs.min + js,
                    vs.nInitialSamples = Math.max(mT, 1 + Math.min(Math.ceil(k * Math.abs(vs.max - vs.min) / (2 * Math.PI) * 1e3), 12e3)))
                }
                return vs
            }
        case 5:
        case 100:
            {
                let k = {
                    min: 0,
                    max: 1
                }
                  , {min: ne, max: Ne} = ((oe = t.domain) == null ? void 0 : oe.type) === "1d" ? t.domain : k;
                switch (M = mr(is([ne, Ne]), E),
                M.type) {
                case "empty":
                    return !1;
                case "interval":
                    ne = M.bounds[0],
                    Ne = M.bounds[1]
                }
                let _e;
                return (!isFinite(ne) || !isFinite(Ne)) && (_e = EF,
                ne = yT(ne),
                Ne = yT(Ne)),
                {
                    min: ne,
                    max: Ne,
                    screen: o,
                    nInitialSamples: iD(ne, Ne),
                    xtolerance: S,
                    ytolerance: S,
                    ztolerance: S,
                    parameterTransform: _e,
                    map: ([gt,At]) => _.mapCoordinatePair([gt, At])
                }
            }
        case 8:
            return {
                xmin: c,
                xmax: l,
                ymin: p,
                ymax: m,
                mathToPixels: _,
                tolerance: S
            };
        case 106:
            return {
                ...U,
                u: new Be(c,l),
                v: new Be(p,m)
            };
        case 120:
        case 122:
        case 107:
            return {
                ...U,
                u: new Be(p,m),
                v: new Be(d,y)
            };
        case 121:
        case 123:
        case 108:
            return {
                ...U,
                u: new Be(c,l),
                v: new Be(d,y)
            };
        case 109:
            return {
                ...U,
                u: new Be(f,g ? h : Yr.xmax),
                v: new Be(x,g ? T : 2 * Math.PI)
            };
        case 124:
        case 110:
            {
                let {min: k, max: ne} = ((te = t.domain) == null ? void 0 : te.type) === "1d" ? t.domain : {
                    min: 0,
                    max: 2 * Math.PI
                };
                return {
                    ...U,
                    u: new Be(k,ne),
                    v: new Be(d,y)
                }
            }
        case 211:
            {
                let {min: k, max: ne} = ((st = t.domain) == null ? void 0 : st.type) === "1d" ? t.domain : {
                    min: 0,
                    max: 2 * Math.PI / u
                };
                return {
                    ...{
                        xmin: k,
                        xmax: ne,
                        ymin: d,
                        ymax: y
                    },
                    u: new Be(k,ne),
                    v: new Be(d,y),
                    mathToPixels: Ol,
                    tolerance: la
                }
            }
        case 212:
            {
                let k = g ? h : 2 * Math.PI / u
                  , ne = g ? T : Math.PI / u;
                return {
                    ...{
                        xmin: f,
                        xmax: k,
                        ymin: x,
                        ymax: ne
                    },
                    u: new Be(f,k),
                    v: new Be(x,ne),
                    mathToPixels: Ol,
                    tolerance: la
                }
            }
        case 215:
        case 214:
            return {
                ...{
                    xmin: f,
                    xmax: h,
                    ymin: x,
                    ymax: T
                },
                u: new Be(f,h),
                v: new Be(x,x),
                mathToPixels: Ol,
                tolerance: la
            };
        case 213:
            {
                let k = g ? h : Yr.xmax
                  , ne = g ? T : 2 * Math.PI / u;
                return {
                    ...{
                        xmin: f,
                        xmax: k,
                        ymin: x,
                        ymax: ne
                    },
                    u: new Be(f,k),
                    v: new Be(x,ne),
                    mathToPixels: Ol,
                    tolerance: la
                }
            }
        case 111:
            return {
                ...U,
                u: new Be(f,g ? h : 2 * Math.PI / u),
                v: new Be(x,g ? T : Math.PI / u)
            };
        case 117:
        case 118:
        case 119:
        case 129:
        case 130:
        case 103:
        case 112:
        case 126:
        case 113:
        case 127:
        case 210:
        case 114:
            return {
                ...U,
                u: new Be(f,h),
                v: new Be(x,T)
            };
        case 200:
        case 201:
        case 202:
        case 206:
        case 205:
        case 203:
        case 204:
        case 207:
        case 208:
            {
                if (t.graphMode === 200 && (t.slice_coordinate === "z" || t.slice_coordinate === "_implicit"))
                    return {
                        xmin: c,
                        xmax: l,
                        ymin: p,
                        ymax: m,
                        mathToPixels: _,
                        tolerance: la
                    };
                if (t.graphMode === 201 && (t.slice_coordinate === "x" || t.slice_coordinate === "_implicit"))
                    return {
                        ...{
                            xmin: p,
                            xmax: m,
                            ymin: d,
                            ymax: y
                        },
                        mathToPixels: Ol,
                        tolerance: la
                    };
                if (t.graphMode === 202 && (t.slice_coordinate === "y" || t.slice_coordinate === "_implicit"))
                    return {
                        ...{
                            xmin: c,
                            xmax: l,
                            ymin: d,
                            ymax: y
                        },
                        mathToPixels: Ol,
                        tolerance: la
                    };
                let {min: k, max: ne} = ((Tt = t.domain) == null ? void 0 : Tt.type) === "1d" ? t.domain : {
                    min: 0,
                    max: 2 * Math.PI
                };
                return {
                    x: new Be(c,l),
                    y: new Be(p,m),
                    z: new Be(d,y),
                    t: new Be(k,ne),
                    u: new Be(f,h),
                    v: new Be(x,T)
                }
            }
        case 209:
            return t.slice_coordinate === "z" ? {
                xmin: c,
                xmax: l,
                ymin: p,
                ymax: m,
                mathToPixels: _,
                tolerance: la
            } : t.slice_coordinate === "x" ? {
                ...{
                    xmin: p,
                    xmax: m,
                    ymin: d,
                    ymax: y
                },
                mathToPixels: Ol,
                tolerance: la
            } : t.slice_coordinate === "y" ? {
                ...{
                    xmin: c,
                    xmax: l,
                    ymin: d,
                    ymax: y
                },
                mathToPixels: Ol,
                tolerance: la
            } : t.slice_coordinate === "_implicit" ? {
                ...U,
                u: new Be(c,l),
                v: new Be(p,m)
            } : !1;
        default:
            return !1
        }
    }
    function EF(e) {
        return Math.sinh(10 * e) / (1 - e * e)
    }
    function yT(e) {
        if (e === 1 / 0)
            return 1;
        if (e === -1 / 0)
            return -1;
        let t = Math.asinh(e);
        return 2 * t / (10 + Math.sqrt(100 + 4 * t * t))
    }
    function EZ(e) {
        switch (e) {
        case 120:
        case 122:
            return 107;
        case 121:
        case 123:
            return 108;
        case 124:
            return 110;
        case 126:
            return 112;
        case 127:
            return 113;
        default:
            return e
        }
    }
    function Ta(e) {
        var g, f, h, x, T, P, C, S, E, M, _, U, Q, K, w;
        let {viewState: t, graphInfo: n, compiled: r, derivative: o} = e, i = r.fn, {degreeMode: s} = t, a = s ? Math.PI / 180 : 1, u = Hp(t, n, i), c, l, p, m = EZ(n.graphMode), d = t.xAxisScale === "linear" && t.yAxisScale === "linear";
        if (!u)
            c = {
                segments: [],
                resolved: !0
            };
        else {
            switch (m) {
            case 1:
            case 2:
                let B = o ? o.fn : void 0;
                c = n.isLinear && d && xc(n.linearCoefficients) ? gD(n.linearCoefficients, u) : xD(i, u, B);
                break;
            case 6:
                c = sT(ye => [ye, i(ye)], u);
                break;
            case 8:
                c = Zy(i, u);
                break;
            case 5:
                u.max === u.min ? c = dZ(i, u.min) : c = n.isLinear && d && xc(n.linearCoefficients) ? mZ(n.linearCoefficients, u) : sT(i, u);
                break;
            case 100:
                let W = r.fn
                  , {min: oe, max: te} = ((g = n.domain) == null ? void 0 : g.type) === "1d" ? n.domain : {
                    min: 0,
                    max: 1
                };
                if (!isFinite(oe) || !isFinite(te)) {
                    oe = yT(oe),
                    te = yT(te);
                    let ye = W;
                    W = ee => ye(EF(ee))
                }
                let st = new Be(oe,te)
                  , Tt = qp(W, st, n.resolution, t);
                return {
                    graphMode: 100,
                    guid: Do(),
                    points: Tt,
                    color: n.color,
                    thickness: n.lineWidth,
                    compiled: r
                };
            case 112:
            case 113:
            case 130:
            case 103:
            case 106:
            case 107:
            case 108:
            case 109:
            case 110:
            case 111:
                {
                    let ye = u, {u: ee, v: k} = ye, ne = m === 112 || m === 113, Ne = n.graphMode === 122 || n.graphMode === 123, _e = ne ? Jy : Ne ? 2 : iF, {resolution: gt} = n, At = gt === void 0 || isNaN(gt) ? _e : pr(lF(gt), 2, 100), Fi = is([ee.min, ee.max]).type !== "empty" && is([k.min, k.max]).type !== "empty", Cr;
                    switch (Fi && m) {
                    case 103:
                        {
                            let js = r.fn;
                            Cr = hF(js, ye, ee, k, At);
                            break
                        }
                    case 130:
                        {
                            Cr = hF( (Lc, LI) => {
                                let[Je,re] = r.fn(Lc, LI);
                                return [Je, re, 0]
                            }
                            , ye, ee, k, At);
                            break
                        }
                    case 106:
                        Cr = bZ(r, ye, At);
                        break;
                    case 107:
                        Cr = xZ(r, ye, At);
                        break;
                    case 108:
                        Cr = TZ(r, ye, At);
                        break;
                    case 109:
                        Cr = IZ(r, ye, ee, k, At, s);
                        break;
                    case 110:
                        Cr = PZ(r, ye, ee, k, At, s);
                        break;
                    case 111:
                        Cr = SZ(r, ye, ee, k, At, s);
                        break;
                    case 112:
                    case 113:
                        Cr = TD(r, e.dependencies, e.gradient, u, At, {
                            isInequality: (f = e.isImplicit3dInequality) != null ? f : !1
                        });
                        break;
                    case !1:
                        Cr = hZ();
                        break
                    }
                    let Cs = n.graphMode === 113 || n.graphMode === 127;
                    return {
                        meshData: Cr,
                        resolved: Cr.resolved,
                        color: n.color,
                        surfaceOpacity: Cs ? 1 : (h = n.surfaceOpacity) != null ? h : 1,
                        uvArgs: (x = Ji[n.graphMode]) != null ? x : [],
                        extraMeshArgs: (T = Al[n.graphMode]) != null ? T : [],
                        graphMode: m,
                        compiled: r,
                        restrictionShader: e.restrictionShader3d
                    }
                }
            case 200:
            case 201:
            case 202:
            case 211:
            case 206:
            case 205:
            case 203:
            case 204:
            case 213:
            case 207:
            case 208:
            case 212:
            case 214:
            case 215:
            case 209:
                {
                    let ye = (Je, re, hn) => {
                        let It = (Vg, Bg) => {
                            let tm = hn(Vg, Bg);
                            return isNaN(tm[0]) || isNaN(tm[1]) || isNaN(tm[2]) ? NaN : Je(Vg, Bg)
                        }
                          , $e = t.viewport
                          , {xmin: ft, xmax: Wn, ymin: We, ymax: Ve, zmin: on, zmax: em} = $e
                          , uf = (ft + Wn) / 2
                          , FI = (We + Ve) / 2
                          , VI = (on + em) / 2
                          , oq = Wn - ft
                          , iq = Ve - We
                          , sq = em - on
                          , CR = Zy(It, {
                            ...re,
                            map3d: (Vg, Bg) => {
                                let[tm,vR,MR] = hn(Vg, Bg);
                                return isNaN(tm) || isNaN(vR) || isNaN(MR) ? [NaN, NaN, NaN] : [(tm - uf) / oq, (vR - FI) / iq, (MR - VI) / sq]
                            }
                        });
                        return {
                            segments: CR.segments,
                            resolved: CR.resolved,
                            graphMode: 8,
                            color: n.color,
                            lineWidth: n.lineWidth,
                            lineOpacity: n.lineOpacity,
                            listIndex: n.listIndex,
                            operator: n.operator,
                            compiled: r,
                            poi: {}
                        }
                    }
                    , ee = r.fn, k = (P = n.slice_value) != null ? P : 0, ne = (C = n.slice_coordinate) != null ? C : "", Ne = u, _e, gt, At, Fi = {}, Cr = !0, Cs = (Je, re) => {
                        let It = ye(Je, u, (We, Ve) => {
                            let {x: on, y: em, z: uf} = re(We, Ve, Je(We, Ve));
                            return [on, em, uf]
                        }
                        )
                          , $e = n.lineWidth
                          , ft = Ky(It, t, $e, k)
                          , Wn = ft.points;
                        for (let We = 0; We < Wn.length / 3; We++) {
                            let Ve = Wn[3 * We]
                              , on = Wn[3 * We + 1]
                              , em = Wn[3 * We + 2]
                              , {x: uf, y: FI, z: VI} = re(Ve, on, em);
                            Wn[3 * We] = uf,
                            Wn[3 * We + 1] = FI,
                            Wn[3 * We + 2] = VI
                        }
                        return ft
                    }
                    , vs = (Je, re) => {
                        let hn = [];
                        for (let ft = 0; ft < Je.segments.length; ft++) {
                            let Wn = Je.segments[ft];
                            for (let We = 0; We < Wn.length / 2; We++) {
                                let Ve = Wn[2 * We]
                                  , on = Wn[2 * We + 1];
                                hn.push(re(Ve, on))
                            }
                            ft < Je.segments.length - 1 && hn.push([NaN, NaN, 0])
                        }
                        let It = n.lineWidth
                          , $e = t.viewport;
                        return Gd(hn, $e, It)
                    }
                    , js = u, Lc = (Je, re) => {
                        var It;
                        let hn = ye(Je, js, re);
                        return Cr = (It = hn.resolved) != null ? It : !0,
                        vs(hn, re)
                    }
                    ;
                    switch (m) {
                    case 200:
                        {
                            if (ne === "z")
                                return Cs( (re, hn) => ee(re, hn) - k, mF);
                            if (ne === "_implicit") {
                                let re = n.slice_function.fn;
                                At = Lc( ($e, ft) => re($e, ft, ee($e, ft)), ($e, ft) => [$e, ft, ee($e, ft)]);
                                break
                            }
                            let Je = ne === "x";
                            _e = Je ? Ne.y : Ne.x,
                            gt = Je ? re => [k, re, ee(k, re)] : re => [re, k, ee(re, k)],
                            At = qp(gt, _e, n.resolution, t);
                            break
                        }
                    case 201:
                        {
                            if (ne === "x")
                                return Cs( (re, hn) => ee(re, hn) - k, dF);
                            if (ne === "_implicit") {
                                let re = n.slice_function.fn;
                                At = Lc( ($e, ft) => re(ee($e, ft), $e, ft), ($e, ft) => [ee($e, ft), $e, ft]);
                                break
                            }
                            let Je = ne === "y";
                            _e = Je ? Ne.z : Ne.y,
                            gt = Je ? re => [ee(k, re), k, re] : re => [ee(re, k), re, k],
                            At = qp(gt, _e, n.resolution, t);
                            break
                        }
                    case 202:
                        {
                            if (ne === "y")
                                return Cs( (re, hn) => ee(re, hn) - k, fF);
                            if (ne === "_implicit") {
                                let re = n.slice_function.fn;
                                At = Lc( ($e, ft) => re($e, ee($e, ft), ft), ($e, ft) => [$e, ee($e, ft), ft]);
                                break
                            }
                            let Je = ne === "x";
                            _e = Je ? Ne.z : Ne.x,
                            gt = Je ? re => [k, ee(k, re), re] : re => [re, ee(re, k), k],
                            At = qp(gt, _e, n.resolution, t);
                            break
                        }
                    case 209:
                        {
                            let Je = r.fn;
                            if (ne === "x")
                                return Cs( (re, hn) => Je(k, re, hn), dF);
                            if (ne === "y")
                                return Cs( (re, hn) => Je(re, k, hn), fF);
                            if (ne === "z")
                                return Cs( (re, hn) => Je(re, hn, k), mF);
                            if (ne === "_implicit") {
                                let {resolution: re} = n
                                  , hn = re === void 0 || isNaN(re) ? Jy : pr(lF(re), 2, 100);
                                At = oF(r.fn, n.slice_function.fn, u, hn);
                                let It = t.viewport
                                  , $e = [];
                                for (let ft = 0; ft < At.length / 3; ft++)
                                    $e.push([At[3 * ft], At[3 * ft + 1], At[3 * ft + 2]]);
                                At = Gd($e, It, n.lineWidth),
                                Fi = n.slice_function.executionMetadata;
                                break
                            } else
                                throw new Error("Programming Error: unexpected slice coordinate")
                        }
                    case 206:
                    case 205:
                        {
                            let Je = ne === "z";
                            _e = Je ? Ne.t : Ne.z,
                            gt = Je ? re => [ee(re, k), re, k] : re => [ee(k, re), k, re],
                            At = oD(gt, _e, n.resolution, t);
                            break
                        }
                    case 211:
                        {
                            let Je = r.fn, re;
                            switch (ne) {
                            case "x":
                                re = (We, Ve) => Je(We, Ve) * Yn(We * a) - k;
                                break;
                            case "y":
                                re = (We, Ve) => Je(We, Ve) * Nn(We * a) - k;
                                break;
                            case "r":
                                re = (We, Ve) => Je(We, Ve) - k;
                                break;
                            case "_implicit":
                                let Wn = n.slice_function.fn;
                                re = (We, Ve) => Wn(Je(We, Ve) * Yn(We * a), Je(We, Ve) * Nn(We * a), Ve, Je(We, Ve), We);
                                break;
                            default:
                                throw new Error("Programming Error: bad slice")
                            }
                            let hn = ne === "x"
                              , It = ne === "y"
                              , $e = (Wn, We) => [hn ? k : Je(Wn, We) * Yn(Wn * a), It ? k : Je(Wn, We) * Nn(Wn * a), We]
                              , ft = ye(re, js, $e);
                            At = vs(ft, $e),
                            Cr = (S = ft.resolved) != null ? S : !0;
                            break
                        }
                    case 213:
                        {
                            let Je = ne === "x", re = ne === "y", hn = ne === "z", It = r.fn, $e;
                            switch (ne) {
                            case "x":
                                $e = (Ve, on) => Ve * Yn(on * a) - k;
                                break;
                            case "y":
                                $e = (Ve, on) => Ve * Nn(on * a) - k;
                                break;
                            case "z":
                                $e = (Ve, on) => It(Ve, on) - k;
                                break;
                            case "_implicit":
                                let We = n.slice_function.fn;
                                $e = (Ve, on) => We(Ve * Yn(on * a), Ve * Nn(on * a), It(Ve, on), Ve, on);
                                break;
                            default:
                                throw new Error("Programming Error: bad slice")
                            }
                            let ft = (We, Ve) => [Je ? k : We * Yn(Ve * a), re ? k : We * Nn(Ve * a), hn ? k : It(We, Ve)]
                              , Wn = ye($e, js, ft);
                            At = vs(Wn, ft);
                            break
                        }
                    case 212:
                        {
                            let Je = ne === "x", re = ne === "y", hn = ne === "z", It = r.fn, $e;
                            switch (ne) {
                            case "x":
                                $e = (Ve, on) => It(Ve, on) * Nn(on * a) * Yn(Ve * a) - k;
                                break;
                            case "y":
                                $e = (Ve, on) => It(Ve, on) * Nn(on * a) * Nn(Ve * a) - k;
                                break;
                            case "z":
                                $e = (Ve, on) => It(Ve, on) * Yn(on * a) - k;
                                break;
                            case "rho":
                                $e = (Ve, on) => It(Ve, on) - k;
                                break;
                            case "_implicit":
                                let We = n.slice_function.fn;
                                $e = (Ve, on) => We(It(Ve, on) * Nn(on * a) * Nn(Ve * a), It(Ve, on) * Nn(on * a) * Yn(Ve * a), It(Ve, on) * Yn(on * a), It(Ve, on), Ve, on);
                                break;
                            default:
                                throw new Error("Programming Error: bad slice")
                            }
                            let ft = (We, Ve) => [Je ? k : It(We, Ve) * Nn(Ve * a) * Yn(We * a), re ? k : It(We, Ve) * Nn(Ve * a) * Nn(We * a), hn ? k : It(We, Ve) * Yn(Ve * a)]
                              , Wn = ye($e, js, ft);
                            At = vs(Wn, ft),
                            Cr = (E = Wn.resolved) != null ? E : !0;
                            break
                        }
                    case 215:
                    case 214:
                        {
                            let Je = m === 214 ? r.fn : (hn, It) => {
                                let[$e,ft] = r.fn(hn, It);
                                return [$e, ft, 0]
                            }
                            , re;
                            switch (ne) {
                            case "x":
                                re = (It, $e) => Je(It, $e)[0] - k;
                                break;
                            case "y":
                                re = (It, $e) => Je(It, $e)[1] - k;
                                break;
                            case "z":
                                re = (It, $e) => Je(It, $e)[2] - k;
                                break;
                            case "u":
                                re = (It, $e) => It - k;
                                break;
                            case "v":
                                re = (It, $e) => $e - k;
                                break;
                            case "_implicit":
                                let hn = n.slice_function.fn;
                                re = (It, $e) => {
                                    let[ft,Wn,We] = Je(It, $e);
                                    return hn(ft, Wn, We, It, $e)
                                }
                                ;
                                break;
                            default:
                                throw new Error("Programming Error: bad slice")
                            }
                            At = Lc(re, Je),
                            Fi = (_ = (M = n.slice_function) == null ? void 0 : M.executionMetadata) != null ? _ : {};
                            break
                        }
                    case 203:
                    case 204:
                        {
                            let Je = ne === "r";
                            _e = Je ? Ne.v : Ne.u,
                            gt = Je ? re => [k, re, ee(k, re)] : re => [re, k, ee(re, k)],
                            At = oD(gt, _e, n.resolution, t);
                            break
                        }
                    case 207:
                    case 208:
                        {
                            let Je = ne === "theta";
                            _e = Je ? Ne.v : Ne.u,
                            gt = Je ? re => [ee(k, re), k, re] : re => [ee(re, k), re, k],
                            At = KL(gt, _e, n.resolution, t);
                            break
                        }
                    }
                    let LI = {
                        goodCoercionCount: ((U = Fi.goodCoercionCount) != null ? U : 0) + ((Q = r.executionMetadata.goodCoercionCount) != null ? Q : 0),
                        badCoercionCount: ((K = Fi.badCoercionCount) != null ? K : 0) + ((w = r.executionMetadata.badCoercionCount) != null ? w : 0)
                    };
                    return {
                        graphMode: 100,
                        guid: Do(),
                        points: At,
                        resolved: Cr,
                        color: n.color,
                        thickness: n.lineWidth,
                        compiled: {
                            ...r,
                            executionMetadata: LI
                        }
                    }
                }
            default:
                throw new Error("Programming Error: unexpected graphmode " + m)
            }
            p = c.poi
        }
        if ((!p || p.zeros.x.length + p.extrema.x.length + p.intercept.x.length > 250) && (p = pZ()),
        m === 1)
            for (let B in p) {
                if (!p.hasOwnProperty(B))
                    continue;
                let W = B;
                l = p[W].y,
                p[W].y = p[W].x,
                p[W].x = l
            }
        let y = {
            segments: c.segments,
            resolved: c.resolved,
            graphMode: m,
            color: n.color,
            style: n.lineStyle,
            lineWidth: n.lineWidth,
            lineOpacity: n.lineOpacity,
            listIndex: n.listIndex,
            operator: n.operator,
            poi: p,
            compiled: r
        };
        if (m === 6) {
            let B = u;
            y.sampledDomain = {
                min: B.min,
                max: B.max
            }
        }
        return c.fillSegments && (y.fillSegments = c.fillSegments),
        y
    }
    function CZ(e, t, n) {
        let r, o, i, s, a = [], u = null;
        switch (n) {
        case 6:
            u = IF;
            break;
        case 1:
            u = function(c) {
                return [c[1], c[0]]
            }
            ;
            break
        }
        for (r = 0; r < e.length; r++)
            for (s = e[r],
            o = 0; o < s.length; o += 2)
                i = [s[o], s[o + 1]],
                u && (i = u(i)),
                a.push(i[0], i[1]);
        for (r = t.length - 1; r >= 0; r--)
            for (s = t[r],
            o = s.length - 2; o >= 0; o -= 2)
                i = [s[o], s[o + 1]],
                u && (i = u(i)),
                a.push(i[0], i[1]);
        return a
    }
    function zd(e, t, n) {
        let r = l => l[l.length - 2]
          , o = []
          , i = 0
          , s = 0
          , a = []
          , u = []
          , c = -1 / 0;
        for (; ; ) {
            for (; s < e.length && !(e[s].length >= 2); )
                s += 1;
            for (; i < t.length && !(t[i].length >= 2); )
                i += 1;
            (s >= e.length || e[s][0] > c) && (i >= t.length || t[i][0] > c) && (a.length > 0 && u.length > 0 && o.push(CZ(a, u, n)),
            a = [],
            u = [],
            c = Math.max(c, s < e.length ? r(e[s]) : 1 / 0),
            c = Math.max(c, i < t.length ? r(t[i]) : 1 / 0));
            let l = !1;
            if (s < e.length && e[s][0] <= c && (c = Math.max(c, r(e[s])),
            a.push(e[s]),
            s += 1,
            l = !0),
            i < t.length && t[i][0] <= c && (c = Math.max(c, r(t[i])),
            u.push(t[i]),
            i += 1,
            l = !0),
            !l)
                break
        }
        return o
    }
    function Up(e) {
        let t = []
          , n = {};
        for (let r = 0; r < e.length; r++) {
            let o = e[r]
              , [i,s] = o;
            !isNaN(i) && !isNaN(s) ? t.push(o) : n[r] = !0
        }
        return {
            points: t,
            droppedIndices: n
        }
    }
    var Ji = {
        [8]: ["x", "y"],
        [106]: ["x", "y"],
        [120]: ["y", "z"],
        [122]: ["y", "z"],
        [107]: ["y", "z"],
        [121]: ["x", "z"],
        [123]: ["x", "z"],
        [108]: ["x", "z"],
        [109]: ["r", "theta"],
        [124]: ["theta", "z"],
        [110]: ["theta", "z"],
        [111]: ["theta", "phi"],
        [130]: ["u", "v"],
        [103]: ["u", "v"],
        [126]: ["x", "y"],
        [112]: ["x", "y", "z"],
        [113]: ["x", "y", "z"],
        [127]: ["x", "y"],
        [201]: ["y", "z"],
        [202]: ["x", "z"],
        [200]: ["x", "y"],
        [206]: ["theta", "z"],
        [205]: ["theta", "z"],
        [211]: ["theta", "z"],
        [203]: ["r", "theta"],
        [204]: ["r", "theta"],
        [213]: ["r", "theta"],
        [207]: ["theta", "phi"],
        [208]: ["theta", "phi"],
        [212]: ["theta", "phi"],
        [214]: ["u", "v"],
        [215]: ["u", "v"],
        [209]: ["x", "y", "z"],
        [210]: ["x", "y", "z"]
    }
      , Al = {
        [110]: ["r"],
        [111]: ["rho"]
    };
    function Jle(e) {
        return e.graphMode === 3 || e.graphMode === 25 || El(e.graphMode)
    }
    function Qle(e) {
        return El(e.graphMode)
    }
    var NZ = {};
    cu(NZ, {
        LinearToSRGB: () => _Z,
        SRGBToLinear: () => hT,
        colorString: () => CF,
        colors: () => kp,
        colors3d: () => RZ,
        convertColorStringToLinearRGB: () => PD,
        getDisplayColor: () => $s,
        invertColor: () => MZ,
        isValidHexColor: () => bT,
        mutateOpacity: () => DZ,
        normalizeColor: () => ID,
        parseHex: () => vF,
        shadeColor: () => vZ
    });
    function ID(e) {
        return bT(e) ? (e.match(/^#([A-Fa-f0-9]{3})$/g) && (e = "#" + e[1] + e[1] + e[2] + e[2] + e[3] + e[3]),
        e.toLowerCase()) : e
    }
    function bT(e) {
        return typeof e == "string" && (e.match(/^#([A-Fa-f0-9]{3})$/g) || e.match(/^#([A-Fa-f0-9]{6})$/g))
    }
    function vZ(e, t) {
        if (e = ID(e),
        !bT(e))
            return e;
        t > 1 && (t = 1),
        t < -1 && (t = -1);
        let n = parseInt(e.slice(1), 16)
          , r = t < 0 ? 0 : 255
          , o = t < 0 ? t * -1 : t
          , i = n >> 16
          , s = n >> 8 & 255
          , a = n & 255;
        return CF(Math.round((r - i) * o) + i, Math.round((r - s) * o) + s, Math.round((r - a) * o) + a)
    }
    function CF(e, t, n) {
        return "#" + (16777216 + Math.round(e) * 65536 + Math.round(t) * 256 + Math.round(n)).toString(16).slice(1)
    }
    function MZ(e) {
        if (e = ID(e),
        !bT(e))
            return e;
        let t = "0123456789abcdef";
        return "#" + e.slice(1).split("").map(n => t[15 - t.indexOf(n)]).join("")
    }
    function vF(e) {
        e = e.replace(/#/, "");
        let t, n, r;
        return e.length === 3 ? (t = parseInt(e.slice(0, 1) + e.slice(0, 1), 16),
        n = parseInt(e.slice(1, 2) + e.slice(1, 2), 16),
        r = parseInt(e.slice(2, 3) + e.slice(2, 3), 16)) : e.length === 6 ? (t = parseInt(e.slice(0, 2), 16),
        n = parseInt(e.slice(2, 4), 16),
        r = parseInt(e.slice(4, 6), 16)) : (t = 0,
        n = 0,
        r = 0),
        {
            r: t,
            g: n,
            b: r
        }
    }
    function DZ(e, t) {
        let n = /(rgba\([\d]+\,\ ?[\d]+\,\ ?[\d]+\,\ ?)[\d.]+(\))/;
        return e.match(n) ? e.replace(n, `$1${t}$2`) : e
    }
    function $s(e, t) {
        if (t && t.colorLatexValue) {
            let n = t.colorLatexValue;
            return Array.isArray(n) ? n[0] : n
        }
        return e.color
    }
    function hT(e) {
        return e < .04045 ? e * .0773993808 : Math.pow(e * .9478672986 + .0521327014, 2.4)
    }
    function _Z(e) {
        return e < .0031308 ? e * 12.92 : 1.055 * Math.pow(e, .41666) - .055
    }
    function PD(e) {
        let t = vF(e);
        return [hT(t.r / 255), hT(t.g / 255), hT(t.b / 255)]
    }
    var kp = {
        RED: "#c74440",
        BLUE: "#2d70b3",
        GREEN: "#348543",
        PURPLE: "#6042a6",
        ORANGE: "#fa7e19",
        BLACK: "#000000",
        GRAY: "#aaaaaa",
        FOCUS_OUTLINE: "#2f72dc"
    }
      , RZ = {
        RED: kp.RED,
        BLUE: kp.BLUE,
        GREEN: kp.GREEN,
        ORANGE: kp.ORANGE,
        PURPLE: kp.PURPLE,
        GRAY: kp.GRAY
    };
    function co(e, t, n) {
        let r = n.getDependencies(), o, i;
        switch (r.length) {
        case 0:
            o = MF(n),
            i = n.boundDomain("x");
            break;
        case 1:
            i = n.boundDomain(r[0]),
            os(i) && !Ei(i) && (o = MF(n));
            break;
        default:
            i = Vr();
            break
        }
        return {
            graphMode: e.getGraphMode(t, n),
            color: $s(e.userData, e.metaData),
            pointStyle: e.userData.pointStyle,
            lineStyle: e.userData.lineStyle,
            arrowMode: e.userData.arrowMode,
            operator: e.getOperator(),
            isLinear: !!o,
            linearCoefficients: o,
            domainBound: i
        }
    }
    function MF(e) {
        switch (e.valueType) {
        case b:
            return SD(e);
        case R:
            {
                let t = SD(e.slot(0))
                  , n = SD(e.slot(1));
                return !t || !n ? void 0 : [t, n]
            }
        default:
            return
        }
    }
    function SD(e) {
        let t = e.getDependencies();
        switch (t.length) {
        case 0:
            return [+e.asValue(), 0];
        case 1:
            if (e.polynomialOrder(t[0]) > 1)
                return;
            let n = e.getPolynomialCoefficients(t[0]);
            return [n[0] ? +n[0].asValue() : 0, n[1] ? +n[1].asValue() : 0];
        default:
            return
        }
    }
    var ng = class {
        constructor(t) {
            this.parentType = t;
            this.count = 0;
            this.intersections = []
        }
        addPoint(t) {
            this.intersections.push(t),
            this.count += 1
        }
        addPoints(t) {
            this.intersections.push(...t),
            this.count += t.length
        }
        addIntersection(t, n) {
            n.valueType === R ? this.addPoint(n.value) : this.addPoints(n.value)
        }
        getPoints() {
            return this.intersections
        }
    }
      , Hd = class {
        constructor(t) {
            this.parentType = t;
            this.count = 0;
            this.intersectionsByIndex = new Map;
            if (t === Tr)
                this.scalarType = Ee;
            else if (t === fo)
                this.scalarType = Ae;
            else if (t === mo)
                this.scalarType = ce;
            else
                throw new Error(`Expected ListOfSegment or ListOfArc but got ${Ke(t)}`)
        }
        getListItemIntersections(t) {
            let n = this.intersectionsByIndex.get(t);
            return n || (n = new ng(this.scalarType),
            this.intersectionsByIndex.set(t, n)),
            n
        }
        addIntersection(t, n) {
            let r = Ja(t);
            if (r !== void 0) {
                let o = r - 1
                  , i = this.getListItemIntersections(o);
                n.valueType === zt ? i.addPoints(n.value) : i.addPoint(n.value),
                this.count += 1
            } else {
                Nu(n.valueType, [zt]);
                for (let o = 0; o < n.value.length; o++)
                    this.getListItemIntersections(o).addPoint(n.value[o]);
                this.count += n.value.length
            }
        }
    }
      , ED = class {
        constructor() {
            this.parentType = De;
            this.count = 0;
            this.intersectionsByEdgeIndex = new Map
        }
        getEdgeIntersections(t) {
            let n = this.intersectionsByEdgeIndex.get(t);
            return n || (n = new ng(Ee),
            this.intersectionsByEdgeIndex.set(t, n)),
            n
        }
        addPoint(t, n) {
            this.getEdgeIntersections(t).addPoint(n),
            this.count += 1
        }
        addIntersection(t, n) {
            if (t.type !== "polygon-edge")
                throw new Error(`Expected a polygon edge parent ref type but got ${t.type}`);
            let r = t.edgeIndex - 1
              , o = this.getEdgeIntersections(r);
            n.valueType === zt ? (o.addPoints(n.value),
            this.count += n.value.length) : (o.addPoint(n.value),
            this.count += 1)
        }
    }
      , CD = class {
        constructor() {
            this.parentType = Dr;
            this.count = 0;
            this.intersectionsByEdgeIndex = new Map
        }
        getEdgeIntersections(t) {
            let n = this.intersectionsByEdgeIndex.get(t);
            return n || (n = new Hd(Tr),
            this.intersectionsByEdgeIndex.set(t, n)),
            n
        }
        addIntersection(t, n) {
            if (t.type !== "polygon-edge")
                throw new Error(`Expected a polygon edge parent ref type but got ${t.type}`);
            let r = t.edgeIndex - 1
              , o = this.getEdgeIntersections(r)
              , i = Ja(t);
            if (i !== void 0) {
                let s = i - 1;
                n.valueType === zt ? o.getListItemIntersections(s).addPoints(n.value) : o.getListItemIntersections(s).addPoint(n.value),
                this.count += 1
            } else {
                Nu(n.valueType, [zt]);
                for (let s = 0; s < n.value.length; s++)
                    o.getListItemIntersections(s).addPoint(n.value[s]);
                this.count += n.value.length
            }
        }
    }
      , Ud = class {
        constructor() {
            this.data = {}
        }
        getChildIntersections(t) {
            return this.data[t]
        }
        addChildIntersection(t, n) {
            Nu(n == null ? void 0 : n.valueType, [R, zt]);
            let r;
            if (t.valueType == Dr)
                r = this.data[t.id] || new CD;
            else if (t.valueType === Tr || t.valueType === fo || t.valueType === mo)
                r = this.data[t.id] || new Hd(t.valueType);
            else if (t.valueType === De)
                r = this.data[t.id] || new ED;
            else if (t.valueType === Ee || t.valueType === Ae || t.valueType === ce)
                r = this.data[t.id] || new ng(t.valueType);
            else
                return;
            this.data[t.id] = r,
            r.addIntersection(t.ref, n)
        }
        static compareIntersectionCounts({prevChildIntersections: t, nextChildIntersections: n}) {
            var i, s;
            let r = {}
              , o = new Set([...Object.keys(t.data), ...Object.keys(n.data)]);
            for (let a of o) {
                let u = ((i = t.data[a]) == null ? void 0 : i.count) || 0
                  , c = ((s = n.data[a]) == null ? void 0 : s.count) || 0;
                r[a] = {
                    prev: u,
                    next: c
                }
            }
            return r
        }
    }
    ;
    function vD(e, t) {
        let n;
        switch (t) {
        case "solvedEquation":
            n = 2;
            break;
        case "baseComparator":
            n = 4;
            break;
        default:
            n = 1;
            break
        }
        return Math.floor(e / n)
    }
    var OZ = {
        lineOpacity: "computedLineOpacity",
        lineWidth: "computedLineWidth",
        color: "colorLatexValue",
        fillOpacity: "fillOpacity",
        surfaceOpacity: "surfaceOpacity",
        resolution: "resolution"
    };
    function AZ(e) {
        return e.startsWith("shader:")
    }
    function TT(e, t) {
        return "colorLatex"in e && AZ(e.colorLatex) ? e.colorLatex : t
    }
    function Ia(e, t, n) {
        return Array.isArray(e) ? e[vD(t, n)] : e
    }
    function Ys(e, t, n) {
        let r = 1 / 0;
        for (let i of t) {
            let s = e[i];
            Array.isArray(s) && s.length < r && (r = s.length)
        }
        let o = 1;
        return n === "solvedEquation" ? o = 2 : n === "baseComparator" && (o = 4),
        o * r
    }
    function ru(e, t, n) {
        let r = vD(t, n)
          , o = e.userData.lineStyle
          , i = Ia(e.metaData.computedLineWidth, t, n)
          , s = Ia(e.metaData.computedLineOpacity, t, n)
          , a = Ia(e.metaData.computedFillOpacity, t, n)
          , u = Ia(e.metaData.computedSurfaceOpacity, t, n)
          , c = e.metaData.colorLatexValue ? Ia(e.metaData.colorLatexValue, t, n) : e.userData.color
          , l = Ia(e.metaData.computedResolution, t, n);
        return {
            listIndex: r,
            style: o,
            lineWidth: i,
            lineOpacity: s,
            fillOpacity: a,
            surfaceOpacity: u,
            color: c,
            resolution: l
        }
    }
    function lo(e, {node: t, concrete: n, graphInfo: r, styleBroadcastStrategy: o, policy: i}, s) {
        let a = Ys(t.metaData, Object.keys(e).map(c => OZ[c]), o)
          , u = [];
        return Vo.wrap(n).eachElement( (c, l) => {
            if (l >= a)
                return;
            let p = co(t, i, c);
            p.graphMode = r.graphMode;
            let m = ru(t, l, o);
            p.listIndex = m.listIndex,
            p.style = m.style,
            "lineWidth"in e && (p.lineWidth = m.lineWidth),
            "lineOpacity"in e && (p.lineOpacity = m.lineOpacity),
            "fillOpacity"in e && (p.fillOpacity = m.fillOpacity),
            "surfaceOpacity"in e && (p.surfaceOpacity = m.surfaceOpacity),
            "color"in e && (p.color = TT(t.userData, m.color)),
            "resolution"in e && (p.resolution = m.resolution),
            u.push(...s(c, p))
        }
        ),
        u
    }
    function MD(...e) {
        return e.some(t => isNaN(t))
    }
    function IT(e, t) {
        if (!t)
            return [];
        let n = [];
        for (let r of e) {
            let o = t;
            if ("listIndex"in r && r.listIndex !== void 0 && t instanceof Hd && (o = t.getListItemIntersections(r.listIndex)),
            r.graphMode === 17 || r.graphMode === 19) {
                Nu(o.parentType, [Ee, Ae]);
                let i = o.getPoints();
                if (!i)
                    continue;
                let s = 0, a, u = 1, c, [l,p,m,d] = r.segments[0];
                for (let y = 0; y < i.length; y++) {
                    let[g,f] = i[y]
                      , h = Qs(g, f, 0, l, p, 0, m, d, 0);
                    h < s && (s = h,
                    a = y),
                    r.graphMode === 17 && h > u && (u = h,
                    c = y)
                }
                a !== void 0 && n.push(xT(r, 17, [[l, p, i[a][0], i[a][1]]])),
                c !== void 0 && n.push(xT(r, 17, [[m, d, i[c][0], i[c][1]]]))
            } else if (r.graphMode === 21) {
                Nu(o.parentType, [ce]);
                let i = o.getPoints();
                if (!i)
                    continue;
                let[s,a,u,c,l] = r.segments[0]
                  , p = l - c + (l < c ? 1 : -1) * 2 * Math.PI
                  , m = [];
                for (let d of i) {
                    let[y,g] = d
                      , f = Math.atan2(g - a, y - s)
                      , h = Z1(f, c, p);
                    0 < h && h < 1 && m.push(h)
                }
                if (m.length) {
                    m.push(0, 1),
                    m.sort();
                    let d = 0
                      , y = 0;
                    for (let h = 0; h < m.length - 1; h++) {
                        let x = m[h + 1] - m[h];
                        (d === void 0 || x > d) && (d = x,
                        y = h)
                    }
                    let g = m[y]
                      , f = m[y + 1];
                    g > 0 && n.push(xT(r, 21, [[s, a, u, c, c + g * p]])),
                    f < 1 && n.push(xT(r, 21, [[s, a, u, l, l - (1 - f) * p]]))
                }
            }
        }
        return n
    }
    function xT(e, t, n) {
        return {
            resolved: !0,
            graphMode: t,
            segments: n,
            operator: e.operator,
            poi: {},
            color: e.color,
            style: cm.DASHED,
            lineWidth: 1,
            lineOpacity: .5,
            isIntersectionExtension: !0
        }
    }
    function PT(e) {
        let t = []
          , n = [];
        for (let[r,o] of e)
            !isNaN(r) && !isNaN(o) ? t.push(r, o) : (t.length >= 4 && n.push(t),
            t = []);
        return t.length >= 4 && n.push(t),
        n
    }
    function DF({node: e, reconciledProps: t, styleBroadcastStrategy: n, viewState: r, concrete: o}) {
        let i = []
          , s = e.userData.shouldGraph && t.points
          , a = e.userData.shouldGraph && t.lines
          , u = ["colorLatexValue"];
        s && u.push("computedPointOpacity", "computedPointSize");
        let c = Vo.wrap(o).asValue();
        Br(c);
        let l = Ys(e.metaData, u, n)
          , p = Math.min(c.length, l);
        if (s)
            for (let m = 0; m < p; m++) {
                let {color: d} = ru(e, m, n)
                  , y = Ia(e.metaData.computedPointSize, m, n);
                i.push({
                    graphMode: 114,
                    position: c[m],
                    radius: .02 * y,
                    guid: Do(),
                    color: d
                })
            }
        if (a) {
            let m = Ia(e.metaData.computedLineWidth, 0, n)
              , {color: d} = ru(e, 0, n);
            i.push({
                graphMode: 100,
                points: Gd(c, r.viewport, m),
                thickness: m,
                guid: Do(),
                color: d
            })
        }
        return i
    }
    function _F({node: e, concrete: t, styleBroadcastStrategy: n, graphInfo: r, policy: o}) {
        var C;
        let i = e.metaData.colorLatexValue ? !Array.isArray(e.metaData.colorLatexValue) : !0
          , s = e.metaData.computedSurfaceOpacity
          , a = []
          , u = []
          , c = []
          , l = []
          , p = []
          , [m,d,y] = [new it, new it, new it]
          , [g,f,h] = [new it, new it, new it]
          , x = (S, E, M, _, U, Q, K, w, B) => {
            if (g.set(S, E, M),
            f.set(_, U, Q),
            h.set(K, w, B),
            !g.isFinite() || !f.isFinite() || !h.isFinite())
                return !1;
            let W = a.length / 3;
            return a.push(g.x, g.y, g.z, f.x, f.y, f.z, h.x, h.y, h.z),
            m.subVectors(g, h),
            d.subVectors(f, g),
            y.crossVectors(m, d),
            u.push(y.x, y.y, y.z, y.x, y.y, y.z, y.x, y.y, y.z),
            c.push(W, W + 1, W + 2),
            l.push(0, 0, 0, 1, 1, 0),
            !0
        }
          , T = () => {
            let S = {
                guid: Do(),
                resolved: !0,
                positions: new Float32Array(a),
                normals: new Float32Array(u),
                faces: new Uint32Array(c),
                uvs: new Float32Array(l),
                extraAttrs: new Float32Array([])
            };
            return p.length && (S.colors = new Float32Array(p)),
            S
        }
        ;
        if (t.valueType === Zo && !Array.isArray(s)) {
            let S = e.metaData.computedSurfaceOpacity
              , E = "";
            if (i) {
                let Q = (C = e.metaData.colorLatexValue) != null ? C : e.userData.color;
                E = TT(e.userData, Q)
            }
            let M = ST(t._chunk)
              , _ = M.value
              , U = M.restriction;
            for (let Q = 0; Q < _.length; Q++) {
                let[[K,w,B],[W,oe,te],[st,Tt,ye]] = _[Q]
                  , ee = x(K, w, B, W, oe, te, st, Tt, ye);
                if (!i && ee) {
                    let k = e.metaData.colorLatexValue[Q]
                      , [ne,Ne,_e] = PD(k);
                    p.push(ne, Ne, _e, ne, Ne, _e, ne, Ne, _e)
                }
            }
            return [{
                meshData: T(),
                color: E,
                surfaceOpacity: S != null ? S : 1,
                restrictionShader: U,
                graphMode: 117
            }]
        }
        let P = t.getRestrictedFunctionForGLSL(["x", "y", "z"], Qi);
        return t = P.concrete,
        lo({
            color: !0,
            surfaceOpacity: !0
        }, {
            concrete: t,
            graphInfo: r,
            node: e,
            policy: o,
            styleBroadcastStrategy: n
        }, (S, E) => {
            var te;
            let[[M,_,U],[Q,K,w],[B,W,oe]] = S.asValue();
            return a = [],
            u = [],
            c = [],
            l = [],
            x(M, _, U, Q, K, w, B, W, oe),
            [{
                meshData: T(),
                color: TT(e.userData, E.color),
                surfaceOpacity: (te = E.surfaceOpacity) != null ? te : 1,
                restrictionShader: P.restriction,
                graphMode: 117
            }]
        }
        )
    }
    function RF({node: e, concrete: t, graphInfo: n, policy: r, styleBroadcastStrategy: o}) {
        var s;
        let i = e.metaData.colorLatexValue ? !Array.isArray(e.metaData.colorLatexValue) : !0;
        if (t.valueType === Gi && i && !Array.isArray(e.metaData.computedLineWidth)) {
            let a = (s = e.metaData.colorLatexValue) != null ? s : e.userData.color
              , u = e.metaData.computedLineWidth
              , c = [];
            return lo({
                color: !0
            }, {
                node: e,
                concrete: t,
                policy: r,
                graphInfo: n,
                styleBroadcastStrategy: o
            }, l => {
                if (l.valueType === en) {
                    let[[p,m,d],[y,g,f]] = l.asValue();
                    c.push(p, m, d, y, g, f, NaN, NaN, NaN)
                }
                return []
            }
            ),
            [{
                graphMode: 119,
                guid: Do(),
                points: c,
                color: a,
                thickness: u != null ? u : 1
            }]
        }
        return lo({
            color: !0,
            lineWidth: !0
        }, {
            node: e,
            concrete: t,
            policy: r,
            graphInfo: n,
            styleBroadcastStrategy: o
        }, (a, u) => {
            let {lineWidth: c, color: l} = u
              , p = a.asValue()
              , [[m,d,y],[g,f,h]] = p;
            return MD(m, d, y, g, f, h) ? [] : [{
                graphMode: 119,
                guid: Do(),
                points: [m, d, y, g, f, h],
                color: l,
                thickness: c
            }]
        }
        )
    }
    function NF({node: e, concrete: t, graphInfo: n, policy: r, styleBroadcastStrategy: o}) {
        var s;
        let i = e.metaData.colorLatexValue ? !Array.isArray(e.metaData.colorLatexValue) : !0;
        if (t.valueType === qi && i && !Array.isArray(e.metaData.computedLineWidth)) {
            let a = (s = e.metaData.colorLatexValue) != null ? s : e.userData.color
              , u = e.metaData.computedLineWidth
              , c = [];
            return lo({
                color: !0
            }, {
                node: e,
                concrete: t,
                policy: r,
                graphInfo: n,
                styleBroadcastStrategy: o
            }, l => {
                if (l.valueType === qe) {
                    let[[p,m,d],[y,g,f]] = l.asValue();
                    c.push(y, g, f, p + y, m + g, d + f)
                }
                return []
            }
            ),
            [{
                graphMode: 129,
                guid: Do(),
                points: c,
                color: a,
                thickness: u != null ? u : 1
            }]
        }
        return lo({
            color: !0,
            lineWidth: !0
        }, {
            node: e,
            concrete: t,
            policy: r,
            graphInfo: n,
            styleBroadcastStrategy: o
        }, (a, u) => {
            let {lineWidth: c, color: l} = u
              , p = a.asValue()
              , [[m,d,y],[g,f,h]] = p;
            return MD(m, d, y, g, f, h) ? [] : [{
                graphMode: 129,
                guid: Do(),
                points: [g, f, h, m + g, d + f, y + h],
                color: l,
                thickness: c
            }]
        }
        )
    }
    function OF({node: e, concrete: t, graphInfo: n, policy: r, styleBroadcastStrategy: o}) {
        return lo({
            color: !0,
            resolution: !0,
            surfaceOpacity: !0
        }, {
            node: e,
            concrete: t,
            policy: r,
            graphInfo: n,
            styleBroadcastStrategy: o
        }, (i, s) => {
            let {color: a, surfaceOpacity: u} = s
              , c = i.asValue()
              , [[l,p,m],d] = c
              , y = Math.abs(d);
            return isNaN(l) || isNaN(p) || isNaN(m) || isNaN(d) ? [] : [{
                graphMode: 118,
                position: [l, p, m],
                radius: [y, y, y],
                guid: Do(),
                color: a,
                surfaceOpacity: u != null ? u : 1
            }]
        }
        )
    }
    function wZ() {
        throw new Error("Programming error: this function is not expected to be called")
    }
    function DD(e, t, n, r) {
        let o = [];
        for (let i = 0; i < t.otherVariableSolutionData.length; i++) {
            let s = t.otherVariableSolutionData[i];
            if (!s)
                continue;
            let {coefficients: a, restriction: u} = s
              , c = a.argNames[0];
            if (c !== "x" && c !== "y")
                continue;
            let l = a.getCompiledFunction().fn, p, m;
            c === "y" ? (p = 1,
            m = 2) : (p = 2,
            m = 1);
            let d = void 0
              , {listIndex: y, style: g, lineWidth: f, lineOpacity: h, color: x} = ru(e, i, d)
              , T = Hp(n, {
                graphMode: p,
                domainBound: Vr(),
                lineWidth: f,
                operator: "="
            }, wZ);
            if (!T)
                continue;
            let P = PF(l, T);
            for (let C of P) {
                let S = new An(u.substituteConstantArguments({
                    [c]: C
                }))
                  , E = co(e, r, S);
                E = {
                    ...E,
                    graphMode: m,
                    lineWidth: f
                };
                let _ = Ku(e, r, S, n, E, void 0, t.branchMultiplier === 2 ? "solvedEquation" : void 0);
                for (let U of _)
                    o.push({
                        ...U,
                        listIndex: y,
                        style: g,
                        lineWidth: f,
                        lineOpacity: h,
                        color: x
                    })
            }
        }
        return o.length > 0 ? o : !1
    }
    function AF(e, t, n, r) {
        let o = co(e, t, n)
          , i = o.graphMode
          , s = "baseComparator"
          , a = e.userData.lines === void 0 ? !0 : e.userData.lines;
        if (i === 8 || i === 112 || i === 113 || i === 127 || i === 210)
            return Ku(e, t, n, r, o);
        if (i === 10)
            return [];
        if (!(n instanceof O.SolvedEquation))
            return [];
        let u = e.getOperator()
          , c = []
          , l = []
          , p = !0;
        n._expression.eachElement(h => {
            c.push(h.getCompiledFunction());
            try {
                l.push(h.getCompiledDerivative())
            } catch (x) {
                p = !1
            }
        }
        ),
        p || (l = void 0);
        let m = []
          , d = [-1, 0, 0, 1]
          , y = Ys(e.metaData, ["computedLineWidth", "computedLineOpacity", "computedFillOpacity", "colorLatexValue"], s)
          , g = Math.min(c.length, y);
        for (let h = 0; h < g; h++) {
            let x = co(e, t, n._expression.args[h]);
            x.graphMode = i;
            let {listIndex: T, style: P, color: C, lineWidth: S, lineOpacity: E, fillOpacity: M} = ru(e, h, s);
            x.listIndex = T,
            x.style = P,
            x.color = C,
            o.graphMode === 6 && (x.domain = {
                type: "1d",
                min: e.metaData.evaluatedDomainMin,
                max: e.metaData.evaluatedDomainMax,
                isExplicit: e.metaData.isExplicitDomain
            });
            let _ = Ta({
                viewState: r,
                graphInfo: x,
                compiled: c[h],
                derivative: l ? l[h] : void 0
            });
            _.lineWidth = S,
            _.lineOpacity = E,
            _.fillOpacity = M,
            _.operator = sl(ro[u].inclusive, d[h % 4]),
            a || (_.lineWidth = 0),
            m.push(_)
        }
        for (let h = 0; h < g; h += 4) {
            let x = zd(m[h + 1].segments, m[h + 2].segments, i);
            m.push({
                graphMode: 7,
                listIndex: m[h].listIndex,
                segments: x,
                poi: {},
                fillOpacity: m[h].fillOpacity,
                color: m[h].color
            })
        }
        let f = DD(e, n, r, t);
        if (f) {
            for (let h of f)
                h.operator = sl(ro[u].inclusive, 0);
            Array.prototype.push.apply(m, f)
        }
        return m
    }
    function wF(e, t, n, r) {
        let o = co(e, t, n);
        if (o.graphMode === 10)
            return [];
        let i = []
          , s = sl(ro[e._operators[0]].inclusive, 0)
          , a = sl(ro[e._operators[1]].inclusive, 0)
          , u = e.userData
          , c = e.metaData
          , l = u.lines === void 0 ? !0 : u.lines
          , p = ["colorLatexValue", "computedFillOpacity"];
        l && p.push("computedLineWidth", "computedLineOpacity");
        let m = Ys(c, p)
          , d = n._expressions;
        return Br(d),
        Vo.eachArgs(d, (y, g) => {
            let f = g;
            if (f >= m)
                return;
            y[0].userData = y[1].userData = u,
            y[0].metaData = y[1].metaData = c;
            let h = void 0, {color: x, lineWidth: T, lineOpacity: P, fillOpacity: C} = ru(e, f, h), S, E;
            y[0].type === "IRExpression" && (S = Ku(e, t, y[0], r, o)[0],
            S.listIndex = f,
            S.operator = s,
            S.color = x,
            S.lineWidth = T,
            S.lineOpacity = P,
            i.push(S)),
            y[1].type === "IRExpression" && (E = Ku(e, t, y[1], r, o)[0],
            E.listIndex = f,
            E.operator = a,
            E.color = x,
            E.lineWidth = T,
            E.lineOpacity = P,
            i.push(E));
            let M = S == null ? void 0 : S.segments
              , _ = E == null ? void 0 : E.segments;
            if (Br(M),
            Br(_),
            S && E) {
                let U = zd(M, _, S.graphMode);
                l || (S.lineWidth = 0,
                E.lineWidth = 0),
                i.push({
                    graphMode: 7,
                    listIndex: S.listIndex,
                    segments: U,
                    lineOpacity: P,
                    fillOpacity: C,
                    poi: {},
                    color: x
                })
            }
        }
        ),
        i
    }
    function LF(e=void 0) {
        let {xmin: t, xmax: n, ymin: r, ymax: o, zmin: i, zmax: s} = e != null ? e : new dT
          , a = [t, r, s, t, o, s, n, o, s, n, r, s, t, r, i, t, o, i, n, o, i, n, r, i, t, r, i, t, r, s, t, o, s, t, o, i, n, r, i, n, r, s, n, o, s, n, o, i, n, r, i, n, r, s, t, r, s, t, r, i, n, o, i, n, o, s, t, o, s, t, o, i]
          , u = [0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0]
          , c = [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1]
          , l = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23];
        return {
            positions: new Float32Array(a),
            normals: new Float32Array(u),
            faces: new Uint16Array(l),
            uvs: new Float32Array(c)
        }
    }
    var {abs: wl, min: _D, max: RD} = Math;
    function ND(e, t) {
        let {xmin: n, xmax: r, ymin: o, ymax: i, zmin: s, zmax: a} = t
          , u = [[n, o, a], [n, i, a], [r, i, a], [r, o, a], [n, o, s], [n, i, s], [r, i, s], [r, o, s]]
          , c = [[0, 1], [1, 2], [2, 3], [3, 0], [4, 5], [5, 6], [6, 7], [7, 4], [0, 4], [1, 5], [2, 6], [3, 7]]
          , l = [];
        for (let[M,_] of c) {
            let U = u[M]
              , Q = u[_]
              , K = e(...U)
              , w = e(...Q)
              , B = K / (K - w);
            0 <= B && B <= 1 && l.push(Ns(U, Q, B))
        }
        if (l.length < 3)
            return;
        let p = _D(...l.map(M => M[0])), m = RD(...l.map(M => M[0])), d = _D(...l.map(M => M[1])), y = RD(...l.map(M => M[1])), g = _D(...l.map(M => M[2])), f = RD(...l.map(M => M[2])), h = e(n, o, s), x = (e(r, o, s) - h) / (r - n), T = (e(n, i, s) - h) / (i - o), P = (e(n, o, a) - h) / (a - s), C, S, E;
        return wl(P) >= wl(x) && wl(P) >= wl(T) ? (C = (M, _) => [M, _, s - (h + x * (M - n) + T * (_ - o)) / P],
        S = new Be(p,m),
        E = new Be(d,y)) : wl(T) >= wl(P) && wl(T) >= wl(x) ? (C = (M, _) => [M, o - (h + x * (M - n) + P * (_ - s)) / T, _],
        S = new Be(p,m),
        E = new Be(g,f)) : (C = (M, _) => [n - (h + T * (M - o) + P * (_ - s)) / x, M, _],
        S = new Be(d,y),
        E = new Be(g,f)),
        {
            explicitPlane: C,
            u: S,
            v: E
        }
    }
    function rg(e, t) {
        let n = []
          , r = []
          , o = []
          , i = []
          , s = ND(e, t);
        if (s) {
            let {explicitPlane: a, u, v: c} = s;
            n.push(...a(u.min, c.min), ...a(u.max, c.min), ...a(u.min, c.max), ...a(u.max, c.max));
            let l = new it(n[0],n[1],n[2])
              , p = new it(n[3],n[4],n[5])
              , m = new it(n[6],n[7],n[8])
              , d = new it().subVectors(m, l)
              , y = new it().subVectors(l, p)
              , g = d.cross(y).normalize();
            r.push(g.x, g.y, g.z, g.x, g.y, g.z, g.x, g.y, g.z, g.x, g.y, g.z),
            o.push(0, 0, 0, 1, 1, 0, 1, 1),
            i.push(0, 1, 2, 3, 2, 1)
        }
        return {
            positions: n,
            normals: r,
            faces: i,
            uvs: o,
            resolved: !0,
            extraAttrs: []
        }
    }
    function Ll(e, t) {
        if (t.type !== 33)
            return !1;
        let n = e.getInstruction(t.args[2]);
        return n.type === 1 && ra(n.valueType) && VN(n.valueType, n.value) || Ll(e, n) && FF(e, t.args[1]) && FF(e, n.args[1])
    }
    function OD(e, t) {
        let n = [];
        for (; t.type === 33; )
            n.push(t.args[0]),
            t = e.getInstruction(t.args[2]);
        return n
    }
    function *ET(e, t) {
        let n = e.getInstruction(t);
        n.type !== 32 ? yield t : (yield*ET(e, n.args[0]),
        yield*ET(e, n.args[1]))
    }
    function VF(e, t) {
        return e.getInstruction(t).type === 25
    }
    function BF(e, t) {
        let n = e.getInstruction(t);
        if (n.type !== 25)
            return;
        let r = n.args[0]
          , o = n.args[1]
          , i = e.getInstruction(r)
          , s = e.getInstruction(o)
          , a = (s.type === 41 || s.type === 40) && Ye(e.getInstruction(s.args[0]));
        return i.type === 2 && (Ye(s) || a) && ae(s.valueType, b) ? {
            type: "constant",
            variable: e.argNames[r],
            index: o
        } : ae(i.valueType, b) && ae(s.valueType, b) ? {
            type: "implicit",
            index: e.Subtract([r, o])
        } : void 0
    }
    function FF(e, t) {
        let n = e.getInstruction(t);
        return n.type === 1 && n.valueType === b && L(n.value) === 1
    }
    function GF(e) {
        let t = [];
        for (let r = 0; r < e.instructionsLength(); r++)
            t.push(!1);
        let n = [];
        t[e.getReturnIndex()] = !0;
        for (let r = e.instructionsLength() - 1; r >= 0; r--) {
            if (!t[r])
                continue;
            let o = e.getInstruction(r);
            if (o.type === 2 && n.push(e.argNames[r]),
            !de(o))
                continue;
            let i = Ll(e, o) ? [o.args[1]] : o.args;
            for (let s of i)
                t[s] = !0
        }
        return n
    }
    var kd = class {
        constructor({enableGeometry: t, enable3d: n, scales: r, includeFunctionParametersInRandomSeed: o, isComplexEnabled: i, customRegressions: s, isRecursionEnabled: a}) {
            this._isGeometry = !1;
            this._is3dProduct = !1;
            this._isGeometry = t,
            this._is3dProduct = n,
            this._scales = r,
            this._includeFunctionParametersInRandomSeed = o,
            this._isComplexEnabled = !!i,
            this._customRegressions = s,
            this._isRecursionEnabled = !!a
        }
        isGeometryEnabled() {
            return this._isGeometry
        }
        is3dProduct() {
            return this._is3dProduct
        }
        is3dPolicy() {
            return !1
        }
        isComplexEnabled() {
            return this._isComplexEnabled
        }
        isRecursionEnabled() {
            return this._isRecursionEnabled
        }
        polygonUnsupportedPreferTriangle() {
            return !1
        }
        areAllScalesLinear() {
            return this._scales ? this._scales.xAxisScale === "linear" && this._scales.yAxisScale === "linear" : !0
        }
        assignmentForbidden(t) {
            return t === "x" || t === "y" || t === "theta" || t === "index" || t === "dt" || t.slice(0, 3) === "tmp" || rt.hasOwnProperty(t) || this.isComplexEnabled() && t === Gr
        }
        isValidSlider(t) {
            return t === "x" || t === "y" ? !0 : !(t.slice(0, 3) === "ans" || t.slice(0, 6) === "idref_" || this.assignmentForbidden(t))
        }
        sliderVariables(t) {
            return t.indexOf("theta") !== -1 && (t = t.filter(n => n !== "r")),
            t.filter(n => !(this.assignmentForbidden(n) || n.slice(0, 3) === "ans" || n.slice(0, 6) === "idref_" || n[0] === "_" || this.isGeometryEnabled() && n[0] === "$"))
        }
        tooManySliderVariables(t, n, r) {
            return r ? t.length >= 1 : t.length >= 2 && n.length >= 1
        }
        graphingEnabled() {
            return !0
        }
        ansEnabled() {
            return !1
        }
        dimensionVarsEnabled() {
            return !0
        }
        validRegressionParameter(t) {
            return t !== "x" && t !== "y"
        }
        validLHS(t) {
            return t !== "theta" && t.slice(0, 6) !== "idref_"
        }
        unplottablePolarFunction(t, n) {
            return t !== "theta" ? !1 : n.indexOf("r") !== -1
        }
        validDoubleInequalitySymbol(t) {
            return t === "x" || t === "y"
        }
        validDoubleInequalityVariables(t) {
            return t.length > 2 ? !1 : t.every(this.validDoubleInequalitySymbol)
        }
        validExpressionVariables(t) {
            return t.length === 1 && t[0] === "x"
        }
        validSolvedVariable(t) {
            return t === "x" || t === "y" || t === "r"
        }
        validImplicitVariables(t) {
            switch (t.length) {
            case 0:
                return !0;
            case 1:
                return t[0] === "x" || t[0] === "y" || t[0] === "r";
            case 2:
                return t[0] === "x" && t[1] === "y" || t[0] === "y" && t[1] === "x" || t[0] === "r" && t[1] === "theta" || t[0] === "theta" && t[1] === "r";
            default:
                return !1
            }
        }
        graphableListVariables(t, n) {
            return t === "x" || t === "y" || t === "r" || n === "x" || n === "y"
        }
        validParametricVariable(t) {
            return t === "t"
        }
        validParametricVariables(t) {
            return t.length === 1 && this.validParametricVariable(t[0])
        }
        validInequalityVariables(t) {
            switch (t.length) {
            case 1:
                return t[0] === "x" || t[0] === "y" || t[0] === "r";
            case 2:
                return this.validImplicitVariables(t);
            default:
                return !1
            }
        }
        validFirstColumnVariable(t) {
            return t !== "y" && t !== "r" && t !== "theta" && !t.match(/y_(\d+)/)
        }
        validActionVariable(t) {
            return t === "dt" || t === "index"
        }
        complicatedPolarImplicit(t, n) {
            return t === "theta" || t === "r" && n !== 1
        }
        graphMode(t, n, r) {
            if (n.length === 0)
                return t === "x" ? 1 : t === "r" ? 6 : t === "y" ? 2 : 10;
            let o = n[0];
            return o === "y" ? 1 : t === "x" ? 1 : t === "r" && o === "theta" ? 6 : this.isComplexEnabled() && t !== "y" && o !== "x" ? 10 : 2
        }
        functionDefinitionGraphMode(t, n) {
            return this.graphMode(t, n)
        }
        tableableAsConstant(t) {
            return !(t === "x" || t === "r" || t === "theta")
        }
        implicitIndependent(t) {
            return "x"
        }
        implicitDependency(t) {
            return t.length !== 1 ? "y" : t[0] === "y" ? "x" : t[0] === "theta" ? "r" : "y"
        }
        disabledFeatures() {
            return []
        }
        shouldIncludeFunctionParametersInRandomSeed() {
            return this._includeFunctionParametersInRandomSeed
        }
        isCustomRegressionSupported() {
            return this._customRegressions
        }
        getScales() {
            var t;
            return (t = this._scales) != null ? t : {
                xAxisScale: "linear",
                yAxisScale: "linear"
            }
        }
    }
      , CT = class {
        constructor({beta3d: t, includeFunctionParametersInRandomSeed: n, isComplexEnabled: r, customRegressions: o, isRecursionEnabled: i}) {
            this._isBeta3d = !1;
            this._isBeta3d = t,
            this.policy2d = new kd({
                enableGeometry: !1,
                enable3d: !0,
                scales: {
                    xAxisScale: "linear",
                    yAxisScale: "linear"
                },
                includeFunctionParametersInRandomSeed: n,
                isComplexEnabled: r,
                customRegressions: o,
                isRecursionEnabled: i
            })
        }
        isGeometryEnabled() {
            return !1
        }
        is3dProduct() {
            return !0
        }
        is3dPolicy() {
            return !0
        }
        isBeta3d() {
            return this._isBeta3d
        }
        isComplexEnabled() {
            return this.policy2d.isComplexEnabled()
        }
        isRecursionEnabled() {
            return this.policy2d.isRecursionEnabled()
        }
        polygonUnsupportedPreferTriangle() {
            return !0
        }
        areAllScalesLinear() {
            return !0
        }
        graphingEnabled() {
            return !0
        }
        ansEnabled() {
            return !1
        }
        dimensionVarsEnabled() {
            return !1
        }
        validInequalityVariables(t) {
            return this.validImplicitVariables(t)
        }
        validFirstColumnVariable(t) {
            return this.policy2d.validFirstColumnVariable(t)
        }
        validActionVariable(t) {
            return this.policy2d.validActionVariable(t)
        }
        tableableAsConstant(t) {
            return this.policy2d.tableableAsConstant(t)
        }
        implicitIndependent(t) {
            return this.policy2d.implicitIndependent(t)
        }
        validRegressionParameter(t) {
            return this.policy2d.validRegressionParameter(t)
        }
        assignmentForbidden(t) {
            return t === "x" || t === "y" || t === "z" || t === "r" || t === "rho" || t === "theta" || t === "phi" || this.policy2d.assignmentForbidden(t)
        }
        sliderVariables(t) {
            return t.filter(n => !(this.assignmentForbidden(n) || n.slice(0, 3) === "ans" || n.slice(0, 6) === "idref_" || n[0] === "_"))
        }
        tooManySliderVariables(t, n, r) {
            return r ? this.isBeta3d() ? n.length >= 1 : t.length >= 1 : n.length >= 1
        }
        isValidSlider(t) {
            return !(t.slice(0, 3) === "ans" || t.slice(0, 6) === "idref_" || this.assignmentForbidden(t))
        }
        validLHS(t) {
            return t !== "phi" && this.policy2d.validLHS(t)
        }
        unplottablePolarFunction(t, n) {
            return !1
        }
        complicatedPolarImplicit(t, n) {
            return !1
        }
        validDoubleInequalitySymbol(t) {
            return og(t)
        }
        validDoubleInequalityVariables(t) {
            return t.every(og)
        }
        validExpressionVariables(t) {
            return t.length === 2 && t.every(n => n == "x" || n == "y")
        }
        validSolvedVariable(t) {
            return og(t) || t === "r" || t === "rho"
        }
        validImplicitVariables(t) {
            return t.every(og)
        }
        graphableListVariables(t, n) {
            return t === "x" || t === "y" || t === "z" || t === "r" || t === "rho" || n === "x" || n === "y"
        }
        validParametricVariable(t) {
            return t === "t" || t === "u" || t === "v"
        }
        validParametricVariables(t) {
            return t.length === 1 && this.validParametricVariable(t[0]) || t.length === 2 && t.every(AD)
        }
        functionDefinitionGraphMode(t, n) {
            if (n.length === 1)
                switch (n[0]) {
                case "x":
                    return 121;
                case "y":
                    return 120;
                default:
                    return 10
                }
            else if (n.length === 2 && n.every(r => r == "x" || r == "y"))
                return 106;
            return 10
        }
        graphMode(t, n, r) {
            if (r != null || (r = n),
            n.length === 0)
                switch (t) {
                case "z":
                    return r.some(o => o === "r" || o === "theta") ? 109 : 106;
                case "y":
                    return r.includes("z") ? 108 : 123;
                case "x":
                    return r.includes("z") ? 107 : 122;
                case "r":
                    return r.indexOf("r") > -1 ? 10 : qF(r);
                case "rho":
                    return 111;
                default:
                    return 10
                }
            switch (t) {
            case "z":
                return n.every(o => o == "x" || o == "y") ? 106 : n.every(o => o == "r" || o == "theta") ? 109 : 10;
            case "y":
                return n.every(o => o == "x") ? r.some(o => o === "z") ? 108 : 121 : n.every(o => o == "x" || o == "z") ? 108 : 10;
            case "x":
                return n.every(o => o == "y") ? r.some(o => o === "z") ? 107 : 120 : n.every(o => o == "y" || o == "z") ? 107 : 10;
            case "r":
                return n.every(o => o == "theta") ? qF(r) : n.every(o => o == "theta" || o == "z") ? 110 : 10;
            case "rho":
                return n.every(o => o == "theta" || o == "phi") ? 111 : 10;
            default:
                return 10
            }
        }
        implicitDependency(t) {
            if (t.length !== 2)
                return "z";
            let n = t[0] < t[1] ? t[0] + t[1] : t[1] + t[0];
            return n === "xy" ? "z" : n === "xz" ? "y" : n === "yz" ? "x" : "z"
        }
        disabledFeatures() {
            return []
        }
        shouldIncludeFunctionParametersInRandomSeed() {
            return this.policy2d.shouldIncludeFunctionParametersInRandomSeed()
        }
        isCustomRegressionSupported() {
            return this.policy2d.isCustomRegressionSupported()
        }
        getScales() {
            return {
                xAxisScale: "linear",
                yAxisScale: "linear"
            }
        }
    }
      , og = e => e === "x" || e === "y" || e === "z"
      , AD = e => e === "u" || e === "v";
    function qF(e) {
        return e.some(n => og(n) || n === "r") ? 110 : 124
    }
    ct.prototype.getGraphMode = function(e, t) {
        return 10
    }
    ;
    ct.prototype.graphmodeDependencies = Pa;
    function Pa(e, t) {
        let n = t.getDependencies();
        if (e.is3dProduct() && t instanceof An) {
            let r = new Set(GF(t._chunk));
            return n.filter(o => r.has(o))
        } else
            return n
    }
    function LZ(e, t) {
        let n;
        return e && e.hasOwnProperty("dragMode") ? e.dragMode === Jt.AUTO ? n = t.defaultDragMode : n = e.dragMode : n = t.defaultDragMode,
        U1(n, t.moveStrategy)
    }
    function zF(e, t) {
        let n = e.is3dPolicy();
        if (Zb(t) && !n && LZ(this.userData, t) !== Jt.NONE)
            return t.valueType === N ? 26 : 4;
        let r = Pa(e, t);
        switch (t.valueType) {
        case to:
        case G:
            if (n) {
                if (r.length === 0)
                    return 114;
                if (e.validParametricVariables(r))
                    return r.length == 1 ? 100 : ec(103, t)
            }
            return 10;
        case N:
        case ke:
        case R:
        case zt:
            {
                let o = ae(t.valueType, N);
                return r.length === 0 ? o ? 25 : 3 : n && e.validParametricVariables(r) ? r.length === 1 ? 5 : r.every(AD) ? ec(130, t) : 10 : e.validParametricVariables(r) ? 5 : 10
            }
        case b:
        case Y:
            return !e.is3dPolicy() && r.length === 1 ? 2 : n && r.length === 2 && r.indexOf("x") > -1 && r.indexOf("y") > -1 ? ec(106, t) : 10
        }
        if (r.length > 0)
            return 10;
        switch (t.valueType) {
        case Hi:
        case Oa:
            return 5;
        case zi:
        case _a:
            return 5;
        case yo:
        case ta:
            return n ? 100 : 10;
        case Fs:
        case Aa:
            return n ? ec(130, t) : 10;
        case ws:
        case Ra:
            return n ? ec(130, t) : 10;
        case Ls:
        case Na:
            return n ? ec(103, t) : 10;
        case en:
        case Gi:
            return n ? 119 : 10;
        case qe:
        case qi:
            return n ? 129 : 10;
        case lr:
        case Zo:
            return n ? 117 : 10;
        case Lr:
        case ea:
            return n ? 118 : 10;
        case De:
        case Dr:
            return 16;
        case he:
        case hi:
            return 20;
        case ce:
        case mo:
            return 21;
        case Ee:
        case Tr:
            return 17;
        case Ce:
        case bi:
            return 18;
        case Ae:
        case fo:
            return 19;
        case Ie:
        case xi:
            return this instanceof ze && this.getDependencies().length === 1 ? 10 : 24;
        case Oe:
        case Ar:
        case Se:
        case wr:
            return 23;
        default:
            return 10
        }
    }
    Z.prototype.getGraphMode = zF;
    function HF(e, t) {
        let n = t._expression.getDependencies();
        if (n.length > 1)
            return 10;
        if (Xm(t._expression) && t._expression.isList && t._expression.length === 0)
            return 10;
        let r = t._symbol
          , o = t.getDependencies();
        return e.graphMode(r, n, o)
    }
    O.Equation.prototype.getGraphMode = O.CallAssignment.prototype.getGraphMode = bo.prototype.getGraphMode = O.ComparatorChain.prototype.getGraphMode = function(e, t) {
        if (t.type === "Error")
            return 10;
        let n = Pa(e, t)
          , r = t.getDependencies();
        if (e.is3dPolicy()) {
            let o = 10;
            return n.length > 0 && (r.includes("z") ? o = this.isInequality() ? 113 : 112 : o = this.isInequality() ? 127 : 126),
            ec(o, t)
        }
        return t.type === "IRExpression" && t.isConstant ? 10 : t instanceof O.SolvedEquation ? HF(e, t) : n.length === 1 || n.length === 2 ? 8 : 10
    }
    ;
    function LD(e) {
        var t;
        return e === 106 || e === 200 || e === 107 || e === 201 || e === 108 || e === 202 ? ["x", "y", "z", "_implicit"] : e === 110 || e === 211 ? ["x", "y", "z", "r", "theta", "_implicit"] : e === 111 || e === 212 ? ["x", "y", "z", "rho", "theta", "phi", "_implicit"] : e === 109 || e === 213 ? ["x", "y", "z", "r", "theta", "_implicit"] : e === 103 || e === 214 || e === 130 || e === 215 ? ["x", "y", "z", "u", "v", "_implicit"] : e === 113 || e === 210 || e === 112 || e === 209 ? ["x", "y", "z", "_implicit"] : (t = Ji[e]) != null ? t : []
    }
    function ec(e, t) {
        let n = LD(e)
          , r = t._chunk;
        try {
            let i = Mc(r, n, {
                allowSlices: !0
            }).getSliceVariablesOrImplicit();
            if (i.length !== 1)
                return e;
            let s = i[0];
            return n.indexOf(s) < 0 ? 10 : VL(e, s)
        } catch (o) {
            return 10
        }
    }
    O.DoubleInequality.prototype.getGraphMode = function(e, t) {
        let n = t.getDependencies();
        return e.graphMode(t._symbol, [], n)
    }
    ;
    Ln.prototype.getGraphMode = function(e, t) {
        if (t instanceof O.SolvedEquation)
            return HF(e, t);
        if (this.isEquation(e, t))
            return this.asEquation().getGraphMode(e, t);
        let n = Pa(e, t)
          , r = this._symbol
          , o = t.getDependencies();
        switch (t.valueType) {
        case b:
        case Y:
        case He:
            switch (n.length) {
            case 0:
                {
                    let s = e.graphMode(r, [], o);
                    return e.is3dPolicy() ? ec(s, t) : s
                }
            case 1:
                if (t.valueType === Y && !e.graphableListVariables(r, n[0]))
                    return 10;
                if (this.type === "Slider")
                    return 10;
                let i = e.graphMode(r, n, o);
                return e.is3dPolicy() ? ec(i, t) : i;
            default:
                return e.is3dPolicy() ? ec(e.graphMode(r, n, o), t) : 10
            }
        case G:
            if (!e.is3dPolicy() || e.assignmentForbidden(r) || n.length > 0 && !e.validParametricVariables(n))
                return 10;
            switch (n.length) {
            case 0:
                return 114;
            case 1:
                return 100;
            case 2:
                return 103;
            default:
                return 10
            }
        default:
            return zF.call(this, e, t)
        }
    }
    ;
    O.FunctionDefinition.prototype.getGraphMode = function(e, t) {
        let n = e.is3dPolicy();
        if (this._argSymbols.length !== 1 && !n)
            return 10;
        if (this.recursionInfo) {
            let i = t instanceof An ? t.getRecursiveFunctionMetadata() : void 0;
            if ((i == null ? void 0 : i.type) === "missing-non-recursive-branch")
                return 10;
            if ((i == null ? void 0 : i.recursiveStructure.domainInfo[this._symbol][0]) === 1)
                return 10
        }
        let r = e.functionDefinitionGraphMode(this._symbol, this._argSymbols)
          , o = Pa(e, t);
        switch (t.valueType) {
        case b:
        case Y:
            if (n)
                return r;
            switch (o.length) {
            case 0:
                return r;
            case 1:
                return o[0] !== this._argSymbols[0] ? 10 : r;
            default:
                return 10
            }
            break;
        default:
            return 10
        }
    }
    ;
    O.Regression.prototype.getGraphMode = function(e, t) {
        return this.isLhsSimple ? t.isModelValid ? t.model.getDependencies().length !== 1 ? 10 : 2 : 10 : 10
    }
    ;
    function FD(e, t) {
        return t.type === "Error" ? 10 : 11
    }
    O.Histogram.prototype.getGraphMode = FD;
    O.DotPlot.prototype.getGraphMode = FD;
    O.BoxPlot.prototype.getGraphMode = FD;
    O.Image.prototype.getGraphMode = function(e, t) {
        return this.userData.showPoints ? this.center.type === "Error" || this.radianAngle.type === "Error" || this.width.type === "Error" || this.height.type === "Error" || this.opacity.type === "Error" ? 10 : 3 : 10
    }
    ;
    function UF(e) {
        let t = 0
          , n = 0
          , r = []
          , o = oo(e, e.getReturnIndex())
          , i = VD(e);
        for (let s = 0; s < e.instructionsLength(); s++) {
            if (!o[s])
                continue;
            let a = e.getInstruction(s);
            a.type === 25 ? r[s] = 1 : a.type === 31 || a.type === 32 ? r[s] = r[a.args[0]] + r[a.args[1]] : r[s] = 0,
            Ll(e, a) && i[a.args[0]] && (t += 1,
            n += r[a.args[0]])
        }
        return {
            numRestrictions: t,
            numEqualityRestrictions: n
        }
    }
    function $d(e, t, n) {
        try {
            return FZ(e, t, n)
        } catch (r) {
            return r instanceof v ? r : F(r)
        }
    }
    function FZ(e, t, n) {
        var l, p;
        if (!e.is3dProduct() || n.type === "Error")
            return n;
        if (!(n instanceof An))
            return F("Expected peel error to be checked on an IRExpression");
        function r(m, d) {
            let y = d.filter(g => m.indexOf(g) < 0);
            if (y.length)
                return $C(y[0]).allowExport().setDependencies(y)
        }
        function o() {
            let m = vT(s)
              , d = VZ(e, n);
            return r(m, d)
        }
        function i() {
            let m = kF(s);
            if (s === 117) {
                let y = GZ(n);
                return y.error === BD ? YC() : r(m, y.mispredicted)
            }
            let d = BZ(e, n, s);
            return r(m, d)
        }
        let s = t.getGraphMode(e, n)
          , a = n._chunk
          , {numRestrictions: u, numEqualityRestrictions: c} = UF(a);
        if (c !== 0)
            if (c === 1) {
                if (u !== c && !t.isInequality())
                    return qE();
                let y = Mc(a, [], {
                    allowSlices: !0
                }).getSliceVariablesOrImplicit();
                if (y.length !== 1)
                    return Lu();
                let g = LD(s)
                  , f = y[0];
                if (g.indexOf(f) < 0)
                    return f === "_implicit" ? Lu().allowExport() : XC(f).allowExport().setDependencies([f])
            } else
                return GE();
        return (p = (l = o()) != null ? l : i()) != null ? p : n
    }
    function VZ(e, t) {
        let n = Pa(e, t);
        return t.getDependencies().filter(o => n.indexOf(o) < 0)
    }
    function BZ(e, t, n) {
        let r = Pa(e, t)
          , o = new Set;
        if (t instanceof An) {
            let s = t.getRestrictedFunctionForGLSL(vT(n), Qi).concrete;
            for (let a of s.getDependencies())
                r.indexOf(a) > -1 || o.add(a)
        }
        return [...o]
    }
    function GZ(e) {
        let t = new Set, n;
        if (e instanceof An) {
            let r = e._chunk;
            r.argNames.forEach(i => t.add(i));
            let o = ST(r);
            n = o.error,
            o.restriction !== void 0 && ["x", "y", "z"].forEach(i => t.delete(i))
        }
        return {
            mispredicted: [...t],
            error: n
        }
    }
    function vT(e) {
        var n;
        if (!Zu(e))
            return [];
        let t = qZ(e) ? ["x", "y", "z"] : [];
        return e === 211 && t.push("r"),
        e === 212 && t.push("rho"),
        t.push(...(n = Al[e]) != null ? n : []),
        t.push(...kF(e).filter(r => t.indexOf(r) < 0)),
        t
    }
    function qZ(e) {
        return zZ(e) || e == 200 || e == 201 || e == 202 || e == 211 || e == 212 || e == 213 || e == 214 || e == 215
    }
    function zZ(e) {
        if (!Zu(e))
            return !1;
        switch (e) {
        case 106:
        case 107:
        case 108:
        case 110:
        case 111:
        case 109:
        case 122:
        case 123:
        case 112:
        case 113:
        case 127:
        case 130:
        case 103:
        case 210:
        case 117:
            return !0;
        case 124:
        case 120:
        case 121:
        case 126:
        case 114:
        case 118:
        case 119:
        case 129:
        case 128:
        case 100:
        case 200:
        case 201:
        case 202:
        case 206:
        case 205:
        case 211:
        case 203:
        case 204:
        case 213:
        case 207:
        case 208:
        case 212:
        case 214:
        case 215:
        case 209:
            return !1;
        default:
            return !1
        }
    }
    function kF(e) {
        var t;
        return Zu(e) ? (t = Ji[e]) != null ? t : [] : []
    }
    var HZ = e => {
        let t = []
          , n = []
          , r = e.length;
        for (let o = 0; o < r; o++)
            t.push(e[o][0]),
            n.push(e[o][1]);
        return {
            defined: {
                x: t,
                y: n
            }
        }
    }
      , Ai = HZ;
    function YF(e, t, n) {
        let r = e !== void 0 && t !== void 0 ? Math.min(e, t) : void 0
          , o = e !== void 0 && t !== void 0 ? Math.max(e, t) : void 0;
        switch (n) {
        case "left":
            return [[-1 / 0, e]];
        case "right":
            return [[e, 1 / 0]];
        case "inner":
            return [[r, o]];
        case "outer":
            return [[-1 / 0, r], [o, 1 / 0]];
        default:
            throw new Error(`Unexpected tails ${n}`)
        }
    }
    function UZ(e) {
        let {viewState: t, graphInfo: n, compiled: r, derivative: o, bounds: i} = e
          , s = Vi(n)
          , a = mr(n.domainBound, is(i));
        if (!Ei(a))
            return s.domainBound = a,
            s.lineStyle = cm.SOLID,
            Ta({
                graphInfo: s,
                viewState: t,
                compiled: r,
                derivative: o
            })
    }
    function ZF(e) {
        let {viewState: t, graphInfo: n, compiled: r, minOverride: o, maxOverride: i, showPoint: s} = e, a = r.fn, u = Hp(t, n, a), c;
        if (!u)
            c = {
                segments: [],
                resolved: !0
            };
        else {
            let {min: m, max: d} = u;
            c = TF({
                fn: a,
                min: Math.max(m, o != null ? o : 0),
                max: i !== void 0 ? Math.min(i, d) : d
            })
        }
        let {points: l, droppedIndices: p} = Up(c.segments);
        return {
            segments: [l],
            droppedIndices: p,
            graphMode: 3,
            color: n.color,
            style: n.pointStyle,
            poi: Ai(c.segments),
            resolved: c.resolved,
            showPoint: s
        }
    }
    function MT(e) {
        let {viewState: t, graphInfo: n, compiled: r, bounds: o, showPoint: i} = e
          , s = Vi(n)
          , a = mr(n.domainBound, is(o));
        if (!Ei(a))
            return s.domainBound = a,
            s.pointStyle = Gc.POINT,
            ZF({
                graphInfo: s,
                viewState: t,
                compiled: r,
                showPoint: i,
                minOverride: void 0,
                maxOverride: void 0
            })
    }
    function kZ(e) {
        let {viewState: t, graphInfo: n, compiled: r, cdfBound1: o, cdfBound2: i, tails: s, maxOverride: a, showPoint: u} = e
          , c = YF(o, i, s)
          , l = [];
        for (let[p,m] of c) {
            p = Math.ceil(p),
            m = Math.floor(m);
            let d = a !== void 0 ? a : 1 / 0;
            p === -1 / 0 && m >= d ? l.push(MT({
                bounds: [p, d],
                viewState: t,
                graphInfo: n,
                compiled: r,
                showPoint: u
            })) : p === -1 / 0 && m < 1 / 0 ? l.push(MT({
                bounds: [p, m],
                viewState: t,
                graphInfo: n,
                compiled: r,
                showPoint: u
            })) : p > -1 / 0 && m >= d ? l.push(MT({
                bounds: [p, d],
                viewState: t,
                graphInfo: n,
                compiled: r,
                showPoint: u
            })) : l.push(MT({
                bounds: [p, m],
                viewState: t,
                graphInfo: n,
                compiled: r,
                showPoint: u
            }))
        }
        return l
    }
    function $Z(e) {
        if (!e)
            return;
        let t = e.defaults.map( (n, r) => {
            var o, i;
            return (i = (o = e.evaluatedParams) == null ? void 0 : o[r]) != null ? i : n
        }
        );
        switch (e.symbol) {
        case "tdist":
            {
                let[n,r,o] = t
                  , i = wh(0, n != null ? n : 1);
                return {
                    type: "continuousDistribution",
                    xmin: -3 * o + r,
                    xmax: 3 * o + r,
                    ymin: 0,
                    ymax: i / o
                }
            }
        case "normaldist":
            {
                let[n,r] = t
                  , o = Lh(n, n, r);
                return {
                    type: "continuousDistribution",
                    xmin: n - 2 * Math.abs(r),
                    xmax: n + 2 * Math.abs(r),
                    ymin: 0,
                    ymax: o
                }
            }
        case "chisqdist":
            {
                let[n] = t;
                n === void 0 && (n = 2);
                let r = n < 2 ? 5 : rS(n - 2, n);
                return {
                    type: "continuousDistribution",
                    xmin: n - 2 * Math.sqrt(2 * n),
                    xmax: n + 2 * Math.sqrt(2 * n),
                    ymin: 0,
                    ymax: r
                }
            }
        case "poissondist":
            {
                let[n] = t;
                n === void 0 && (n = .5);
                let r = Math.max(Vh(Math.floor(n), n), Vh(Math.ceil(n), n));
                return {
                    type: "discreteDistribution",
                    xmin: 0,
                    xmax: 2.5 * n,
                    ymin: 0,
                    ymax: r
                }
            }
        case "uniformdist":
            {
                let[n,r] = t
                  , o = (n + r) / 2
                  , i = r - n
                  , s = oS(o, n, r);
                return {
                    type: "continuousDistribution",
                    xmin: n - i / 3,
                    xmax: r + i / 3,
                    ymin: 0,
                    ymax: s
                }
            }
        case "binomialdist":
            {
                let[n,r] = t;
                n === void 0 && (n = 1);
                let o = Fh(r * n, n, r);
                return {
                    type: "discreteDistribution",
                    xmin: 0,
                    xmax: n,
                    ymin: 0,
                    ymax: o
                }
            }
        case "geodist":
            {
                let[n] = t
                  , r = n;
                return {
                    type: "discreteDistribution",
                    xmin: 1,
                    xmax: -5 / Math.log1p(-n),
                    ymin: 0,
                    ymax: r
                }
            }
        default:
            throw new Error(`Unhandled distribution type ${e.symbol}`)
        }
    }
    function $F(e) {
        var t;
        if (e !== void 0 && e.symbol === "binomialdist")
            return (t = e.evaluatedParams) == null ? void 0 : t[0]
    }
    function YZ(e) {
        if (e !== void 0 && e.symbol === "geodist")
            return 1
    }
    function XF(e, t, n, r, o, i) {
        var f, h;
        let s = e.metaData.evaluatedDistributionSpec
          , a = e.metaData.evaluatedCDFBound1
          , u = e.metaData.evaluatedCDFBound2
          , c = $Z(s)
          , l = s && s.discrete
          , p = (h = (f = e.userData.cdf) == null ? void 0 : f.tails) != null ? h : "inner"
          , m = a !== void 0 && !isNaN(a)
          , d = u !== void 0 && !isNaN(u) || p === "right" || p === "left"
          , y = m && d && i
          , g = [{
            ...l ? ZF({
                viewState: n,
                graphInfo: {
                    ...r,
                    pointStyle: y ? Gc.OPEN : Gc.POINT
                },
                compiled: t,
                showPoint: e.userData.shouldGraph,
                minOverride: YZ(s),
                maxOverride: $F(s)
            }) : Ta({
                viewState: n,
                graphInfo: r,
                compiled: t
            }),
            boundingBox: c
        }];
        if (y)
            if (l) {
                let x = kZ({
                    viewState: n,
                    graphInfo: r,
                    compiled: t,
                    tails: p,
                    cdfBound1: a,
                    cdfBound2: u,
                    maxOverride: $F(s),
                    showPoint: e.userData.shouldGraph
                });
                g.push(...x.filter(P => !!P));
                let T = [];
                x.forEach(P => P == null ? void 0 : P.segments[0].forEach(C => {
                    !isNaN(C[0]) && !isNaN(C[1]) && T.push([C[0], 0, C[0], C[1]])
                }
                )),
                g.push({
                    graphMode: 5,
                    segments: T,
                    boundingBox: c,
                    poi: {},
                    color: r.color
                })
            } else
                YF(a, u, p).map(T => UZ({
                    bounds: T,
                    viewState: n,
                    graphInfo: r,
                    compiled: t,
                    derivative: o
                })).forEach(T => {
                    if (T && T.segments.length) {
                        let P, C;
                        for (let S = 0; S < T.segments.length; S++) {
                            let E = T.segments[S];
                            if (E.length >= 4) {
                                P = E[0];
                                break
                            }
                        }
                        for (let S = T.segments.length - 1; S >= 0; S--) {
                            let E = T.segments[S];
                            if (E.length >= 4) {
                                C = E[E.length - 2];
                                break
                            }
                        }
                        if (P !== void 0 && C !== void 0 && isFinite(P) && isFinite(C)) {
                            let S = zd(T.segments, [[P, 0, C, 0]], T.graphMode);
                            g.push({
                                graphMode: 7,
                                segments: S,
                                poi: {},
                                color: r.color
                            })
                        }
                    }
                }
                );
        return g
    }
    function jF(e, {viewState: t, node: n, concrete: r, graphInfo: o, policy: i, styleBroadcastStrategy: s}) {
        let a = r.valueType === b;
        return lo({
            lineOpacity: !0,
            lineWidth: !0,
            resolution: !0,
            fillOpacity: !0,
            surfaceOpacity: !0,
            color: !0
        }, {
            node: n,
            concrete: r,
            policy: i,
            graphInfo: o,
            styleBroadcastStrategy: s
        }, (u, c) => {
            var P, C, S, E, M, _, U, Q, K, w, B, W;
            (e === 6 || e === 110 || e === 124) && (c.domain = {
                type: "1d",
                min: n.metaData.evaluatedDomainMin,
                max: n.metaData.evaluatedDomainMax,
                isExplicit: n.metaData.isExplicitDomain
            });
            let l = (P = Ji[e]) != null ? P : []
              , p = u.getCompiledFunction(l);
            (e == 130 || e == 103 || e == 111 || e == 109) && (c.domain = (C = p.domain) != null ? C : {
                type: "2d",
                uMin: n.metaData.evaluatedDomain3DMin1,
                uMax: n.metaData.evaluatedDomain3DMax1,
                vMin: n.metaData.evaluatedDomain3DMin2,
                vMax: n.metaData.evaluatedDomain3DMax2
            });
            let m = [], d;
            try {
                d = u.getCompiledDerivative()
            } catch (oe) {
                d = void 0
            }
            if (((S = n.metaData.evaluatedDistributionSpec) == null ? void 0 : S.type) === "distribution") {
                let oe = XF(n, p, t, c, d, a);
                if (oe)
                    return oe
            }
            let y = w0(c.graphMode)
              , g = (E = n.userData.extendTo3D) != null ? E : !1
              , f = y && !g
              , h = !i.is3dPolicy() || f
              , x = (M = n.userData.lines) != null ? M : h
              , T = (_ = n.userData.lines) != null ? _ : !f;
            if (c.graphMode === 127 && !g && ((U = n.userData.lines) == null || U)) {
                let oe = (Q = Ji[c.graphMode]) != null ? Q : []
                  , te = u._chunk.copy();
                te.GreaterEqual([te.getReturnIndex(), te.Constant(0)]);
                let st = u.getCompiledFunction(oe)
                  , Tt = 0
                  , ye = t.viewport
                  , k = rg( (_e, gt, At) => At - Tt, ye);
                return [{
                    meshData: Ts(k),
                    color: c.color,
                    surfaceOpacity: (K = c.surfaceOpacity) != null ? K : 1,
                    uvArgs: (w = Ji[c.graphMode]) != null ? w : [],
                    extraMeshArgs: (B = Al[c.graphMode]) != null ? B : [],
                    graphMode: 106,
                    compiled: st,
                    restrictionShader: as(te, Qi)
                }]
            }
            if (y && (n.userData.lines === !0 ? (x = f,
            T = !f) : n.userData.lines === !1 && (x = !1,
            T = !1)),
            T && Zu(c.graphMode)) {
                let oe = vT(c.graphMode);
                if (c.graphMode === 113 || c.graphMode === 127) {
                    let {positions: te, normals: st, faces: Tt, uvs: ye} = LF()
                      , ee = {
                        guid: Do(),
                        isDomainCube: !0,
                        resolved: !0,
                        positions: te,
                        normals: st,
                        faces: Tt,
                        uvs: ye,
                        extraAttrs: new Float32Array([])
                    }
                      , k = u.toImplicitBool();
                    m.push({
                        meshData: ee,
                        graphMode: 113,
                        color: c.color,
                        surfaceOpacity: 1,
                        uvArgs: [],
                        extraMeshArgs: [],
                        compiled: p,
                        restrictionShader: as(k._chunk, Qi),
                        listIndex: c.listIndex
                    });
                    let ne = JF(k._chunk, u._chunk, oe);
                    for (let Ne of ne) {
                        let _e = WF(c, {
                            concrete: new An(Ne.value),
                            restriction: Ne.restriction && as(Ne.restriction, Qi)
                        }, t);
                        (_e.graphMode === 113 || _e.graphMode === 118) && (_e.listIndex = c.listIndex),
                        m.push(_e)
                    }
                } else {
                    let te = u.getRestrictedFunctionForGLSL(oe, Qi)
                      , st = WF(c, te, t);
                    m.push(st)
                }
            }
            if (x && ZZ(n, c),
            !Zu(c.graphMode)) {
                let oe = Ta({
                    viewState: t,
                    graphInfo: c,
                    compiled: p,
                    derivative: d
                });
                if (i.is3dPolicy() && x && pT(oe.graphMode)) {
                    let te = (W = c.lineWidth) != null ? W : 1;
                    m.push(Ky(oe, t, te))
                } else if (oe.fillSegments) {
                    let {fillSegments: te, ...st} = oe;
                    x || (st.lineWidth = 0),
                    m.push(st)
                } else
                    x || (oe.lineWidth = 0),
                    (x || !Zu(e)) && m.push(oe);
                c.graphMode === 8 && c.operator !== "=" && m.push({
                    graphMode: 7,
                    segments: oe.fillSegments,
                    poi: {},
                    listIndex: c.listIndex,
                    color: c.color,
                    fillOpacity: c.fillOpacity
                })
            }
            return m
        }
        )
    }
    function ZZ(e, t) {
        var r, o, i;
        if (w0(t.graphMode))
            switch (t.graphMode) {
            case 121:
            case 123:
                {
                    t.graphMode = 2,
                    t.willConvertTo3D = !0,
                    (r = t.lineWidth) != null || (t.lineWidth = 1);
                    break
                }
            case 120:
            case 122:
                {
                    t.graphMode = 1,
                    t.willConvertTo3D = !0,
                    (o = t.lineWidth) != null || (t.lineWidth = 1);
                    break
                }
            case 124:
                let {min: s, max: a} = ((i = t.domain) == null ? void 0 : i.type) === "1d" ? t.domain : {
                    min: 0,
                    max: 2 * Math.PI
                };
                t.graphMode = 6,
                t.domain = {
                    type: "1d",
                    min: s,
                    max: a,
                    isExplicit: e.metaData.isExplicitDomain
                };
                break;
            case 126:
                t.graphMode = 8;
                break
            }
    }
    function WF(e, t, n) {
        var c, l, p;
        let r = (c = Ji[e.graphMode]) != null ? c : [], o = t.concrete.getCompiledFunction(r), i, s, a = !1;
        if (e.graphMode === 112 || e.graphMode === 126 || e.graphMode === 113) {
            e.operator !== "=" && (a = !0);
            try {
                i = t.concrete.gradient(["x", "y", "z"])._chunk,
                s = i.getCompiledFunction(["x", "y", "z"]).fn
            } catch (m) {}
        }
        if (e.graphMode === 112 && s && i) {
            let m = XZ(o.fn, s, i, n.viewport);
            if (m)
                return {
                    graphMode: 118,
                    position: m.center,
                    radius: m.radii,
                    guid: Do(),
                    color: e.color,
                    restrictionShader: t.restriction,
                    surfaceOpacity: (l = e.surfaceOpacity) != null ? l : 1
                }
        }
        let u = e.graphMode;
        if ((u === 112 || u === 113 || u === 127 || u === 106 || u === 107 || u === 108) && t.concrete._chunk.isLinearIn(["x", "y", "z"]) || u === 106 && t.concrete._chunk.isConstant()) {
            let m = n.viewport, d;
            switch (u) {
            case 106:
                d = (f, h, x) => x - o.fn(f, h);
                break;
            case 107:
                d = (f, h, x) => f - o.fn(h, x);
                break;
            case 108:
                d = (f, h, x) => h - o.fn(f, x);
                break;
            case 112:
            case 113:
            case 127:
                d = o.fn;
                break
            }
            let y = Ts(rg(d, m))
              , g = u === 113 || u === 127;
            return u === 127 && (u = 113),
            {
                meshData: y,
                color: e.color,
                surfaceOpacity: g ? 1 : (p = e.surfaceOpacity) != null ? p : 1,
                uvArgs: [],
                extraMeshArgs: [],
                graphMode: u,
                compiled: o,
                restrictionShader: t.restriction
            }
        }
        return Ta({
            viewState: n,
            graphInfo: e,
            compiled: o,
            restrictionShader3d: t.restriction,
            isImplicit3dInequality: a,
            gradient: s,
            dependencies: t.concrete._dependencies
        })
    }
    function XZ(e, t, n, r) {
        if (r.zmin === void 0 || r.zmax === void 0)
            return;
        let o = n.argNames.indexOf("x")
          , i = n.argNames.indexOf("y")
          , s = n.argNames.indexOf("z");
        if (o === -1 || i === -1 || s === -1)
            return;
        let a = n.getInstruction(n.getReturnIndex());
        if (a.type !== 38 || a.args.length !== 3)
            return;
        let[u,c,l] = a.args
          , p = Eo(n, o, {
            allowRestriction: !1,
            allowClosedBlockReferences: !1
        })
          , m = Eo(n, i, {
            allowRestriction: !1,
            allowClosedBlockReferences: !1
        })
          , d = Eo(n, s, {
            allowRestriction: !1,
            allowClosedBlockReferences: !1
        });
        if (Pn(p, u) !== 1 || Pn(m, c) !== 1 || Pn(d, l) !== 1 || Pn(m, u) !== 0 || Pn(d, u) !== 0 || Pn(p, c) !== 0 || Pn(d, c) !== 0 || Pn(p, l) !== 0 || Pn(m, l) !== 0)
            return;
        let {xmin: y, ymin: g, zmin: f, xmax: h, ymax: x, zmax: T} = r
          , P = t(y, g, f)
          , C = t(h, x, T)
          , S = .5 * (C[0] - P[0]) / (h - y)
          , E = .5 * (C[1] - P[1]) / (x - g)
          , M = .5 * (C[2] - P[2]) / (T - f)
          , _ = (y * C[0] - h * P[0]) / (C[0] - P[0])
          , U = (g * C[1] - x * P[1]) / (C[1] - P[1])
          , Q = (f * C[2] - T * P[2]) / (C[2] - P[2])
          , K = -e(_, U, Q)
          , w = Math.sqrt(K / S)
          , B = Math.sqrt(K / E)
          , W = Math.sqrt(K / M);
        if (!(!isFinite(_) || !isFinite(U) || !isFinite(Q) || !isFinite(w) || !isFinite(B) || !isFinite(W) || w === 0 || B === 0 || W === 0))
            return {
                center: [_, U, Q],
                radii: [w, B, W]
            }
    }
    var WZ = !1;
    function jZ(e, t) {
        let n = t.viewport.xmax - t.viewport.xmin
          , r = t.viewport.ymax - t.viewport.ymin
          , o = _s(n, r)
          , i = _s(30, 30)
          , s = Math.round(2 - Math.log(o / i) / Math.LN10);
        if (s <= 0)
            return Math.round(e) + "";
        {
            let a = Math.pow(10, s);
            return Math.round(e * a) / a + ""
        }
    }
    function JZ(e, t) {
        return t.degreeMode ? Math.round(e / (Math.PI / 180) * 10) / 10 + "\xB0" : Math.round(e * 100) / 100 + ""
    }
    function QZ(e, t) {
        let n = t.viewport.xmax - t.viewport.xmin
          , r = t.viewport.ymax - t.viewport.ymin
          , o = n * r
          , i = 30 * 30
          , s = Math.round(2 - Math.log(o / i) / Math.LN10);
        if (s <= 0)
            return Math.round(e) + "";
        {
            let a = Math.pow(10, s);
            return Math.round(e * a) / a + ""
        }
    }
    function QF({node: e, policy: t, styleBroadcastStrategy: n, viewState: r, concrete: o, childIntersections: i}) {
        let s = []
          , a = e.userData.lines === void 0 ? !0 : e.userData.lines
          , u = e.userData.fill === void 0 ? !0 : e.userData.fill;
        if (!u && !a)
            return s;
        let c = Ys(e.metaData, ["computedLineOpacity", "computedLineWidth", "colorLatexValue", "fillOpacity"], n)
          , l = o.asValue();
        X(o.valueType) || (l = [l]);
        for (let p = 0; p < l.length; p++) {
            if (p > c - 1)
                continue;
            let m = l[p];
            if (!m.length)
                continue;
            let d = co(e, t, o)
              , {listIndex: y, lineWidth: g, lineOpacity: f, fillOpacity: h, color: x} = ru(e, p, n);
            !e.userData.shouldOmitLastPolygonSegment && m.length > 2 && (m = [...m, m[0]]),
            Br(m);
            let T = PT(m);
            if (T.length) {
                if (u && m.length > 2 && s.push({
                    segments: T,
                    graphMode: 7,
                    poi: {},
                    color: x,
                    fillOpacity: h,
                    style: d.style,
                    listIndex: y
                }),
                a && (s.push({
                    segments: T,
                    graphMode: 5,
                    poi: {},
                    color: x,
                    style: e.userData.lineStyle,
                    lineWidth: g,
                    lineOpacity: f,
                    listIndex: y
                }),
                i))
                    for (let P = 0; P < m.length - 1; P++) {
                        Nu(i.parentType, [De, Dr]);
                        let C = i.getEdgeIntersections(P);
                        if (!C)
                            continue;
                        let[S,E] = m[P]
                          , [M,_] = m[P + 1];
                        s.push(...IT([{
                            segments: [[S, E, M, _]],
                            resolved: !0,
                            graphMode: 17,
                            color: x,
                            style: e.userData.lineStyle,
                            arrowMode: d.arrowMode,
                            lineWidth: g,
                            lineOpacity: f,
                            listIndex: y,
                            poi: {}
                        }], C))
                    }
                if (WZ && e.userData.showLabel) {
                    let P = e.computedLabels && e.computedLabels[y || 0];
                    s.push({
                        graphMode: 22,
                        objectType: 16,
                        segments: T,
                        color: x,
                        listIndex: y,
                        showLabel: !0,
                        labelSize: e.metaData.computedLabelSize,
                        labelAngle: e.metaData.computedLabelAngle,
                        labelOrientation: e.userData.labelOrientation,
                        labels: P ? [P] : [QZ(uS(m), r)]
                    })
                }
            }
        }
        return s
    }
    function KF({node: e, concrete: t, policy: n, graphInfo: r, styleBroadcastStrategy: o}) {
        return lo({
            lineOpacity: !0,
            lineWidth: !0,
            color: !0
        }, {
            node: e,
            concrete: t,
            policy: n,
            graphInfo: r,
            styleBroadcastStrategy: o
        }, (i, s) => {
            let[[a,u],c] = i.asValue();
            return isNaN(a) || isNaN(u) || isNaN(c) ? [] : [{
                segments: [[a, u, c]],
                resolved: !0,
                graphMode: 20,
                color: s.color,
                style: s.lineStyle,
                lineWidth: s.lineWidth,
                lineOpacity: s.lineOpacity,
                listIndex: s.listIndex,
                operator: s.operator,
                poi: {}
            }]
        }
        )
    }
    function eV({node: e, concrete: t, policy: n, graphInfo: r, childIntersections: o, styleBroadcastStrategy: i}) {
        return lo({
            color: !0,
            lineWidth: !0,
            lineOpacity: !0
        }, {
            node: e,
            concrete: t,
            policy: n,
            graphInfo: r,
            styleBroadcastStrategy: i
        }, (s, a) => {
            let u = kh(s.asValue());
            if (!u)
                return [];
            let c = [];
            return u.type === "arc" ? c.push({
                graphMode: 21,
                segments: [[u.center[0], u.center[1], u.radius, u.startAngle, u.endAngle]],
                color: a.color,
                style: a.lineStyle,
                lineWidth: a.lineWidth,
                lineOpacity: a.lineOpacity,
                listIndex: a.listIndex,
                operator: r.operator,
                poi: {}
            }) : u.type === "rays" ? c.push({
                graphMode: 19,
                segments: [[u.start1[0], u.start1[1], u.end1[0], u.end1[1]]],
                color: a.color,
                style: a.lineStyle,
                lineWidth: a.lineWidth,
                lineOpacity: a.lineOpacity,
                listIndex: a.listIndex,
                operator: r.operator,
                poi: {}
            }, {
                graphMode: 19,
                segments: [[u.start2[0], u.start2[1], u.end2[0], u.end2[1]]],
                color: a.color,
                style: a.lineStyle,
                lineWidth: a.lineWidth,
                lineOpacity: a.lineOpacity,
                listIndex: a.listIndex,
                operator: r.operator,
                poi: {}
            }) : c.push({
                graphMode: 17,
                segments: [[u.start[0], u.start[1], u.end[0], u.end[1]]],
                color: a.color,
                style: a.lineStyle,
                lineWidth: a.lineWidth,
                lineOpacity: a.lineOpacity,
                listIndex: a.listIndex,
                operator: r.operator,
                poi: {}
            }),
            [...c, ...IT(c, o)]
        }
        )
    }
    function tV({node: e, concrete: t, policy: n, graphInfo: r, childIntersections: o, viewState: i, styleBroadcastStrategy: s}) {
        return lo({
            color: !0,
            lineWidth: !0,
            lineOpacity: !0
        }, {
            node: e,
            concrete: t,
            policy: n,
            graphInfo: r,
            styleBroadcastStrategy: s
        }, (a, u) => {
            let[[c,l],[p,m]] = a.asValue();
            if (isNaN(c) || isNaN(l) || isNaN(p) || isNaN(m))
                return [];
            let d = []
              , y = {
                segments: [[c, l, p, m]],
                resolved: !0,
                graphMode: u.graphMode,
                color: u.color,
                style: u.lineStyle,
                arrowMode: u.arrowMode,
                lineWidth: u.lineWidth,
                lineOpacity: u.lineOpacity,
                listIndex: u.listIndex,
                operator: r.operator,
                poi: {}
            };
            if (d.push(dD(n, y, i)),
            d.push(...IT([y], o)),
            e.userData.showLabel && r.graphMode === 17) {
                let g = u.listIndex
                  , f = e.computedLabels && e.computedLabels[g || 0];
                d.push({
                    graphMode: 22,
                    objectType: 17,
                    segments: [[c, l, p, m]],
                    color: u.color,
                    listIndex: g,
                    showLabel: !0,
                    labelSize: e.metaData.computedLabelSize,
                    labelAngle: e.metaData.computedLabelAngle,
                    labelOrientation: e.userData.labelOrientation,
                    labels: f ? [f] : [jZ(_s(p - c, m - l), i)]
                })
            }
            return d
        }
        )
    }
    function nV({node: e, concrete: t, policy: n, graphInfo: r, viewState: o, styleBroadcastStrategy: i}) {
        return lo({
            lineOpacity: !0,
            lineWidth: !0,
            color: !0
        }, {
            node: e,
            concrete: t,
            policy: n,
            graphInfo: r,
            styleBroadcastStrategy: i
        }, (s, a) => {
            let[u,c] = s.asValue()
              , [[l,p],[m,d]] = [c, [c[0] + u[0], c[1] + u[1]]];
            if (isNaN(m) || isNaN(d) || isNaN(l) || isNaN(p))
                return [];
            let y = {
                segments: [[l, p, m, d]],
                resolved: !0,
                graphMode: 24,
                color: a.color,
                style: a.lineStyle,
                arrowMode: a.arrowMode,
                lineWidth: a.lineWidth,
                lineOpacity: a.lineOpacity,
                listIndex: a.listIndex,
                operator: r.operator,
                poi: {}
            };
            return [dD(n, y, o)]
        }
        )
    }
    function rV({node: e, concrete: t, policy: n, graphInfo: r, viewState: o, styleBroadcastStrategy: i}) {
        return lo({
            lineOpacity: !0,
            lineWidth: !0,
            color: !0
        }, {
            node: e,
            concrete: t,
            policy: n,
            graphInfo: r,
            styleBroadcastStrategy: i
        }, (s, a) => {
            let u = Rr(s);
            if (!u)
                return [];
            let {value: c, valueType: l} = u
              , [[p,m],d,y] = c;
            if (isNaN(p) || isNaN(m) || isNaN(d) || isNaN(y))
                return [];
            let g = a.listIndex
              , f = l === Se
              , h = f ? y : Math.abs(y)
              , x = [];
            if (x.push({
                graphMode: 23,
                segments: [[p, m, d, y, f ? 1 : 0]],
                color: a.color,
                style: a.lineStyle,
                lineWidth: a.lineWidth,
                lineOpacity: a.lineOpacity,
                listIndex: g,
                operator: r.operator,
                poi: {}
            }),
            e.userData.showAngleLabel) {
                let T = e.computedLabels && e.computedLabels[g || 0];
                x.push({
                    graphMode: 22,
                    objectType: 23,
                    segments: [[p, m, d, y]],
                    color: a.color,
                    listIndex: g,
                    showLabel: !0,
                    labelSize: e.metaData.computedLabelSize,
                    labelAngle: e.metaData.computedLabelAngle,
                    labelOrientation: e.userData.labelOrientation,
                    labels: T ? [T] : [JZ(h, o)]
                })
            }
            return x
        }
        )
    }
    function KZ(e, t, n) {
        return e ? t === 0 && n === 0 ? e[2].type !== "none" || e[3].type !== "none" : t !== 0 && n !== 0 ? e[0].type !== "none" && e[1].type !== "none" : t !== 0 ? e[0].type !== "none" : n !== 0 ? e[1].type !== "none" : !1 : !1
    }
    function oV(e, t) {
        let n = [];
        if (t.center.valueType !== R || t.center.getDependencies().length !== 0 || t.radianAngle.type !== "IRExpression" || t.width.type !== "IRExpression" || t.height.type !== "IRExpression" || t.opacity.type !== "IRExpression" || !t.radianAngle.isConstant || !t.width.isConstant || !t.height.isConstant || !t.opacity.isConstant)
            return n;
        let r = []
          , o = []
          , i = t.width.asValue() / 2
          , s = t.height.asValue() / 2
          , a = t.radianAngle.asValue();
        for (let u = -1; u <= 1; u++)
            for (let c = -1; c <= 1; c++) {
                let[l,p] = t.center.asValue()
                  , m = [l + u * i * Math.cos(a) + c * s * Math.sin(a), p - u * i * Math.sin(a) + c * s * Math.cos(a)];
                KZ(t.moveStrategy, u, c) && (r.push(m),
                o.push([u, c]))
            }
        return n.push({
            segments: [r],
            scaleFactors: [o],
            graphMode: 4,
            color: $s(e.userData, e.metaData),
            style: e.userData.style,
            poi: Ai(r),
            movablePointInfo: [],
            pointOpacity: 1
        }),
        n
    }
    function iV({node: e, graphInfo: t, policy: n, reconciledProps: r, concrete: o, viewState: i, styleBroadcastStrategy: s}) {
        let a = e.userData
          , u = e.metaData
          , c = lo({
            color: !0,
            lineOpacity: !0,
            lineWidth: !0,
            resolution: !0,
            fillOpacity: !0
        }, {
            node: e,
            concrete: o,
            policy: n,
            graphInfo: t,
            styleBroadcastStrategy: s
        }, (p, m) => {
            var y;
            let d = p.getDependencies();
            if (d.length === 0 && !wa(p.valueType)) {
                let {points: g, droppedIndices: f} = Up([p.asValue()]);
                return [{
                    segments: [g],
                    graphMode: 3,
                    droppedIndices: f,
                    color: $s(a, u),
                    style: a.lineStyle,
                    showPoint: !1,
                    poi: Ai(g)
                }]
            } else {
                let g = p.getCompiledFunction(d);
                m.domain = (y = g.domain) != null ? y : {
                    type: "1d",
                    min: e.metaData.evaluatedDomainMin,
                    max: e.metaData.evaluatedDomainMax
                };
                let f = Ta({
                    viewState: i,
                    graphInfo: m,
                    compiled: g
                })
                  , h = lT(n, f, i, m.lineWidth);
                if (r.lines && !r.fill)
                    return [h];
                let x = {
                    segments: h.segments,
                    color: m.color,
                    fillOpacity: m.fillOpacity,
                    listIndex: m.listIndex,
                    graphMode: 7,
                    poi: {}
                };
                return r.lines ? [h, x] : [x]
            }
        }
        )
          , l = [];
        for (let p of c)
            p && l.push(p);
        return l
    }
    function GD(e) {
        let t = e.editableLabelMode;
        return t === zb.Text || t === zb.Math
    }
    function sV(e, {node: t, reconciledProps: n, concrete: r}) {
        let {points: o, droppedIndices: i} = Up([r.asValue()])
          , s = t.userData.shouldGraph && n.points
          , a = t.userData.showLabel && !s;
        if (s)
            return [{
                segments: [o],
                graphMode: e,
                droppedIndices: i,
                color: $s(t.userData, t.metaData),
                style: t.userData.pointStyle,
                showLabel: !!t.userData.showLabel,
                labelSize: t.metaData.computedLabelSize,
                labelAngle: t.metaData.computedLabelAngle,
                labelOrientation: t.userData.labelOrientation,
                pointOpacity: t.metaData.computedPointOpacity,
                pointSize: t.metaData.computedMovablePointSize,
                suppressTextOutline: t.userData.suppressTextOutline,
                pointOutline: t.userData.pointOutline,
                editableLabel: GD(t.userData),
                labels: t.computedLabels || [],
                poi: Ai(o),
                movablePointInfo: []
            }];
        if (a) {
            let u;
            switch (e) {
            case 4:
                u = 3;
                break;
            case 26:
                u = 25;
                break;
            default:
                let c = e;
                throw new Error(`Unexpected graphMode: ${c}`)
            }
            return [{
                segments: [o],
                graphMode: u,
                color: $s(t.userData, t.metaData),
                style: t.userData.pointStyle,
                showLabel: !!t.userData.showLabel,
                nakedLabel: !0,
                labelSize: t.metaData.computedLabelSize,
                labelAngle: t.metaData.computedLabelAngle,
                labelOrientation: t.userData.labelOrientation,
                pointOpacity: t.metaData.computedPointOpacity,
                suppressTextOutline: t.userData.suppressTextOutline,
                pointOutline: t.userData.pointOutline,
                editableLabel: GD(t.userData),
                labels: t.computedLabels || [],
                poi: Ai(o),
                showPoint: !1
            }]
        } else
            return []
    }
    function aV(e, {node: t, policy: n, styleBroadcastStrategy: r, viewState: o, reconciledProps: i, concrete: s}) {
        let a = []
          , u = t.userData.shouldGraph && i.points
          , c = t.userData.shouldGraph && i.lines
          , l = ["colorLatexValue"];
        u && l.push("computedPointOpacity", "computedPointSize"),
        (t.userData.showLabel || u) && l.push("computedLabelSize", "computedLabelAngle");
        let p = Ys(t.metaData, l, r)
          , m = Vo.wrap(s).asValue();
        Br(m),
        m.length > p && (m.length = p);
        let d = t.userData.showLabel && !u && !c
          , y = Up(m);
        if (t.userData.showLabel || u) {
            let g = {
                segments: [y.points],
                graphMode: e,
                droppedIndices: y.droppedIndices,
                color: t.metaData.colorLatexValue || t.userData.color,
                style: t.userData.pointStyle,
                showLabel: !!t.userData.showLabel,
                showPoint: u,
                labelSize: t.metaData.computedLabelSize,
                labelAngle: t.metaData.computedLabelAngle,
                labelOrientation: t.userData.labelOrientation,
                pointSize: t.metaData.computedPointSize,
                pointOpacity: t.metaData.computedPointOpacity,
                suppressTextOutline: t.userData.suppressTextOutline,
                pointOutline: t.userData.pointOutline,
                interactiveLabel: !!t.userData.interactiveLabel,
                editableLabel: GD(t.userData),
                nakedLabel: d,
                labels: t.computedLabels || [],
                poi: Ai(m)
            };
            n.is3dPolicy() ? a.push(...cF(g)) : a.push(g)
        }
        if (c) {
            let g = t.metaData.computedLineWidth
              , f = {
                segments: PT(m),
                graphMode: 5,
                color: $s(t.userData, t.metaData),
                style: t.userData.lineStyle,
                lineWidth: g,
                lineOpacity: t.metaData.computedLineOpacity,
                poi: {}
            };
            a.push(lT(n, f, o, g))
        }
        return a
    }
    function uV(e, t, n, r) {
        var a;
        let o = co(e, t, n);
        if (n.model.type === "Error")
            return [];
        let s = Ku(e, t, n.model, r, o);
        for (let u of s)
            (a = e.tableRegressionData) != null && a.tableId && (u.tableId = e.tableRegressionData.tableId);
        return s
    }
    function Yp(e, t) {
        return qD(e, t).freeDependencies
    }
    function qD(e, t) {
        let n = {};
        if (t.type === "FunctionDefinition" || t.type === "RecursiveFunctionBaseCase") {
            let {freeDependencies: r, updateSymbols: o} = DT(e, t._expression, n)
              , i = r.filter(s => s !== t._symbol);
            if (t instanceof _r || t instanceof xo)
                for (let s of t._argSymbols)
                    i.includes(s) || i.push(s);
            return {
                freeDependencies: i,
                updateSymbols: o
            }
        }
        return DT(e, t, n)
    }
    function cV(e, t, n) {
        let r = []
          , o = []
          , i = [];
        for (let s of t.scopes) {
            let a = cV(e, s, n);
            for (let u of a.freeDependencies)
                r.indexOf(u) === -1 && t.definitions.indexOf(u) === -1 && r.push(u);
            for (let u of a.updateSymbols)
                o.indexOf(u) === -1 && o.push(u)
        }
        for (let s of t.dependencies) {
            if (t.definitions.indexOf(s) !== -1)
                continue;
            let a = eX(e, s, n)
              , u = t.substitutionDependencies.indexOf(s) !== -1;
            for (let c of a.freeDependencies)
                r.indexOf(c) === -1 && t.definitions.indexOf(c) === -1 && r.push(c),
                u && i.indexOf(c) === -1 && t.definitions.indexOf(c) === -1 && i.push(c);
            for (let c of a.updateSymbols)
                o.indexOf(c) === -1 && o.push(c)
        }
        return {
            freeDependencies: r,
            updateSymbols: o
        }
    }
    function DT(e, t, n) {
        if (t.type === "Slider" || t.type === "Assignment")
            return DT(e, t._expression, n);
        {
            let {freeDependencies: r, updateSymbols: o} = cV(e, t.getScope(), n)
              , i = t.getUpdateSymbols();
            if (i.length > 0) {
                o = o.slice();
                for (let s of i)
                    o.indexOf(s) === -1 && o.push(s)
            }
            return {
                freeDependencies: r,
                updateSymbols: o
            }
        }
    }
    function eX(e, t, n) {
        if (n[t])
            return n[t];
        let r = tX(e, t, n);
        return n[t] = r,
        r
    }
    function tX(e, t, n) {
        if (rt[t])
            return {
                freeDependencies: [],
                updateSymbols: []
            };
        let r = e[t];
        return r ? (n[t] = {
            freeDependencies: [],
            updateSymbols: []
        },
        DT(e, r, n)) : {
            freeDependencies: [t],
            updateSymbols: []
        }
    }
    function lV(e, t) {
        let n = {}
          , r = t.getDependencies().slice();
        for (; r.length; ) {
            let o = r.pop();
            if (n.hasOwnProperty(o))
                continue;
            if (e.isLocal(o) || e.isError(o))
                return;
            let i = e.getVisibleGlobalDefinition(o);
            n[o] = i,
            i && i.getDependencies && Array.prototype.push.apply(r, i.getDependencies())
        }
        return Object.entries(n)
    }
    function pV(e, t, n) {
        mV(e, t, n, {})
    }
    function mV(e, t, n, r) {
        let o = {};
        for (let i of n.definitions) {
            if (o[i])
                switch (n.kind) {
                case "Integral":
                case "RepeatedOperator":
                    throw F(new Error(`${n.kind} scope is not expected to define multiple symbols`));
                case "FunctionDefinition":
                    throw DC(i);
                case "ListComprehension":
                    throw Lb(i);
                case "Substitution":
                    throw Jv(i);
                default:
                    let s = n.kind;
                    throw F(new Error(`Unexpected scope kind ${s}`))
                }
            o[i] = !0
        }
        for (let i of n.definitions) {
            let s = t[i];
            if (s) {
                if (e.assignmentForbidden(i))
                    switch (n.kind) {
                    case "RepeatedOperator":
                        throw xb(i);
                    case "Integral":
                        throw Db(i);
                    case "FunctionDefinition":
                        throw bb(i);
                    case "Substitution":
                    case "ListComprehension":
                        throw gy(i);
                    default:
                        let a = n.kind;
                        throw F(new Error(`Unexpected scope kind ${a}`))
                    }
                if ((n.kind === "ListComprehension" || n.kind === "Substitution") && s.type === "FunctionDefinition")
                    throw hy(i)
            }
            if (r[i])
                switch (n.kind) {
                case "RepeatedOperator":
                    throw xb(i);
                case "Integral":
                    throw Db(i);
                case "FunctionDefinition":
                    throw bb(i);
                case "ListComprehension":
                    throw Lb(i);
                case "Substitution":
                    throw Wv(i);
                default:
                    let a = n.kind;
                    throw F(new Error(`Unexpected scope kind ${a}`))
                }
        }
        r = Fn(r);
        for (let i of n.definitions)
            r[i] = !0;
        for (let i of n.scopes)
            mV(e, t, i, r)
    }
    function dV(e, t) {
        let {mappedArgIndex: n, mappedReturnIndex: r, solutionIndex: o} = t
          , i = yl(e, n)
          , s = nX(e, i, r)
          , a = o
          , u = e.NanOfType(e.getReturnType())
          , c = new zo(e,0,r);
        return c.copyUntilEnd( (l, p, m) => {
            if (m === n)
                return o;
            if (!i[m] && !l.isInClosedBlock(m))
                return m;
            if (de(p)) {
                let d = c.mapArgs(p.args);
                return p.type === 33 && s[m] && (a = l.Piecewise([d[0], a, u])),
                l.copyInstructionWithArgs(p, d)
            } else
                return c.copyLeafOrFunctionHeader(p)
        }
        ),
        a
    }
    function nX(e, t, n) {
        let r = [];
        for (let o = 0; o < n; o++)
            r.push(!1);
        r[n] = t[n];
        for (let o = n; o >= 0; o--) {
            if (!r[o] || !t[o])
                continue;
            let i = e.getInstruction(o);
            if (i.type === 33)
                r[i.args[1]] = !0;
            else if (de(i))
                for (let s of i.args)
                    r[s] = !0
        }
        return r
    }
    function fV(e, t) {
        try {
            return rX(e, t)
        } catch (n) {
            return n instanceof v ? n : F(n)
        }
    }
    function zD(e, t) {
        try {
            let n = new An(t)
              , r = Yp({}, n)
              , o = [];
            for (let s = 0; s < r.length; s++)
                o.push(b);
            let i = RT({
                policy: e,
                frame: {},
                argNames: r,
                argTypes: o,
                selection: void 0,
                locals: []
            });
            return i.chunk = t,
            t.fuseBroadcast(),
            yV({
                policy: e,
                ctx: i,
                isInequality: !1,
                allowSolvingIn3D: !0
            }, t)
        } catch (n) {
            return n instanceof v ? n : F(n)
        }
    }
    function _T(e, t) {
        let n = e.getInstruction(t);
        if (n.type !== 1)
            return !1;
        switch (n.valueType) {
        case N:
            return Number.isNaN(n.value[0]);
        case b:
            return Number.isNaN(n.value);
        case ke:
            return n.value.length > 0 && n.value.every(r => Number.isNaN(r[0]));
        case Y:
            return n.value.length > 0 && n.value.every(r => Number.isNaN(r));
        case sn:
            return !n.value;
        case gu:
            return n.value.length > 0 && n.value.every(r => !r);
        case Oe:
        case Se:
            return Number.isNaN(n.value[2]);
        case Ar:
        case wr:
            return n.value.length > 0 && n.value.every(r => Number.isNaN(r[2]));
        default:
            throw F("Unexpected type in isConstantNaN: " + Ke(n.valueType))
        }
    }
    function rX({policy: e, frame: t}, n) {
        let r = !1
          , o = [];
        if (n instanceof gl) {
            let x = n._lhs
              , T = x._symbol;
            if (!t[T] && !e.assignmentForbidden(T) && (r = !0,
            o = x._dependencies,
            x.args.length > 1)) {
                let C = n._dependencies.filter(E => !o.includes(E))
                  , S = xn([T]).setDependencies(C);
                throw S.silent = !0,
                S
            }
        }
        let i = n.asComparator()
          , s = Yp(t, i)
          , a = [];
        for (let x = 0; x < s.length; x++)
            a.push(b);
        let u = RT({
            policy: e,
            frame: t,
            argNames: s,
            argTypes: a,
            selection: void 0,
            locals: []
        })
          , {chunk: c} = u
          , l = i.getOperator()
          , p = l !== "="
          , m = Re(u, i.args[0])
          , d = Xi(c, m, {
            peelableCoerce: !0
        });
        if (d !== m && !_T(c, m) && _T(c, d))
            throw Vm(l);
        let y = Re(u, i.args[1])
          , g = Xi(c, y, {
            peelableCoerce: !0
        });
        if (g !== y && !_T(c, y) && _T(c, g))
            throw Vm(l);
        try {
            eu(c, e, i, [d, g])
        } catch (x) {
            throw x instanceof v && r && (x.silent = !0),
            x
        }
        switch (l) {
        case "<":
            c.Less([d, g]);
            break;
        case ">":
            c.Greater([d, g]);
            break;
        case "<=":
            c.LessEqual([d, g]);
            break;
        case ">=":
            c.GreaterEqual([d, g]);
            break;
        case "=":
            c.Equal([d, g]);
            break
        }
        if (c.fuseBroadcast(),
        c.isConstant())
            return new An(c);
        let h = c.getInstruction(d).type !== 2 || Yp(t, i.args[1]).indexOf(c.argNames[d]) !== -1;
        if (!ps.plotImplicits && h)
            throw ev();
        return ro[l].direction === -1 ? c.Subtract([g, d]) : c.Subtract([d, g]),
        c.fuseBroadcast(),
        yV({
            policy: e,
            ctx: u,
            isInequality: p,
            allowSolvingIn3D: !1,
            maybeBaseCase: r,
            callParameters: o
        }, c)
    }
    function yV({policy: e, ctx: t, isInequality: n, allowSolvingIn3D: r, maybeBaseCase: o, callParameters: i}, s) {
        let a = s.getLiveArgNames();
        if (a.length === 0)
            throw F(`Unexpected: non-constant node with dependencies: ${a}`);
        if (a.length === 1 && !n && !ps.plotSingleVariableImplicitEquations)
            return KC();
        let u = g => g === "x" || g === "y" || g === "z";
        if (e.is3dPolicy() ? !a.every(u) : a.length > 2) {
            let g = e.sliderVariables(a);
            if (o) {
                let f = i ? a.filter(x => !i.includes(x)) : a
                  , h = xn(g).setDependencies(f);
                return h.silent = !0,
                h
            } else
                return xn(g).setDependencies(a)
        }
        if (n && !e.validInequalityVariables(a))
            return JC().setDependencies(a);
        let {localFrames: c, effectiveOrder: l, variableOfInterest: p} = oX(t, n);
        if (e.complicatedPolarImplicit(p, l))
            return tv().setDependencies(a);
        if (!e.validImplicitVariables(a)) {
            let g = Tp();
            return o && (g.silent = !0),
            g
        }
        if (e.is3dPolicy() && r && l !== 1)
            return Lu();
        if (l > 2 || e.is3dPolicy() && !r)
            return new An(s);
        let m = []
          , d = []
          , y = 1;
        for (let g = 0; g < c.length; g++) {
            let f = c[g]
              , h = iX(f, n);
            y = h.length;
            for (let T of h) {
                let P = f.chunk.copy();
                if (P.setReturnIndex(T),
                f.isRestrictedPolynomial) {
                    let {mappedArgIndex: C, mappedReturnIndex: S} = f;
                    P.setReturnIndex(dV(P, {
                        mappedArgIndex: C,
                        mappedReturnIndex: S,
                        solutionIndex: P.getReturnIndex()
                    }))
                }
                P.fuseBroadcast(),
                m.push(new An(P))
            }
            let x = !1;
            for (let T of f.coefficients) {
                let P = f.chunk.getInstruction(T);
                P.type === 1 && P.value !== 0 && (x = !0)
            }
            if (s.argNames.length !== 2 || x)
                d.push(void 0);
            else {
                let T = f.chunk.copy()
                  , P = f.coefficients.slice();
                T.List(P);
                let C = X(s.getReturnType()) ? s.elementAt(g) : s.copy()
                  , E = C.argNames.indexOf(p) === 0 ? 1 : 0
                  , M = C.getReturnIndex();
                C.Add([E, C.Multiply([C.Constant(0), M])]),
                d.push({
                    coefficients: T,
                    restriction: C
                })
            }
        }
        return new O.SolvedEquation(p,new Vo(m),d,y)
    }
    function oX(e, t) {
        let n = e.chunk
          , r = e.policy
          , o = n.argNames
          , i = X(n.getReturnType())
          , s = [];
        e: for (let a = 0; a < o.length; a++) {
            let u = o[a]
              , c = o.length > 1 && !r.validSolvedVariable(u);
            s[a] = {
                localFrames: [],
                effectiveOrder: 0,
                variableOfInterest: u
            };
            let l = !t;
            if (c) {
                s[a].effectiveOrder = 1 / 0;
                continue
            }
            let p = i ? n.getConstantListLength() : 1;
            if (p == null)
                throw new Error("Programming error: cannot solve a variable-length list expression");
            for (let m = 0; m < p; m++) {
                let d = i ? n.elementAt(m) : n;
                if (d.polynomialOrder(u, {
                    allowRestriction: l,
                    allowClosedBlockReferences: !1
                }) > 2) {
                    s[a].effectiveOrder = 1 / 0;
                    continue e
                }
                let g = d.getPolynomialCoefficients(u);
                s[a].localFrames.push(g),
                s[a].effectiveOrder = Math.max(s[a].effectiveOrder, g.coefficients.length - 1)
            }
        }
        if (o.length === 1)
            return s[0];
        if (o.length === 2 && !o.includes("z"))
            return o[0] === "y" && (s = [s[1], s[0]]),
            s[0].effectiveOrder === 0 ? s[1] : s[1].effectiveOrder === 0 ? s[0] : s[s[0].effectiveOrder < s[1].effectiveOrder ? 0 : 1];
        {
            let a = s.filter(c => c.effectiveOrder === 1);
            if (a.length > 0)
                return a[0];
            let u = s.filter(c => c.effectiveOrder === 2);
            return u.length > 0 ? u[0] : s[0]
        }
    }
    function iX(e, t) {
        return t ? aX(e) : sX(e)
    }
    function sX({chunk: e, coefficients: t}) {
        let[n,r,o] = t
          , i = e.Constant(be(0, 1))
          , s = e.Constant(NaN);
        if (o === void 0) {
            r === void 0 && (r = i);
            let a = e.Negative([e.Divide([n, r])])
              , u = e.Equal([r, i]);
            return [e.Piecewise([u, s, a])]
        } else {
            let a = e.Constant(be(2, 1))
              , u = e.Multiply([a, o])
              , c = e.Negative([e.Divide([r, u])])
              , l = e.Divide([n, o])
              , p = e.Subtract([e.Square([c]), l])
              , m = e.Equal([o, i])
              , d = e.Equal([p, i])
              , y = e.getInstruction(p);
            if (y.type === 1 && L(y.value) === 0)
                return [e.Piecewise([m, s, c])];
            {
                let g = e.NativeFunction("sqrt", [p])
                  , f = e.Greater([r, i])
                  , h = e.Less([r, i])
                  , x = e.Greater([c, i])
                  , T = e.Piecewise([x, e.Add([c, g]), e.Subtract([c, g])])
                  , P = e.Piecewise([d, T, e.Divide([l, T])])
                  , C = e.Negative([e.Divide([n, r])]);
                return [e.Piecewise([m, e.Piecewise([h, C, s]), T]), e.Piecewise([m, e.Piecewise([f, C, s]), P])]
            }
        }
    }
    function aX({chunk: e, coefficients: t}) {
        let[n,r,o] = t
          , i = e.Constant(be(0, 1));
        o === void 0 && (o = i),
        r === void 0 && (r = i),
        n === void 0 && (n = i);
        let s = e.Constant(be(2, 1))
          , a = e.Constant(NaN)
          , u = e.Constant(be(1e305, 1))
          , c = e.Negative([u])
          , l = e.Multiply([s, o])
          , p = e.Negative([e.Divide([r, l])])
          , m = e.Divide([n, o])
          , d = e.Subtract([e.Square([p]), m])
          , y = e.NativeFunction("sqrt", [d])
          , g = e.Negative([e.Divide([n, r])])
          , f = e.Equal([o, i])
          , h = e.Equal([d, i])
          , x = e.Greater([o, i])
          , T = e.Equal([r, i])
          , P = e.Greater([r, i])
          , C = e.Less([r, i])
          , S = e.Greater([p, i])
          , E = e.Greater([n, i])
          , M = e.Less([d, i])
          , _ = e.Piecewise([S, e.Add([p, y]), e.Subtract([p, y])])
          , U = e.Piecewise([h, _, e.Divide([m, _])])
          , Q = e.Piecewise([S, U, _])
          , K = e.Piecewise([S, _, U]);
        return [e.Piecewise([f, e.Piecewise([C, g, a]), e.Piecewise([x, Q, a])]), e.Piecewise([f, e.Piecewise([T, e.Piecewise([E, c, a]), a]), e.Piecewise([x, e.Piecewise([M, c, a]), Q])]), e.Piecewise([f, e.Piecewise([T, e.Piecewise([E, u, a]), a]), e.Piecewise([x, e.Piecewise([M, u, a]), K])]), e.Piecewise([f, e.Piecewise([P, g, a]), e.Piecewise([x, K, a])])]
    }
    function gV(e, {viewState: t, node: n, concrete: r, graphInfo: o, policy: i, styleBroadcastStrategy: s}) {
        return lo({
            color: !0,
            lineWidth: !0,
            lineOpacity: !0,
            resolution: !0
        }, {
            node: n,
            concrete: r,
            policy: i,
            graphInfo: o,
            styleBroadcastStrategy: s
        }, (a, u) => {
            var E;
            let c = (E = Ji[e]) != null ? E : []
              , l = a.getCompiledFunction(c).domain;
            switch (e) {
            case 206:
            case 211:
                u.domain = {
                    type: "1d",
                    min: n.metaData.evaluatedDomainMin,
                    max: n.metaData.evaluatedDomainMax,
                    isExplicit: n.metaData.isExplicitDomain
                };
                break;
            case 203:
            case 204:
            case 213:
            case 207:
            case 208:
            case 212:
            case 214:
            case 215:
                u.domain = l != null ? l : {
                    type: "2d",
                    uMin: n.metaData.evaluatedDomain3DMin1,
                    uMax: n.metaData.evaluatedDomain3DMax1,
                    vMin: n.metaData.evaluatedDomain3DMin2,
                    vMax: n.metaData.evaluatedDomain3DMax2
                };
                break
            }
            let p = {
                allowSlices: !0
            }, m = Mc(a._chunk, c, p), {valueChunk: d, slices: y} = m.getValueAndRestrictionChunk(), g = d.getInstruction(d.getReturnIndex()).valueType, f = wa(g) ? bx(d) : d.getCompiledFunction(c), h = y[0], x = h.type === "implicit", T = x ? NaN : h.value, P = x ? "_implicit" : h.variable, C, S = M => Ta({
                viewState: t,
                graphInfo: {
                    ...u,
                    slice_coordinate: P,
                    slice_value: T,
                    slice_function: M
                },
                compiled: f
            });
            if (x) {
                let M = ["x", "y", "z"]
                  , _ = ["x", "y", "z", "r", "theta"]
                  , U = ["x", "y", "z", "rho", "theta", "phi"]
                  , Q = ["x", "y", "z", "u", "v"]
                  , K = h.sliceChunk;
                switch (e) {
                case 200:
                case 201:
                case 202:
                    C = K.getCompiledFunction(M);
                    break;
                case 211:
                case 213:
                    C = K.getCompiledFunction(_);
                    break;
                case 212:
                    C = K.getCompiledFunction(U);
                    break;
                case 215:
                case 214:
                    C = K.getCompiledFunction(Q);
                    break;
                case 209:
                    {
                        let w = (oe, te) => {
                            let st = te.getCompiledFunction(M)
                              , Tt = oe._symbol
                              , ye = oe._expression.args
                              , ee = [];
                            for (let k of ye) {
                                if (!(k instanceof An))
                                    throw F("Programming Error: bad type");
                                if (Tt === "x")
                                    f = k._chunk.getCompiledFunction(["y", "z"]),
                                    u.graphMode = 201;
                                else if (Tt === "y")
                                    f = k._chunk.getCompiledFunction(["x", "z"]),
                                    u.graphMode = 202;
                                else if (Tt === "z")
                                    f = k._chunk.getCompiledFunction(["x", "y"]),
                                    u.graphMode = 200;
                                else
                                    throw F("Programming Error: bad lhs");
                                ee.push(S(st))
                            }
                            return ee
                        }
                          , B = (oe, te) => {
                            let st = t.viewport
                              , Tt = te.getCompiledFunction(M)
                              , ye = oe.getCompiledFunction(M).fn
                              , ee = ND(ye, st);
                            if (ee) {
                                let {explicitPlane: k, u: ne, v: Ne} = ee;
                                return u.graphMode = 214,
                                f = {
                                    args: ["u", "v"],
                                    source: "",
                                    constants: [],
                                    fn: k,
                                    executionMetadata: {}
                                },
                                u.domain = {
                                    type: "2d",
                                    uMin: ne.min,
                                    uMax: ne.max,
                                    vMin: Ne.min,
                                    vMax: Ne.max
                                },
                                [S(Tt)]
                            } else
                                return []
                        }
                        ;
                        if (K.isImplicitPlane())
                            return B(K, d);
                        if (d.isImplicitPlane())
                            return B(d, K);
                        let W = zD(i, d);
                        return W.type === "SolvedEquation" ? w(W, K) : (W = zD(i, K),
                        W.type === "SolvedEquation" ? w(W, d) : [S(K.getCompiledFunction(M))])
                    }
                }
            }
            return [S(C)]
        }
        )
    }
    function hV({viewState: e, node: t, concrete: n, graphInfo: r, policy: o, styleBroadcastStrategy: i}) {
        return lo({
            color: !0,
            surfaceOpacity: !0,
            resolution: !0
        }, {
            node: t,
            concrete: n,
            policy: o,
            graphInfo: r,
            styleBroadcastStrategy: i
        }, (s, a) => {
            var C, S, E, M, _, U, Q, K;
            let u = (C = Ji[r.graphMode]) != null ? C : []
              , c = {
                allowSlices: !0
            }
              , l = Mc(s._chunk, u, c)
              , {restrictionChunk: p, slices: m} = l.getSlicesAndRestrictionChunk()
              , d = p.getCompiledFunction(u);
            if (m[0].type === "implicit") {
                let w = m[0].sliceChunk, B;
                try {
                    B = w.copy().gradient(["x", "y", "z"]).getCompiledFunction(["x", "y", "z"]).fn
                } catch (st) {}
                let W = (S = a.resolution) != null ? S : NaN;
                return isNaN(W) && (W = Jy),
                W = pr(W, 0, 100),
                [{
                    meshData: TD(w.getCompiledFunction(u), void 0, B, e.viewport, W, {
                        isInequality: !1
                    }),
                    color: a.color,
                    surfaceOpacity: (E = a.surfaceOpacity) != null ? E : 1,
                    uvArgs: (M = Ji[a.graphMode]) != null ? M : [],
                    extraMeshArgs: (_ = Al[a.graphMode]) != null ? _ : [],
                    graphMode: 210,
                    compiled: d,
                    restrictionShader: as(p, Qi)
                }]
            }
            let y = m[0].value, g = m[0].variable, f = e.viewport, h;
            switch (g) {
            case "x":
                h = (w, B, W) => w - y;
                break;
            case "y":
                h = (w, B, W) => B - y;
                break;
            case "z":
                h = (w, B, W) => W - y;
                break;
            default:
                return []
            }
            let x = rg(h, f);
            return [{
                meshData: Ts(x),
                color: a.color,
                surfaceOpacity: (U = a.surfaceOpacity) != null ? U : 1,
                uvArgs: (Q = Ji[a.graphMode]) != null ? Q : [],
                extraMeshArgs: (K = Al[a.graphMode]) != null ? K : [],
                graphMode: 210,
                compiled: d,
                restrictionShader: as(p, Qi)
            }]
        }
        )
    }
    function uX(e) {
        return Array.prototype.concat.apply([], e)
    }
    function bV(e) {
        let t = [];
        for (let n of e)
            typeof n == "number" ? t.push(n) : t.push(PS(n));
        return t
    }
    function xV(e, t) {
        let n = {}
          , r = t.columns[0];
        if (r.type === "Error")
            return n;
        let o = bV(r.asValueMixed());
        for (let i = 1; i < e.columns.length; i++) {
            let s = t.columns[i];
            if (s.type === "Error")
                continue;
            let a = bV(s.asValueMixed())
              , u = e.columns[i].header.userData
              , c = e.columns[i].header.metaData;
            if (u.hidden)
                continue;
            let l = Ys(c, ["colorLatexValue", "computedPointSize", "computedPointOpacity"])
              , p = u.dragMode;
            (e.columnIsViewportDependency(0) || e.columnIsViewportDependency(i)) && (p = Jt.NONE);
            let m = p === Jt.X || p === Jt.XY
              , d = p === Jt.Y || p === Jt.XY
              , y = !!u.points
              , g = !!u.lines
              , f = []
              , h = []
              , x = []
              , T = []
              , P = []
              , C = []
              , S = 1 / 0
              , E = -1 / 0
              , M = 1 / 0
              , _ = -1 / 0
              , U = {};
            for (let w = 0; w < o.length; w++) {
                let B = o[w]
                  , W = a[w];
                if (!isFinite(B) || !isFinite(W)) {
                    U[w] = !0,
                    g && (C.length > 1 && P.push(C),
                    C = []);
                    continue
                }
                if (y) {
                    if (w >= l)
                        continue;
                    let oe = m && e.isValueDraggable(t, 0, w)
                      , te = d && e.isValueDraggable(t, i, w);
                    oe || te ? (x.push([B, W]),
                    T.push({
                        index: w,
                        dragX: oe,
                        dragY: te
                    })) : h.push([B, W])
                }
                g && C.push([B, W]),
                B < S && (S = B),
                B > E && (E = B),
                W < M && (M = W),
                W > _ && (_ = W)
            }
            let Q = e.columns[i]
              , K = {
                type: "table",
                symbol: "header"in Q ? Q.header._symbol : void 0,
                xmin: S,
                xmax: E,
                ymin: M,
                ymax: _
            };
            x.length && f.push({
                graphMode: 4,
                segments: [x],
                color: c.colorLatexValue || u.color,
                tableId: u.tableId,
                poi: Ai(x),
                movablePointInfo: T,
                boundingBox: K,
                pointOpacity: c.computedPointOpacity,
                pointSize: c.computedMovablePointSize,
                pointOutline: u.pointOutline,
                style: u.pointStyle
            }),
            h.length && f.push({
                segments: [h],
                droppedIndices: U,
                graphMode: 3,
                showPoint: !0,
                poi: Ai(h),
                color: c.colorLatexValue || u.color,
                pointSize: c.computedPointSize,
                pointOutline: u.pointOutline,
                pointOpacity: c.computedPointOpacity,
                style: u.pointStyle,
                tableId: u.tableId,
                boundingBox: K
            }),
            (P.length || C.length) && (P.push(C),
            f.push({
                segments: P.map(uX),
                graphMode: 5,
                poi: {},
                color: $s(u, c),
                style: u.lineStyle,
                lineWidth: Array.isArray(c.computedLineWidth) ? c.computedLineWidth[0] : c.computedLineWidth,
                lineOpacity: Array.isArray(c.computedLineOpacity) ? c.computedLineOpacity[0] : c.computedLineOpacity,
                tableId: u.tableId,
                boundingBox: K
            })),
            f.length && (n[u.id] = f)
        }
        return n
    }
    function Qde(e) {
        return 2 * cX(e * .5)
    }
    function cX(e) {
        return e <= 8 ? 3 * e : e >= 16 ? 2 * e : e + 16
    }
    function UD(e, t) {
        let n = 1 / 0
          , r = -1 / 0
          , o = 1 / 0
          , i = -1 / 0;
        for (let s of t)
            for (let a = 0; a < s.length; a += 2) {
                let u = s[a]
                  , c = s[a + 1];
                u < n && (n = u),
                u > r && (r = u),
                c < o && (o = c),
                c > i && (i = c)
            }
        if (isFinite(n) && isFinite(o))
            return {
                type: e,
                xmin: n,
                ymin: o,
                xmax: r,
                ymax: i
            }
    }
    function PV(e, t, n) {
        let r = {};
        n -= .5 * t;
        for (let o = e.length - 1; o >= 0; o--) {
            let i = e[o]
              , s = Math.floor((i - n) / t);
            r[s] ? r[s].data.push(i) : r[s] = {
                id: s,
                data: [i],
                min: s * t + n,
                max: s * t + n + t,
                center: s * t + n + t / 2
            }
        }
        return r
    }
    function SV(e, t, n) {
        let r = co(e, t, n)
          , o = n.args[0].asValue()
          , i = n.args[1].asValue()
          , s = e.userData.vizProps && e.userData.vizProps.binAlignment === "left" ? i / 2 : 0;
        Br(o);
        let a = PV(o, i, s)
          , u = 1;
        e.userData.vizProps && e.userData.vizProps.histogramMode === "density" ? u = 1 / (o.length * i) : e.userData.vizProps && e.userData.vizProps.histogramMode === "relative" && (u = 1 / o.length);
        let c = []
          , l = [];
        for (let m in a) {
            let d = a[m]
              , y = d.data.length;
            l.push([d.min, 0 * u, d.min, y * u, d.max, y * u, d.max, 0 * u]);
            let g = 0;
            a[d.id + 1] && (g = a[d.id + 1].data.length);
            let f = [d.min, 0 * u, d.min, y * u, d.max, y * u];
            g < y && f.push(d.max, g * u),
            c.push(f)
        }
        let p = UD("histogram", l);
        return p && i && (p.binWidth = i),
        [{
            segments: l,
            graphMode: 7,
            boundingBox: p,
            poi: {},
            color: r.color,
            fillOpacity: .4
        }, {
            segments: c,
            graphMode: 2,
            poi: {
                zeros: {
                    x: [],
                    y: []
                },
                extrema: {
                    x: [],
                    y: []
                },
                intercept: {
                    x: [],
                    y: []
                }
            },
            color: r.color
        }]
    }
    function EV(e, t, n) {
        let r = co(e, t, n)
          , o = n.args[1].asValue()
          , i = e.userData.vizProps && e.userData.vizProps.binAlignment === "left" ? o / 2 : 0
          , s = n.args[0].asValue();
        Br(s);
        let a = PV(s, o, i), u = !1, c, l = [];
        for (let f in a) {
            let h = a[f];
            for (let x = h.data.length - 1; x >= 0; x--)
                h.center !== h.data[x] && (u = !0)
        }
        if (e.userData.vizProps && e.userData.vizProps.dotplotXMode === "exact")
            for (let f in a) {
                c = a[f].data,
                c.reverse();
                for (let x = 0; x < c.length; x++)
                    l.push([c[x], x + 1])
            }
        else
            for (let f in a) {
                let h = a[f];
                c = h.data;
                for (let x = 0; x < c.length; x++)
                    l.push([h.center, x + 1])
            }
        let p = UD("dotplot", l);
        p && o && (p.ymin = 0,
        p.xmin -= .5 * o,
        p.xmax += .5 * o,
        p.binWidth = o);
        let {computedPointOpacity: m, computedPointSize: d} = e.metaData
          , y = Ia(m, 0)
          , g = e.userData.pointSize ? Ia(d, 0) : 14;
        return [{
            segments: [l],
            graphMode: 3,
            boundingBox: p,
            poi: Ai(l),
            color: r.color,
            style: e.userData.pointStyle,
            pointSize: g,
            pointOpacity: y,
            showPoint: !0,
            needsDotplotXMode: u
        }]
    }
    function CV(e, t, n) {
        let r = co(e, t, n)
          , o = e.metaData.evaluatedAxisOffset
          , i = e.metaData.evaluatedBreadth
          , s = n.args[0].asValue();
        if (Br(s),
        isNaN(i) || isNaN(o))
            return [];
        let a = Math.min.apply(null, s)
          , u = Math.max.apply(null, s)
          , c = ap(s, 1)
          , l = ap(s, 2)
          , p = ap(s, 3)
          , m = o
          , d = m - i / 2
          , y = m + i / 2
          , g = i / 10
          , f = [];
        if (e.userData.vizProps.showBoxplotOutliers) {
            let T = p - c
              , P = c - 1.5 * T
              , C = p + 1.5 * T;
            a = 1 / 0,
            u = -1 / 0,
            s.forEach(S => {
                P <= S && S < a && (a = S),
                u < S && S <= C && (u = S),
                (S < P || S > C) && f.push([S, m])
            }
            )
        }
        let h = [[c, d, p, d, p, y, c, y, c, d], [l, d, l, y], [c, m, a, m], [p, m, u, m], [a, m - g, a, m + g], [u, m - g, u, m + g]];
        if (e.userData.vizProps && e.userData.vizProps.alignedAxis === "y") {
            for (let T of h)
                for (let P = 0; P < T.length; P += 2) {
                    let C = T[P];
                    T[P] = T[P + 1],
                    T[P + 1] = C
                }
            for (let T of f) {
                let P = T[0];
                T[0] = T[1],
                T[1] = P
            }
        }
        let x = [{
            segments: h,
            graphMode: 5,
            boundingBox: UD("boxplot", h.concat(f)),
            poi: {},
            color: r.color
        }];
        return f.length && x.push({
            segments: [f],
            graphMode: 3,
            color: r.color,
            style: Gc.OPEN,
            showPoint: !0,
            poi: Ai(f)
        }),
        x
    }
    var Qi = 200;
    function pX(e, t, n, r, o) {
        switch (e.type) {
        case "Image":
            return oV(e, n);
        case "Table":
            return xV(e, n);
        case "BoxPlot":
            return CV(e, t, n);
        case "DotPlot":
            return EV(e, t, n);
        case "Histogram":
            return SV(e, t, n);
        case "Regression":
            return uV(e, t, n, r);
        case "DoubleInequality":
            return wF(e, t, n, r)
        }
        return e instanceof bo ? AF(e, t, n, r) : mX(e, t, n, r, o)
    }
    function Ku(e, t, n, r, o, i, s) {
        if (n instanceof O.SolvedEquation) {
            let p = Ku(e, t, n._expression, r, o, i, n.branchMultiplier === 2 ? "solvedEquation" : void 0)
              , m = DD(e, n, r, t);
            return m && (p || (p = []),
            Array.prototype.push.apply(p, m)),
            p
        }
        let a = n.getExpressionType(o.graphMode, n.valueType)
          , u = A0(a, {
            points: e.userData.points,
            lines: e.userData.lines,
            fill: e.userData.fill
        })
          , c = {
            node: e,
            concrete: n,
            reconciledProps: u,
            styleBroadcastStrategy: s,
            viewState: r,
            graphInfo: o,
            policy: t,
            childIntersections: i
        }
          , l = o.graphMode;
        switch (l) {
        case 20:
            return KF(c);
        case 21:
            return eV(c);
        case 17:
        case 18:
        case 19:
            return tV(c);
        case 24:
            return nV(c);
        case 23:
            return rV(c);
        case 16:
            return QF(c);
        case 114:
            return DF(c);
        case 117:
            return _F(c);
        case 119:
            return RF(c);
        case 129:
            return NF(c);
        case 118:
            return OF(c);
        case 26:
        case 4:
            return sV(l, c);
        case 25:
        case 3:
            return aV(l, c);
        case 5:
        case 100:
            return iV(c);
        case 1:
        case 2:
        case 8:
        case 112:
        case 126:
        case 113:
        case 127:
        case 6:
        case 130:
        case 103:
        case 106:
        case 107:
        case 108:
        case 109:
        case 110:
        case 111:
        case 120:
        case 121:
        case 122:
        case 123:
        case 124:
            return jF(l, c);
        case 200:
        case 201:
        case 202:
        case 206:
        case 205:
        case 211:
        case 203:
        case 204:
        case 213:
        case 207:
        case 208:
        case 212:
        case 214:
        case 215:
        case 209:
            return gV(l, c);
        case 210:
            return hV(c);
        case 7:
        case 22:
        case 128:
        case 11:
        case 10:
        case 15:
            return [];
        default:
            let p = l;
            throw new Error(`Unexpected graphMode: ${p}`)
        }
    }
    function vV(e, t, n, r, o) {
        var i, s, a;
        try {
            let u = pX(e, t, n, r, o);
            if (Array.isArray(u))
                for (let c of u) {
                    if (!("compiled"in c))
                        continue;
                    let l = (i = c.compiled) == null ? void 0 : i.executionMetadata;
                    l && (l.recursionTerminationStatus && (c.recursionTerminationStatus = l.recursionTerminationStatus),
                    ((s = l.badCoercionCount) != null ? s : 0) >= 1 && ((a = l.goodCoercionCount) != null ? a : 0) <= 2 && (c.nanBlame = fT.ComplexCoercion))
                }
            return u
        } catch (u) {
            let c = u instanceof O.Error ? u.getError() : F(u).getError();
            return [xF(c)]
        }
    }
    function mX(e, t, n, r, o) {
        let i = co(e, t, n);
        return Ku(e, t, n, r, i, o)
    }
    var $D = class {
        constructor(t, n, r, o) {
            this.openChunk = t;
            this.returnIndex = n;
            this.restrictionIndex = r;
            this.slices = o
        }
        getSliceVariablesOrImplicit() {
            return this.slices.map(t => t.type === "constant" ? t.variable : "_implicit")
        }
        getPeeledSlices() {
            let t = [];
            for (let n of this.slices)
                if (n.type === "constant") {
                    let r = this.openChunk.getInstruction(n.index);
                    if (Ye(r) && r.valueType === b)
                        t.push({
                            type: "constant",
                            variable: n.variable,
                            value: L(r.value)
                        });
                    else if (!(Ye(r) && r.valueType === Y))
                        throw Lu()
                } else if (this.openChunk.getInstruction(n.index).valueType === b) {
                    let o = this.openChunk.copy();
                    o.setReturnIndex(n.index),
                    o.fuseBroadcast(),
                    t.push({
                        type: "implicit",
                        sliceChunk: o
                    })
                } else
                    throw Lu();
            return t
        }
        getValueAndRestrictionChunk() {
            let t = this.getPeeledSlices()
              , n = this.openChunk.copy();
            n.setReturnIndex(this.returnIndex),
            n.fuseBroadcast();
            let r;
            return this.restrictionIndex !== void 0 && (r = this.openChunk.copy(),
            r.setReturnIndex(this.restrictionIndex),
            r.fuseBroadcast()),
            {
                valueChunk: n,
                restrictionChunk: r,
                slices: t
            }
        }
        getSlicesAndRestrictionChunk() {
            let t = this.getPeeledSlices()
              , n = this.openChunk.copy()
              , r = n.GreaterEqual([this.returnIndex, n.Constant(0)]);
            return this.restrictionIndex !== void 0 && (r = n.And([r, this.restrictionIndex])),
            n.setReturnIndex(r),
            n.fuseBroadcast(),
            {
                restrictionChunk: n,
                slices: t
            }
        }
    }
      , OT = class {
        constructor(t, n, r) {
            this.chunk = t;
            this.slices = [];
            this.oldIPToRestriction = [];
            var o, i;
            this.produceNumbers = (o = r == null ? void 0 : r.produceNumbers) != null ? o : !1,
            this.allowSlices = (i = r == null ? void 0 : r.allowSlices) != null ? i : !1,
            this.newChunk = new $u({
                argNames: t.argNames,
                argTypes: t.argTypes
            }),
            this.startTrue = this.produceNumbers ? this.newChunk.Constant(1 / 0) : this.newChunk.ConstantOfType(Fe, !0),
            this.peelable = yX(t),
            this.dependsOnArgs = VD(t),
            this.copyCtx = new zo(t,0,t.instructionsLength() - 1,this.newChunk),
            hX(t, this.peelable, n)
        }
        selectRestriction() {
            return !0
        }
    }
    ;
    function VD(e) {
        let t = [];
        for (let n = 0; n < e.argNames.length; n++)
            t.push(n);
        return qu(e, t, 0, e.getReturnIndex())
    }
    var YD = class extends OT {
        constructor(n, r, o) {
            super(n, r, o);
            this.currSelectIndex = 0;
            this.selectIndex = o.selectIndex
        }
        selectRestriction() {
            let n = this.selectIndex === this.currSelectIndex;
            return this.currSelectIndex++,
            this.produceNumbers ? n : !n
        }
    }
    ;
    function Mc(e, t, n) {
        let r = new OT(e,t,n);
        ZD(r, 0, e.instructionsLength() - 1);
        let o = r.oldIPToRestriction[e.getReturnIndex()];
        return new $D(r.newChunk,r.copyCtx.mapIndex(e.getReturnIndex()),r.startTrue === o ? void 0 : o,r.slices)
    }
    function *JF(e, t, n) {
        var o, i;
        let r = kD(e, n, {
            produceNumbers: !1,
            selectIndex: 0
        });
        if (r === void 0 || r.count <= 1) {
            yield{
                value: t,
                restriction: void 0
            };
            return
        }
        for (let s = 0; s < r.count; s++) {
            let a = (o = kD(e, n, {
                produceNumbers: !0,
                selectIndex: s
            })) == null ? void 0 : o.chunk
              , u = s === 0 ? r.chunk : (i = kD(e, n, {
                produceNumbers: !1,
                selectIndex: s
            })) == null ? void 0 : i.chunk;
            if (!a || !u)
                throw new Error("Programming Error: selectIndex gave invalid chunk.");
            yield{
                value: a,
                restriction: u
            }
        }
    }
    function kD(e, t, n) {
        let r = new YD(e,t,n);
        ZD(r, 0, e.instructionsLength() - 1);
        let o = r.oldIPToRestriction[e.getReturnIndex()];
        if (r.currSelectIndex === 0)
            return;
        let i = r.copyCtx.mapIndex(e.getReturnIndex())
          , s = r.newChunk.getInstruction(i);
        if (s.type !== 29)
            throw new Error("Programming Error: Expected GreaterEqual.");
        let a = r.produceNumbers ? r.newChunk.Subtract([s.args[0], s.args[1]]) : i;
        return r.selectRestriction() && (o = AT(r, [o, a])),
        r.newChunk.setReturnIndex(o),
        {
            chunk: r.newChunk,
            count: r.currSelectIndex
        }
    }
    function ZD(e, t, n) {
        let {chunk: r, newChunk: o, copyCtx: i, peelable: s, oldIPToRestriction: a} = e;
        for (let u = t; u <= n; u++) {
            let c = r.getInstruction(u);
            if (s[u] && (c.type === 19 || c.type === 23)) {
                u = fX(e, u);
                continue
            }
            let l, p;
            if (c.type === 2)
                l = u,
                p = e.startTrue;
            else if (!de(c))
                l = i.copyLeafOrFunctionHeader(c),
                p = e.startTrue;
            else if (s[u] && Ll(r, c) && e.dependsOnArgs[c.args[0]]) {
                l = i.mapIndex(c.args[1]);
                let m = c.args.map(d => a[d]);
                for (let d of bX(e, c))
                    e.selectRestriction() && m.push(d);
                p = AT(e, m)
            } else
                l = o.copyInstructionWithArgs(c, i.mapArgs(c.args)),
                p = AT(e, c.args.map(m => a[m]));
            i.markMappedIndex(u, l),
            a[u] = p
        }
    }
    function AT(e, t) {
        let r = [...new Set(t)].filter(o => !DV(e, o));
        return r.length ? wT(e, r).reduce( (o, i) => e.produceNumbers ? e.newChunk.NativeFunction("listMin", [o, i]) : e.newChunk.And([o, i])) : e.startTrue
    }
    function dX(e, t) {
        let n = [...new Set(t)];
        return n.some(r => !DV(e, r)) ? wT(e, n).reduce( (r, o) => e.produceNumbers ? e.newChunk.NativeFunction("listMax", [r, o]) : e.newChunk.Or([r, o])) : e.startTrue
    }
    function wT(e, t) {
        if (!e.produceNumbers)
            return t;
        let n = e.newChunk;
        return t.map(r => {
            let o = n.getInstruction(r);
            if (o.valueType !== Fe)
                return r;
            switch (o.type) {
            case 27:
            case 29:
                return n.Subtract([o.args[0], o.args[1]]);
            case 26:
            case 28:
                return n.Subtract([o.args[1], o.args[0]]);
            case 25:
                throw F("convertBoolsToNums on an equality.");
            case 32:
                return n.NativeFunction("listMin", wT(e, o.args));
            case 31:
                return n.NativeFunction("listMax", wT(e, o.args));
            case 1:
                return n.Constant(o.value ? 1 / 0 : -1 / 0);
            default:
                throw F("convertBoolsToNums on a non-opcode condition.")
            }
        }
        )
    }
    function DV({newChunk: e}, t) {
        let n = e.getInstruction(t);
        return n.type === 1 && (n.valueType === b && n.value === 1 / 0 || n.valueType === Fe && n.value)
    }
    function fX(e, t) {
        let {chunk: n, newChunk: r, copyCtx: o, oldIPToRestriction: i, startTrue: s} = e, a = n.getInstruction(t), u = a.endIndex, c = n.getInstruction(u), l, p;
        if (a.type === 23) {
            let f = r.copyInstructionWithArgs(a, [o.mapIndex(a.args[0])]);
            o.markMappedIndex(t, f),
            i[t] = s,
            p = t + 1
        } else {
            let f = o.mapArgs(a.args);
            f.push(s);
            let h = r.copyInstructionWithArgs(a, f);
            i[t] = s,
            o.markMappedIndex(t, h);
            for (let x = 2; x < a.args.length; x++) {
                let T = t + x - 1
                  , P = r.copyInstructionWithArgs(n.getInstruction(T), [o.mapIndex(T)]);
                i[T] = s,
                o.markMappedIndex(T, P)
            }
            l = r.BlockVar(e.produceNumbers ? b : Fe, [o.mapIndex(t)]),
            p = t + a.args.length - 1
        }
        ZD(e, p, u - 1);
        let m = o.mapArgs(c.args)
          , d = e.slices.filter(f => p <= f.index && f.index < u)
          , y = l;
        if (a.type === 19) {
            if (l === void 0)
                throw new Error("Expected restrictionAccumVar to be defined");
            y = AT(e, [l, i[c.args[1]]]),
            m.push(y)
        } else {
            m.push(i[c.args[1]]);
            for (let f of d)
                m.push(f.index)
        }
        let g = r.copyInstructionWithArgs(c, m);
        i[u] = s,
        o.markMappedIndex(u, g);
        for (let f = 1; f < c.args.length; f++) {
            let h = r.copyInstructionWithArgs(n.getInstruction(u + f), [o.mapIndex(u)]);
            o.markMappedIndex(u + f, h)
        }
        if (a.type === 23) {
            let f = r.BroadcastResult(e.produceNumbers ? Y : yi, [o.mapIndex(u)]);
            for (let h of d)
                h.index = r.BroadcastResult(Y, [o.mapIndex(u)]);
            for (let h = 1; h < c.args.length; h++)
                i[u + h] = f
        } else {
            let f = r.BlockVar(e.produceNumbers ? b : Fe, [o.mapIndex(u)]);
            l === y && (f = s);
            for (let h = 1; h < c.args.length; h++)
                i[u + h] = f
        }
        return u + c.args.length - 1
    }
    function yX(e) {
        let t = [];
        for (let r = 0; r < e.instructionsLength(); r++)
            t.push(!1);
        t[e.getReturnIndex()] = !0;
        let n = e.instructionsLength() - 1;
        for (let r = n; r >= 0; r--) {
            if (!t[r])
                continue;
            let o = e.getInstruction(r);
            if (de(o))
                for (let i of gX(e, o))
                    t[i] = !0
        }
        return t
    }
    function gX(e, t) {
        switch (t.type) {
        case 14:
        case 56:
        case 8:
        case 9:
        case 26:
        case 28:
        case 27:
        case 29:
        case 10:
        case 11:
        case 12:
        case 13:
        case 25:
        case 32:
        case 15:
        case 38:
        case 47:
        case 19:
        case 39:
        case 40:
        case 41:
        case 23:
        case 24:
        case 48:
        case 50:
            return t.args;
        case 33:
            return Ll(e, t) ? OD(e, t).concat([t.args[1]]) : [];
        case 37:
            {
                let r = ir[t.symbol];
                return r.noPeel ? [] : r.tag === "reducer" || r.tag === "doubleReducer" || r.tag === "never-broadcast" || r.tag === "parameterizedReducer" ? t.args.filter(o => e.getInstruction(o).type !== 48) : t.args
            }
        case 20:
            return t.args.slice(1);
        case 51:
            return [t.args[1]];
        case 31:
            return [];
        case 16:
        case 42:
        case 21:
        case 22:
        case 44:
        case 49:
        case 53:
        case 54:
        case 55:
            return [];
        default:
            let n = t;
            throw new Error(`Unexpected opcode ${n.type}`)
        }
    }
    function hX(e, t, n) {
        let r = [];
        for (let o = 0; o < e.argNames.length; o++) {
            let i = e.argNames[o];
            n.indexOf(i) < 0 && r.push(o)
        }
        for (let o of r) {
            let i = yl(e, o);
            for (let s = 0; s < e.instructionsLength(); s++)
                t[o] && (t[o] = !i[s])
        }
    }
    function bX(e, t) {
        let n = OD(e.chunk, t)
          , r = e.copyCtx.mapArgs(n);
        if (e.allowSlices && r.length === 1) {
            let o = BF(e.newChunk, r[0]);
            if (o)
                return e.slices.push(o),
                []
        }
        if (r.some(o => VF(e.newChunk, o)))
            throw Lu();
        if (r.length === 1) {
            let o = r[0];
            return [...ET(e.newChunk, o)]
        }
        return [dX(e, r)]
    }
    function ST(e) {
        let t = {
            value: [],
            error: "unhandled restriction"
        }
          , n = {
            value: [],
            error: BD
        }
          , r = e.getInstruction(e.getReturnIndex());
        if (r.type == 1) {
            if (r.valueType === lr)
                return {
                    value: NT([r.value])
                };
            if (r.valueType === Zo)
                return {
                    value: NT(r.value)
                }
        }
        if (r.type === 33 && r.valueType === lr) {
            let y = e.copy()
              , g = MV(y, r);
            if (g === void 0)
                return t;
            let f = e.getInstruction(g);
            if (f.type === 1 && f.valueType === lr) {
                let h = as(y, Qi);
                return {
                    value: NT([f.value]),
                    restriction: h
                }
            }
        }
        if (r.type !== 48)
            return t;
        let o = e.getInstruction(r.args[0]);
        if (o.type !== 24)
            return t;
        let i = e.getInstruction(o.args[1]);
        if (i.type !== 33)
            return t;
        let s = xX(e)
          , a = e.copy()
          , u = MV(a, i, s);
        if (u === void 0)
            return n;
        let c = e.getInstruction(u);
        if (c.type !== 41)
            return t;
        if (s[i.args[0]])
            return n;
        let p = e.getInstruction(c.args[0]);
        if (p.type !== 1 || p.valueType !== Zo)
            return t;
        let m = NT(p.value)
          , d = as(a, Qi);
        return {
            value: m,
            restriction: d
        }
    }
    function xX(e) {
        let t = [];
        for (let n = 0; n < e.getReturnIndex(); n++)
            e.getInstruction(n).type === 23 && t.push(n);
        return qu(e, t, 0, e.getReturnIndex() - 1)
    }
    var BD = "restriction list on triangles";
    function NT(e) {
        return e.map(t => {
            let n = t[0].map(i => L(i))
              , r = t[1].map(i => L(i))
              , o = t[2].map(i => L(i));
            return [n, r, o]
        }
        )
    }
    function MV(e, t, n) {
        let r = t.args[0]
          , o = t.args[1];
        if (!(n && n[r])) {
            for (; e.getInstruction(o).type === 33; ) {
                if (t = e.getInstruction(o),
                n && n[t.args[0]])
                    return;
                r = e.And([r, t.args[0]]),
                o = t.args[1]
            }
            return e.setReturnIndex(r),
            o
        }
    }
    function _V(e, t) {
        let n = []
          , r = [];
        for (let a = 0; a < e.argNames.length; a++)
            t.hasOwnProperty(e.argNames[a]) || (n.push(e.argNames[a]),
            r.push(e.argTypes[a]));
        let o = new $u({
            argNames: n,
            argTypes: r
        })
          , i = new zo(e,0,e.instructionsLength() - 1,o)
          , s = 0;
        return i.copyUntilEnd( (a, u, c) => {
            if (c < e.argNames.length) {
                if (t.hasOwnProperty(e.argNames[c]))
                    return a.ConstantOfType(e.argTypes[c], t[e.argNames[c]]);
                {
                    let l = s;
                    return s += 1,
                    l
                }
            }
            if (de(u)) {
                let l = i.mapArgs(u.args);
                return a.copyInstructionWithArgs(u, l)
            } else
                return i.copyLeafOrFunctionHeader(u)
        }
        ),
        o
    }
    var LT = class e {
        constructor() {
            this.maps = {
                real: {},
                complexOne: {},
                complexI: {}
            }
        }
        clone() {
            let t = new e;
            return t.maps = Vi(this.maps),
            t
        }
        pruneIP(t) {
            for (let n of Object.values(this.maps))
                delete n[t]
        }
        truncate(t) {
            for (let n of Object.values(this.maps))
                for (let r in n) {
                    let o = +r;
                    o >= t ? delete n[o] : TX(n[o], t)
                }
        }
        getMapEntry(t, n, r) {
            let o = this.maps[n]
              , i = o[r];
            if (i)
                return i;
            let s = {
                maxValidReference: t.instructionsLength() - 1,
                map: []
            };
            return o[r] = s,
            s
        }
        _cachedDerivativesForTests() {
            let t = [];
            for (let[n,r] of Object.entries(this.maps))
                for (let o in r)
                    t.push(`${o} ${n}`);
            return t.sort(),
            t
        }
    }
    ;
    function TX(e, t) {
        e.map.length = Math.min(e.map.length, t),
        e.maxValidReference = Math.min(e.maxValidReference, t - 1)
    }
    var IX = {
        "+": !0,
        "-": !0,
        "*": !0,
        "\\cdot": !0,
        "\\times": !0,
        "/": !0,
        "!": !0,
        "(": !0,
        ")": !0,
        "\\{": !0,
        "\\}": !0,
        "(|": !0,
        "|)": !0,
        "[": !0,
        "]": !0,
        ",": !0,
        "...": !0,
        ":": !0,
        "=": !0,
        ">": !0,
        "<": !0,
        ">=": !0,
        "<=": !0,
        "->": !0,
        "~": !0,
        "%": !0,
        ".": !0,
        for: !0,
        with: !0,
        Letter: !0,
        Decimal: !0,
        Cmd: !0,
        TokenNode: !0,
        Differential: !0,
        End: !0,
        Trig: !0,
        Ln: !0,
        Log: !0,
        Int: !0,
        Sum: !0,
        Prod: !0,
        Err: !0
    };
    function Bfe(e) {
        let t = Dc[e];
        if (!t)
            return !0;
        switch (t) {
        case "Ln":
        case "Log":
        case "for":
        case "with":
        case "Trig":
            return !0;
        default:
            return !1
        }
    }
    var Dc = {
        "\\lt": "<",
        "\\gt": ">",
        "\\le": "<=",
        "\\ge": ">=",
        "\\leq": "<=",
        "\\geq": ">=",
        "\\ldots": "...",
        "\\sim": "~",
        "\\to": "->",
        "\\cdot": "\\cdot",
        "\\times": "\\times",
        "\\div": "/",
        "\\ln": "Ln",
        "\\log": "Log",
        "\\int": "Int",
        "\\sum": "Sum",
        "\\prod": "Prod",
        "\\backslash": "Err",
        "\\for": "for",
        "\\with": "with"
    }
      , PX = ["sin", "cos", "tan", "cot", "sec", "csc"];
    for (let e of PX)
        Dc["\\" + e] = "Trig",
        Dc["\\" + e + "h"] = "Trig",
        Dc["\\arc" + e] = "Trig",
        Dc["\\arc" + e + "h"] = "Trig",
        Dc["\\ar" + e + "h"] = "Trig";
    function Gfe(e) {
        return e === "\\log" || e === "\\prod" || e === "\\sum" || e === "\\int"
    }
    var XD = {
        "+": "+",
        "-": "-",
        "*": "*",
        "/": "/",
        "!": "!",
        "(": "(",
        ")": ")",
        "[": "[",
        "]": "]",
        ",": ",",
        "...": "...",
        ":": ":",
        "=": "=",
        ">=": ">=",
        "<=": "<=",
        ">": ">",
        "<": "<",
        "~": "~",
        ".": "."
    }
      , RV = {
        "\\{": "\\{",
        "\\}": "\\}",
        "\\%": "%"
    }
      , NV = {
        "|": "(|",
        "\\{": "\\{",
        "[": "[",
        "(": "("
    }
      , OV = {
        "|": "|)",
        "\\}": "\\}",
        "]": "]",
        ")": ")"
    }
      , AV = Object.keys(IX);
    function wV(e) {
        return 48 <= e && e <= 57
    }
    function SX(e) {
        return 97 <= e && e <= 122
    }
    function EX(e) {
        return 65 <= e && e <= 90
    }
    function FT(e) {
        return SX(e) || EX(e)
    }
    function VT(e) {
        return e === 92
    }
    function WD(e) {
        return e === 39
    }
    function LV(e) {
        if (9 <= e && e <= 13 || 8192 <= e && e <= 8202)
            return !0;
        switch (e) {
        case 32:
        case 160:
        case 5760:
        case 8232:
        case 8233:
        case 8239:
        case 8287:
        case 12288:
        case 65279:
            return !0;
        default:
            return !1
        }
    }
    var CX = {
        mcd: "gcd",
        gcf: "gcd",
        mcm: "lcm",
        signum: "sign",
        sgn: "sign",
        stdDevP: "stdevp",
        stddevp: "stdevp",
        stdDev: "stdev",
        stddev: "stdev",
        variance: "var",
        TScore: "tscore",
        inverseCdf: "quantile",
        inversecdf: "quantile",
        arsinh: "arcsinh",
        arcosh: "arccosh",
        artanh: "arctanh",
        arcsch: "arccsch",
        arsech: "arcsech",
        arcoth: "arccoth"
    };
    function FV(e) {
        let t = 0;
        for (; VT(e.charCodeAt(t)); )
            t += 1;
        return t > 0 && (e = e.slice(t)),
        CX[e] || e
    }
    function VV(e, t, n) {
        return {
            type: "Comparator",
            span: e,
            symbol: t,
            args: n
        }
    }
    function BV(e, t, n) {
        if (t.length < 1)
            throw "Programming Error: ComparatorChain must have at least one comparator.";
        if (n.length !== t.length + 1)
            throw "Programming Error: ComparatorChain must have one more arg than symbols";
        return {
            type: "ComparatorChain",
            span: e,
            args: n,
            symbols: t
        }
    }
    function GV(e, t) {
        return {
            type: "Tilde",
            span: e,
            args: t
        }
    }
    function qV(e, t) {
        return {
            type: "Pos",
            span: e,
            args: t
        }
    }
    function zV(e, t) {
        return {
            type: "Neg",
            span: e,
            args: t
        }
    }
    function HV(e, t) {
        return {
            type: "Add",
            span: e,
            args: t
        }
    }
    function UV(e, t) {
        return {
            type: "Sub",
            span: e,
            args: t
        }
    }
    function kV(e, t) {
        return {
            type: "Mul",
            span: e,
            args: t
        }
    }
    function $V(e, t) {
        return {
            type: "DotMul",
            span: e,
            args: t
        }
    }
    function YV(e, t) {
        return {
            type: "CrossMul",
            span: e,
            args: t
        }
    }
    function ZV(e, t) {
        return {
            type: "Div",
            span: e,
            args: t
        }
    }
    function XV(e, t) {
        return {
            type: "Bang",
            span: e,
            args: t
        }
    }
    function ag(e, t) {
        return {
            type: "Call",
            span: e,
            args: t
        }
    }
    function jD(e, t) {
        return {
            type: "ImplicitCall",
            span: e,
            args: t
        }
    }
    function WV(e, t) {
        return {
            type: "Index",
            span: e,
            args: t
        }
    }
    function JD(e, t) {
        return {
            type: "Paren",
            span: e,
            args: t
        }
    }
    function QD(e, t) {
        return {
            type: "List",
            span: e,
            args: t
        }
    }
    function jV(e, t) {
        return {
            type: "Pipes",
            span: e,
            args: t
        }
    }
    function KD(e, t) {
        return {
            type: "Subscript",
            span: e,
            args: t
        }
    }
    function BT(e, t) {
        return {
            type: "Superscript",
            span: e,
            args: t
        }
    }
    function ug(e, t, n) {
        return {
            type: "Prime",
            span: e,
            nprimes: t,
            args: n
        }
    }
    function GT(e, t) {
        return {
            type: "Seq",
            span: e,
            args: t
        }
    }
    function JV(e, t) {
        return {
            type: "Sqrt",
            span: e,
            args: t
        }
    }
    function QV(e, t) {
        return {
            type: "Nthroot",
            span: e,
            args: t
        }
    }
    function KV(e, t) {
        return {
            type: "Frac",
            span: e,
            args: t
        }
    }
    function eB(e, t) {
        return {
            type: "Derivative",
            span: e,
            args: t
        }
    }
    function tB(e, t) {
        return {
            type: "Integral",
            span: e,
            args: t
        }
    }
    function nB(e, t) {
        return {
            type: "EmptyIntegral",
            span: e,
            args: t
        }
    }
    function rB(e, t) {
        return {
            type: "Sum",
            span: e,
            args: t
        }
    }
    function oB(e, t) {
        return {
            type: "Product",
            span: e,
            args: t
        }
    }
    function iB(e, t) {
        return {
            type: "Piecewise",
            span: e,
            args: t
        }
    }
    function sB(e) {
        return {
            type: "EmptyPiecewise",
            span: e
        }
    }
    function aB(e) {
        return {
            type: "EmptyRangeEnd",
            span: e
        }
    }
    function uB(e, t) {
        return {
            type: "Colon",
            span: e,
            args: t
        }
    }
    function e_(e, t) {
        return {
            type: "Ellipsis",
            span: e,
            args: t
        }
    }
    function cB(e, t) {
        return {
            type: "For",
            span: e,
            args: t
        }
    }
    function lB(e, t) {
        return {
            type: "With",
            span: e,
            args: t
        }
    }
    function pB(e, t) {
        return {
            type: "Dot",
            span: e,
            args: t
        }
    }
    function mB(e, t) {
        return {
            type: "PercentOf",
            span: e,
            args: t
        }
    }
    function dB(e, t) {
        return {
            type: "RightArrow",
            span: e,
            args: t
        }
    }
    function t_(e, t) {
        return {
            type: "Juxt",
            span: e,
            args: t
        }
    }
    function fB(e, t) {
        return {
            type: "Letter",
            span: e,
            val: t
        }
    }
    function qT(e, t) {
        return {
            type: "Decimal",
            span: e,
            val: t
        }
    }
    function Zp(e, t) {
        return {
            type: "Cmd",
            span: e,
            val: FV(t)
        }
    }
    function yB(e, t) {
        return {
            type: "Alphanumeric",
            span: e,
            val: t
        }
    }
    function gB(e, t, n, r) {
        return {
            type: "MixedNumber",
            span: e,
            whole: t,
            num: n,
            den: r
        }
    }
    function Sr(e) {
        if (e.type === "Subscript") {
            if (e.args[1].type !== "Alphanumeric")
                return !1;
            e = e.args[0]
        }
        switch (e.type) {
        case "Cmd":
            return !0;
        case "Letter":
            return !0;
        default:
            return !1
        }
    }
    function hB(e) {
        return e.type !== "Superscript" ? !1 : Sr(e.args[0])
    }
    function bB(e, t) {
        if (e.type !== "Letter" || e.val !== "d" || t.type !== "Juxt")
            return !1;
        let[n,r] = t.args;
        return n.type !== "Letter" || n.val !== "d" ? !1 : Sr(r)
    }
    function Ro(e) {
        return e.type === "Seq" ? e.args : [e]
    }
    function xB(e, t, n, r, o, i, s, a) {
        return {
            opts: e,
            input: t,
            prevSpan: n,
            startIndex: r,
            endIndex: o,
            token: i,
            mode: s,
            parent: a
        }
    }
    function ve(e, t) {
        return vi(e.token.span, t.prevSpan)
    }
    function Er(e, t) {
        return vi(e, t.prevSpan)
    }
    function r_(e) {
        return Va(e.token.span.input, e.token.span.start)
    }
    function MX(e, t) {
        return {
            type: "Differential",
            span: e,
            val: t
        }
    }
    function pi(e, t, n) {
        return {
            type: e,
            span: t,
            val: n
        }
    }
    function _c(e, t) {
        let n = Va(e.span.input, e.span.start);
        return o_(t, e, 0, n, void 0, void 0)
    }
    function o_(e, t, n, r, o, i) {
        let s = t.args;
        if (n > s.length && i)
            return TB(i, r);
        n = cg(s, n);
        let {token: a, endIndex: u} = IB(t, n, o);
        if (a.type === "End" && i) {
            let c = i.input.args[i.startIndex];
            if (c.type === "LeftRight") {
                let l = c.right
                  , p = OV[l.val] || "Err"
                  , m = pi(p, l.span, l.val);
                return xB(e, t, r, n, u, m, o, i)
            }
        } else
            a.type === "Int" ? o = DX(o) : a.type === "Differential" && (o = _X(o));
        return xB(e, t, r, n, u, a, o, i)
    }
    function Ze(e) {
        let t = e.input.args[e.startIndex]
          , n = e.token.span;
        return t && t.type === "LeftRight" ? o_(e.opts, t.arg, 0, n, e.mode, e) : TB(e, n)
    }
    function TB(e, t) {
        let {input: n, endIndex: r, mode: o, parent: i} = e;
        return o_(e.opts, n, r + 1, t, o, i)
    }
    function No(e) {
        return e.token
    }
    function DX(e) {
        return {
            type: "integral",
            parent: e
        }
    }
    function _X(e) {
        if (!e || e.type !== "integral")
            throw new Error("Programming Error: expected lexer to be in integral mode.");
        return e.parent
    }
    function po(e, t) {
        return No(e).type === t
    }
    function UT(e) {
        if (e.startIndex < e.input.args.length)
            return !1;
        let t = e.parent;
        return !(t && t.input.args[t.startIndex].type === "LeftRight" && e.startIndex === e.input.args.length)
    }
    function i_(e, t) {
        return t.token.span.start > e.token.span.start
    }
    function Hr(e, t) {
        return {
            token: t,
            endIndex: e
        }
    }
    function IB(e, t, n) {
        let r = e.args;
        if (t >= r.length) {
            let i = Va(e.span.input, e.span.end);
            return Hr(t, pi("End", i, ""))
        }
        let o = e.args[t];
        switch (o.type) {
        case "Sqrt":
        case "Frac":
        case "SupSub":
            return Hr(t, o);
        case "Letter":
            {
                if (!n || n.type !== "integral" || o.val != "d")
                    return Hr(t, o);
                let {endIndex: c, token: l} = IB(e, t + 1, n);
                if (l.type === "Letter" || l.type === "Cmd") {
                    let p = MX(vi(o.span, l.span), l.val);
                    return Hr(c, p)
                } else
                    return Hr(t, o)
            }
        case "LeftRight":
            {
                let c = o.left
                  , l = NV[c.val] || "Err"
                  , p = vi(o.span, c.span);
                return Hr(t, pi(l, p, c.val))
            }
        case "OperatorName":
            let i = [];
            for (let c of o.arg.args) {
                if (c.type !== "Letter")
                    return Hr(t, pi("Err", o.span, Ir(o.arg.span)));
                i.push(c.val)
            }
            let s = "\\" + i.join("")
              , a = Dc[s] || "Cmd";
            return Hr(t, pi(a, o.span, s));
        case "TokenNode":
            {
                let c = "$";
                if (o.arg.args.length === 0)
                    return Hr(t, pi("Err", o.span, Ir(o.arg.span)));
                for (let l of o.arg.args) {
                    if (l.type !== "Digit")
                        return Hr(t, pi("Err", o.span, Ir(o.arg.span)));
                    c += l.val
                }
                return Hr(t, pi("TokenNode", o.span, c))
            }
        case "Cmd":
            {
                let c = Dc[o.val] || "Cmd";
                return Hr(t, pi(c, o.span, o.val))
            }
        case "EscapedSymbol":
            {
                let c = RV[o.val] || "Err";
                return Hr(t, pi(c, o.span, o.val))
            }
        case "Symbol":
            return RX(e, t, o);
        case "Digit":
            return PB(e, t);
        default:
            throw `Unexpected atom ${o.type}.`
        }
    }
    function RX(e, t, n) {
        switch (n.val) {
        case ".":
            return NX(e, t);
        case "-":
            {
                let o = e.args[t + 1];
                if (o && zT(o, ">")) {
                    let i = pi("->", vi(n.span, o.span), "->");
                    return Hr(t + 1, i)
                }
                break
            }
        case "<":
            {
                let o = e.args[t + 1];
                if (o && zT(o, "=")) {
                    let i = pi("<=", vi(n.span, o.span), "<=");
                    return Hr(t + 1, i)
                }
                break
            }
        case ">":
            {
                let o = e.args[t + 1];
                if (o && zT(o, "=")) {
                    let i = pi(">=", vi(n.span, o.span), ">=");
                    return Hr(t + 1, i)
                }
                break
            }
        }
        let r = XD[n.val] || "Err";
        return Hr(t, pi(r, n.span, n.val))
    }
    function NX(e, t) {
        let n = e.args[t];
        if (n.type !== "Symbol" || n.val !== ".")
            throw new Error("Programming Error: expected '.'");
        if (t + 2 < e.args.length && HT(e.args[t + 1]) && HT(e.args[t + 2])) {
            let i = vi(n.span, e.args[t + 2].span);
            return Hr(t + 2, pi("...", i, Ir(i)))
        }
        let r = cg(e.args, t + 1);
        if (r < e.args.length && e.args[r].type === "Digit")
            return PB(e, t);
        let o = XD[n.val] || "Err";
        return Hr(t, pi(o, n.span, n.val))
    }
    function PB(e, t) {
        let n = OX(e, t);
        if (n)
            return n;
        let r = e.args
          , o = e.args[t].span
          , i = []
          , s = !1
          , a = !1;
        for (; t < r.length; t++) {
            let c = cg(r, t);
            if (c >= r.length)
                break;
            let l = r[c];
            if (l.type === "Digit")
                t = c,
                s = !0,
                i.push(l.val);
            else if (!a && HT(l)) {
                if (c + 1 < r.length && HT(e.args[c + 1]))
                    break;
                t = c,
                a = !0,
                i.push(".")
            } else
                break
        }
        if (!s)
            throw new Error("Programming Error: decimals must have at least one digit.");
        let u = vi(o, e.args[t - 1].span);
        return Hr(t - 1, pi("Decimal", u, i.join("")))
    }
    function OX(e, t) {
        let n = e.args
          , r = n[t].span
          , o = [];
        for (; t < n.length; t++) {
            let c = cg(n, t);
            if (c >= n.length)
                break;
            let l = n[c];
            if (l.type !== "Digit")
                break;
            t = c,
            o.push(l.val)
        }
        if (t = cg(n, t),
        t >= n.length)
            return;
        let i = n[t];
        if (i.type !== "Frac")
            return;
        let s = []
          , a = [];
        for (let c of i.num.args)
            if (!n_(c)) {
                if (c.type !== "Digit")
                    return;
                s.push(c.val)
            }
        for (let c of i.den.args)
            if (!n_(c)) {
                if (c.type !== "Digit")
                    return;
                a.push(c.val)
            }
        let u = vi(r, i.span);
        return Hr(t, gB(u, o.join(""), s.join(""), a.join("")))
    }
    function n_(e) {
        switch (e.type) {
        case "Sqrt":
        case "Frac":
        case "SupSub":
        case "LeftRight":
        case "OperatorName":
        case "TokenNode":
        case "Symbol":
        case "Letter":
        case "Digit":
            return !1;
        case "Cmd":
            return e.val === "\\space";
        case "EscapedSymbol":
            return e.val === "\\ " || e.val === "\\:" || e.val === "\\," || e.val === "\\;";
        default:
            throw `Unexpected atom ${e.type}.`
        }
    }
    function cg(e, t) {
        for (; t < e.length && n_(e[t]); )
            t += 1;
        return t
    }
    function HT(e) {
        return zT(e, ".")
    }
    function zT(e, t) {
        return e.type === "Symbol" && e.val === t
    }
    var Yd = {}
      , AX = ["sin", "cos", "tan", "cot", "sec", "csc", "sinh", "cosh", "tanh", "coth", "sech", "csch"];
    AX.forEach(e => {
        Yd[e] = "arc" + e,
        Yd["arc" + e] = e
    }
    );
    var wX = 0;
    function _B(e, t) {
        return LX(e, t)
    }
    function yt(e, t) {
        let n = [];
        for (let r = 0; r < t.length; r++)
            n.push(wn(e, t[r]));
        return n
    }
    function SB(e, t, n) {
        let r = e.nodes
          , [o,i] = yt(e, t);
        if (YT(n)) {
            let s = Va(n.span.input, n.span.end)
              , a = e.setInput(wB(e), s);
            i = e.setInput(new r.SeededFunctionCall(i,[a]), n.span)
        }
        return [o, i]
    }
    function LX(e, t) {
        return e.setInput(FX(e, t), t.span)
    }
    function RB(e) {
        if (e.type !== "Call")
            return;
        let[t,n] = e.args
          , r = Ro(n);
        if (Sr(t) && r.every(Sr))
            return {
                base: t,
                args: r
            }
    }
    function eye(e) {
        return RB(e) !== void 0
    }
    function NB(e) {
        if (e.type !== "Call")
            return !1;
        let[t,n] = e.args;
        return Sr(t)
    }
    function u_(e) {
        return Sr(e)
    }
    function FX(e, t) {
        let n = e.nodes;
        switch (t.type) {
        case "Comparator":
            if (t.symbol === "=") {
                let[r,o] = t.args
                  , i = RB(r);
                if (i) {
                    let {base: s, args: a} = i
                      , u = yt(e, a)
                      , c = e;
                    if (e.includeFunctionParametersInRandomSeed)
                        for (let p of u)
                            c = mg(c, {
                                prefix: "fc",
                                expr: p
                            });
                    let l = wn(c, o);
                    return new n.FunctionDefinition(wn(e, s),u,l)
                } else {
                    if (r.type === "Call" && Sr(r.args[0]))
                        return new n.CallAssignment(wn(e, r),wn(e, o));
                    if (u_(r)) {
                        let s;
                        return o.type === "For" ? s = e.setInput(kT(e, o, {
                            parentIsList: !1
                        }), o.span) : s = wn(e, o),
                        new n.Assignment(wn(e, r),s)
                    }
                }
                return new n.Equation(wn(e, r),wn(e, o))
            } else
                return tc(e, t);
        case "Tilde":
            {
                let[r,o] = yt(e, t.args);
                return new n.Regression(r,o)
            }
        case "ComparatorChain":
            {
                if (!e.specializeDoubleInequalities || t.symbols.length !== 2)
                    return tc(e, t);
                let[r,o,i] = t.args
                  , [s,a] = t.symbols;
                return !Sr(o) || t.symbols.includes("=") ? tc(e, t) : new n.DoubleInequality([wn(e, r), s, wn(e, o), a, wn(e, i)])
            }
        case "Call":
            {
                let[r,o] = t.args;
                if (r.type === "Cmd")
                    switch (r.val) {
                    case "histogram":
                        return new n.Histogram(yt(e, Ro(o)));
                    case "dotplot":
                        return new n.DotPlot(yt(e, Ro(o)));
                    case "boxplot":
                        return new n.BoxPlot(yt(e, Ro(o)));
                    case "stats":
                        return new n.Stats(yt(e, Ro(o)));
                    default:
                        return lg(e, t)
                    }
                return lg(e, t)
            }
        case "For":
            return kT(e, t, {
                parentIsList: !1
            });
        default:
            return lg(e, t)
        }
    }
    function OB(e) {
        if (e.type !== "Paren")
            return !1;
        let[t] = e.args;
        return t.type !== "Seq" ? !1 : t.args.length === 2 || t.args.length === 3
    }
    function EB(e, t, n, r) {
        let o = VX(e, n, r);
        if (o !== void 0)
            return e.setInput(o, vi(t.args[0].span, r.span))
    }
    function VX(e, t, n) {
        let r = e.nodes;
        if (n.type === "Letter")
            switch (n.val) {
            case "x":
            case "y":
            case "z":
            case "p":
                return new r.NamedCoordinateAccess(n.val,[t])
            }
        else if (n.type === "Cmd")
            switch (n.val) {
            case "real":
            case "imag":
                throw sE(n.val)
            }
    }
    function wn(e, t) {
        return e.setInput(lg(e, t), t.span)
    }
    function lg(e, t) {
        let n = e.nodes;
        switch (t.type) {
        case "Pos":
            return wn(e, t.args[0]);
        case "Neg":
            let r = -1
              , o = t.args[0];
            for (; ; )
                if (o.type === "Pos" || o.type === "Paren" && !OB(o))
                    o = o.args[0];
                else if (o.type === "Neg")
                    o = o.args[0],
                    r *= -1;
                else
                    break;
            switch (o.type) {
            case "Decimal":
                {
                    let s = MB(o);
                    return new n.Constant(r === -1 ? Ii(s) : s)
                }
            case "MixedNumber":
                {
                    let s = DB(o);
                    return new n.MixedNumber(r === -1 ? Ii(s) : s)
                }
            default:
                return r === -1 ? new n.Negative([wn(e, o)]) : wn(e, o)
            }
        case "Add":
            return new n.Add(yt(e, t.args));
        case "Sub":
            return new n.Subtract(yt(e, t.args));
        case "Mul":
            return new n.Multiply(yt(e, t.args));
        case "DotMul":
            return new n.DotMultiply(yt(e, t.args));
        case "CrossMul":
            return new n.CrossMultiply(yt(e, t.args));
        case "Div":
            return new n.Divide(yt(e, t.args));
        case "Bang":
            {
                let[s] = t.args;
                return s.type === "Call" && Sr(s.args[0]) && !YT(s.args[0]) && Ro(s.args[1]).length === 1 ? new n.FunctionFactorial(yt(e, s.args)) : new n.FunctionCall("\\factorial",yt(e, t.args))
            }
        case "PercentOf":
            return new n.PercentOf(yt(e, t.args));
        case "Call":
            return CB(e, t);
        case "ImplicitCall":
            return UX(t),
            CB(e, t);
        case "Dot":
            {
                let s = t.args[1]
                  , [a,u] = SB(e, t.args, s);
                if (s.type === "Letter")
                    switch (s.val) {
                    case "x":
                    case "y":
                    case "z":
                    case "p":
                        return new n.NamedCoordinateAccess(s.val,[a]);
                    default:
                        break
                    }
                else if (s.type === "Call") {
                    let c = s.args[0]
                      , l = EB(e, t, a, c);
                    if (l !== void 0)
                        return new n.Multiply([l, wn(e, s.args[1])])
                }
                return new n.DotAccess([a, u])
            }
        case "Prime":
            {
                let[s] = t.args;
                if (s.type === "Call") {
                    let[a,u] = s.args
                      , c = Ro(u).length;
                    if (a.type === "Cmd" && a.val === "logbase") {
                        if (c !== 2)
                            throw bp()
                    } else if (c !== 1)
                        throw bp();
                    return new n.Prime(t.nprimes,yt(e, t.args))
                } else
                    throw s.type === "ImplicitCall" ? gb() : yb()
            }
        case "Index":
            {
                let[s,a] = t.args;
                if (a.type === "Seq")
                    return new n.ListAccess([wn(e, s), e.setInput(new n.List(yt(e, a.args)), void 0)]);
                if (a.type === "Ellipsis") {
                    let[u,c] = a.args;
                    return new n.ListAccess([wn(e, s), e.setInput(new n.Range([e.setInput(new n.List(yt(e, Ro(u))), void 0), e.setInput(new n.List(c.type === "EmptyRangeEnd" ? [] : yt(e, Ro(c))), void 0)]), void 0)])
                }
                return pg(a) ? new n.ListAccess([wn(e, s), e.setInput(tc(e, a), void 0)]) : new n.ListAccess(yt(e, t.args))
            }
        case "Paren":
            {
                let[s] = t.args;
                if (s.type === "Seq") {
                    if (s.args.length === 0)
                        throw oy();
                    return new n.ParenSeq(yt(e, s.args))
                } else
                    return wn(e, s)
            }
        case "List":
            {
                if (t.args.length === 0)
                    return new n.List([]);
                let s = t.args[0];
                if (s.type === "Ellipsis") {
                    let[a,u] = s.args;
                    return new n.Range([e.setInput(new n.List(yt(e, Ro(a))), void 0), e.setInput(new n.List(yt(e, Ro(u))), void 0)])
                } else if (s.type === "For")
                    return kT(e, s, {
                        parentIsList: !0
                    });
                return new n.List(yt(e, Ro(s)))
            }
        case "Pipes":
            {
                let[s] = t.args;
                return new n.Norm([wn(e, s)])
            }
        case "Subscript":
            {
                let[s,a] = t.args;
                if (a.val.length === 0)
                    throw fb();
                let u;
                switch (s.type) {
                case "Letter":
                    u = s.val;
                    break;
                case "Cmd":
                    u = s.val;
                    break;
                default:
                    throw hC()
                }
                if (u === "ans")
                    throw Mi("ans");
                return new n.Identifier(`${u}_${a.val}`)
            }
        case "Superscript":
            {
                let[s,a] = t.args;
                if (s.type === "Call" && s.args[1].type !== "Seq" && !YT(s.args[0]) && !kX(s))
                    return new n.FunctionExponent(yt(e, [s.args[0], s.args[1], a]));
                if (s.type === "Dot") {
                    let u = s.args[1]
                      , [c,l] = SB(e, s.args, u)
                      , p = wn(e, a);
                    if (u.type === "Letter")
                        switch (u.val) {
                        case "x":
                        case "y":
                        case "z":
                            return new n.Exponent([e.setInput(new n.NamedCoordinateAccess(u.val,[c]), s.span), p]);
                        default:
                            break
                        }
                    else if (u.type === "Call") {
                        let m = u.args[0]
                          , d = EB(e, s, c, m);
                        if (d !== void 0)
                            return new n.Multiply([d, e.setInput(new n.Exponent([wn(e, u.args[1]), p]), Ci(t.span.input, u.args[0].span.end, a.span.end))])
                    }
                    return new n.Exponent([e.setInput(new n.DotAccess([c, l]), s.span), p])
                } else
                    return new n.Exponent(yt(e, t.args))
            }
        case "Sqrt":
            return new n.FunctionCall("sqrt",yt(e, t.args));
        case "Nthroot":
            return new n.FunctionCall("nthroot",yt(e, [t.args[1], t.args[0]]));
        case "Frac":
            return new n.Divide(yt(e, t.args));
        case "Derivative":
            {
                let s = yt(e, t.args);
                if (!Sr(t.args[0]))
                    throw F(`Expected identifier in derivative, but found ${t.args[0].type}`);
                return new n.Derivative(s[0],[s[1]])
            }
        case "Integral":
            {
                let[s,a,u,c] = t.args
                  , l = yt(e, [s, a, u, c]);
                return new n.Integral(l)
            }
        case "EmptyIntegral":
            {
                let[s,a,u] = yt(e, t.args)
                  , c = e.setInput(new n.Constant(be(1, 1)), void 0);
                return new n.Integral([s, a, u, c])
            }
        case "Sum":
            {
                let[s,a,u] = t.args;
                if (a.type !== "Comparator" || !Zd(a))
                    throw fv();
                let c = yt(e, [a.args[0], a.args[1], u])
                  , l = wn(mg(e, {
                    prefix: "ro",
                    expr: c[0]
                }), s);
                return new n.Sum(c.concat(l))
            }
        case "Product":
            {
                let[s,a,u] = t.args;
                if (a.type !== "Comparator" || !Zd(a))
                    throw yv();
                let c = yt(e, [a.args[0], a.args[1], u])
                  , l = wn(mg(e, {
                    prefix: "ro",
                    expr: c[0]
                }), s);
                return new n.Product(c.concat(l))
            }
        case "Juxt":
            {
                if (e.writeIntegral) {
                    let[u,c] = t.args;
                    if (c.type === "Letter" && c.val === "t" && u.type === "Juxt" && ([u,c] = u.args,
                    c.type === "Letter" && c.val === "n")) {
                        if (u.type === "Juxt") {
                            if ([u,c] = u.args,
                            c.type === "Letter" && c.val === "i")
                                throw Rb()
                        } else if (u.type === "Letter" && u.val === "i")
                            throw Rb()
                    }
                }
                let[s,a] = t.args;
                if (s.type === "MixedNumber" && !(Sr(a) || a.type === "Piecewise" || a.type === "Call" || a.type === "Paren"))
                    throw pb($T(s));
                if (a.type === "MixedNumber")
                    throw pb($T(a));
                return new n.Multiply(yt(e, t.args))
            }
        case "Letter":
            return new n.Identifier(t.val);
        case "Cmd":
            {
                let s = t.val;
                switch (s) {
                case "ans":
                    {
                        if (e.index === void 0)
                            throw py("ans");
                        return new n.Ans(`ans_{${e.index - 1}}`)
                    }
                case "approx":
                    throw eb(s);
                case "dt":
                    {
                        if (!e.allowDt)
                            throw py(s);
                        return new n.Identifier(s)
                    }
                case "index":
                    {
                        if (!e.allowIndex)
                            throw py(s);
                        return new n.Identifier(s)
                    }
                default:
                    return new n.Identifier(s)
                }
            }
        case "With":
            {
                if (e.isSubstitutionRHS)
                    throw Fb();
                let[s,a] = t.args
                  , u = {
                    ...e,
                    isSubstitutionRHS: !0
                };
                return new n.Substitution(wn(u, s),qX(u, a))
            }
        case "Decimal":
            return new n.Constant(MB(t));
        case "MixedNumber":
            return new n.MixedNumber(DB(t));
        case "Piecewise":
            return HX(e, t);
        case "RightArrow":
            return zX(e, t);
        case "Seq":
            return new n.BareSeq(yt(e, t.args));
        case "EmptyPiecewise":
            return new n.Restriction([e.setInput(new n.Constant(!0), Va(t.span.input, t.span.start))]);
        case "Comparator":
            throw t.symbol === "=" ? Mi("=") : tb();
        case "ComparatorChain":
            throw t.symbols.includes("=") ? GS() : tb();
        case "Tilde":
            throw Mi("~");
        case "Colon":
            throw Mi(":");
        case "Ellipsis":
            throw Mi("...");
        case "For":
            return kT(e, t, {
                parentIsList: !1
            });
        case "EmptyRangeEnd":
            throw pv();
        case "Err":
            throw $X(t.error);
        default:
            throw `Unexpected surface node ${t.type}.`
        }
    }
    function s_(e) {
        return Yd.hasOwnProperty(e)
    }
    function AB(e) {
        return e === "ln" || e === "log" || e === "logbase"
    }
    function BX(e) {
        return e.type === "Decimal" && e.val === "2"
    }
    function GX(e) {
        return e.type !== "Neg" ? !1 : (e = e.args[0],
        e.type === "Decimal" && e.val === "1")
    }
    function CB(e, t) {
        let n = e.nodes
          , [r,o] = t.args
          , i = wn(e, r)
          , s = Ro(o)
          , a = yt(e, s);
        if (YT(r)) {
            let u = Va(o.span.input, o.span.start)
              , c = e.setInput(wB(e), u);
            return new n.SeededFunctionCall(i,[c].concat(a))
        }
        if (Sr(r))
            return new n.FunctionCall(i,a);
        if (r.type === "Superscript") {
            let[u,c] = r.args;
            if (u.type === "Cmd") {
                let l = u.val;
                if (s_(l) || AB(l)) {
                    if (BX(c))
                        return new n.Exponent([e.setInput(new n.FunctionCall(l,a), void 0), wn(e, c)]);
                    if (GX(c) && Yd[l] !== void 0)
                        return new n.FunctionCall(Yd[l],a);
                    throw s_(l) ? SC(l) : EC(l === "logbase" ? "log" : l)
                }
            }
        }
        return new n.Multiply([i, wn(e, o)])
    }
    function kT(e, t, {parentIsList: n}) {
        let r = e.nodes
          , [o,i] = t.args
          , s = e.setInput(new r.Identifier(`_comprehensionIndex_${wX++}`), void 0);
        if (o.type === "For")
            throw tl("for");
        let a = wn(mg(e, {
            prefix: "li",
            expr: s
        }), o)
          , u = [];
        if (i.type === "Seq") {
            let p = !1
              , m = !1
              , d = !1;
            for (let y = 0; y < i.args.length; y++) {
                let g = i.args[y];
                Zd(g) || e.allowIntervalComprehensions && g.type === "ComparatorChain" ? p = !0 : m = !0,
                g.type === "Cmd" && g.val === "cursor" && (d = !0)
            }
            if (p && m) {
                let y = tl("for");
                throw d && y.setCursorContext({
                    type: "for-assignment-lhs",
                    allowedTypes: [R]
                }),
                y
            }
        }
        let c = [];
        for (let p of Ro(i))
            if (e.allowIntervalComprehensions && p.type === "ComparatorChain") {
                let m = a_(p)
                  , {min: d, identifier: y, max: g, open: f} = m;
                c.push({
                    identifier: wn(e, y),
                    bounds: [wn(e, d), wn(e, g)],
                    open: f
                })
            } else if (p.type === "Comparator" && Zd(p)) {
                let m = e.setInput(new r.AssignmentExpression(yt(e, p.args)), p.span);
                u.push(m)
            } else {
                if (p.type === "Comparator")
                    throw Bm("a");
                {
                    let m = Hv();
                    throw p.type === "Cmd" && p.val === "cursor" && m.setCursorContext({
                        type: "for-assignment-lhs",
                        allowedTypes: [R]
                    }),
                    m
                }
            }
        let l = n;
        return new r.ListComprehension(s,a,u,l,c)
    }
    function qX(e, t) {
        let n = e.nodes;
        if (t.type === "Seq") {
            let i = !1
              , s = !1
              , a = !1;
            for (let u = 0; u < t.args.length; u++) {
                let c = t.args[u];
                if (c.type === "With")
                    throw tl("with");
                if (Zd(c) || vB(c))
                    i = !0;
                else if (e.allowIntervalComprehensions && c.type === "ComparatorChain")
                    try {
                        a_(c),
                        s = !0
                    } catch (l) {
                        a = !0
                    }
                else
                    a = !0
            }
            if ((i || s) && a)
                throw tl("with");
            if (s)
                throw Vb()
        }
        if (e.allowIntervalComprehensions && t.type === "ComparatorChain") {
            let i;
            try {
                a_(t),
                i = !0
            } catch (s) {
                i = !1
            }
            if (i)
                throw Vb()
        }
        if (t.type === "With")
            throw Fb();
        let r = Ro(t)
          , o = [];
        for (let i of r) {
            if (i.type != "Comparator" || !Zd(i) && !vB(i))
                throw yy();
            let s = e.setInput(new n.AssignmentExpression(yt(e, i.args)), i.span);
            o.push(s)
        }
        return o
    }
    function vB(e) {
        if (e.type !== "Comparator" || e.symbol !== "=")
            return !1;
        let t = e.args[0];
        if (t.type !== "Call")
            return !1;
        let[n] = t.args;
        return !!Sr(n)
    }
    function a_(e) {
        if (e.symbols.length !== 2)
            throw Bm("a");
        let[t,n,r] = e.args
          , [o,i] = e.symbols;
        if (!Sr(n))
            throw Bm("a");
        if (o !== "<" && o !== "<=" || i !== "<" && i !== "<=" || e.symbols.includes("="))
            throw Bm(Ir(n.span));
        return {
            min: t,
            identifier: n,
            max: r,
            open: [o === "<", i === "<"]
        }
    }
    function zX(e, t) {
        let n = e.nodes;
        if (!Sr(t.args[0]))
            throw _E();
        return e = mg(e, {
            prefix: "ec",
            expr: e.setInput(new n.Identifier("globalEventCount"), void 0)
        }),
        new n.UpdateRule(yt(e, t.args))
    }
    function HX(e, t) {
        let n = e.nodes
          , [r] = t.args
          , o = Ro(r);
        if (o.length === 1 && pg(o[0])) {
            let m = o[0];
            return new n.Restriction([e.setInput(tc(e, m), m.span)])
        }
        if (o.length > 1 && o.every(pg)) {
            let m = e.setInput(tc(e, o[0]), o[0].span);
            for (let d = 1; d < o.length; d++) {
                let y = e.setInput(tc(e, o[d]), o[d].span);
                m = e.setInput(new n.Or([m, y]), vi(o[0].span, o[d].span))
            }
            return new n.Restriction([m])
        }
        let i, s = [];
        e: for (i = 0; i < o.length; i++) {
            let m = o[i];
            switch (m.type) {
            case "Colon":
                {
                    let[d,y] = m.args;
                    if (!pg(d))
                        throw MC();
                    if (y.type === "With" && y.args[1].type === "Seq")
                        throw tl("with");
                    s.push({
                        condition: e.setInput(tc(e, d), d.span),
                        if_expr: wn(e, y)
                    });
                    break
                }
            case "Comparator":
            case "ComparatorChain":
                s.push({
                    condition: e.setInput(tc(e, m), m.span),
                    if_expr: e.setInput(new n.Constant(be(1, 1)), Ci("1", 0, 1))
                });
                break;
            case "For":
                throw tl("for");
            default:
                break e
            }
        }
        if (i === 0)
            throw CC();
        if (i < o.length - 1)
            throw vC();
        let a, u;
        i === o.length - 1 ? (a = lg(e, o[i]),
        u = o[i]) : a = new n.Constant(NaN);
        let c = a, l = u == null ? void 0 : u.span, p;
        for (; s.length; )
            p = s.pop(),
            c = new n.Piecewise([p.condition, p.if_expr, e.setInput(c, l)]),
            l = void 0;
        return c
    }
    function pg(e) {
        return e.type === "Comparator" || e.type === "ComparatorChain"
    }
    function tc(e, t) {
        let n = e.nodes;
        switch (t.type) {
        case "Comparator":
            switch (t.symbol) {
            case "<":
                return new n["Comparator['<']"](yt(e, t.args));
            case "<=":
                return new n["Comparator['<=']"](yt(e, t.args));
            case ">":
                return new n["Comparator['>']"](yt(e, t.args));
            case ">=":
                return new n["Comparator['>=']"](yt(e, t.args));
            case "=":
                return new n["Comparator['=']"](yt(e, t.args));
            default:
                throw new Error(`Unexpected symbol ${t.symbol}`)
            }
        case "ComparatorChain":
            return new n.ComparatorChain(t.symbols,yt(e, t.args));
        default:
            throw F(`Unexpected type for condition: ${t.type}`)
        }
    }
    function UX(e) {
        let[t,n] = e.args;
        if (t.type === "Superscript" && (t = t.args[0]),
        t.type === "Cmd" && t.val === "logbase" && n.type === "Seq" && n.args.length === 2) {
            if (!iu(n.args[0]))
                throw lb("log")
        } else if (!iu(n))
            throw t.type === "Cmd" ? lb(t.val) : F(`Unexpected type for args of implicit call: ${n.type}`)
    }
    function MB(e) {
        return op(e.val)
    }
    function DB(e) {
        let t = op(e.whole)
          , n = op(e.num)
          , r = op(e.den);
        return Pi(t, Fo(n, r))
    }
    function kX(e) {
        if (e.type !== "Call")
            return !1;
        let t = e.args[0];
        for (; t.type === "Superscript" || t.type === "Subscript" || t.type === "Prime"; )
            t = t.args[0];
        return t.type !== "Cmd" ? !1 : s_(t.val) || AB(t.val)
    }
    function Zd(e) {
        return e.type === "Comparator" && e.symbol === "=" && Sr(e.args[0])
    }
    function $X(e) {
        switch (e.type) {
        case "UnexpectedParseError":
        case "MissingBound":
        case "EmptyGroup":
        case "UnexpectedDifferential":
        case "UnexpectedEnd":
            return F(`Unexpected error type: ${e.type}`);
        case "InvalidOperatorName":
            return gC();
        case "UnexpectedCloseDelimiter":
        case "MissingCloseDelimiter":
            return Cv(e.open, e.close);
        case "UnrecognizedSymbol":
            return e.val === "." ? Mi(e.val) : eb(e.val);
        case "EmptyInput":
            return iy();
        case "BinaryOperatorMissingRight":
        case "BinaryOperatorMissingLeft":
            return Lm(e.val === "%" ? "% of" : e.val);
        case "UnaryOperatorMissingLeft":
            return cC(e.val);
        case "UnaryOperatorMissingRight":
            return lC(e.val);
        case "UnexpectedSubscript":
            return RC(e.base);
        case "PercentMissingOf":
            return Mv();
        case "SumMissingBound":
            return mv();
        case "ProductMissingBound":
            return dv();
        case "IntegralMissingBound":
            return bv();
        case "SumMissingBody":
            return Iv();
        case "ProductMissingBody":
            return Pv();
        case "IntegralMissingBody":
            return Sv();
        case "DerivativeMissingBody":
            return Ev();
        case "IntegralMissingDifferential":
            return xv();
        case "DifferentialWithSuperscript":
            return Tv();
        case "FractionMissingNumerator":
            return pC();
        case "FractionMissingDenominator":
            return mC();
        case "FractionEmpty":
            return dC();
        case "EmptySuperscript":
            return fC();
        case "EmptySubscript":
            return fb();
        case "InvalidSubscript":
            return yC(e.val);
        case "SuperscriptWithPrime":
            return bC();
        case "PrimeWithoutParen":
            return gb();
        case "UnexpectedPrime":
            return yb();
        case "EmptyRadical":
            return xC();
        case "EmptyRadicalIndex":
            return TC();
        case "EmptySquareBracket":
            return IC();
        case "EmptyPipe":
            return PC();
        case "FunctionMissingArgument":
            return Ba(e.val, 1, 0, {
                includeUsageExample: !0
            });
        case "AdjacentNumbers":
            return aC($T(e.args[0]), $T(e.args[1]));
        case "TokenWithSubscript":
            return uC();
        case "UnexpectedFor":
            return Mi("for");
        default:
            throw `Unexpected surface node ${e.type}.`
        }
    }
    function $T(e) {
        switch (e.type) {
        case "Decimal":
            return e.val;
        case "MixedNumber":
            return `${e.whole} ${e.num}/${e.den}`;
        default:
            let t = e;
            throw new Error(`Unexpected node type ${t.type}`)
        }
    }
    function iu(e) {
        switch (e.type) {
        case "Letter":
        case "Decimal":
        case "MixedNumber":
        case "Cmd":
        case "EmptyPiecewise":
            return !0;
        case "Neg":
            {
                let n = e.args[0];
                for (; ; )
                    if (n.type === "Pos" || n.type === "Paren" && !OB(n))
                        n = n.args[0];
                    else if (n.type === "Neg")
                        n = n.args[0];
                    else
                        break;
                return n.type === "Decimal" || n.type === "MixedNumber"
            }
        case "Pos":
            return iu(e.args[0]);
        case "Paren":
            return iu(e.args[0]);
        case "Juxt":
        case "Mul":
        case "DotMul":
        case "CrossMul":
        case "Div":
            return iu(e.args[0]) && iu(e.args[1]);
        case "Subscript":
            return iu(e.args[0]);
        case "Superscript":
        case "Frac":
        case "Add":
        case "Sub":
            return iu(e.args[0]) && iu(e.args[1]);
        case "Piecewise":
            {
                let[n] = e.args;
                return pg(n)
            }
        case "Call":
            {
                let[n,r] = e.args;
                return Sr(n) || hB(n) ? !1 : iu(n) && iu(r)
            }
        case "Derivative":
        case "Sqrt":
        case "Nthroot":
        case "Pipes":
        case "Bang":
            return !1;
        case "Comparator":
        case "ComparatorChain":
        case "Tilde":
        case "ImplicitCall":
        case "Index":
        case "List":
        case "Seq":
        case "Integral":
        case "EmptyIntegral":
        case "Sum":
        case "Product":
        case "Colon":
        case "Ellipsis":
        case "For":
        case "With":
        case "Dot":
        case "PercentOf":
        case "Prime":
        case "EmptyRangeEnd":
        case "RightArrow":
            return !1;
        default:
            throw `Unexpected surface node ${e.type}.`
        }
    }
    function YT(e) {
        return e.type !== "Cmd" ? !1 : e.val === "random" || e.val === "shuffle"
    }
    function wB(e) {
        let t = new e.nodes.ExtendSeed("",[e.setInput(new e.nodes.Identifier("globalRandomSeed"), void 0), e.setInput(new e.nodes.Seed(e.nextSeed()), void 0)]);
        if (!e.seedExtensions)
            return t;
        for (let {prefix: n, expr: r} of e.seedExtensions)
            t = new e.nodes.ExtendSeed(n,[e.setInput(t, void 0), r]);
        return t
    }
    function mg(e, t) {
        let n = e.seedExtensions || [];
        return {
            ...e,
            seedExtensions: n.concat(t)
        }
    }
    function Xd(e) {
        return {
            type: "initial",
            tokenType: e
        }
    }
    function dg(e) {
        return {
            type: "l",
            tokenType: e
        }
    }
    function fg(e) {
        return {
            type: "r",
            tokenType: e
        }
    }
    function gn(e) {
        return {
            type: "la",
            tokenType: e
        }
    }
    function Wd(e) {
        return {
            type: "ra",
            tokenType: e
        }
    }
    function LB(e, t) {
        for (let n of AV)
            if (t[n] === void 0)
                throw new Error(`Programming Error: token ${n} must be a assigned a ${e} precedence`)
    }
    function Xp(e, t, n, r) {
        if (t[n] !== void 0)
            throw new Error(`Programming Error: duplicate ${e} entry for token ${n}.`);
        t[n] = r
    }
    function FB(e) {
        let t = {}
          , n = {}
          , r = {};
        for (let a = 0; a < e.length; a++) {
            let u = e[a];
            for (let {type: c, tokenType: l} of u)
                switch (c) {
                case "initial":
                    Xp("initial", t, l, a);
                    break;
                case "l":
                    Xp("left", n, l, a);
                    break;
                case "r":
                    Xp("right", r, l, a);
                    break;
                case "la":
                    Xp("left", n, l, a),
                    Xp("right", r, l, a);
                    break;
                case "ra":
                    Xp("left", n, l, a),
                    Xp("right", r, l, a - 1);
                    break
                }
        }
        LB("left", n),
        LB("right", r);
        function o(a) {
            return r[a]
        }
        function i(a) {
            return n[a]
        }
        function s(a) {
            let u = t[a];
            return u === void 0 ? o(a) : u
        }
        return {
            rightPrec: o,
            leftPrec: i,
            initialPrec: s
        }
    }
    function Ge(e, t) {
        return {
            type: "Err",
            span: e,
            error: t
        }
    }
    function VB() {
        return {
            type: "UnexpectedParseError"
        }
    }
    function BB() {
        return {
            type: "EmptyInput"
        }
    }
    function GB() {
        return {
            type: "EmptyGroup"
        }
    }
    function c_() {
        return {
            type: "EmptySubscript"
        }
    }
    function qB() {
        return {
            type: "EmptySuperscript"
        }
    }
    function l_() {
        return {
            type: "EmptyRadical"
        }
    }
    function zB() {
        return {
            type: "EmptySquareBracket"
        }
    }
    function HB() {
        return {
            type: "EmptyPipe"
        }
    }
    function UB() {
        return {
            type: "EmptyRadicalIndex"
        }
    }
    function p_() {
        return {
            type: "UnexpectedEnd"
        }
    }
    function Wp(e) {
        return {
            type: "BinaryOperatorMissingRight",
            val: e
        }
    }
    function kB(e) {
        return {
            type: "BinaryOperatorMissingLeft",
            val: e
        }
    }
    function m_(e) {
        return {
            type: "UnaryOperatorMissingRight",
            val: e
        }
    }
    function d_(e) {
        return {
            type: "UnaryOperatorMissingLeft",
            val: e
        }
    }
    function $B(e, t) {
        return {
            type: "MissingCloseDelimiter",
            open: e,
            close: t
        }
    }
    function yg(e, t) {
        return {
            type: "UnexpectedCloseDelimiter",
            open: e,
            close: t
        }
    }
    function YB() {
        return {
            type: "UnexpectedDifferential"
        }
    }
    function ZB(e) {
        return {
            type: "UnrecognizedSymbol",
            val: e
        }
    }
    function XB(e) {
        return {
            type: "InvalidSubscript",
            val: e
        }
    }
    function WB(e) {
        return {
            type: "UnexpectedSubscript",
            base: e
        }
    }
    function f_(e) {
        return {
            type: "FunctionMissingArgument",
            val: e
        }
    }
    function jB() {
        return {
            type: "PercentMissingOf"
        }
    }
    function y_() {
        return {
            type: "PrimeWithoutParen"
        }
    }
    function JB() {
        return {
            type: "SuperscriptWithPrime"
        }
    }
    function ZT() {
        return {
            type: "UnexpectedPrime"
        }
    }
    function QB() {
        return {
            type: "SumMissingBound"
        }
    }
    function KB() {
        return {
            type: "ProductMissingBound"
        }
    }
    function g_() {
        return {
            type: "MissingBound"
        }
    }
    function eG() {
        return {
            type: "IntegralMissingBound"
        }
    }
    function tG() {
        return {
            type: "SumMissingBody"
        }
    }
    function nG() {
        return {
            type: "ProductMissingBody"
        }
    }
    function rG() {
        return {
            type: "IntegralMissingBody"
        }
    }
    function oG() {
        return {
            type: "DerivativeMissingBody"
        }
    }
    function iG() {
        return {
            type: "IntegralMissingDifferential"
        }
    }
    function sG() {
        return {
            type: "DifferentialWithSuperscript"
        }
    }
    function aG() {
        return {
            type: "FractionMissingNumerator"
        }
    }
    function uG() {
        return {
            type: "FractionMissingDenominator"
        }
    }
    function cG() {
        return {
            type: "FractionEmpty"
        }
    }
    function h_(e) {
        return {
            type: "AdjacentNumbers",
            args: e
        }
    }
    function lG() {
        return {
            type: "TokenWithSubscript"
        }
    }
    var ZX = [[Xd("("), gn(")"), Xd("\\{"), gn("\\}"), fg("["), gn("]"), Xd("(|"), gn("|)"), gn("Differential"), gn("End")], [gn("for")], [fg("with")], [Wd("...")], [gn(",")], [Wd(":")], [fg("->")], [dg("with")], [gn("="), gn(">"), gn("<"), gn(">="), gn("<="), gn("~")], [dg("->")], [gn("+"), gn("-")], [gn("*"), gn("\\cdot"), gn("\\times"), gn("/"), gn("Decimal"), gn("MixedNumber"), gn("Letter"), gn("Cmd"), gn("TokenNode"), gn("%"), fg("("), gn("\\{"), gn("(|"), gn("Frac"), gn("Sqrt"), gn("Trig"), gn("Ln"), gn("Log"), Wd("Int"), Wd("Sum"), Wd("Prod")], [Xd("+"), Xd("-")], [gn("!")], [gn("SupSub")], [dg("["), gn(".")], [dg("(")], [gn("Err")]]
      , {leftPrec: x_, rightPrec: pG, initialPrec: T_} = FB(ZX)
      , mG = {
        trailingComma: !1
    };
    function yG(e, t) {
        let n = t ? {
            ...mG,
            ...t
        } : mG
          , r = _c(e, n)
          , o = XX(r);
        return o.type === "Err" && o.error.type === "EmptyGroup" ? Ge(o.span, BB()) : o
    }
    function XX(e) {
        return Fl(e, {
            isToplevel: !0
        })
    }
    function Fl(e, {isToplevel: t}={
        isToplevel: !1
    }) {
        if (UT(e))
            return Ge(ve(e, e), GB());
        let {state: n, tree: r} = Or(e, 0, {
            isToplevel: t
        });
        return r.type !== "Err" && !UT(n) ? I_(n).tree : r
    }
    function H(e, t) {
        return {
            state: e,
            tree: t
        }
    }
    function Or(e, t, {isToplevel: n}={
        isToplevel: !1
    }) {
        let r = e, o;
        if ({state: r, tree: o} = WX(r),
        o.type === "Err")
            return H(r, o);
        if (!i_(e, r))
            throw new Error("Programming Error: parseInitial did not advance state.");
        for (; !UT(r); ) {
            let i;
            if (po(r, "(") && !QX(o) ? i = pG("(") : i = x_(No(r).type),
            t >= i)
                break;
            let s = r
              , a = jX(r, o, n) ? T_("(") : pG(No(r).type);
            if ({state: r, tree: o} = JX(r, o, a),
            o.type === "Err")
                return H(r, o);
            if (!i_(s, r))
                throw new Error("Programming Error: parseSuccessor did not advance state.")
        }
        return H(r, o)
    }
    function Is(e) {
        return e.type === "UnexpectedDifferential" || e.type === "UnexpectedCloseDelimiter" || e.type === "UnexpectedEnd"
    }
    function WX(e) {
        let t = e, n = No(e), r = T_(n.type), o;
        switch (n.type) {
        case "+":
            {
                if (e = Ze(e),
                {state: e, tree: o} = Or(e, r),
                o.type === "Err") {
                    if (!Is(o.error))
                        return H(e, o);
                    let s = ve(t, e)
                      , a = Ge(s, m_(n.val));
                    return H(e, a)
                }
                return H(e, qV(ve(t, e), [o]))
            }
        case "-":
            if (e = Ze(e),
            {state: e, tree: o} = Or(e, r),
            o.type === "Err") {
                if (!Is(o.error))
                    return H(e, o);
                let s = ve(t, e)
                  , a = Ge(s, m_(n.val));
                return H(e, a)
            } else
                return H(e, zV(ve(t, e), [o]));
        case "(":
            return gg(e);
        case "\\{":
            return e = Ze(e),
            po(e, "\\}") ? (e = Ze(e),
            H(e, sB(ve(t, e)))) : ({state: e, tree: o} = Or(e, r),
            {state: e, tree: o} = hg(t, e, o, "\\{", "\\}"),
            o.type === "Err" ? H(e, o) : H(e, iB(ve(t, e), [o])));
        case "[":
            return e = Ze(e),
            po(e, "]") ? (e = Ze(e),
            H(e, QD(ve(t, e), []))) : ({state: e, tree: o} = Or(e, r),
            {state: e, tree: o} = hg(t, e, o, "[", "]"),
            o.type === "Err" ? H(e, o) : H(e, QD(ve(t, e), [o])));
        case "(|":
            {
                if (e = Ze(e),
                po(e, "|)")) {
                    e = Ze(e);
                    let s = ve(t, e);
                    return H(e, Ge(s, HB()))
                }
                return {state: e, tree: o} = Or(e, r),
                {state: e, tree: o} = hg(t, e, o, "(|", "|)"),
                o.type === "Err" ? H(e, o) : H(e, jV(ve(t, e), [o]))
            }
        case "Frac":
            {
                if (e.opts.disallowFrac)
                    throw wb();
                e = Ze(e);
                let s = Fl(_c(n.num, e.opts))
                  , a = Fl(_c(n.den, e.opts));
                if (s.type === "Err" && s.error.type === "EmptyGroup" && a.type === "Err" && a.error.type === "EmptyGroup") {
                    let u = ve(t, e)
                      , c = Ge(u, cG());
                    return H(e, c)
                }
                if (s.type === "Err" && s.error.type === "EmptyGroup") {
                    let u = ve(t, e)
                      , c = Ge(u, aG());
                    return H(e, c)
                }
                if (a.type === "Err" && a.error.type === "EmptyGroup") {
                    let u = ve(t, e)
                      , c = Ge(u, uG());
                    return H(e, c)
                }
                if (s.type === "Err")
                    return H(e, s);
                if (a.type === "Err")
                    return H(e, a);
                if (bB(s, a) && a.type === "Juxt") {
                    let u = a.args[1], c;
                    if ({state: e, tree: c} = Or(e, x_("*") - 1),
                    c.type === "Err") {
                        if (Is(c.error)) {
                            let l = ve(t, e);
                            return H(e, Ge(l, oG()))
                        }
                        return H(e, c)
                    }
                    return H(e, eB(ve(t, e), [u, c]))
                }
                return H(e, KV(ve(t, e), [s, a]))
            }
        case "Sqrt":
            if (e = Ze(e),
            n.optArg) {
                let s = Fl(_c(n.optArg, e.opts));
                if (s.type === "Err")
                    return s.error.type === "EmptyGroup" ? H(e, Ge(s.span, UB())) : H(e, s);
                let a = Fl(_c(n.arg, e.opts));
                return a.type === "Err" ? a.error.type === "EmptyGroup" ? H(e, Ge(a.span, l_())) : H(e, a) : H(e, QV(ve(t, e), [s, a]))
            } else {
                let s = Fl(_c(n.arg, e.opts));
                return s.type === "Err" ? s.error.type === "EmptyGroup" ? H(e, Ge(s.span, l_())) : H(e, s) : H(e, JV(ve(t, e), [s]))
            }
        case "Trig":
        case "Ln":
            {
                e = Ze(e);
                let s = Zp(ve(t, e), n.val)
                  , a = 0
                  , u = No(e);
                if (u.type === "SupSub") {
                    if (e = Ze(e),
                    u.sub) {
                        let p = ve(t, e)
                          , m = Ge(p, WB(s.val));
                        return H(e, m)
                    }
                    let l = XT(u, e.opts);
                    if (l) {
                        if (l.type === "Err")
                            return H(e, l);
                        s = BT(ve(t, e), [s, l])
                    }
                    a = u.nprimes
                }
                let c = po(e, "(");
                if (c) {
                    if ({state: e, tree: o} = gg(e),
                    o.type === "Err")
                        return H(e, o);
                    o = ag(ve(t, e), [s, o.args[0]])
                } else {
                    if ({state: e, tree: o} = Or(e, r - 1),
                    o.type === "Err")
                        return Is(o.error) ? H(e, Ge(ve(t, e), f_(n.val))) : H(e, o);
                    o = jD(ve(t, e), [s, o])
                }
                if (a > 0) {
                    let l = ve(t, e);
                    if (!c) {
                        let p = Ge(l, y_());
                        return H(e, p)
                    }
                    o = ug(l, a, [o])
                }
                return H(e, o)
            }
        case "Log":
            {
                e = Ze(e);
                let s = ve(t, e), a = Zp(s, n.val), u = 0, c, l, p = No(e);
                if (p.type === "SupSub" && (e = Ze(e),
                c = gG(p, e.opts),
                l = XT(p, e.opts),
                u = p.nprimes),
                c && c.type === "Err")
                    return H(e, c);
                if (l && l.type === "Err")
                    return H(e, l);
                let m = po(e, "(");
                if (m) {
                    if ({state: e, tree: o} = gg(e),
                    o.type === "Err")
                        return H(e, o);
                    o = o.args[0]
                } else if ({state: e, tree: o} = Or(e, r - 1),
                o.type === "Err")
                    return Is(o.error) ? H(e, Ge(ve(t, e), f_(n.val))) : H(e, o);
                let d = c ? Zp(s, "\\logbase") : a
                  , y = c ? GT(ve(t, e), Ro(o).concat(c)) : o;
                if (l && (d = BT(ve(t, e), [d, l])),
                m ? o = ag(ve(t, e), [d, y]) : o = jD(ve(t, e), [d, y]),
                u > 0) {
                    let g = ve(t, e);
                    if (!m) {
                        let f = Ge(g, y_());
                        return H(e, f)
                    }
                    o = ug(g, u, [o])
                }
                return H(e, o)
            }
        case "Int":
            {
                e = Ze(e);
                let s = No(e);
                e = Ze(e);
                let a = b_(s, t, e);
                if (a.type === "Err")
                    return a.error.type === "MissingBound" ? H(e, Ge(a.span, eG())) : H(e, a);
                let {sup: u, sub: c} = a, l;
                if (po(e, "Differential"))
                    return {state: e, tree: l} = fG(e),
                    l.type === "Err" ? H(e, l) : H(e, nB(ve(t, e), [l, c, u]));
                if ({state: e, tree: o} = Or(e, r),
                o.type === "Err")
                    return Is(o.error) ? H(e, Ge(o.span, rG())) : H(e, o);
                let p = o;
                return po(e, "Differential") ? ({state: e, tree: l} = fG(e),
                l.type === "Err" ? H(e, l) : H(e, tB(ve(t, e), [l, c, u, p]))) : H(e, Ge(ve(t, e), iG()))
            }
        case "Sum":
            {
                e = Ze(e);
                let s = No(e);
                e = Ze(e);
                let a = b_(s, t, e);
                if (a.type === "Err")
                    return a.error.type === "MissingBound" ? H(e, Ge(a.span, QB())) : H(e, a);
                let {sup: u, sub: c} = a;
                return {state: e, tree: o} = Or(e, r),
                o.type === "Err" ? Is(o.error) ? H(e, Ge(o.span, tG())) : H(e, o) : H(e, rB(ve(t, e), [o, c, u]))
            }
        case "Prod":
            {
                e = Ze(e);
                let s = No(e);
                e = Ze(e);
                let a = b_(s, t, e);
                if (a.type === "Err")
                    return a.error.type === "MissingBound" ? H(e, Ge(a.span, KB())) : H(e, a);
                let {sup: u, sub: c} = a;
                return {state: e, tree: o} = Or(e, r),
                o.type === "Err" ? Is(o.error) ? H(e, Ge(o.span, nG())) : H(e, o) : H(e, oB(ve(t, e), [o, c, u]))
            }
        case "Cmd":
            return e = Ze(e),
            o = Zp(ve(t, e), n.val),
            H(e, o);
        case "TokenNode":
            {
                e = Ze(e);
                let s = No(e);
                return s.type === "SupSub" && s.sub ? (e = Ze(e),
                H(e, Ge(ve(t, e), lG()))) : (o = Zp(ve(t, e), n.val),
                H(e, o))
            }
        case "Letter":
            return e = Ze(e),
            o = fB(ve(t, e), n.val),
            H(e, o);
        case "Decimal":
            {
                e = Ze(e);
                let s = qT(ve(t, e), n.val)
                  , a = e.token;
                if (a.type === "Decimal" || a.type === "MixedNumber") {
                    let u = e;
                    e = Ze(e);
                    let c = ve(t, e)
                      , l = a.type === "MixedNumber" ? a : qT(ve(u, e), a.val);
                    return H(e, Ge(c, h_([s, l])))
                }
                if (n.val.endsWith(".") && a.type === "Cmd" && (a.val === "\\real" || a.val === "\\imag"))
                    throw nb();
                return H(e, s)
            }
        case "MixedNumber":
            {
                if (e.opts.disallowFrac)
                    throw wb();
                e = Ze(e);
                let s = e.token;
                if (s.type === "Decimal" || s.type === "MixedNumber") {
                    let a = e;
                    e = Ze(e);
                    let u = ve(t, e)
                      , c = s.type === "MixedNumber" ? s : qT(ve(a, e), s.val);
                    return H(e, Ge(u, h_([n, c])))
                }
                return H(e, n)
            }
        case "*":
        case "\\cdot":
        case "\\times":
        case "/":
        case ",":
        case "=":
        case ">":
        case "<":
        case ">=":
        case "<=":
        case "->":
        case "~":
        case ":":
        case "...":
        case "%":
        case ".":
        case "for":
        case "with":
            {
                e = Ze(e);
                let s = ve(t, e)
                  , a = Ge(s, kB(n.val));
                return H(e, a)
            }
        case "!":
            {
                e = Ze(e);
                let s = ve(t, e)
                  , a = Ge(s, d_(n.val));
                return H(e, a)
            }
        case "SupSub":
            {
                e = Ze(e);
                let s = "supsub";
                n.sub ? s = "subscript" : n.sup ? s = "superscript" : n.nprimes > 0 && (s = "prime");
                let a = ve(t, e)
                  , u = Ge(a, d_(s));
                return H(e, u)
            }
        case ")":
        case "\\}":
        case "]":
        case "|)":
        case "Differential":
            return I_(e);
        case "Err":
            {
                e = Ze(e);
                let s = ve(t, e)
                  , a = Ge(s, ZB(n.val));
                return H(e, a)
            }
        case "End":
            {
                let s = ve(t, e)
                  , a = Ge(s, p_());
                return H(e, a)
            }
        default:
            throw `Unexpected token type ${n.type}.`
        }
    }
    function jX(e, t, n) {
        return po(e, "=") && n && (NB(t) || u_(t))
    }
    function JX(e, t, n) {
        let r = No(e), o;
        switch (r.type) {
        case "+":
        case "-":
        case "*":
        case "\\cdot":
        case "\\times":
        case "/":
        case "~":
        case ":":
        case ".":
        case "->":
        case "for":
            {
                if (e = Ze(e),
                {state: e, tree: o} = Or(e, n),
                o.type === "Err")
                    if (Is(o.error)) {
                        let s = Er(t.span, e)
                          , a = Ge(s, Wp(r.val));
                        return H(e, a)
                    } else
                        return H(e, o);
                return H(e, dG(r.type, Er(t.span, e), [t, o]))
            }
        case "with":
            {
                if (e = Ze(e),
                {state: e, tree: o} = Or(e, n),
                o.type === "Err")
                    if (Is(o.error)) {
                        let s = Er(t.span, e)
                          , a = Ge(s, Wp(r.val));
                        return H(e, a)
                    } else
                        return H(e, o);
                return H(e, dG(r.type, Er(t.span, e), [t, o]))
            }
        case "%":
            {
                e = Ze(e);
                let s = No(e);
                if (s.type !== "Cmd" || s.val !== "of" && s.val !== "\\of") {
                    let a = Ge(r.span, jB());
                    return H(e, a)
                }
                if (e = Ze(e),
                {state: e, tree: o} = Or(e, n),
                o.type === "Err")
                    if (Is(o.error)) {
                        let a = Er(t.span, e)
                          , u = Ge(a, Wp(r.val));
                        return H(e, u)
                    } else
                        return H(e, o);
                return H(e, mB(Er(t.span, e), [t, o]))
            }
        case "=":
        case ">=":
        case "<=":
        case ">":
        case "<":
            {
                let s = [t]
                  , a = [];
                for (; ; ) {
                    let c = No(e).type;
                    if (c !== "=" && c !== ">=" && c !== "<=" && c !== ">" && c !== "<")
                        break;
                    if (a.push(c),
                    e = Ze(e),
                    {state: e, tree: o} = Or(e, n),
                    o.type === "Err")
                        if (Is(o.error)) {
                            let l = Er(t.span, e)
                              , p = Ge(l, Wp(r.val));
                            return H(e, p)
                        } else
                            return H(e, o);
                    s.push(o)
                }
                let u = s[s.length - 1];
                return u.type === "Comparator" ? (s.pop(),
                Array.prototype.push.apply(s, u.args),
                a.push(u.symbol)) : u.type === "ComparatorChain" && (s.pop(),
                Array.prototype.push.apply(s, u.args),
                Array.prototype.push.apply(a, u.symbols)),
                s.length === 2 ? H(e, VV(Er(t.span, e), a[0], s)) : H(e, BV(Er(t.span, e), a, s))
            }
        case "!":
            return e = Ze(e),
            H(e, XV(Er(t.span, e), [t]));
        case "[":
            {
                let s = e;
                if (e = Ze(e),
                po(e, "]")) {
                    e = Ze(e);
                    let a = ve(s, e);
                    return H(e, Ge(a, zB()))
                }
                return {state: e, tree: o} = Or(e, n),
                {state: e, tree: o} = hg(s, e, o, "[", "]"),
                o.type === "Err" ? H(e, o) : H(e, WV(Er(t.span, e), [t, o]))
            }
        case "Sqrt":
        case "Frac":
        case "Letter":
        case "Cmd":
        case "TokenNode":
        case "Trig":
        case "Ln":
        case "Log":
        case "Sum":
        case "Int":
        case "Prod":
        case "Decimal":
        case "MixedNumber":
        case "\\{":
        case "(|":
            return {state: e, tree: o} = Or(e, n),
            o.type === "Err" ? H(e, o) : H(e, t_(Er(t.span, e), [t, o]));
        case "(":
            if (Sr(t)) {
                if ({state: e, tree: o} = gg(e),
                o.type === "Err")
                    return H(e, o);
                let s = Er(t.span, e);
                return H(e, ag(s, [t, o.args[0]]))
            } else if (t.type === "Prime" && Sr(t.args[0])) {
                if ({state: e, tree: o} = gg(e),
                o.type === "Err")
                    return H(e, o);
                let s = Er(t.span, e);
                return H(e, ug(s, t.nprimes, [ag(s, [t.args[0], o.args[0]])]))
            } else
                return {state: e, tree: o} = Or(e, n),
                o.type === "Err" ? H(e, o) : H(e, t_(Er(t.span, e), [t, o]));
        case "SupSub":
            {
                e = Ze(e);
                let s = hG(r)
                  , a = XT(r, e.opts);
                if (s && s.type === "Err")
                    return H(e, s);
                if (a && a.type === "Err")
                    return H(e, a);
                if (s && (t = KD(Er(t.span, e), [t, s])),
                a && (t = BT(Er(t.span, e), [t, a])),
                r.nprimes > 0) {
                    let u = Er(t.span, e);
                    if (!Sr(t)) {
                        let c = Ge(u, ZT());
                        return H(e, c)
                    }
                    t = ug(u, r.nprimes, [t])
                }
                return H(e, t)
            }
        case ",":
            {
                let s = [t];
                for (; po(e, ",") && (e = Ze(e),
                !(po(e, "...") || e.opts.trailingComma && KX(e))); ) {
                    if ({state: e, tree: o} = Or(e, n),
                    o.type === "Err")
                        if (Is(o.error)) {
                            let a = Er(t.span, e)
                              , u = Ge(a, Wp(r.val));
                            return H(e, u)
                        } else
                            return H(e, o);
                    s.push(o)
                }
                return H(e, GT(Er(t.span, e), s))
            }
        case "...":
            {
                if (e = Ze(e),
                po(e, ",") && (e = Ze(e)),
                n >= x_(No(e).type))
                    return H(e, e_(Er(t.span, e), [t, aB(r_(e))]));
                if ({state: e, tree: o} = Or(e, n),
                o.type === "Err")
                    if (Is(o.error)) {
                        let s = Er(t.span, e)
                          , a = Ge(s, Wp(r.val));
                        return H(e, a)
                    } else
                        return H(e, o);
                return H(e, e_(Er(t.span, e), [t, o]))
            }
        case "]":
        case ")":
        case "\\}":
        case "|)":
        case "Differential":
            return I_(e);
        case "Err":
            return Or(e, n);
        case "End":
            {
                let s = ve(e, e)
                  , a = Ge(s, p_());
                return H(e, a)
            }
        default:
            throw `Unexpected token type ${r.type}.`
        }
    }
    function QX(e) {
        return !!(Sr(e) || e.type === "Prime" && Sr(e.args[0]))
    }
    function dG(e, t, n) {
        switch (e) {
        case "+":
            return HV(t, n);
        case "-":
            return UV(t, n);
        case "*":
            return kV(t, n);
        case "\\cdot":
            return $V(t, n);
        case "\\times":
            return YV(t, n);
        case "/":
            return ZV(t, n);
        case "~":
            return GV(t, n);
        case ":":
            return uB(t, n);
        case ".":
            switch (n[0].type) {
            case "Decimal":
            case "MixedNumber":
                throw nb();
            default:
                return pB(t, n)
            }
        case "->":
            return dB(t, n);
        case "for":
            return cB(t, n);
        case "with":
            return lB(t, n);
        default:
            throw `Unexpected token type ${e}.`
        }
    }
    function gG(e, t) {
        if (!e.sub)
            return;
        let n = e.sub
          , r = Fl(_c(n, t));
        return r.type === "Err" && r.error.type === "EmptyGroup" ? Ge(r.span, c_()) : r
    }
    function hG(e) {
        if (!e.sub)
            return;
        let t = e.sub;
        if (t.args.length === 0)
            return Ge(t.span, c_());
        let n = [];
        for (let r of t.args)
            if (r.type === "Digit" || r.type === "Letter")
                n.push(r.val);
            else {
                let o = r.span;
                return Ge(o, XB(Ir(o)))
            }
        return yB(t.span, n.join(""))
    }
    function XT(e, t) {
        if (!e.sup)
            return;
        let n = Fl(_c(e.sup, t));
        return n.type === "Err" ? n.error.type === "EmptyGroup" ? Ge(n.span, qB()) : n : e.nprimes > 0 ? Ge(e.span, JB()) : n
    }
    function b_(e, t, n) {
        if (e.type !== "SupSub") {
            let i = ve(t, n);
            return Ge(i, g_())
        }
        if (e.nprimes > 0) {
            let i = ve(t, n);
            return Ge(i, ZT())
        }
        let r = gG(e, n.opts)
          , o = XT(e, n.opts);
        if (!r || r.type === "Err" && r.error.type === "EmptySubscript" || !o || o.type === "Err" && o.error.type === "EmptySuperscript") {
            let i = ve(t, n);
            return Ge(i, g_())
        }
        return r.type === "Err" ? r : o.type === "Err" ? o : {
            type: "Bounds",
            sup: o,
            sub: r
        }
    }
    function gg(e) {
        if (e.opts.disableParentheses)
            throw qv();
        let t = e
          , n = No(e)
          , r = T_(n.type);
        if (po(e, "("))
            e = Ze(e);
        else
            throw new Error("Programming Error: expected '(' at start of parseParen.");
        if (po(e, ")")) {
            let i = GT(r_(e), []);
            e = Ze(e);
            let s = ve(t, e);
            return H(e, JD(s, [i]))
        }
        let o;
        return {state: e, tree: o} = Or(e, r),
        {state: e, tree: o} = hg(t, e, o, "(", ")"),
        o.type === "Err" ? H(e, o) : H(e, JD(ve(t, e), [o]))
    }
    function fG(e) {
        let t = e
          , n = No(e);
        if (n.type !== "Differential")
            throw new Error("Programming Error: expected differential");
        e = Ze(e);
        let r = Zp(n.span, n.val)
          , o = No(e);
        if (o.type === "SupSub") {
            e = Ze(e);
            let i = ve(t, e)
              , s = hG(o);
            if (s) {
                if (s.type === "Err")
                    return H(e, s);
                r = KD(i, [r, s])
            }
            if (o.sup)
                return H(e, Ge(i, sG()));
            if (o.nprimes > 0)
                return H(e, Ge(i, ZT()))
        }
        return H(e, r)
    }
    function hg(e, t, n, r, o) {
        if (n.type === "Err" && n.error.type !== "UnexpectedEnd")
            return H(t, n);
        if (n.type === "Err" || !po(t, o)) {
            let i = ve(e, t)
              , s = Ge(i, $B(r, o));
            return H(t, s)
        }
        return t = Ze(t),
        H(t, n)
    }
    function I_(e) {
        let t = e;
        switch (No(e).type) {
        case ")":
            {
                e = Ze(e);
                let r = ve(t, e);
                return H(e, Ge(r, yg("(", ")")))
            }
        case "]":
            {
                e = Ze(e);
                let r = ve(t, e);
                return H(e, Ge(r, yg("[", "]")))
            }
        case "\\}":
            {
                e = Ze(e);
                let r = ve(t, e);
                return H(e, Ge(r, yg("\\{", "\\}")))
            }
        case "|)":
            {
                e = Ze(e);
                let r = ve(t, e);
                return H(e, Ge(r, yg("|", "|")))
            }
        case "Differential":
            {
                e = Ze(e);
                let r = ve(t, e);
                return H(e, Ge(r, YB()))
            }
        default:
            {
                e = Ze(e);
                let r = ve(t, e);
                return H(e, Ge(r, VB()))
            }
        }
    }
    function KX(e) {
        return po(e, ")") || po(e, "]") || po(e, "\\}")
    }
    function Vl(e, t) {
        return vi(e.token.span, t.prevSpan)
    }
    function nc(e, t, n) {
        return {
            type: e,
            span: t,
            val: n
        }
    }
    function eW(e, t, n, r) {
        return {
            input: e,
            prevSpan: t,
            pos: n,
            token: r
        }
    }
    function bG(e) {
        return xG(e, 0, Va(e, 0))
    }
    function xG(e, t, n) {
        for (; LV(e.charCodeAt(t)); )
            t += 1;
        let r = nW(e, t);
        return eW(e, n, t, r)
    }
    function Sa(e) {
        return xG(e.input, e.token.span.end, e.token.span)
    }
    function su(e) {
        return e.token
    }
    function au(e, t) {
        if (su(e).type !== t)
            throw new Error(`Parse Error: expected ${t}.`);
        return Sa(e)
    }
    function P_(e, t) {
        return su(e).type === t
    }
    function WT(e) {
        return e.pos >= e.input.length
    }
    var tW = {
        "[": "[",
        "]": "]",
        "{": "{",
        "}": "}",
        "^": "^",
        _: "_"
    };
    function nW(e, t) {
        let n = t;
        if (t >= e.length)
            return nc("End", Va(e, t), "");
        let r = e.charCodeAt(t);
        if (wV(r)) {
            let o = Ci(e, n, t + 1);
            return nc("Digit", o, e.charAt(n))
        } else if (FT(r)) {
            let o = Ci(e, n, t + 1);
            return nc("Letter", o, e.charAt(n))
        } else if (VT(r))
            if (t += 1,
            FT(e.charCodeAt(t))) {
                for (; FT(e.charCodeAt(t)); )
                    t += 1;
                let o = Ci(e, n, t)
                  , i = Ir(o);
                return nc(i === "\\left" ? "Left" : i === "\\right" ? "Right" : "Cmd", o, i)
            } else {
                t += 1;
                let o = Ci(e, n, t)
                  , i = Ir(o);
                return nc("EscapedSymbol", o, i)
            }
        else if (WD(r)) {
            for (t += 1; WD(e.charCodeAt(t)); )
                t += 1;
            if (e.charAt(t) === "^") {
                t += 1;
                let o = Ci(e, n, t)
                  , i = Ir(o);
                return nc("Primes^", o, i)
            } else {
                let o = Ci(e, n, t)
                  , i = Ir(o);
                return nc("Primes", o, i)
            }
        } else {
            let o = Ci(e, n, t + 1)
              , i = e.charAt(n)
              , s = tW[i] || "Symbol";
            return nc(s, o, i)
        }
    }
    function S_(e, t) {
        return {
            type: "Group",
            span: e,
            args: t
        }
    }
    function TG(e, t, n) {
        return {
            type: "Sqrt",
            span: e,
            optArg: t,
            arg: n
        }
    }
    function IG(e, t, n) {
        return {
            type: "Frac",
            span: e,
            num: t,
            den: n
        }
    }
    function PG(e, t, n, r) {
        return {
            type: "SupSub",
            span: e,
            sup: t,
            sub: n,
            nprimes: r
        }
    }
    function SG(e, t, n, r) {
        return {
            type: "LeftRight",
            span: e,
            left: t,
            right: n,
            arg: r
        }
    }
    function EG(e, t) {
        return {
            type: "OperatorName",
            span: e,
            arg: t
        }
    }
    function CG(e, t) {
        return {
            type: "TokenNode",
            span: e,
            arg: t
        }
    }
    function vG(e, t) {
        return {
            type: "Symbol",
            span: e,
            val: t
        }
    }
    var E_ = {
        type: "primitive",
        errorName: "^"
    }
      , MG = {
        type: "primitive",
        errorName: "_"
    }
      , oW = {
        "\\frac": {
            type: "macro",
            errorName: "\\frac",
            expandsToSingleAtom: !0
        },
        "\\operatorname": {
            type: "macro",
            errorName: "\\operatorname",
            expandsToSingleAtom: !1
        },
        "\\token": {
            type: "macro",
            errorName: "\\token",
            expandsToSingleAtom: !1
        }
    };
    function DG(e) {
        let t = su(e);
        if (t.type === "Cmd")
            return t.val === "\\sqrt" ? P_(Sa(e), "[") ? {
                type: "macro",
                errorName: "\\sqrt[*]",
                expandsToSingleAtom: !1
            } : {
                type: "primitive",
                errorName: "\\sqrt"
            } : oW[t.val];
        if (t.type === "^" || t.type === "Primes^")
            return E_;
        if (t.type === "_")
            return MG
    }
    function _G(e) {
        let {state: t, tree: n} = jT(bG(e), !1);
        if (!WT(t))
            throw new Error(`Parse error: unexpected ${Ir(su(t).span)}.`);
        return n
    }
    function Zs(e, t) {
        return {
            state: e,
            tree: t
        }
    }
    function jT(e, t) {
        let n = e
          , r = [];
        e: for (; !WT(e); ) {
            let i = su(e);
            switch (i.type) {
            case "Cmd":
            case "EscapedSymbol":
            case "Letter":
            case "Digit":
            case "Symbol":
            case "[":
            case "{":
            case "^":
            case "_":
            case "Primes":
            case "Primes^":
            case "Left":
            case "]":
                {
                    if (i.type === "]" && t)
                        break e;
                    let a;
                    if ({state: e, tree: a} = RG(e),
                    a.type === "Group")
                        for (let u of a.args)
                            r.push(u);
                    else
                        r.push(a);
                    break
                }
            case "}":
            case "Right":
            case "End":
                break e;
            default:
                let s = i.type;
                throw new Error(`Unexpected token type ${s}.`)
            }
        }
        let o = Vl(n, e);
        return Zs(e, S_(o, r))
    }
    function RG(e) {
        let t = su(e);
        switch (t.type) {
        case "EscapedSymbol":
        case "Letter":
        case "Digit":
        case "Symbol":
            return e = Sa(e),
            Zs(e, t);
        case "[":
        case "]":
            return e = Sa(e),
            Zs(e, vG(t.span, t.val));
        case "{":
            {
                e = Sa(e);
                let r;
                return {state: e, tree: r} = jT(e, !1),
                e = au(e, "}"),
                Zs(e, r)
            }
        case "^":
        case "_":
        case "Primes":
        case "Primes^":
            return pW(e);
        case "Left":
            return lW(e);
        case "Cmd":
            return iW(e);
        case "}":
        case "Right":
            throw new Error(`Parse Error: unexpected ${t.val}.`);
        case "End":
            throw new Error("Parse Error: unexpected end.");
        default:
            let n = t.type;
            throw new Error(`Unexpected token type ${n}.`)
        }
    }
    function iW(e) {
        let t = DG(e)
          , n = su(e);
        if (!t)
            return e = au(e, "Cmd"),
            Zs(e, n);
        switch (n.val) {
        case "\\operatorname":
            return sW(e, t);
        case "\\token":
            return aW(e, t);
        case "\\sqrt":
            return uW(e, t);
        case "\\frac":
            return cW(e, t);
        default:
            throw new Error(`Unexpected command ${n.val}.`)
        }
    }
    function sW(e, t) {
        let n = e;
        e = au(e, "Cmd");
        let r;
        ({state: e, tree: r} = Bl(e, t));
        let o = Vl(n, e);
        return Zs(e, EG(o, r))
    }
    function aW(e, t) {
        let n = e;
        e = au(e, "Cmd");
        let r;
        ({state: e, tree: r} = Bl(e, t));
        let o = Vl(n, e);
        return Zs(e, CG(o, r))
    }
    function uW(e, t) {
        let n = e;
        e = au(e, "Cmd");
        let r;
        P_(e, "[") && ({state: e, tree: r} = mW(e));
        let o;
        ({state: e, tree: o} = Bl(e, t));
        let i = Vl(n, e);
        return Zs(e, TG(i, r, o))
    }
    function cW(e, t) {
        let n = e;
        e = au(e, "Cmd");
        let r;
        ({state: e, tree: r} = Bl(e, t));
        let o;
        ({state: e, tree: o} = Bl(e, t));
        let i = Vl(n, e);
        return Zs(e, IG(i, r, o))
    }
    function lW(e) {
        let t = e;
        e = au(e, "Left");
        let n = su(e);
        e = Sa(e);
        let r;
        ({state: e, tree: r} = jT(e, !1)),
        e = au(e, "Right");
        let o = su(e);
        e = Sa(e);
        let i = Vl(t, e);
        return Zs(e, SG(i, n, o, r))
    }
    function pW(e) {
        let t = e, n, r, o = 0;
        e: for (; !WT(e); ) {
            let s = su(e);
            switch (s.type) {
            case "^":
                if (e = Sa(e),
                n)
                    throw new Error("Parse Error: double superscript.");
                ({state: e, tree: n} = Bl(e, E_));
                break;
            case "_":
                if (e = Sa(e),
                r)
                    throw new Error("Parse Error: double subscript.");
                ({state: e, tree: r} = Bl(e, MG));
                break;
            case "Primes":
                if (e = Sa(e),
                o > 0)
                    throw new Error("Parse Error: double primes.");
                o = s.val.length;
                break;
            case "Primes^":
                if (e = Sa(e),
                o > 0)
                    throw new Error("Parse Error: double primes.");
                if (n)
                    throw new Error("Parse Error: double superscript");
                o = s.val.length - 1,
                {state: e, tree: n} = Bl(e, E_);
                break;
            default:
                break e
            }
        }
        let i = Vl(t, e);
        return Zs(e, PG(i, n, r, o))
    }
    function Bl(e, t) {
        let n, r = DG(e);
        if (r && (t.type !== "primitive" || !(r.type === "macro" && r.expandsToSingleAtom)))
            throw new Error(`Parse Error: can't use ${r.errorName} as argument of ${t.errorName}. Use {}.`);
        return {state: e, tree: n} = RG(e),
        n.type !== "Group" && (n = S_(n.span, [n])),
        Zs(e, n)
    }
    function mW(e) {
        e = au(e, "[");
        let t;
        return {state: e, tree: t} = jT(e, !0),
        e = au(e, "]"),
        Zs(e, t)
    }
    function dW() {
        throw Gv()
    }
    function NG(e, t) {
        return t && !e._inputSpan && e.setInputSpan(t),
        e
    }
    function C_(e) {
        try {
            let t = mi(e);
            return t instanceof ze ? t : F("TODO-jared-module: expected an identifer here.")
        } catch (t) {
            return F(t)
        }
    }
    function mi(e, t={}) {
        let n = typeof e;
        if (n !== "string")
            throw new Error(`Type Error: parse can only be called with strings, got ${JSON.stringify(e)} of type ${n}`);
        let r = O;
        if (t.disabledFeatures) {
            r = Object.create(r);
            for (let c of t.disabledFeatures) {
                if (!r[c])
                    throw new Error(`Programming Error: ${c} cannot be disabled because it is not a parsenode.`);
                r[c] = dW
            }
        }
        let o = t.seedPrefix === void 0 ? "" : t.seedPrefix
          , i = 0
          , s = () => {
            let c = `${o}::vc${i}`;
            return i += 1,
            c
        }
          , a = {};
        t.trailingComma !== void 0 && (a.trailingComma = t.trailingComma),
        t.disallowFrac && (a.disallowFrac = !0),
        t.disableParentheses && (a.disableParentheses = !0);
        function u(c) {
            return c.parseOptions = t,
            c
        }
        if (e === "")
            return u(iy());
        try {
            let c = _G(e)
              , l = yG(c, a)
              , p = _B({
                ...t,
                nodes: r,
                setInput: NG,
                nextSeed: s
            }, l);
            return p.parseOptions = t,
            p
        } catch (c) {
            let l;
            return c instanceof O.Error ? l = c : typeof c == "string" ? l = new O.Error(c) : l = F(c),
            u(l)
        }
    }
    var yW = ["Sum", "Product", "Integral", "List", "Derivative", "Piecewise", "Restriction", "Norm", "Exponent", "PercentOf", "FunctionDefinition", "UpdateRule", "Substitution", "ListComprehension"]
      , JT = {
        isGeometryEnabled() {
            return !1
        },
        is3dProduct() {
            return !1
        },
        is3dPolicy() {
            return !1
        },
        polygonUnsupportedPreferTriangle() {
            return !1
        },
        areAllScalesLinear() {
            return !0
        },
        assignmentForbidden(e) {
            return !0
        },
        graphingEnabled() {
            return !1
        },
        isValidSlider(e) {
            return !1
        },
        sliderVariables(e) {
            return []
        },
        ansEnabled() {
            return !1
        },
        disabledFeatures() {
            return yW
        },
        dimensionVarsEnabled() {
            return !1
        },
        shouldIncludeFunctionParametersInRandomSeed() {
            return !0
        },
        isComplexEnabled() {
            return !1
        },
        isRecursionEnabled() {
            return !1
        }
    }
      , OG = {
        ...JT,
        isComplexEnabled() {
            return !0
        }
    }
      , AG = {
        ...JT,
        isGeometryEnabled() {
            return !0
        },
        is3dProduct() {
            return !0
        },
        is3dPolicy() {
            return !0
        },
        isComplexEnabled() {
            return !1
        }
    };
    var jd = class e {
        constructor(t, n, r, o, i) {
            this.frame = t;
            this.dynamic = n;
            this.lexical = r;
            this.maxBindingIndex = o;
            this.compiledGlobalCache = i
        }
        static empty(t) {
            return new e(t,{},{},-1,{
                maxIndex: -1,
                entries: {}
            })
        }
        newModuleID(t) {
            let n = this.getVisibleGlobalDefinition(t);
            if (!n || !n.moduleID)
                return;
            let r = n.moduleID
              , o = CA(this.frame);
            if (r !== o)
                return r
        }
        resolve(t) {
            if (this.lexical[t])
                return this.lexical[t];
            if (this.dynamic[t])
                return this.dynamic[t];
            if (this.compiledGlobalCache.entries[t])
                return this.compiledGlobalCache.entries[t]
        }
        getSymbol(t) {
            let n = this.resolve(t);
            if (n)
                switch (n.type) {
                case "lexical":
                case "dynamic":
                case "free":
                    return n.value;
                case "global":
                    return n.value;
                case "error":
                    throw n.error;
                default:
                    throw new Error("Unexpected symbolMap entry type: " + n.type)
                }
        }
        getMaxIndex() {
            return Math.max(this.maxBindingIndex, this.compiledGlobalCache.maxIndex)
        }
        getParseNode(t) {
            let n = this.resolve(t);
            if (n)
                switch (n.type) {
                case "global":
                case "lexical":
                case "dynamic":
                    return n.node;
                case "error":
                case "free":
                    return;
                default:
                    throw new Error("Unexpected symbolMap entry type: " + n.type)
                }
        }
        addLexicalBinding(t, n, r) {
            this.addScopeEntry(t, {
                type: "lexical",
                value: n,
                node: r
            })
        }
        addDynamicBinding(t, n, r) {
            this.addScopeEntry(t, {
                type: "dynamic",
                value: n,
                node: r
            })
        }
        cacheGlobal(t, n, r) {
            this.compiledGlobalCache.entries[t] = {
                type: "global",
                value: n,
                node: r
            },
            this.compiledGlobalCache.maxIndex = Math.max(this.compiledGlobalCache.maxIndex, n)
        }
        setFreeVariable(t, n) {
            this.addScopeEntry(t, {
                type: "free",
                value: n
            })
        }
        setErrorIfAccessed(t, n) {
            this.addScopeEntry(t, {
                type: "error",
                error: n
            })
        }
        addScopeEntry(t, n) {
            var s;
            let r = this.lexical, o = this.dynamic, i;
            switch (n.type) {
            case "lexical":
                {
                    r[t] = n,
                    this.frame[t] === void 0 && ((s = this.dynamic[t]) == null ? void 0 : s.type) !== "dynamic" ? (o[t] = n,
                    i = !0) : i = !1;
                    break
                }
            case "dynamic":
                {
                    o[t] = n,
                    r[t] = {
                        type: "lexical",
                        value: n.value,
                        node: n.node
                    },
                    i = !0;
                    break
                }
            case "error":
                {
                    o[t] = n,
                    i = !0;
                    break
                }
            case "free":
                {
                    o[t] = n,
                    i = !0;
                    break
                }
            default:
                throw new Error("Unexpected symbolMap entry type: " + n.type)
            }
            n.type !== "error" && (this.maxBindingIndex = Math.max(this.maxBindingIndex, n.value)),
            i && (this.compiledGlobalCache = {
                maxIndex: -1,
                entries: {}
            })
        }
        isLocal(t) {
            let n = this.resolve(t);
            return (n == null ? void 0 : n.type) === "lexical" || (n == null ? void 0 : n.type) === "dynamic"
        }
        isGlobal(t) {
            return this.frame[t] !== void 0 && !this.isLocal(t)
        }
        isError(t) {
            var r;
            let n = this.resolve(t);
            return n ? n.type === "error" : ((r = this.frame[t]) == null ? void 0 : r.type) === "Error"
        }
        isDefined(t) {
            return this.isLocal(t) || this.isGlobal(t)
        }
        getVisibleGlobalDefinition(t) {
            let n = this.resolve(t);
            if (!n)
                return wG(this.frame[t]);
            switch (n.type) {
            case "lexical":
            case "dynamic":
            case "free":
                return;
            case "global":
                return wG(this.frame[t]);
            case "error":
                throw n.error;
            default:
                throw new Error("Unexpected symbolMap entry type: " + n.type)
            }
        }
        childScope() {
            return new e(this.frame,Fn(this.dynamic),Fn(this.lexical),this.maxBindingIndex,this.compiledGlobalCache)
        }
        childScopeWithChildGlobalCache() {
            return new e(this.frame,Fn(this.dynamic),Fn(this.lexical),this.maxBindingIndex,{
                maxIndex: this.compiledGlobalCache.maxIndex,
                entries: Fn(this.compiledGlobalCache.entries)
            })
        }
        newLexicalScope() {
            return new e(this.frame,Fn(this.dynamic),{},this.maxBindingIndex,this.compiledGlobalCache)
        }
        newScopeAcrossModuleBoundary(t) {
            let n = IA(this.frame)
              , r = n.getFrame(t)
              , o = n.getPolicyContextForFrame(t).policy
              , i = new e(r,Fn(this.dynamic),{},this.maxBindingIndex,{
                maxIndex: 0,
                entries: {}
            });
            return {
                newPolicy: o,
                newScope: i
            }
        }
    }
    ;
    function wG(e) {
        if ((e == null ? void 0 : e.type) === "Error")
            throw e;
        return e
    }
    function Rc(e, t, n, r) {
        return Gl({
            chunk: e,
            argMap: [t],
            start: n,
            unpatchedHeaderMap: new Map,
            processedHeaders: new Set
        }, r)
    }
    function gW(e, t) {
        let {chunk: n} = e
          , r = n.getInstruction(t)
          , o = [];
        for (let i of r.recursionGroup) {
            let s = e.unpatchedHeaderMap.get(i);
            if (s === void 0)
                throw new Error("Programming Error: `substitute` did not include all headers in a recursion group.");
            o.push(s)
        }
        for (let i of r.recursionGroup)
            e.unpatchedHeaderMap.delete(i);
        for (let i of o)
            n.getInstruction(i).recursionGroup = o
    }
    function Gl(e, t) {
        let {chunk: n, argMap: r, start: o} = e;
        if (t < o)
            return t;
        let i = r[t - o];
        if (i !== void 0)
            return i;
        let s = hW(e, t);
        e.argMap[t - o] = s;
        let a = n.getInstruction(t);
        if (a.type === 4) {
            let u = s;
            e.unpatchedHeaderMap.set(t, u),
            e.processedHeaders.add(t);
            for (let c of a.recursionGroup)
                e.processedHeaders.has(c) || Gl(e, c);
            return Gl(e, a.endIndex),
            u
        }
        if (Po(a))
            switch (a.type) {
            case 23:
            case 21:
            case 50:
                break;
            case 19:
                {
                    let c = a.args.length - 2;
                    for (let l = 0; l < c; l++)
                        Gl(e, t + 1 + l);
                    break
                }
            case 53:
                {
                    let l = n.getInstruction(a.args[0]).signature.argTypes.length;
                    for (let p = 0; p < l; p++)
                        Gl(e, t + 1 + p);
                    break
                }
            default:
                let u = a;
                throw new Error(`Programming Error. Unexpected OpCode: ${u.type}`)
            }
        else if (sx(a)) {
            let u = a.args.length - 1;
            for (let c = 0; c < u; c++)
                Gl(e, t + 1 + c)
        }
        return s
    }
    function hW(e, t) {
        let {chunk: n, start: r} = e
          , o = n.getInstruction(t);
        if (Bo(o)) {
            let a = o.args[0];
            for (let u = a; u <= t; u++) {
                let c = n.getInstruction(u);
                if (de(c))
                    for (let l of c.args)
                        l < a && Gl(e, l)
            }
        }
        if (o.type === 4)
            return n.FunctionHeader(o.symbol, o.valueType, o.signature, o.parameterSymbols);
        if (!de(o))
            return n.copyLeafInstruction(o);
        let i = [];
        for (let a of o.args)
            i.push(Gl(e, a));
        let s = e.argMap[t - r];
        if (s !== void 0)
            return s;
        if (o.type === 55 && !cx(n, t)) {
            let a = o.args[0];
            e.unpatchedHeaderMap.has(a) && gW(e, a)
        }
        return n.copyInstructionWithArgs(o, i)
    }
    function KT(e, t, n, r) {
        let o = Vp(e, t)
          , i = e.Constant(0);
        if (t < n)
            return i;
        let s = e.Constant(1)
          , a = e.Constant(NaN)
          , u = yl(e, n)
          , c = GA(e, o)
          , l = e.derivativeMaps.getMapEntry(e, r, n)
          , {map: p, maxValidReference: m} = l;
        for (let x = 0; x < p.length; x++) {
            let T = p[x];
            T !== void 0 && T > m && (p[x] = void 0)
        }
        let d = !1
          , y = e.instructionsLength() - 1;
        for (let x = 0; x < n; x++)
            p[x] = i;
        let g = new zo(e,n,y)
          , f = oo(e, o);
        return eI({
            chunk: e,
            derivativeVarIndex: n,
            forwardSeed: r,
            forwardMask: u,
            backwardMask: c,
            referenced: f,
            copyCtx: g,
            derivativeMap: p,
            mustCopy: d,
            ZERO: i,
            ONE: s,
            NAN: a
        }, n, o),
        l.maxValidReference = e.instructionsLength() - 1,
        p[o]
    }
    function eI(e, t, n) {
        let {chunk: r, copyCtx: o, derivativeMap: i, backwardMask: s} = e;
        for (let a = t; a <= n; a++) {
            let u = i[a];
            if (u !== void 0)
                if (r.getInstruction(u).type === 0)
                    i[a] = void 0;
                else {
                    o.markMappedIndex(a, QT(e, a));
                    continue
                }
            if (!s[a]) {
                o.markMappedIndex(a, QT(e, a));
                continue
            }
            let c = r.getInstruction(a);
            if (Po(c) && c.endIndex !== -1)
                switch (c.type) {
                case 21:
                    {
                        a = bW(e, a);
                        continue
                    }
                case 19:
                case 23:
                    {
                        a = IW(e, a);
                        continue
                    }
                case 53:
                    {
                        a = SW(e, a);
                        continue
                    }
                }
            o.markMappedIndex(a, QT(e, a)),
            i[a] = EW(e, a)
        }
        return n
    }
    function bW(e, t) {
        let {chunk: n, forwardMask: r, copyCtx: o, derivativeMap: i, ZERO: s} = e
          , a = n.getInstruction(t)
          , u = a.endIndex
          , c = n.getInstruction(u)
          , l = s;
        if (r[a.args[1]]) {
            let p = o.mapIndex(a.args[1]);
            l = n.Add([l, n.Multiply([i[a.args[1]], Rc(n, p, t, c.args[1])])])
        }
        if (r[a.args[0]]) {
            let p = o.mapIndex(a.args[0]);
            l = n.Subtract([l, n.Multiply([i[a.args[0]], Rc(n, p, t, c.args[1])])])
        }
        if (xW(n, t, r)) {
            let p = o.clone()
              , m = n.copyInstructionWithArgs(a, p.mapArgs(a.args));
            p.markMappedIndex(t, m),
            i[t] = s,
            eI({
                ...e,
                copyCtx: p,
                mustCopy: !0
            }, t + 1, u - 1);
            let d = n.copyInstructionWithArgs(c, [p.mapIndex(c.args[0]), i[c.args[1]]]);
            i[u] = d,
            l = n.Add([l, n.copyInstructionWithArgs(n.getInstruction(u + 1), [d])])
        } else
            for (let p = t; p <= u; p++)
                i[p] = s;
        if (TW(n, t, o)) {
            let p = {
                ...e,
                mustCopy: !0
            };
            for (let m = t; m <= u + 1; m++)
                o.markMappedIndex(m, QT(p, m))
        } else
            for (let p = t; p <= u + 1; p++)
                o.markMappedIndex(p, p);
        return i[u + 1] = l,
        u + c.args.length - 1
    }
    function xW(e, t, n) {
        let r = e.getInstruction(t)
          , o = e.getInstruction(r.endIndex);
        if (o.args[1] < t + 1)
            return n[o.args[1]];
        for (let i = t + 1; i <= o.args[1]; i++) {
            let s = e.getInstruction(i);
            if (de(s)) {
                for (let a of s.args)
                    if (a < t && n[a])
                        return !0
            }
        }
        return !1
    }
    function TW(e, t, n) {
        let r = e.getInstruction(t);
        for (let o = t; o <= r.endIndex; o++) {
            let i = e.getInstruction(o);
            if (de(i)) {
                for (let s of i.args)
                    if (n.mapIndex(s) !== s)
                        return !0
            }
        }
        return !1
    }
    function IW(e, t) {
        let {chunk: n, derivativeMap: r, copyCtx: o, ZERO: i} = e, s = n.getInstruction(t), a = s.endIndex, u = n.getInstruction(a), c;
        if (s.type === 23)
            o.markMappedIndex(t, n.copyInstructionWithArgs(s, [o.mapIndex(s.args[0])])),
            r[t] = i,
            c = t + 1;
        else {
            let p = [];
            p.push(o.mapIndex(s.args[0]), o.mapIndex(s.args[1]));
            for (let m = 2; m < s.args.length; m++)
                p.push(o.mapIndex(s.args[m]), r[s.args[m]]);
            o.markMappedIndex(t, n.copyInstructionWithArgs(s, p)),
            r[t] = i;
            for (let m = 2; m < s.args.length; m++) {
                let d = t + m - 1;
                o.markMappedIndex(d, n.copyInstructionWithArgs(n.getInstruction(d), [o.mapIndex(t)])),
                r[d] = n.copyInstructionWithArgs(n.getInstruction(d), [o.mapIndex(t)])
            }
            c = t + s.args.length - 1
        }
        eI({
            ...e,
            mustCopy: !0
        }, c, a - 1);
        let l = [];
        l.push(o.mapIndex(u.args[0]));
        for (let p = 1; p < u.args.length; p++)
            l.push(o.mapIndex(u.args[p]), r[u.args[p]]);
        o.markMappedIndex(a, n.copyInstructionWithArgs(u, l)),
        r[a] = i;
        for (let p = 1; p < u.args.length; p++) {
            let m = a + p;
            o.markMappedIndex(m, n.copyInstructionWithArgs(n.getInstruction(m), [o.mapIndex(a)])),
            r[m] = n.copyInstructionWithArgs(n.getInstruction(m), [o.mapIndex(a)])
        }
        return a + u.args.length - 1
    }
    function QT(e, t) {
        let {chunk: n, copyCtx: r, mustCopy: o, referenced: i} = e;
        if (!i[t])
            return t;
        let s = n.getInstruction(t);
        if (de(s)) {
            let a = []
              , u = !1;
            for (let c of s.args) {
                let l = r.mapIndex(c);
                a.push(l),
                l !== c && (u = !0)
            }
            return u || o ? n.copyInstructionWithArgs(s, a) : t
        } else
            return o ? r.copyLeafOrFunctionHeader(s) : t
    }
    function PW(e, t) {
        let {chunk: n, derivativeMap: r} = e
          , o = n.getInstruction(t)
          , i = []
          , s = o.recursionGroup;
        for (let a of s) {
            let u = n.getInstruction(a)
              , c = {
                argTypes: []
            };
            for (let p of u.signature.argTypes)
                c.argTypes.push(p, p);
            let l = r[a];
            l || (l = n.FunctionHeader(u.symbol + `_\u2202${e.derivativeVarIndex}`, u.valueType, c, u.parameterSymbols),
            i.push(l)),
            e.derivativeMap[a] = l
        }
        for (let a of i) {
            let u = n.getInstruction(a);
            u.recursionGroup = i
        }
        return e.derivativeMap[t]
    }
    function SW(e, t) {
        let {chunk: n, copyCtx: r, derivativeMap: o} = e
          , s = n.getInstruction(t).args[0]
          , a = n.getInstruction(s)
          , u = a.endIndex
          , l = n.getInstruction(u).args[1]
          , p = o[s]
          , m = n.BeginFunction([p]);
        o[t] = m;
        let d = a.signature.argTypes
          , y = [];
        for (let T = 0; T < d.length; T++) {
            let P = d[T]
              , C = t + T + 1;
            y.push(C);
            let S = n.BlockVar(P, [m])
              , E = n.BlockVar(P, [m]);
            r.markMappedIndex(C, S),
            o[C] = E
        }
        let g = t + d.length + 1
          , f = u - 1
          , h = qu(n, y, g, f)
          , x = r.clone();
        return x.markMappedIndex(s, s),
        eI({
            ...e,
            copyCtx: x,
            mustCopy: !0,
            forwardMask: h
        }, g, f),
        n.EndFunction([m, o[l]]),
        u
    }
    function EW(e, t) {
        let {chunk: n, derivativeVarIndex: r, forwardSeed: o, forwardMask: i, copyCtx: s, derivativeMap: a, ZERO: u, ONE: c, NAN: l} = e
          , p = n.getInstruction(t);
        if (t === r) {
            let d;
            switch (o) {
            case "real":
                d = c;
                break;
            case "complexOne":
                d = n.NativeFunction("complex", [c, u]);
                break;
            case "complexI":
                d = n.NativeFunction("complex", [u, c]);
                break
            }
            if (X(p.valueType)) {
                let y = Pr(n, t)
                  , g = n.BeginBroadcast([y])
                  , f = n.EndBroadcast([g, d]);
                return n.BroadcastResult(p.valueType, [f])
            } else
                return d
        }
        if (Po(p) || Bo(p) || p.type === 47 || p.type === 48 || p.type === 25 || p.type === 27 || p.type === 26 || p.type === 29 || p.type === 28 || p.type === 32 || p.type === 31 || p.type === 42 || p.type === 44 || p.type === 49 || p.valueType === _t)
            return u;
        if (p.type === 4)
            return PW(e, t);
        if (!i[t] || VA(p))
            return p.valueType !== b ? vW(n, [s.mapIndex(t), u]) : p.type !== 1 || isFinite(L(p.value)) ? u : l;
        if (p.type === 38 || p.type === 15) {
            let d = [];
            for (let y of p.args)
                d.push(a[y]);
            return n.copyInstructionWithArgs(p, d)
        }
        if (p.type === 33)
            return n.copyInstructionWithArgs(p, [s.mapIndex(p.args[0]), a[p.args[1]], a[p.args[2]]]);
        if (p.type === 55) {
            let d = n.getInstruction(p.args[0]);
            if (d.endIndex === -1)
                throw xE(d.symbol);
            let g = [a[p.args[0]]];
            for (let f of p.args.slice(1)) {
                g.push(s.mapIndex(f));
                let h = a[f];
                if (h === u) {
                    let x = n.getInstruction(f).valueType;
                    wN(x) && (h = n.ZeroOfType(x))
                }
                g.push(h)
            }
            return n.FunctionCall(g)
        }
        let m = u;
        for (let d = 0; d < p.args.length; d++) {
            if (!i[p.args[d]])
                continue;
            let y = a[p.args[d]];
            if (y === u)
                continue;
            let g = CW(e, s.mapIndex(t), d, y);
            g !== u && (m = m === u ? g : MW(n, [g, m]))
        }
        return m
    }
    function CW(e, t, n, r) {
        let {chunk: o, ZERO: i, ONE: s, NAN: a} = e
          , u = o.getInstruction(t);
        switch (u.type) {
        case 8:
            return r;
        case 9:
            switch (n) {
            case 0:
                return r;
            default:
                return o.Negative([r])
            }
        case 10:
            switch (n) {
            case 0:
                return o.Multiply([r, u.args[1]]);
            default:
                return o.Multiply([u.args[0], r])
            }
        case 11:
            switch (n) {
            case 0:
                return o.Divide([r, u.args[1]]);
            default:
                return o.Multiply([u.args[0], o.Divide([o.Negative([r]), o.Square([u.args[1]])])])
            }
        case 14:
            return o.Negative([r]);
        case 56:
            return o.Multiply([o.Constant(2), o.Multiply([u.args[0], r])]);
        case 12:
        case 13:
            switch (n) {
            case 0:
                return o.Multiply([o.Multiply([u.args[1], o.Exponent([u.args[0], o.Subtract([u.args[1], s])])]), r]);
            default:
                return o.Multiply([o.Piecewise([o.Equal([u.args[0], i]), o.Piecewise([o.GreaterEqual([u.args[1], i]), i, a]), o.Multiply([o.NativeFunction("ln", [u.args[0]]), t])]), r])
            }
        case 37:
            return DW(o, t, FG[u.symbol][n], r);
        case 39:
        case 40:
        case 41:
            switch (n) {
            case 0:
                return o.copyInstructionWithArgs(u, [r, u.args[1]]);
            default:
                return i
            }
        case 16:
            return o.copyInstructionWithArgs(u, [r]);
        default:
            {
                let c = u;
                throw new Error(`Unimplemented derivative for opcode ${c.type}`)
            }
        }
    }
    function vW(e, t) {
        switch (e.getInstruction(t[0]).valueType) {
        case Ee:
            return e.NativeFunction("scaleTangentSegment", t);
        case Ce:
            return e.NativeFunction("scaleTangentLine", t);
        case Ae:
            return e.NativeFunction("scaleTangentRay", t);
        case he:
            return e.NativeFunction("scaleTangentCircle", t);
        case ce:
            return e.NativeFunction("scaleTangentArc", t);
        case Oe:
            return e.NativeFunction("scaleTangentUndirectedAngleMarker", t);
        case Se:
            return e.NativeFunction("scaleTangentDirectedAngleMarker", t);
        case De:
            return e.NativeFunction("scaleTangentPolygon", t);
        case we:
            return e.NativeFunction("scaleTangentTransformation", t);
        default:
            return e.Multiply(t)
        }
    }
    function MW(e, t) {
        switch (e.getInstruction(t[0]).valueType) {
        case Ee:
            return e.NativeFunction("addTangentSegment", t);
        case en:
            return e.NativeFunction("addTangentSegmentThreeD", t);
        case Ce:
            return e.NativeFunction("addTangentLine", t);
        case Ae:
            return e.NativeFunction("addTangentRay", t);
        case Ie:
            return e.NativeFunction("addTangentVector", t);
        case he:
            return e.NativeFunction("addTangentCircle", t);
        case ce:
            return e.NativeFunction("addTangentArc", t);
        case Oe:
            return e.NativeFunction("addTangentUndirectedAngleMarker", t);
        case Se:
            return e.NativeFunction("addTangentDirectedAngleMarker", t);
        case De:
            return e.NativeFunction("addTangentPolygon", t);
        case we:
            return e.NativeFunction("addTangentTransformation", t);
        default:
            return e.Add(t)
        }
    }
    function DW(e, t, n, r) {
        let o = jd.empty(rt)
          , s = e.getInstruction(t).args;
        for (let a = 0; a < s.length; a++) {
            let u = _W[a];
            o.addLexicalBinding(u, s[a])
        }
        return o.addLexicalBinding("x_1", r),
        o.addLexicalBinding("q", t),
        Re(v_(AG, e, o, bg.root, void 0, void 0), n)
    }
    var _W = ["x", "y", "z", "u", "v"]
      , LG = {
        exp: ["q*x_1"],
        complexExp: ["q*x_1"],
        ln: ["\\{x >= 0: x_1/x \\}"],
        complexLn: ["x_1/x"],
        log: ["\\{x >= 0: x_1/(x*\\ln(10)) \\}"],
        complexLog: ["x_1/(x*\\ln(10))"],
        sqrt: ["x_1/(2*q)"],
        complexSqrt: ["x_1/(2*q)"],
        complexPow: ["y*\\complexPow(x,y-1)*x_1", "q*\\complexLn(x)*x_1"],
        rtxsqpone: ["x*x_1/q"],
        rtxsqmone: ["x*x_1/q"],
        sin: ["\\cos(x)*x_1"],
        complexSin: ["\\cos(x)*x_1"],
        cos: ["-\\sin(x)*x_1"],
        complexCos: ["-\\sin(x)*x_1"],
        tan: ["(1+q^2)*x_1"],
        complexTan: ["(s*s)*x_1 \\with s=\\sec(x)"],
        arcsin: ["x_1/\\sqrt{1 - x^2}"],
        complexArcsin: ["x_1/(\\complexSqrt(1+x)\\complexSqrt(1-x))"],
        arccos: ["-x_1/\\sqrt{1 - x^2}"],
        complexArccos: ["-x_1/(\\complexSqrt(1+x)\\complexSqrt(1-x))"],
        sinh: ["\\cosh(x)*x_1"],
        complexSinh: ["\\cosh(x)*x_1"],
        cosh: ["\\sinh(x)*x_1"],
        complexCosh: ["\\sinh(x)*x_1"],
        tanh: ["(\\sech(x))^2*x_1"],
        complexTanh: ["(s*s)*x_1 \\with s=\\sech(x)"],
        arcsinh: ["x_1/\\rtxsqpone(x)"],
        complexArcsinh: ["x_1/(\\complexSqrt(1+\\complex(0,1)x)\\complexSqrt(1-\\complex(0,1)x))"],
        arccosh: ["\\{ x > 0: x_1/\\rtxsqmone(x) \\}"],
        complexArccosh: ["x_1/(\\complexSqrt(x+1)\\complexSqrt(x-1))"],
        arctanh: ["\\{ \\abs(x) < 1: x_1/(1 - x^2) \\}"],
        complexArctanh: ["x_1/((1+x)(1-x))"],
        csc: ["-\\cot(x)*q*x_1"],
        complexCsc: ["-\\cot(x)*q*x_1"],
        sec: ["\\tan(x)*q*x_1"],
        complexSec: ["\\tan(x)*q*x_1"],
        cot: ["-(1+q^2)*x_1"],
        complexCot: ["-(c*c)*x_1 \\with c=\\csc(x)"],
        arccsc: ["-x_1/(\\abs(x)*\\rtxsqmone(x))"],
        complexArccsc: ["-x_1/((x\\complexSqrt(1-1/x))(x\\complexSqrt(1+1/x)))"],
        arcsec: ["x_1/(\\abs(x)*\\rtxsqmone(x))"],
        complexArcsec: ["x_1/((x\\complexSqrt(1-1/x))(x\\complexSqrt(1+1/x)))"],
        arccot: ["-x_1/(1+x^2)"],
        complexArccot: ["-x_1/((x+\\complex(0,1))(x-\\complex(0,1)))"],
        csch: ["-\\coth(x)*q*x_1"],
        complexCsch: ["-\\coth(x)*q*x_1"],
        sech: ["-\\tanh(x)*q*x_1"],
        complexSech: ["-\\tanh(x)*q*x_1"],
        coth: ["-(\\csch(x))^2*x_1"],
        complexCoth: ["-(c*c)*x_1 \\with c=\\csch(x)"],
        arccsch: ["-x_1/(\\abs(x)*\\rtxsqpone(x))"],
        complexArccsch: ["-x_1/((x\\complexSqrt(1+\\complex(0,1)/x))(x\\complexSqrt(1-\\complex(0,1)/x)))"],
        arcsech: ["\\{ x >= 0: -x_1/(x*\\sqrt{1 - x^2}) \\}"],
        complexArcsech: ["-x_1/((x\\complexSqrt((1-x)/(1+x)))(1+x))"],
        arccoth: ["\\{ \\abs(x) > 1 : x_1/(1 - x^2) \\}"],
        complexArccoth: ["x_1/((1+x)(1-x))"],
        factorial: ["q*\\polyGamma(0, x + 1)*x_1"],
        floor: ["\\{ q=x: 0/0, 0*x_1 \\}"],
        complexFloor: ["\\{ \\real(d) + \\imag(d) = 0: 0/0, \\imag(d) - \\real(d) = 1: 0/0, 0*x_1 \\} \\with d = x - q"],
        ceil: ["\\{ q=x: 0/0, 0*x_1 \\}"],
        complexCeil: ["\\{ \\real(d) + \\imag(d) = 0: 0/0, \\imag(d) - \\real(d) = -1: 0/0, 0*x_1 \\} \\with d = x - q"],
        round: ["\\{ \\abs(\\mod(x, 1) - 0.5) > 0: 0*x_1 \\}"],
        complexRound: ["\\{ \\real(q) - \\real(x) = 0.5: 0/0, \\imag(q) - \\imag(x) = 0.5: 0/0, 0*x_1 \\}"],
        abs: ["\\{ x=0: 0/0, \\sign(x)*x_1 \\}"],
        sign: ["\\{ x=0: 0/0, 0*x_1 \\}"],
        distance: ["-((y.x-x.x)*x_1.x+(y.y-x.y)*x_1.y)/q", "((y.x-x.x)*x_1.x+(y.y-x.y)*x_1.y)/q"],
        distanceThreeD: ["-((y.x-x.x)*x_1.x+(y.y-x.y)*x_1.y+(y.z-x.z)*x_1.z)/q", "((y.x-x.x)*x_1.x+(y.y-x.y)*x_1.y+(y.z-x.z)*x_1.z)/q"],
        segmentThreeD: ["\\segmentThreeD(x_1,(0,0,0))", "\\segmentThreeD((0,0,0),x_1)"],
        vectorThreeD: ["\\vectorThreeD(x_1,(0,0,0))", "\\vectorThreeD((0,0,0),x_1)"],
        triangle: ["\\triangle(x_1,(0,0,0),(0,0,0))", "\\triangle((0,0,0),x_1,(0,0,0))", "\\triangle((0,0,0),(0,0,0),x_1)"],
        sphere: ["\\sphere(x_1,0)", "\\sphere((0,0,0),x_1)"],
        pointDet: ["\\pointDet(x_1,y)", "\\pointDet(x,x_1)"],
        pointDot: ["\\pointDot(x_1,y)", "\\pointDot(x,x_1)"],
        pointPerp: ["\\pointPerp(x_1)"],
        complexMultiplyPoints: ["\\complexMultiplyPoints(x_1,y)", "\\complexMultiplyPoints(x,x_1)"],
        segment: ["\\segment(x_1,(0,0))", "\\segment((0,0),x_1)"],
        line: ["\\line(x_1,(0,0))", "\\line((0,0),x_1)"],
        ray: ["\\ray(x_1,(0,0))", "\\ray((0,0),x_1)"],
        vector: ["\\vector(x_1, (0,0))", "\\vector((0,0), x_1)"],
        mathVector: ["\\mathVector(x_1,(0,0))", "\\mathVector((0,0),x_1)"],
        mathVectorThreeD: ["\\mathVectorThreeD(x_1,(0,0,0))", "\\mathVectorThreeD((0,0,0),x_1)"],
        rawTransform: ["\\rawTransform(x_1,(0,0))", "\\rawTransform((0,0),x_1)"],
        rawTransformConj: ["\\rawTransformConj(x_1,(0,0))", "\\rawTransformConj((0,0),x_1)"],
        transformWithoutTranslation: ["\\transformWithoutTranslation(x_1)"],
        transformScaleFactor: ["\\transformScaleFactor(x_1)"],
        vectorDisplacementAsPoint: ["\\vectorDisplacementAsPoint(x_1)"],
        vectorThreeDDisplacementAsPoint: ["\\vectorThreeDDisplacementAsPoint(x_1)"],
        basePointFromVector: ["\\basePointFromVector(x_1)"],
        basePointFromVectorThreeD: ["\\basePointFromVectorThreeD(x_1)"],
        circle: ["\\circle(x_1,0)", "\\circle((0,0),x_1)"],
        arc: ["\\arc(x_1,(0,0),(0,0))", "\\arc((0,0),x_1,(0,0))", "\\arc((0,0),(0,0),x_1)"],
        arcCenter: ["(\\pointDot(q-p1,p1_1)\\pointPerp(v_2)+\\pointDot(q-p2,p2_1)\\pointPerp(v_3)+\\pointDot(q-p3,p3_1)\\pointPerp(v_1))/\\pointDet(v_2,v_1) \\with v_1=p2-p1,v_2=p3-p2,v_3=p1-p3".replace(/p1_1/g, "\\arcFirstPoint(x_1)").replace(/p2_1/g, "\\arcMiddlePoint(x_1)").replace(/p3_1/g, "\\arcThirdPoint(x_1)").replace(/p1/g, "\\arcFirstPoint(x)").replace(/p2/g, "\\arcMiddlePoint(x)").replace(/p3/g, "\\arcThirdPoint(x)")],
        arcFirstPoint: ["\\arcFirstPoint(x_1)"],
        arcMiddlePoint: ["\\arcMiddlePoint(x_1)"],
        arcThirdPoint: ["\\arcThirdPoint(x_1)"],
        arcOmega: ["2 * (X_1*Y/(Y*Y+X*X) - Y_1*X/(Y*Y+X*X))".replace(/X_1/g, "((v1x * v2y_1 + v1x_1 * v2y) - (v2x_1 * v1y + v2x * v1y_1))").replace(/Y_1/g, "((v1x * v2x_1 + v1x_1 * v2x) + (v1y_1 * v2y + v1y * v2y_1))").replace(/X/g, "(v1x * v2y - v2x * v1y)").replace(/Y/g, "(v1x * v2x + v1y * v2y)").replace(/v1x_1/g, "(\\arcMiddlePoint(x_1) - \\arcFirstPoint(x_1)).x").replace(/v2x_1/g, "(\\arcThirdPoint(x_1) - \\arcMiddlePoint(x_1)).x").replace(/v1y_1/g, "(\\arcMiddlePoint(x_1) - \\arcFirstPoint(x_1)).y").replace(/v2y_1/g, "(\\arcThirdPoint(x_1) - \\arcMiddlePoint(x_1)).y").replace(/v1x/g, "(\\arcMiddlePoint(x) - \\arcFirstPoint(x)).x").replace(/v2x/g, "(\\arcThirdPoint(x) - \\arcMiddlePoint(x)).x").replace(/v1y/g, "(\\arcMiddlePoint(x) - \\arcFirstPoint(x)).y").replace(/v2y/g, "(\\arcThirdPoint(x) - \\arcMiddlePoint(x)).y")],
        center: ["\\center(x_1)"],
        radius: ["\\radius(x_1)"],
        undirectedAngleMarker: ["\\undirectedAngleMarker(x_1)"],
        directedAngleMarker: ["\\directedAngleMarker(x_1,0,0,0)", "\\directedAngleMarker((0,0),x_1,0,0)", "\\directedAngleMarker((0,0),0,x_1,0)", "\\directedAngleMarker((0,0),0,0,x_1)"],
        directedCoterminalAngle: ["\\directedAngleMarker((0,0),0,\\directedAngleMarkerRawDelta(x_1),0)"],
        undirectedCoterminalAngle: ["\\undirectedAngleMarker(\\directedAngleMarker((0,0),0,\\undirectedAngleMarkerRawDelta(x_1),0))"],
        supplement: ["\\directedAngleMarker((0,0),0,-\\directedAngleMarkerRawDelta(x_1),0)"],
        directedAngleMarkerMultiplier: ["\\directedAngleMarkerMultiplier(x_1)"],
        undirectedAngleMarkerMultiplier: ["\\undirectedAngleMarkerMultiplier(x_1)"],
        directedAngleMarkerRawDelta: ["\\directedAngleMarkerRawDelta(x_1)"],
        undirectedAngleMarkerRawDelta: ["\\undirectedAngleMarkerRawDelta(x_1)"],
        polygonInteriorUndirectedAngles: ["\\polygonInteriorUndirectedAngles(x_1)"],
        polygonInteriorDirectedAngles: ["\\polygonInteriorDirectedAngles(x_1)"],
        lineFromSegment: ["\\lineFromSegment(x_1)"],
        lineFromRay: ["\\lineFromRay(x_1)"],
        segmentGlider: ["\\segmentGlider(x_1,y)", "\\{0<y<1:(\\segmentGlider(x,1)-\\segmentGlider(x,0))*x_1,(0,0)\\}"],
        segmentThreeDGlider: ["\\segmentThreeDGlider(x_1,y)", "\\{0<y<1:(\\segmentThreeDGlider(x,1)-\\segmentThreeDGlider(x,0))*x_1,(0,0,0)\\}"],
        rayGlider: ["\\rayGlider(x_1,y)", "\\{0<y:(\\rayGlider(x,1)-\\rayGlider(x,0))*x_1,(0,0)\\}"],
        lineGlider: ["\\lineGlider(x_1,y)", "(\\lineGlider(x,1)-\\lineGlider(x,0))*x_1"],
        circleGlider: ["\\circleGlider(x_1,y)", "\\{0<y<1:2*\\pi*\\pointPerp(q-\\center(x))*x_1,(0,0)\\}"],
        arcGlider: ["(0/0,0/0)", "(0/0,0/0)"],
        polygonEdgeByParameter: ["\\polygonEdgeByParameter(x_1,y)", "\\{\\floor(y)=y:\\segment((0/0,0/0),(0/0,0/0)),\\segment((0,0),(0,0))\\}"],
        polygonGlider: ["\\polygonGlider(x_1,y)", "\\{y<0:(0,0),y>x.\\vertices.\\count:(0,0),\\floor(y)=y:(0/0,0/0),(x_1*(\\segmentGlider(s,1)-\\segmentGlider(s,0))\\with s=\\polygonEdgeByParameter(x,y))\\}"],
        chooseNonIncidentPoint: ["(0/0,0/0)"],
        circleCircleIntersection: ["(\\radius(x)*\\radius(x_1)+\\pointDot(\\center(x_1),(q-\\center(x))))/\\pointDot(\\pointPerp(q-\\center(y)),q-\\center(x))*\\pointPerp(q-\\center(y))", "(\\radius(y)*\\radius(x_1)+\\pointDot(\\center(x_1),(q-\\center(y))))/\\pointDot(\\pointPerp(q-\\center(x)),q-\\center(y))*\\pointPerp(q-\\center(x))"],
        circleArcIntersection: ["(0/0,0/0)"],
        circleLineIntersection: ["(\\radius(x)*\\radius(x_1)+\\pointDot(\\center(x_1),(q-\\center(x))))/\\pointDot((\\lineGlider(y,1)-\\lineGlider(y,0)),q-\\center(x))*(\\lineGlider(y,1)-\\lineGlider(y,0))", "(\\pointDet(\\lineGlider(x_1,0),\\lineGlider(y,1))+\\pointDet(\\lineGlider(y,0),\\lineGlider(x_1,1))-\\pointDet(q,\\lineGlider(x_1,1)-\\lineGlider(x_1,0)))/(\\pointDet(\\pointPerp(q-\\center(x)),\\lineGlider(y,1)-\\lineGlider(y,0)))*(\\pointPerp(q-\\center(x)))"],
        arcCircleIntersection: ["(0/0,0/0)"],
        arcArcIntersection: ["(0/0,0/0)"],
        arcLineIntersection: ["(0/0,0/0)"],
        lineCircleIntersection: ["(\\pointDet(\\lineGlider(x_1,0),\\lineGlider(x,1))+\\pointDet(\\lineGlider(x,0),\\lineGlider(x_1,1))-\\pointDet(q,\\lineGlider(x_1,1)-\\lineGlider(x_1,0)))/(\\pointDet(\\pointPerp(q-\\center(y)),\\lineGlider(x,1)-\\lineGlider(x,0)))*(\\pointPerp(q-\\center(y)))", "(\\radius(y)*\\radius(x_1)+\\pointDot(\\center(x_1),(q-\\center(y))))/\\pointDot((\\lineGlider(x,1)-\\lineGlider(x,0)),q-\\center(y))*(\\lineGlider(x,1)-\\lineGlider(x,0))"],
        lineArcIntersection: ["(0/0,0/0)"],
        lineLineIntersection: ["(\\pointDet(\\lineGlider(x_1,0),\\lineGlider(x,1))+\\pointDet(\\lineGlider(x,0),\\lineGlider(x_1,1))-\\pointDet(q,\\lineGlider(x_1,1)-\\lineGlider(x_1,0)))/(\\pointDet(\\lineGlider(y,1)-\\lineGlider(y,0),\\lineGlider(x,1)-\\lineGlider(x,0)))*(\\lineGlider(y,1)-\\lineGlider(y,0))", "(\\pointDet(\\lineGlider(x_1,0),\\lineGlider(y,1))+\\pointDet(\\lineGlider(y,0),\\lineGlider(x_1,1))-\\pointDet(q,\\lineGlider(x_1,1)-\\lineGlider(x_1,0)))/(\\pointDet(\\lineGlider(x,1)-\\lineGlider(x,0),\\lineGlider(y,1)-\\lineGlider(y,0)))*(\\lineGlider(x,1)-\\lineGlider(x,0))"],
        parallel: ["\\parallel(x_1,(0,0))", "\\parallel(\\line((0,0),(0,0)),x_1)"],
        perpendicular: ["\\perpendicular(x_1,(0,0))", "\\perpendicular(\\line((0,0),(0,0)),x_1)"],
        angleVertex: ["\\angleVertex(x_1)"],
        angleStart: ["\\angleStart(x_1)"],
        directedAngleVertex: ["\\directedAngleVertex(x_1)"],
        directedAngleStart: ["\\directedAngleStart(x_1)"],
        anglebisector: ["\\ray(\\angleVertex(x_1),\\angleVertex(x_1) + \\pointPerp( \\rayGlider(q,1) - \\angleVertex(x) ) * (s_1 + d_1 / 2)) \\with s_1 = \\angleStart(x_1), d_1 = \\undirectedAngleMarkerRawDelta(x_1)"],
        directedanglebisector: ["\\ray(\\directedAngleVertex(x_1),\\directedAngleVertex(x_1) + \\pointPerp( \\rayGlider(q,1) - \\directedAngleVertex(x) ) * (s_1 + d_1 / 2)) \\with s_1 = \\directedAngleStart(x_1), d_1 = \\directedAngleMarkerRawDelta(x_1)"],
        scaleTangentTransformation: ["\\scaleTangentTransformation(x_1, y)", "\\scaleTangentTransformation(x, x_1)"],
        scaleTangentPolygon: ["\\scaleTangentPolygon(x_1, y)", "\\scaleTangentPolygon(x, x_1)"],
        scaleTangentSegment: ["\\scaleTangentSegment(x_1, y)", "\\scaleTangentSegment(x, x_1)"],
        scaleTangentLine: ["\\scaleTangentLine(x_1, y)", "\\scaleTangentLine(x, x_1)"],
        scaleTangentRay: ["\\scaleTangentRay(x_1, y)", "\\scaleTangentRay(x, x_1)"],
        scaleTangentCircle: ["\\scaleTangentCircle(x_1, y)", "\\scaleTangentCircle(x, x_1)"],
        scaleTangentArc: ["\\scaleTangentArc(x_1, y)", "\\scaleTangentArc(x, x_1)"],
        scaleTangentDirectedAngleMarker: ["\\scaleTangentDirectedAngleMarker(x_1, y)", "\\scaleTangentDirectedAngleMarker(x, x_1)"],
        scaleTangentUndirectedAngleMarker: ["\\scaleTangentUndirectedAngleMarker(x_1, y)", "\\scaleTangentUndirectedAngleMarker(x, x_1)"],
        addTangentPolygon: ["x_1", "x_1"],
        addTangentSegment: ["x_1", "x_1"],
        addTangentSegmentThreeD: ["x_1", "x_1"],
        addTangentLine: ["x_1", "x_1"],
        addTangentRay: ["x_1", "x_1"],
        addTangentVector: ["x_1", "x_1"],
        addTangentCircle: ["x_1", "x_1"],
        addTangentArc: ["x_1", "x_1"],
        addTangentDirectedAngleMarker: ["x_1", "x_1"],
        addTangentUndirectedAngleMarker: ["x_1", "x_1"],
        addTangentTransformation: ["x_1", "x_1"],
        translation: ["\\rawTransform((0,0),x_1)"],
        dilation: ["\\rawTransform((0,0),(1-y)x_1)", "\\rawTransform((x_1,0),-x*x_1)"],
        reflection: ["\\rawTransformConj(a_1,p1_1-\\complexMultiplyPoints(a_1,(p1.x,-p1.y))-\\complexMultiplyPoints(qa,(p1_1.x,-p1_1.y)))\\with a_1=\\pointPerp(qa)*(\\pointDet(v,v_1)*2/(v.x^2+v.y^2))".replace(/p1_1/g, "\\glider(x_1,0)").replace(/p1/g, "\\glider(x,0)").replace(/v_1/g, "(\\glider(x_1,1)-\\glider(x_1,0))").replace(/v/g, "(\\glider(x,1)-\\glider(x,0))").replace(/qa/g, "\\transformScaleFactor(q)")],
        rotation: ["\\rawTransform((0,0),\\complexMultiplyPoints(p,x_1))\\with p=(1,0)-(\\cos(y),\\sin(y))", "\\rawTransform(p,\\complexMultiplyPoints(-p,x))\\with p=(-x_1*\\sin(y),x_1*\\cos(y))"],
        compose: ["\\reflection(\\line((0/0,0/0),(0/0,0/0)))", "\\reflection(\\line((0/0,0/0),(0/0,0/0)))"],
        inverse: ["\\reflection(\\line((0/0,0/0),(0/0,0/0)))"],
        transformPoint: ["\\transformPoint(x_1,y)", "\\transformPoint(\\transformWithoutTranslation(x),x_1)"],
        transformSegment: ["\\transformSegment(x_1,y)", "\\transformSegment(\\transformWithoutTranslation(x),x_1)"],
        transformVector: ["\\transformVector(x_1,y)", "\\transformVector(\\transformWithoutTranslation(x),x_1)"],
        transformLine: ["\\transformLine(x_1,y)", "\\transformLine(\\transformWithoutTranslation(x),x_1)"],
        transformRay: ["\\transformRay(x_1,y)", "\\transformRay(\\transformWithoutTranslation(x),x_1)"],
        transformCircle: ["\\circle(\\transformPoint(x_1,y.\\center), y.\\radius * \\pointDot(a_1,a) / \\hypot(a.x,a.y))\\with a=\\transformScaleFactor(x),a_1=\\transformScaleFactor(x_1)", "\\transformCircle(\\transformWithoutTranslation(x),x_1)"],
        transformArc: ["\\transformArc(x_1,y)", "\\transformArc(\\transformWithoutTranslation(x),x_1)"],
        transformPolygon: ["\\transformPolygon(x_1,y)", "\\transformPolygon(\\transformWithoutTranslation(x),x_1)"],
        transformAngleMarker: ["\\angle((1,0),(0,0),(1,0))", "\\transformAngleMarker(\\transformWithoutTranslation(x),x_1)"],
        transformDirectedAngleMarker: ["\\directedangle((1,0),(0,0),(1,0))", "\\transformDirectedAngleMarker(\\transformWithoutTranslation(x),x_1)"],
        mean: ["\\mean(x_1)"],
        total: ["\\total(x_1)"],
        count: ["0"],
        var: ["2*\\cov(x, x_1)"],
        varp: ["2*\\cov(x, x_1)*(\\count(x)-1)/\\count(x)"],
        stdev: ["\\cov(x, x_1)/q"],
        stdevp: ["\\covp(x, x_1)/q"],
        mad: ["\\mean(\\sign(x-\\mean(x))*(x_1 - \\mean(x_1)))"],
        listMin: ["x_1[\\argmin(x)]"],
        listMax: ["x_1[\\argmax(x)]"],
        min: ["\\{x>y:0,x_1\\}", "\\{x<=y:0,x_1\\}"],
        max: ["\\{x<y:0,x_1\\}", "\\{x>=y:0,x_1\\}"],
        median: ["0.5*(x_1[\\lowerQuantileIndex(x, 0.5)] + x_1[\\upperQuantileIndex(x, 0.5)])"],
        argmin: ["0/0"],
        argmax: ["0/0"],
        gcd: ["0/0"],
        complexGCD: ["0/0"],
        lcm: ["0/0"],
        complexLCM: ["0/0"],
        erf: ["\\frac{2x_1}{\\sqrt{\\pi }}\\exp(-x^2)"],
        invNorm: ["\\frac{x_1}{\\pdf(\\normaldist(0,1),q)}"],
        logbase: ["\\{x > 0: \\frac{x_1}{x*\\ln(y)} \\}", "\\frac{-q*x_1}{y*\\ln(y)}"],
        complexLogbase: ["\\frac{x_1}{x*\\complexLn(y)}", "\\frac{-q*x_1}{y*\\complexLn(y)}"],
        hypot: ["x_1*x/q", "x_1*y/q"],
        polyGamma: ["0/0", "\\polyGamma(1 + x, y)*x_1"],
        mod: ["\\{ q=0: 0/0, x_1 \\}", "\\{ \\mod(x/y, 1) > 0: -\\floor(x/y)*x_1 \\}"],
        complexMod: ["\\{ q=0: 0/0, x_1 \\}", "\\{ \\round(r)=r: 0/0, -\\floor(x/y)*x_1 \\} \\with r=x/y"],
        cov: ["\\cov(x_1, y)", "\\cov(x, x_1)"],
        covp: ["\\covp(x_1, y)", "\\covp(x, x_1)"],
        corr: ["(\\cov(x_1, y) - (\\cov(x, y)*\\cov(x, x_1)/\\var(x)))/(\\stdevp(x)\\stdevp(y))", "(\\cov(x, x_1) - (\\cov(x, y)*\\cov(y, x_1)/\\var(y)))/(\\stdevp(x)\\stdevp(y))"],
        spearman: ["0/0", "0/0"],
        quantile: ["\\{ \\floor(y*(\\count(x)-1)) = y*(\\count(x)-1) :   x_1[\\upperQuantileIndex(x, y)],  (\\ceil(y*(\\count(x)-1)) - y*(\\count(x)-1))*x_1[\\lowerQuantileIndex(x, y)] +   (y*(\\count(x)-1) - \\floor(y*(\\count(x)-1)))*x_1[\\upperQuantileIndex(x, y)]\\}", "\\{ \\floor(y*(\\count(x)-1)) < y*(\\count(x)-1) :   (\\count(x)-1)*(x[\\upperQuantileIndex(x, y)] - x[\\lowerQuantileIndex(x, y)])*x_1\\}"],
        quartile: ["0.5*(x_1[\\lowerQuartileIndex(x, y)] + x_1[\\upperQuartileIndex(x, y)])", "0/0"],
        tscore: ["\\frac{\\sqrt{\\count(x)}(\\stdev(x)*\\mean(x_1)-(\\mean(x)-y)*\\frac{\\cov(x,x_1)}{\\stdev(x)})}{\\stdev(x)^2}", "-x_1*\\sqrt{\\count(x)}/\\stdev(x)"],
        quartileIndex: ["0/0", "0/0"],
        upperQuartileIndex: ["0/0", "0/0"],
        lowerQuartileIndex: ["0/0", "0/0"],
        upperQuantileIndex: ["0/0", "0/0"],
        lowerQuantileIndex: ["0/0", "0/0"],
        nCr: ["q*(\\polyGamma(0, 1 + x) - \\polyGamma(0, 1 + x - y))", "q*(\\polyGamma(0, 1 + x - y) - \\polyGamma(0, 1 + y))"],
        nPr: ["q*(\\polyGamma(0, 1 + x) - \\polyGamma(0, 1 + x - y))", "q*\\polyGamma(0, 1 + x - y)"],
        arctan: ["x_1*y/(y^2+x^2)", "-x_1*x/(y^2+x^2)"],
        complexArctan: ["x_1/((x+\\complex(0,1))(x-\\complex(0,1)))"],
        poissonpdf: ["0/0", "x_1\\frac{\\exp(-y)(\\floor(x)-y)y^{(\\floor(x)-1)}}{(\\floor(x))!}"],
        invPoisson: ["0/0", "0/0"],
        tpdf: ["x_1*q*\\frac{-(y+1)*x}{y+x^2}", "x_1*\\frac{1}{2}q*(  \\frac{x^2-1}{y + x^2} + \\ln(\\frac{y}{y + x^2}) +   \\polyGamma(0, \\frac{1+y}{2}) - \\polyGamma(0, y/2))"],
        invT: ["x_1/\\pdf(\\tdist(y),q)", "0/0"],
        tcdf: ["\\{x<y:-1,1\\}\\pdf(\\tdist(z,u,v),x)*x_1", "\\{y<x:-1,1\\}\\pdf(\\tdist(z,u,v),y)*x_1", "0/0", "\\{x<y:-1,1\\}(\\pdf(\\tdist(z,u,v), y) - \\pdf(\\tdist(z,u,v), x))*x_1", "\\{y<x:-1,1\\}(\\{\\abs(y)=1/0:0,\\frac{u-y}{v}\\pdf(\\tdist(z,u,v),y)\\} - \\{\\abs(x)=1/0:0,\\frac{u-x}{v}\\pdf(\\tdist(z,u,v),x)\\})*x_1"],
        poissoncdf: ["0/0", "0/0", "x_1\\sum _{n=\\max(0,\\floor(\\min(x,y)))}^{\\floor(\\max(x,y))}\\frac{\\exp(-z)(n-z)z^{(n-1)}}{n!}"],
        normalpdf: ["-x_1*\\frac{x-y}{z^2} q", "x_1*\\frac{x-y}{z^2} q", "x_1*(\\frac{(x-y-z)*(x-y+z)}{z^3}) q"],
        binompdf: ["0/0", "0/0", "\\{0<=z<=1: x_1*q*(\\frac{\\round(x)}{z}-\\frac{\\round(y)-\\round(x)}{1-z}), 0 \\}"],
        invBinom: ["0/0", "0/0", "0/0"],
        uniformpdf: ["0", "\\{y<=x: \\frac{x_1}{(z-y)^2}, 0\\}", "\\{z>=x: -\\frac{x_1}{(z-y)^2}, 0\\}"],
        invUniform: ["\\{y<=x<=z: x_1*(z-y), 0\\}", "\\{y<=x<=z: x_1*(1-x), 0\\}", "\\{y<=x<=z: x_1*x, 0\\}"],
        normalcdf: ["\\{x<y:-1,1\\}\\pdf(\\normaldist(z,u), x)*x_1", "\\{y<x:-1,1\\}\\pdf(\\normaldist(z,u), y)*x_1", "\\{x<y:-1,1\\}(\\pdf(\\normaldist(z,u), y) - \\pdf(\\normaldist(z,u), x))*x_1", "\\{y<x:-1,1\\}(\\{\\abs(y)=1/0:0,\\frac{z-y}{u}\\pdf(\\normaldist(z,u),y)\\} - \\{\\abs(x)=1/0:0,\\frac{z-x}{u}\\pdf(\\normaldist(z,u),x)\\})*x_1"],
        binomcdf: ["0/0", "0/0", "0/0", "\\{0<=u<=1: x_1*\\sum _{n=\\max(0,\\round(\\min(x,y)))}^{\\round(\\max(x,y))}(  \\pdf(\\binomialdist(z,u),n)*(\\frac{n}{u}-\\frac{\\round(z)-n}{1-u})), 0 \\}"],
        uniformcdf: ["\\{z>u: 0/0, \\{x<y:-1,1\\}\\pdf(\\uniformdist(z,u), x)*x_1\\}", "\\{z>u: 0/0, \\{y<x:-1,1\\}\\pdf(\\uniformdist(z,u), y)*x_1\\}", "\\{z>u: 0/0, \\{y<x:-1,1\\}(\\frac{\\{z<x<u:u-x,0\\} + \\{z<y<u:y-u,0\\}}{(u-z)^2})*x_1\\}", "\\{z>u: 0/0, \\{y<x:-1,1\\}(\\frac{\\{z<x<u:x-z,0\\} + \\{z<y<u:z-y,0\\}}{(u-z)^2})*x_1\\}"],
        geopdf: ["0/0", "\\{y<=0:0/0,y>1:0,\\round(x)=1:1,(1/y-\\round(x))\\geopdf(x-1,y)\\}x_1"],
        geocdf: ["0/0", "0/0", "\\{z>1:0,(b/z)\\geopdf(b,z)-(\\max(a,0)/z)\\geopdf(a,z)\\}x_1 \\with a=\\ceil(\\min(x,y))-1, b=\\floor(\\max(x,y))"],
        invGeo: ["0/0", "0/0"],
        normalSample: ["0/0", "0/0", "0/0"],
        uniformSample: ["0/0", "0/0", "0/0"],
        tSample: ["0/0", "0/0"],
        poissonSample: ["0/0", "0/0"],
        binomSample: ["0/0", "0/0", "0/0"],
        rgb: ["0/0", "0/0", "0/0"],
        hsv: ["0/0", "0/0", "0/0"],
        polygon: ["\\polygon(x_1)"],
        area: ["0/0"],
        perimeter: ["0/0"],
        vertices: ["\\vertices(x_1)"],
        segments: ["\\segments(x_1)"],
        validateRangeLength: ["0", "0", "0", "\\{q \\ge 1: x_1, 0\\}"],
        validateSampleCount: ["\\{x<0:0,1\\}*x_1"],
        select: ["\\select(x_1, y)", "0*q"],
        shuffle: ["0*y", "\\shuffle(x, x_1)"],
        sortPerm: ["0*x"],
        complexSortPerm: ["0*x"],
        elementsAt: ["\\elementsAt(x_1, y)", "0*q"],
        uniquePerm: ["0*q"],
        tone: ["\\tone(x_1,0)", "\\tone(0,x_1)"],
        restriction: ["0"],
        restrictionToBoolean: ["0"],
        complex: ["\\complex(x_1,0)", "\\complex(0,x_1)"],
        arg: ["\\imag(x_1/x)"],
        complexDivide: ["x_1/y", "-(q/y)x_1"],
        wirtingerEqualOrWarning: ["0", "x_1"],
        coerceComplexToReal: ["\\coerceComplexToReal(x_1)"],
        coerceComplexToRealWithTolerance: ["\\coerceComplexToRealWithTolerance(x_1)"],
        peelableCoerceComplexToReal: ["\\peelableCoerceComplexToReal(x_1)"],
        peelableCoerceComplexToRealWithTolerance: ["\\peelableCoerceComplexToRealWithTolerance(x_1)"],
        coerceRealToComplex: ["\\coerceRealToComplex(x_1)"],
        chisqIndependenceColTotals: ["(0/0)x", "(0/0)x", "(0/0)x"],
        chisqIndependenceRowTotals: ["(0/0)x", "(0/0)x", "(0/0)x"],
        chisqIndependenceExpectedValues: ["(0/0)x", "(0/0)x"],
        chisqcdf: ["\\{x<y:-1,1\\}\\chisqpdf(x,z)*x_1", "\\{y<x:-1,1\\}\\chisqpdf(y,z)*x_1", "0/0"],
        chisqpdf: ["-(1/2)(1+(2-y)/x)q*x_1", "(1/2)(\\ln(x/2)-\\polyGamma(0,y/2))q*x_1"],
        invChisq: ["x_1/\\chisqpdf(q, y)", "0/0"]
    }
      , FG = {};
    for (let e in LG) {
        let t = e
          , n = LG[t]
          , r = [];
        for (let o = 0; o < n.length; o++) {
            let i = n[o];
            r.push(mi(i, {}))
        }
        FG[t] = r
    }
    function xg(e) {
        return ae(e, b) ? "number" : ae(e, N) ? "complex" : void 0
    }
    function tI(e, t, n, r) {
        let o = e.getInstruction(n).valueType;
        if (xg(o) !== r)
            throw F(`Incorrect derivative strategy '${r}' for type ${o}.`);
        let i = e.getInstruction(t).valueType;
        if (!RW(i, r)) {
            let s = e.areAllArgsConstant([t]);
            throw r === "number" ? gE([se(i)], {
                blockExport: s
            }) : hE([se(i), se(o)], {
                blockExport: s
            })
        }
        switch (r) {
        case "number":
            return KT(e, t, n, "real");
        case "complex":
            let s = KT(e, t, n, "complexOne")
              , a = KT(e, t, n, "complexI")
              , u = e.Multiply([e.Negative([e.ImaginaryUnit()]), a])
              , c = e.NativeFunction("wirtingerEqualOrWarning", [s, u]);
            return e.Multiply([e.Constant(be(1, 2)), e.Add([s, c])]);
        default:
            throw F(`Invalid derivative strategy '${r}'.`)
        }
    }
    function RW(e, t) {
        switch (t) {
        case "number":
            return ur(e, N) || ur(e, ke) || ae(e, R) || ae(e, G);
        case "complex":
            return ur(e, N) || ur(e, ke);
        default:
            throw F(`Invalid derivative strategy '${t}'.`)
        }
    }
    function M_(e, t, n) {
        let r = e.getInstruction(n).valueType
          , o = xg(r);
        if (!o)
            throw F(`chunk.derivative called on non-number ${Ke(r)}.`);
        return tI(e, t, n, o)
    }
    function VG(e) {
        let t = [];
        t.push("digraph {");
        for (let n = 0; n < e.instructionsLength(); n++)
            e.getInstruction(n).type !== 0 && t.push(`${n} [label="${n}: ${_p(e, n)}"];`);
        for (let n = 0; n < e.instructionsLength(); n++) {
            let r = e.getInstruction(n);
            if (de(r))
                for (let o of r.args)
                    t.push(`${n} -> ${o};`)
        }
        return t.push("}"),
        t.join(`
`)
    }
    var $u = class e {
        constructor(t) {
            this.derivativeMaps = new LT;
            if (this.instructions = [],
            this.blockMask = [],
            this.comments = [],
            t.argNames.length !== t.argTypes.length)
                throw new Error("Programming Error: length of argNames must match length of argTypes");
            this.argNames = t.argNames,
            this.argTypes = t.argTypes;
            for (let n = 0; n < this.argTypes.length; n++) {
                let r = this.argTypes[n];
                this.LoadArg(r)
            }
            this.returnIndex = this.Constant(NaN)
        }
        computeNeedsThunking() {
            for (let t = this.returnIndex; t >= 0; t--)
                if (this.instructions[t].type === 55)
                    return !0;
            return !1
        }
        setError(t) {
            this.error = t
        }
        getError() {
            return this.error
        }
        setWarning(t) {
            this.warning === void 0 && (this.warning = t)
        }
        restoreWarning(t) {
            this.warning = t
        }
        getWarning() {
            return this.warning
        }
        getReturnIndex() {
            return this.returnIndex
        }
        setReturnIndex(t) {
            if (!(0 <= t && t < this.instructions.length))
                throw new Error(`Programming Error: out of bounds return index ${t}`);
            this.returnIndex = t
        }
        addComments(t) {
            for (let n in t) {
                let r = this.comments[n] || "";
                this.comments[n] = r + t[n]
            }
            return this
        }
        instructionsLength() {
            return this.instructions.length
        }
        getInstruction(t) {
            return this.instructions[t]
        }
        popInstruction() {
            this.unsafelyTruncate(this.instructions.length - 1)
        }
        unsafelyTruncate(t) {
            this.instructions.length = Math.min(t, this.instructions.length),
            this.blockMask.length = Math.min(t, this.blockMask.length),
            this.comments.length = Math.min(t, this.comments.length),
            this.derivativeMaps.truncate(t),
            this.setReturnIndex(this.instructions.length - 1)
        }
        dereferenceFunctionHeader(t) {
            let n = this.getInstruction(t);
            return n.endIndex === -1 ? void 0 : n.endIndex
        }
        getDirectDependencies(t) {
            if (t.type === 55) {
                let n = t.args
                  , r = this.dereferenceFunctionHeader(n[0]);
                if (r !== void 0)
                    return n.concat(r)
            }
            return t.args
        }
        getRecursionStructure(t) {
            let n = this.getInstruction(t);
            if (n.endIndex === -1)
                throw F("Programming error: cannot get recursion structure before function is closed");
            if (!n.__cachedRecursionStructure) {
                let r = {};
                for (let o of n.recursionGroup) {
                    let i = this.getInstruction(o);
                    r[i.symbol] = o
                }
                n.__cachedRecursionStructure = ew(this, r)
            }
            return n.__cachedRecursionStructure
        }
        getRecursiveFunctionMetadata(t) {
            let n = this.getRecursionStructure(t)
              , r = this.getInstruction(t);
            return {
                type: n.canIterate ? "iterative" : "general",
                recursionGroup: r.recursionGroup.map(o => this.getInstruction(o).symbol),
                returnType: r.valueType,
                signature: r.signature,
                recursiveStructure: n
            }
        }
        pushInstructionChecked(t) {
            if (this.instructions.length >= 32768)
                throw BE();
            this.instructions.push(t),
            this.setReturnIndex(this.instructions.length - 1)
        }
        pushLeafInstruction(t) {
            return this.pushInstructionChecked(t),
            this.getReturnIndex()
        }
        pushFunctionHeaderInstruction(t) {
            return this.pushInstructionChecked(t),
            this.getReturnIndex()
        }
        pushInstruction(t) {
            return this.checkInstructionArguments(t),
            this.pushInstructionChecked(t),
            this.setReturnIndex(xL(this)),
            this.setReturnIndex(OL(this)),
            this.setReturnIndex(tL(this)),
            qw(this, this.getReturnIndex()),
            this.returnIndex === this.instructions.length - 1 && this.setReturnIndex(bL(this)),
            this.getReturnIndex()
        }
        checkInstructionArguments(t) {
            for (let n of t.args)
                if (this.blockMask[n])
                    throw new Error("Programming Error: cannot reference an instruction in a closed block")
        }
        markClosedBlock(t, n) {
            for (let r = t; r < n; r++)
                this.blockMask[r] = !0
        }
        LoadArg(t) {
            return this.pushLeafInstruction({
                type: 2,
                valueType: t
            })
        }
        BlockVar(t, n) {
            return this.pushInstruction({
                type: 47,
                valueType: t,
                args: n
            })
        }
        SymbolicVar(t, n) {
            return this.pushLeafInstruction({
                type: 3,
                valueType: t,
                symbol: n
            })
        }
        BroadcastResult(t, n) {
            let r = n[0]
              , i = this.instructions[r].args[0]
              , a = this.getInstruction(i).args[0]
              , u = this.getInstruction(a);
            return this.pushInstruction({
                type: 48,
                valueType: t,
                args: n,
                constantLength: Ye(u) ? Xr(this, a) : void 0
            })
        }
        Constant(t) {
            return this.ConstantOfType(b, t)
        }
        ConstantOfType(t, n) {
            if (typeof n == "number" && (n = be(n, 1)),
            X(t) && n.length > 1e4)
                throw ny();
            return this.pushLeafInstruction({
                type: 1,
                valueType: t,
                value: n
            })
        }
        TupleOfType(t, n) {
            let r;
            return Array.isArray(n) ? r = n : r = Mf[t].map(o => n[o]),
            this.pushInstruction({
                type: 15,
                valueType: t,
                args: r
            })
        }
        Slot(t, n) {
            let r = 16
              , o = this.getInstruction(n[0]).valueType
              , i = dc[o]
              , s = i ? i[t] : Dn;
            if (s === void 0)
                throw F(`Invalid slot index: ${t} for ${Ke(o)}.`);
            return this.pushInstruction({
                type: r,
                valueType: s,
                args: n,
                index: t
            })
        }
        NamedSlot(t, n) {
            let r = this.getInstruction(n[0]).valueType;
            if (r === He)
                return n[0];
            let o = X(r) ? Qe(r) : r;
            return this.Slot(Df(o, t), n)
        }
        ImaginaryUnit() {
            return this.ConstantOfType(N, [be(0, 1), be(1, 1)])
        }
        NanOfType(t) {
            if (t === Rn) {
                let n = this.Constant(NaN);
                return this.Distribution("uniformdist", [n, n])
            } else
                return this.ConstantOfType(t, wo(t))
        }
        ZeroOfType(t) {
            return this.ConstantOfType(t, LN(t))
        }
        Add(t) {
            let n = 8
              , r = kn(this, n, t);
            return this.pushInstruction({
                type: n,
                valueType: r,
                args: t
            })
        }
        Subtract(t) {
            let n = 9
              , r = kn(this, n, t);
            return this.pushInstruction({
                type: n,
                valueType: r,
                args: t
            })
        }
        Multiply(t) {
            let n = 10
              , r = kn(this, n, t);
            return this.pushInstruction({
                type: n,
                valueType: r,
                args: t
            })
        }
        Divide(t) {
            let n = 11
              , r = kn(this, n, t);
            return this.pushInstruction({
                type: n,
                valueType: r,
                args: t
            })
        }
        Exponent(t) {
            let n = 12
              , r = kn(this, n, t);
            return this.pushInstruction({
                type: n,
                valueType: r,
                args: t
            })
        }
        RawExponent(t) {
            let n = 13
              , r = kn(this, n, t);
            return this.pushInstruction({
                type: n,
                valueType: r,
                args: t
            })
        }
        Negative(t) {
            let n = 14
              , r = kn(this, n, t);
            return this.pushInstruction({
                type: n,
                valueType: r,
                args: t
            })
        }
        Square(t) {
            let n = 56
              , r = kn(this, n, t);
            return this.pushInstruction({
                type: n,
                valueType: r,
                args: t
            })
        }
        Equal(t) {
            let n = 25
              , r = kn(this, n, t);
            return this.pushInstruction({
                type: n,
                valueType: r,
                args: t
            })
        }
        Less(t) {
            let n = 26
              , r = kn(this, n, t);
            return this.pushInstruction({
                type: n,
                valueType: r,
                args: t
            })
        }
        Greater(t) {
            let n = 27
              , r = kn(this, n, t);
            return this.pushInstruction({
                type: n,
                valueType: r,
                args: t
            })
        }
        LessEqual(t) {
            let n = 28
              , r = kn(this, n, t);
            return this.pushInstruction({
                type: n,
                valueType: r,
                args: t
            })
        }
        GreaterEqual(t) {
            let n = 29
              , r = kn(this, n, t);
            return this.pushInstruction({
                type: n,
                valueType: r,
                args: t
            })
        }
        Comparator(t, n) {
            switch (t) {
            case "=":
                return this.Equal(n);
            case ">":
                return this.Greater(n);
            case "<":
                return this.Less(n);
            case "<=":
                return this.LessEqual(n);
            case ">=":
                return this.GreaterEqual(n);
            default:
                {
                    let r = t;
                    throw new Error(`Unexpected comparator symbol: ${r}`)
                }
            }
        }
        Or(t) {
            let n = 31
              , r = kn(this, n, t);
            return this.pushInstruction({
                type: n,
                valueType: r,
                args: t
            })
        }
        And(t) {
            let n = 32
              , r = kn(this, n, t);
            return this.pushInstruction({
                type: n,
                valueType: r,
                args: t
            })
        }
        Piecewise(t) {
            let n = 33
              , r = kn(this, n, t);
            return this.pushInstruction({
                type: n,
                valueType: r,
                args: t
            })
        }
        List(t) {
            let n = 38
              , r = kn(this, n, t);
            if (t.length > 1e4)
                throw ny();
            return this.pushInstruction({
                type: n,
                valueType: r,
                args: t
            })
        }
        ListAccess(t) {
            let n = 39
              , r = kn(this, n, t);
            return this.pushInstruction({
                type: n,
                valueType: r,
                args: t
            })
        }
        DeferredListAccess(t) {
            let n = 40
              , r = kn(this, n, t);
            return this.pushInstruction({
                type: n,
                valueType: r,
                args: t
            })
        }
        InboundsListAccess(t) {
            let n = 41
              , r = kn(this, n, t);
            return this.pushInstruction({
                type: n,
                valueType: r,
                args: t
            })
        }
        NativeFunction(t, n) {
            let r = 37
              , o = ir[t].returnType
              , i = typeof o == "function" ? o(n.map(s => this.getInstruction(s).valueType)) : o;
            return this.pushInstruction({
                type: r,
                valueType: i,
                args: n,
                symbol: t
            })
        }
        Distribution(t, n) {
            let r = 42
              , o = Rn;
            return this.pushInstruction({
                type: r,
                valueType: o,
                args: n,
                symbol: t
            })
        }
        BeginIntegral(t, n) {
            let r = 21
              , o = kn(this, r, []);
            return this.pushInstruction({
                type: r,
                valueType: o,
                args: n,
                endIndex: -1,
                callData: t
            })
        }
        EndIntegral(t) {
            let n = 22
              , r = kn(this, n, t)
              , o = t[0]
              , i = this.getInstruction(o);
            this.instructions[o] = {
                type: i.type,
                valueType: i.valueType,
                args: i.args,
                endIndex: this.instructionsLength(),
                callData: i.callData
            };
            let s = this.pushInstruction({
                type: n,
                valueType: r,
                args: t
            });
            return this.markClosedBlock(o, s),
            s
        }
        BeginBroadcast(t, n) {
            let r = 23
              , o = kn(this, r, [])
              , i = this.getInstruction(t[0]);
            if (Ye(i) && Xr(this, t[0]) > 1e4)
                throw ny();
            return this.pushInstruction({
                type: r,
                valueType: o,
                endIndex: -1,
                args: t,
                context: n
            })
        }
        EndBroadcast(t) {
            let n = 24
              , r = kn(this, n, t)
              , o = t[0]
              , i = this.getInstruction(o)
              , s = {
                type: i.type,
                valueType: i.valueType,
                args: i.args,
                endIndex: this.instructionsLength(),
                context: i.context
            };
            this.instructions[o] = s;
            let a = this.pushInstruction({
                type: n,
                valueType: r,
                args: t
            });
            return this.markClosedBlock(o, a),
            a
        }
        BeginLoop(t, n) {
            let r = 19
              , o = kn(this, r, n);
            return this.pushInstruction({
                type: r,
                valueType: o,
                args: n,
                endIndex: -1,
                callData: t
            })
        }
        EndLoop(t) {
            let n = 20
              , r = kn(this, n, t)
              , o = t[0]
              , i = this.getInstruction(o);
            this.instructions[o] = {
                type: i.type,
                valueType: i.valueType,
                args: i.args,
                endIndex: this.instructionsLength(),
                callData: i.callData
            };
            let s = this.pushInstruction({
                type: n,
                valueType: r,
                args: t
            });
            return this.markClosedBlock(o, s),
            s
        }
        BeginMap(t, n) {
            let r = 50
              , o = kn(this, r, n);
            return this.pushInstruction({
                type: r,
                valueType: o,
                args: n,
                endIndex: -1,
                callData: t
            })
        }
        EndMap(t) {
            let n = 51
              , r = kn(this, n, t)
              , o = t[0]
              , i = this.getInstruction(o);
            this.instructions[o] = {
                type: i.type,
                valueType: i.valueType,
                args: i.args,
                endIndex: this.instructionsLength(),
                callData: i.callData
            };
            let s = this.pushInstruction({
                type: n,
                valueType: r,
                args: t
            });
            return this.markClosedBlock(o, s),
            s
        }
        FunctionHeader(t, n, r, o) {
            let i = 4;
            return this.pushFunctionHeaderInstruction({
                type: i,
                valueType: n,
                endIndex: -1,
                symbol: t,
                signature: r,
                parameterSymbols: o,
                recursionGroup: []
            })
        }
        BeginFunction(t) {
            let n = 53
              , r = this.getInstruction(t[0]);
            return this.pushInstruction({
                type: n,
                valueType: r.valueType,
                endIndex: -1,
                args: t
            })
        }
        EndFunction(t) {
            let n = 54
              , r = t[0]
              , o = this.getInstruction(r);
            this.instructions[r] = {
                type: o.type,
                valueType: o.valueType,
                args: o.args,
                endIndex: this.instructionsLength()
            };
            let i = o.args[0]
              , s = this.getInstruction(o.args[0]);
            this.instructions[i] = {
                type: s.type,
                valueType: s.valueType,
                endIndex: this.instructionsLength(),
                symbol: s.symbol,
                signature: s.signature,
                parameterSymbols: s.parameterSymbols,
                recursionGroup: s.recursionGroup
            };
            let a = this.pushInstruction({
                type: n,
                valueType: Dn,
                args: t
            });
            return this.markClosedBlock(r, a),
            a
        }
        FunctionCall(t) {
            let n = 55;
            return this.pushInstruction({
                type: n,
                valueType: kn(this, n, t),
                args: t
            })
        }
        ExtendSeed(t, n) {
            let r = 44
              , o = _t;
            return this.pushInstruction({
                type: r,
                valueType: o,
                args: n,
                tag: t
            })
        }
        Noop() {
            let t = 0
              , n = Dn;
            return this.pushLeafInstruction({
                type: t,
                valueType: n
            })
        }
        Action(t, n) {
            return this.pushInstruction({
                type: 49,
                valueType: pt,
                args: n,
                symbols: t
            })
        }
        replaceInstructionWithConstant(t, n) {
            this.instructions[t] = n,
            this.blockMask[t] = void 0
        }
        replaceInstructionWithBlockVarOrFunctionCall(t, n) {
            this.instructions[t] = n
        }
        reopenFinalBlock() {
            let t = this.getInstruction(this.getReturnIndex());
            if (t.type !== 48)
                return this;
            let n = t.args[0]
              , o = this.getInstruction(n).args[0];
            for (let i = o; i < n; i++)
                this.blockMask[i] = void 0;
            return this.unsafelyTruncate(n),
            this
        }
        reopenAllBlocks() {
            this.blockMask = []
        }
        isInClosedBlock(t) {
            return !!this.blockMask[t]
        }
        copy() {
            let t = new e({
                argNames: this.argNames,
                argTypes: this.argTypes
            });
            return t.instructions = this.instructions.slice(),
            t.blockMask = this.blockMask.slice(),
            t.comments = this.comments.slice(),
            t.derivativeMaps = this.derivativeMaps.clone(),
            t.warning = this.warning,
            t.setReturnIndex(this.getReturnIndex()),
            t
        }
        fuseBroadcast() {
            return this.setReturnIndex(Wr(this, this.getReturnIndex())),
            this
        }
        copyLeafInstruction(t) {
            return this.pushLeafInstruction(t)
        }
        copyInstructionWithArgs(t, n) {
            return Nd(this, t, n)
        }
        replaceInstructionWithNoop(t) {
            this.instructions[t] = {
                type: 0,
                valueType: Dn
            }
        }
        getReturnType() {
            return this.instructions[this.getReturnIndex()].valueType
        }
        isConstant() {
            return Ye(this.instructions[this.getReturnIndex()])
        }
        areAllArgsConstant(t) {
            for (let n of t)
                if (!Ye(this.instructions[n]))
                    return !1;
            return !0
        }
        asValue() {
            return Xr(this, this.getReturnIndex())
        }
        asCompilerValue() {
            let t = this.instructions[this.getReturnIndex()];
            switch (t.type) {
            case 1:
                return t.value;
            default:
                throw new Error(`Unexpected opcode ${t.type}.`)
            }
        }
        getConstantListLength() {
            return Un(this, this.getReturnIndex())
        }
        getListLengthDependencies() {
            let t = this.copy()
              , n = Pr(t, t.getReturnIndex());
            return Go(t, n)
        }
        elementAt(t) {
            let n = this.copy()
              , r = n.getReturnIndex();
            return n.setReturnIndex(By(n, r, t)),
            n
        }
        substituteConstantArguments(t) {
            return _V(this, t)
        }
        interpretWithParameters(t) {
            return mL(this, this.getReturnIndex(), t)
        }
        getCompiledFunction(t) {
            let n;
            if (t) {
                n = t.slice();
                for (let s of this.argNames)
                    n.indexOf(s) === -1 && n.push(s)
            } else
                n = this.argNames;
            let {source: r, constants: o} = hx(this)
              , i = {};
            return {
                args: n,
                source: r,
                constants: o,
                executionMetadata: i,
                fn: Oy(n, r, o, i)
            }
        }
        getRestrictedFunctionForGLSL(t, n) {
            let r = Mc(this, t, {
                allowSlices: !0
            }), {restrictionChunk: o, valueChunk: i} = r.getValueAndRestrictionChunk(), s;
            if (o !== void 0)
                try {
                    s = as(o, n)
                } catch (a) {
                    o = void 0
                }
            return s === void 0 && r.getSliceVariablesOrImplicit().length == 0 ? {
                concrete: new An(this),
                restriction: void 0,
                restrictionExpr: void 0
            } : {
                concrete: new An(i),
                restriction: s,
                restrictionExpr: o && new An(o)
            }
        }
        polynomialOrder(t, n) {
            return Jw(this, t, n)
        }
        getPolynomialCoefficients(t) {
            return Qw(this, t)
        }
        takeDerivative(t) {
            let n = this.argNames.indexOf(t);
            return n === -1 ? this.setReturnIndex(this.ZeroOfType(this.getReturnType())) : this.setReturnIndex(M_(this, this.getReturnIndex(), n)),
            this
        }
        gradient(t) {
            let n = []
              , r = this.getReturnIndex();
            for (let o of t) {
                let i = this.argNames.indexOf(o);
                i === -1 ? n.push(this.Constant(0)) : n.push(M_(this, r, i))
            }
            return this.List(n),
            this
        }
        deriveRegressionRestrictions() {
            return IL(this)
        }
        boundDomain(t) {
            return Kw(this, t, this.getReturnIndex())
        }
        findLinearSubset(t) {
            let n = NL(this)
              , r = [];
            for (let o of t) {
                let i = this.argNames.indexOf(o);
                if (i === -1)
                    throw new Error("Programming Error: findLinearSubset called with a non-dependency");
                r.push(n[i])
            }
            return r
        }
        isLinearIn(t) {
            let n = this.argNames.filter(r => t.includes(r));
            return n.length === 0 ? !1 : this.findLinearSubset(n).every(Boolean)
        }
        isImplicitPlane() {
            let t = n => n === "x" || n === "y" || n === "z";
            return this.isLinearIn(["x", "y", "z"]) && this.argNames.every(t)
        }
        print(t, n=this.comments) {
            let r;
            return t === void 0 ? (t = this.instructionsLength() - 1,
            r = {
                printUnreferencedInstructions: !0,
                comments: n
            }) : r = {
                printUnreferencedInstructions: !1,
                comments: n
            },
            UA(this, t, r)
        }
        printInstruction(t) {
            return _p(this, t)
        }
        toDot() {
            return VG(this)
        }
        getLiveArgNames() {
            let t = oo(this, this.getReturnIndex())
              , n = [];
            for (let r = 0; r < this.argNames.length; r++)
                t[r] && n.push(this.argNames[r]);
            return n
        }
        getCursorContext() {
            return this.cursorContext
        }
        setCursorContext(t) {
            this.cursorContext = t
        }
        coerceToNumericIfPossible(t={}) {
            return Xi(this, this.getReturnIndex(), t)
        }
        coerceNonComplexToNumberIfPossible() {
            return Vp(this, this.getReturnIndex())
        }
    }
    ;
    var Ea = {
        normaldist: {
            pdf: function(e, t, n) {
                let r = e.getInstruction(t);
                return e.NativeFunction("normalpdf", n.concat(r.args))
            },
            cdf: function(e, t, n) {
                let r = e.getInstruction(t);
                return e.NativeFunction("normalcdf", n.concat(r.args))
            },
            mean: function(e, t, n) {
                return e.getInstruction(t).args[0]
            },
            median: function(e, t, n) {
                return Ea.normaldist.mean(e, t, n)
            },
            stdev: function(e, t, n) {
                let r = e.getInstruction(t);
                return e.NativeFunction("abs", [r.args[1]])
            },
            var: function(e, t, n) {
                let r = e.getInstruction(t);
                return e.Square([r.args[1]])
            },
            quantile: function(e, t, n) {
                let r = e.getInstruction(t);
                return e.Add([e.Multiply([e.NativeFunction("invNorm", n), e.NativeFunction("abs", [r.args[1]])]), r.args[0]])
            },
            random: function(e, t, n) {
                let r = e.getInstruction(t);
                return e.NativeFunction("normalSample", [n[0], r.args[0], r.args[1]])
            }
        },
        tdist: {
            pdf: function(e, t, n) {
                let r = e.getInstruction(t)
                  , o = r.args[1]
                  , i = e.NativeFunction("abs", [r.args[2]])
                  , s = e.Divide([e.Subtract([n[0], o]), i]);
                return e.Divide([e.NativeFunction("tpdf", [s, r.args[0]]), i])
            },
            cdf: function(e, t, n) {
                let r = e.getInstruction(t);
                return e.NativeFunction("tcdf", [n[0], n[1], r.args[0], r.args[1], r.args[2]])
            },
            mean: function(e, t, n) {
                return e.getInstruction(t).args[1]
            },
            median: function(e, t, n) {
                return Ea.tdist.mean(e, t, n)
            },
            stdev: function(e, t, n) {
                return e.NativeFunction("sqrt", [Ea.tdist.var(e, t, n)])
            },
            var: function(e, t, n) {
                let r = e.getInstruction(t)
                  , o = e.Constant(1)
                  , i = e.Constant(2)
                  , s = r.args[0]
                  , a = r.args[2];
                return e.Piecewise([e.Greater([s, o]), e.Piecewise([e.Greater([s, i]), e.Multiply([e.Divide([s, e.Subtract([s, i])]), e.Square([a])]), e.Constant(1 / 0)]), e.Constant(NaN)])
            },
            quantile: function(e, t, n) {
                let r = e.getInstruction(t)
                  , o = r.args[1]
                  , i = e.NativeFunction("abs", [r.args[2]]);
                return e.Add([e.Multiply([e.NativeFunction("invT", [n[0], r.args[0]]), i]), o])
            },
            random: function(e, t, n) {
                let r = e.getInstruction(t)
                  , o = r.args[1]
                  , i = e.NativeFunction("abs", [r.args[2]]);
                return e.Add([e.Multiply([e.NativeFunction("tSample", [n[0], r.args[0]]), i]), o])
            }
        },
        poissondist: {
            pdf: function(e, t, n) {
                let r = e.getInstruction(t);
                return e.NativeFunction("poissonpdf", n.concat(r.args))
            },
            cdf: function(e, t, n) {
                let r = e.getInstruction(t);
                return e.NativeFunction("poissoncdf", n.concat(r.args))
            },
            mean: function(e, t, n) {
                return e.getInstruction(t).args[0]
            },
            median: function(e, t, n) {
                let r = e.getInstruction(t);
                return e.NativeFunction("invPoisson", [e.Constant(.5), r.args[0]])
            },
            stdev: function(e, t, n) {
                let r = e.getInstruction(t);
                return e.NativeFunction("sqrt", [r.args[0]])
            },
            var: function(e, t, n) {
                return Ea.poissondist.mean(e, t, n)
            },
            quantile: function(e, t, n) {
                let r = e.getInstruction(t);
                return e.NativeFunction("invPoisson", [n[0], r.args[0]])
            },
            random: function(e, t, n) {
                let r = e.getInstruction(t);
                return e.NativeFunction("poissonSample", [n[0], r.args[0]])
            }
        },
        geodist: {
            pdf: function(e, t, n) {
                let r = e.getInstruction(t);
                return e.NativeFunction("geopdf", n.concat(r.args))
            },
            cdf: function(e, t, n) {
                let r = e.getInstruction(t);
                return e.NativeFunction("geocdf", n.concat(r.args))
            },
            mean: function(e, t, n) {
                let r = e.getInstruction(t);
                return e.Divide([e.Constant(1), r.args[0]])
            },
            median: function(e, t, n) {
                let r = e.getInstruction(t);
                return e.NativeFunction("invGeo", [e.Constant(.5), r.args[0]])
            },
            stdev: function(e, t, n) {
                return e.NativeFunction("sqrt", [Ea.geodist.var(e, t, n)])
            },
            var: function(e, t, n) {
                let o = e.getInstruction(t).args[0];
                return e.Divide([e.Subtract([e.Constant(1), o]), e.Square([o])])
            },
            quantile: function(e, t, n) {
                let r = e.getInstruction(t);
                return e.NativeFunction("invGeo", [n[0], r.args[0]])
            },
            random: function(e, t, n) {
                let r = e.getInstruction(t);
                return e.NativeFunction("invGeo", [e.NativeFunction("uniformSample", [n[0], e.Constant(0), e.Constant(1)]), r.args[0]])
            }
        },
        binomialdist: {
            pdf: function(e, t, n) {
                let r = e.getInstruction(t);
                return e.NativeFunction("binompdf", n.concat(r.args))
            },
            cdf: function(e, t, n) {
                let r = e.getInstruction(t);
                return e.NativeFunction("binomcdf", n.concat(r.args))
            },
            mean: function(e, t, n) {
                let r = e.getInstruction(t);
                return e.Multiply([r.args[0], r.args[1]])
            },
            median: function(e, t, n) {
                let r = e.getInstruction(t);
                return e.NativeFunction("invBinom", [e.Constant(.5), r.args[0], r.args[1]])
            },
            stdev: function(e, t, n) {
                return e.NativeFunction("sqrt", [Ea.binomialdist.var(e, t, n)])
            },
            var: function(e, t, n) {
                let r = e.getInstruction(t)
                  , [o,i] = r.args;
                return e.Multiply([o, e.Multiply([i, e.Subtract([e.Constant(1), i])])])
            },
            quantile: function(e, t, n) {
                let r = e.getInstruction(t);
                return e.NativeFunction("invBinom", [n[0], r.args[0], r.args[1]])
            },
            random: function(e, t, n) {
                let r = e.getInstruction(t);
                return e.NativeFunction("binomSample", [n[0], r.args[0], r.args[1]])
            }
        },
        uniformdist: {
            pdf: function(e, t, n) {
                let r = e.getInstruction(t);
                return e.NativeFunction("uniformpdf", n.concat(r.args))
            },
            cdf: function(e, t, n) {
                let r = e.getInstruction(t);
                return e.NativeFunction("uniformcdf", n.concat(r.args))
            },
            mean: function(e, t, n) {
                let r = e.getInstruction(t);
                return e.Divide([e.Add([r.args[0], r.args[1]]), e.Constant(2)])
            },
            median: function(e, t, n) {
                return Ea.uniformdist.mean(e, t, n)
            },
            stdev: function(e, t, n) {
                return e.NativeFunction("sqrt", [Ea.uniformdist.var(e, t, n)])
            },
            var: function(e, t, n) {
                let r = e.getInstruction(t)
                  , o = e.Subtract([r.args[1], r.args[0]]);
                return e.Divide([e.Square([o]), e.Constant(12)])
            },
            quantile: function(e, t, n) {
                let r = e.getInstruction(t);
                return e.NativeFunction("invUniform", [n[0], r.args[0], r.args[1]])
            },
            random: function(e, t, n) {
                let r = e.getInstruction(t);
                return e.NativeFunction("uniformSample", [n[0], r.args[0], r.args[1]])
            }
        },
        chisqdist: {
            pdf: function(e, t, n) {
                let r = e.getInstruction(t);
                return e.NativeFunction("chisqpdf", n.concat(r.args))
            },
            cdf: function(e, t, n) {
                let r = e.getInstruction(t);
                return e.NativeFunction("chisqcdf", n.concat(r.args))
            },
            mean: function(e, t, n) {
                return e.getInstruction(t).args[0]
            },
            median: function(e, t, n) {
                let r = e.getInstruction(t);
                return e.NativeFunction("invChisq", [e.Constant(.5), r.args[0]])
            },
            stdev: function(e, t, n) {
                let r = e.getInstruction(t);
                return e.NativeFunction("sqrt", [e.Multiply([e.Constant(2), r.args[0]])])
            },
            var: function(e, t, n) {
                let r = e.getInstruction(t);
                return e.Multiply([e.Constant(2), r.args[0]])
            },
            quantile: function(e, t, n) {
                let r = e.getInstruction(t);
                return e.NativeFunction("invChisq", [n[0], r.args[0]])
            },
            random: function(e, t, n) {
                let r = e.getInstruction(t);
                return e.NativeFunction("invChisq", [e.NativeFunction("uniformSample", [n[0], e.Constant(0), e.Constant(1)]), r.args[0]])
            }
        }
    };
    function BG(e, t, n) {
        let r = n[0]
          , o = e.Constant(0)
          , i = e.Constant(1);
        if (Un(e, t) === 0)
            return e.Constant(NaN);
        let a = Pr(e, t);
        return e.InboundsListAccess([t, e.Add([e.NativeFunction("floor", [e.Multiply([e.NativeFunction("uniformSample", [r, o, i]), a])]), i])])
    }
    function GG(e, t, n) {
        switch (t) {
        case N:
            return e.NativeFunction("complex", n);
        case R:
        case G:
            return e.TupleOfType(t, n);
        default:
            throw F(`Type ${Ke(t)} is not a supported aggregate type for building.`)
        }
    }
    function Tg(e) {
        if (!e)
            return;
        let {latex: t, latexSelection: n} = e;
        if (t === void 0 || n === void 0)
            return;
        let {start: r, end: o} = n;
        return {
            input: t,
            start: r,
            end: o
        }
    }
    function D_(e, t, n) {
        if (!t)
            return;
        let r = __(t, n._expression);
        r === "start-to-end" ? e.setCursorContext({
            type: n.type === "Assignment" ? "assignment-rhs" : "function-definition-body",
            allowedTypes: [Dn]
        }) : r === "empty-list" && e.setCursorContext({
            type: "expression-arguments",
            expressionType: "List",
            argIndex: 0,
            argCount: 0,
            isLastValidArg: !1,
            positionWithinArg: "start-to-end",
            allowedTypesForInsertedArg: [Dn]
        })
    }
    function qG(e, t, n) {
        if (t) {
            let r = __(t, n.args[1]);
            r === "start-to-end" ? e.setCursorContext({
                type: "for-assignment-rhs",
                allowedTypes: [Ee, he, ce, Ce, Ae, De, ...Ui.types]
            }) : r === "empty-list" && e.setCursorContext({
                type: "for-assignment-rhs",
                allowedTypes: [Dn]
            })
        }
    }
    function Jd(e, t, n, r, o) {
        let i = NW(e, t, n, r, o);
        i && e.setCursorContext(i)
    }
    function __(e, t) {
        let n = t.getInputSpan();
        return n ? e.start === n.start && e.end === n.end ? "start-to-end" : e.start === e.end && e.start === n.end ? "end" : e.start === e.end && e.start === n.start ? "start" : e.start === e.end && t.type === "List" && t.args.length === 0 ? "empty-list" : "not-aligned" : "not-aligned"
    }
    function R_(e, t) {
        if (!e)
            return;
        let n = !1;
        t instanceof Qo && t.args[1]instanceof Qn && (n = !0,
        t = t.args[1]);
        let r = t.args;
        if (r) {
            if (r.length === 0) {
                let o = t.getInputSpan();
                if (!o)
                    return;
                let i = Ir(o)
                  , s = -1;
                return t.type === "List" ? s = i.indexOf("[") : (t.type === "FunctionCall" || t.type === "SeededFunctionCall") && (s = i.indexOf("(")),
                s < 0 ? void 0 : e.start === o.start + s + 1 ? {
                    argIndex: 0,
                    positionWithinArg: "start-to-end",
                    isDotCall: n
                } : void 0
            }
            for (let o = 0; o < r.length; o++) {
                let i = r[o]
                  , s = i.getInputSpan();
                if ((s == null ? void 0 : s.input) !== e.input)
                    continue;
                if (e.start < s.start)
                    break;
                let a = __(e, i);
                if (a !== "not-aligned")
                    return {
                        argIndex: o,
                        positionWithinArg: a,
                        isDotCall: n
                    }
            }
        }
    }
    function NW(e, t, n, r, o) {
        if (!n || !r.args)
            return;
        let i = R_(n, r);
        if (i === void 0)
            return;
        i.isDotCall && (r = r.args[1]);
        let s = i.positionWithinArg === "end" ? i.argIndex + 1 : i.argIndex;
        i.isDotCall && (s += 1);
        let a;
        i.positionWithinArg === "empty-list" || i.positionWithinArg === "start-to-end" ? a = [...o.slice(0, s), void 0, ...o.slice(s + 1)] : r instanceof Io ? a = s === 1 ? [o[0], void 0, o[1]] : [o[0], o[1], void 0] : a = [...o.slice(0, s), void 0, ...o.slice(s)],
        a = a.map(p => {
            if (!(p === void 0 || e.getInstruction(p).type === 2))
                return p
        }
        );
        let u = [];
        for (let p of a)
            u.push(p === void 0 ? void 0 : e.getInstruction(p).valueType);
        let c = Ox(t, r, u)
          , l = c && Of(c, s);
        if (i.positionWithinArg === "empty-list") {
            let p = l == null ? void 0 : l.filter(X).map(Qe);
            return (p == null ? void 0 : p.length) === 0 ? void 0 : {
                type: "expression-arguments",
                expressionType: "List",
                argIndex: 0,
                argCount: 0,
                isLastValidArg: !1,
                positionWithinArg: "start-to-end",
                allowedTypesForInsertedArg: p != null ? p : [Dn]
            }
        } else {
            if ((l == null ? void 0 : l.length) === 0)
                return;
            let p = !1;
            if (c) {
                let y = 0;
                for (let g of c) {
                    let f = g.maxArity !== void 0 ? g.maxArity - 1 : 1 / 0;
                    y = Math.max(y, f)
                }
                p = i.positionWithinArg === "end" && i.argIndex === y - 1 || i.positionWithinArg === "start-to-end" && i.argIndex === y
            }
            let m = r.args.length;
            if (r instanceof Io && r.args.length === 3) {
                let y = r.args[2];
                y instanceof Vn && y.isNaN() && (m = 2)
            }
            let d = {
                type: "expression-arguments",
                expressionType: r.type,
                argIndex: i.argIndex,
                argCount: m,
                isLastValidArg: p,
                positionWithinArg: i.positionWithinArg,
                allowedTypesForInsertedArg: l != null ? l : [Dn]
            };
            if (r instanceof Qn && (d.functionSymbol = r._symbol,
            d.isDotCall = i.isDotCall,
            r instanceof Qn && r._symbol === "polygon")) {
                let y = r.args.filter(g => !(g instanceof dn && g._symbol === "cursor"));
                if (y.length > 0) {
                    let g = y[0].getInputSpan()
                      , f = y[y.length - 1].getInputSpan();
                    d.polygonVertices = g && f ? {
                        firstLatex: Ir(g),
                        lastLatex: Ir(f)
                    } : void 0
                }
            }
            return d
        }
    }
    function Ig(e, t, n) {
        if (t === n)
            return !0;
        if (t < n)
            return !1;
        let r = [!0];
        for (let i = n + 1; i <= t; i++)
            r.push(!1);
        let o = [t];
        for (; o.length; ) {
            let i = o.pop();
            if (r[i - n])
                continue;
            r[i - n] = !0;
            let s = e.getInstruction(i);
            if (de(s))
                for (let a of e.getDirectDependencies(s)) {
                    if (a === n)
                        return !0;
                    a < n || r[a - n] || o.push(a)
                }
        }
        return !1
    }
    function zG(e, t, n) {
        return nI(e, r => {
            var p, m;
            let {chunk: o} = r
              , i = []
              , s = [];
            for (let d = 0; d < n.length; d++) {
                let y = o.getInstruction(n[d]).valueType;
                X(y) ? (i.push(2),
                s.push(o.SymbolicVar(y, t._argSymbols[d]))) : (i.push(0),
                s.push(n[d]))
            }
            if (i.every(d => d === 0))
                return i;
            let a = rI(r, t, s)
              , u = Math.min(...s)
              , c = oo(o, a)
              , l = [];
            for (let d = 0; d < s.length; d++)
                l[s[d]] = new Set([d]);
            for (let d = u; d <= a; d++) {
                if (!c[d])
                    continue;
                let y = o.getInstruction(d);
                if (de(y)) {
                    if (y.type === 39 || y.type === 40 || y.type === 41) {
                        let g = y.args[0]
                          , f = y.args[1]
                          , h = o.getInstruction(f);
                        if (h.type === 23) {
                            let x = h.endIndex
                              , T = (p = l[x]) != null ? p : new Set;
                            for (let P of l[g] || [])
                                T.add(P);
                            l[x] = T;
                            continue
                        }
                    }
                    if (y.type === 48)
                        l[d] = l[y.args[0]];
                    else if (y.type === 37 && y.symbol === "count" && y.args.length === 1)
                        l[d] = l[y.args[0]];
                    else if (!(y.type === 23 && ((m = y.context) == null ? void 0 : m.type) === "implicit")) {
                        if (!(y.type === 44 && y.tag === "fc"))
                            for (let g of y.args) {
                                let f = l[g] || [];
                                for (let h of f)
                                    i[h] = 1
                            }
                    }
                }
            }
            return i
        }
        )
    }
    function OW(e, t, n) {
        let r = jd.empty(t);
        for (let o = 0; o < e.argNames.length; o++) {
            let i = e.argNames[o];
            n.includes(i) ? r.addLexicalBinding(i, o) : r.setFreeVariable(i, o)
        }
        return r
    }
    var Qd = class Qd {
        constructor(t, n, r, o, i) {
            if (this.kind = t,
            this.substitutedGlobals = {
                ...n == null ? void 0 : n.substitutedGlobals
            },
            this.functionBodySubstitutions = {
                ...n == null ? void 0 : n.functionBodySubstitutions
            },
            t && r && i) {
                let s = i.filter(a => r.isGlobal(a));
                for (let a of s)
                    this.substitutedGlobals[a] || (this.substitutedGlobals[a] = t);
                if (o && s.length > 0) {
                    let a = this.recursionGroupKey(o.fnSymbols);
                    this.functionBodySubstitutions[a] || (this.functionBodySubstitutions[a] = {
                        operator: t,
                        substitutedGlobals: s
                    })
                }
            }
        }
        recursionGroupKey(t) {
            return [...t].sort().join(",")
        }
        getFunctionBodySubstitution(t) {
            let n = this.recursionGroupKey(t);
            return this.functionBodySubstitutions[n]
        }
        allowsRegressionParameterDependency() {
            if (!this.kind)
                return !0;
            for (let t in this.substitutedGlobals)
                return !1;
            return !0
        }
        getRegressionDependencyError(t) {
            if (this.allowsRegressionParameterDependency())
                return;
            let[n,r] = Object.entries(this.substitutedGlobals)[0];
            return jv(n, t, r)
        }
        getKind() {
            return this.kind
        }
        getSubstitutedGlobals() {
            return this.substitutedGlobals
        }
        with(t, n, r) {
            return new Qd("with",this,t,n,r)
        }
        for(t, n, r) {
            return new Qd("for",this,t,n,r)
        }
    }
    ;
    Qd.root = new Qd;
    var bg = Qd
      , A_ = class {
        constructor(t, n) {
            this.definitions = t;
            this.baseCases = n;
            this.type = "type-inference";
            this.argTypes = {};
            this.returnTypes = {};
            this.baseCaseTypes = {};
            this.firstValidBaseCaseIdentifiers = {};
            this.stack = [];
            this.isUnconditionallyRecursive = !1;
            this.fnSymbols = Object.keys(t)
        }
        registerFunctionCall(t, n) {
            this.argTypes[t] || (this.argTypes[t] = n)
        }
    }
    ;
    function v_(e, t, n, r, o, i) {
        return {
            policy: e,
            chunk: t,
            scope: n,
            substitutionContext: r,
            recursiveFunctionContext: o,
            selection: i
        }
    }
    function Ps(e, t) {
        return {
            ...e,
            scope: t
        }
    }
    function JG(e, t) {
        let {newPolicy: n, newScope: r} = e.scope.newScopeAcrossModuleBoundary(t);
        return {
            ...e,
            scope: r,
            policy: n
        }
    }
    function QG(e, t) {
        let n = e.scope.newModuleID(t);
        return n ? JG(e, n) : e
    }
    function nI(e, t) {
        let {chunk: n, scope: r} = e
          , o = n.instructionsLength()
          , i = r.childScopeWithChildGlobalCache()
          , s = Ps(e, i)
          , a = t(s);
        return n.unsafelyTruncate(o),
        a
    }
    function RT(e) {
        let {policy: t, frame: n, argNames: r, argTypes: o, selection: i, locals: s} = e
          , a = new $u({
            argNames: r,
            argTypes: o
        })
          , u = OW(a, n, s);
        return v_(t, a, u, bg.root, void 0, i)
    }
    function Kd(e, t) {
        let {policy: n, frame: r, argNames: o, argTypes: i} = e
          , s = Tg(t.userData)
          , a = qD(r, t)
          , {freeDependencies: u, updateSymbols: c} = a;
        if (o || (o = u),
        !i) {
            i = [];
            for (let m = 0; m < o.length; m++)
                i.push(b)
        }
        let l;
        t.type === "FunctionDefinition" || t.type === "RecursiveFunctionBaseCase" ? l = t._argSymbols : l = [];
        let p = RT({
            policy: n,
            frame: r,
            argNames: o,
            argTypes: i,
            selection: s,
            locals: l
        });
        try {
            pV(n, r, t.getScope()),
            Re(p, t),
            e.coerceToNumber === "all" || ae(p.chunk.getReturnType(), sn) ? p.chunk.coerceToNumericIfPossible() : e.coerceToNumber === "all-except-complex" && p.chunk.coerceNonComplexToNumberIfPossible(),
            e.wrapInList && !X(p.chunk.getReturnType()) && p.chunk.List([p.chunk.getReturnIndex()]),
            p.chunk.fuseBroadcast(),
            AW(p, t, c)
        } catch (m) {
            let d = m instanceof v ? m : F(m);
            d.setCursorContext(p.chunk.getCursorContext()),
            p.chunk.setError(d)
        }
        return p.chunk
    }
    function AW(e, t, n) {
        let {chunk: r, scope: o} = e;
        if (t.type === "FunctionDefinition") {
            for (let s of n)
                if (t._argSymbols.indexOf(s) !== -1 || t._symbol === s)
                    throw sb(s)
        }
        let i = [];
        for (let s of n)
            o.isDefined(s) || i.push(s);
        if (i.length) {
            let s = L_(e, i[0]).setDependencies(r.argNames.concat(i));
            throw r.isConstant() && r.getReturnType() === pt && s.setActionValue(r.asValue()),
            s
        }
    }
    function Re(e, t) {
        let {chunk: n} = e, r;
        if (Tw(),
        FW(e, t)) {
            hw(),
            r = n.copyLeafInstruction(t.__IRCache.instruction);
            let o = t.__IRCache.warning;
            o !== void 0 && n.setWarning(o)
        } else {
            bw();
            let o = n.instructionsLength()
              , i = n.getWarning() === void 0;
            r = VW(e, t),
            r = wW(e, o, r);
            let s = i ? n.getWarning() : void 0;
            LW(e, t, r, s)
        }
        return n.setReturnIndex(r),
        r
    }
    function wW(e, t, n) {
        let {chunk: r, scope: o} = e;
        if (n <= t)
            return n;
        let i = r.getInstruction(n);
        return Ye(i) ? (r.unsafelyTruncate(Math.max(t, o.getMaxIndex() + 1)),
        r.copyLeafInstruction(i)) : n
    }
    function LW(e, t, n, r) {
        let {chunk: o, scope: i} = e
          , s = o.getInstruction(n);
        if (!Ye(s))
            return;
        let a = lV(i, t);
        a && (xw(),
        t.__IRCache = {
            keyComplexEnabled: e.policy.isComplexEnabled(),
            keys: a,
            instruction: s,
            warning: r
        })
    }
    function FW(e, t) {
        let {scope: n, substitutionContext: r} = e;
        if (!t.__IRCache)
            return !1;
        let o = t.__IRCache.keys;
        for (let[i,s] of o) {
            if (n.isLocal(i) || n.isError(i))
                return !1;
            let a = n.getVisibleGlobalDefinition(i);
            if (a !== s || a && a.type === "RegressionParameter" && !r.allowsRegressionParameterDependency())
                return !1
        }
        return e.policy.isComplexEnabled() === t.__IRCache.keyComplexEnabled
    }
    function VW(e, t) {
        var u, c, l, p;
        let {policy: n, chunk: r, scope: o, substitutionContext: i, selection: s} = e
          , a = t.type;
        switch (a) {
        case "Constant":
            {
                let m = t._constantValue
                  , d = typeof m == "boolean" ? Fe : b;
                return r.ConstantOfType(d, m)
            }
        case "RegressionParameter":
            return r.Constant(t.asCompilerValue());
        case "MixedNumber":
            return r.Constant(t._constantValue);
        case "ImaginaryUnit":
            return r.ImaginaryUnit();
        case "Negative":
            return r.Negative(oI(e, t, t.args));
        case "Add":
            return r.Add(Ca(e, t, t.args));
        case "Subtract":
            return r.Subtract(Ca(e, t, t.args));
        case "Multiply":
            return r.Multiply(Ca(e, t, t.args));
        case "DotMultiply":
            {
                let[m,d] = Ca(e, t, t.args);
                return (c = (u = kG(e, m, d)) != null ? u : Sc(r, [m, d]) ? kG(e, ti(r, m), ti(r, d)) : void 0) != null ? c : r.Multiply([m, d])
            }
        case "CrossMultiply":
            {
                let[m,d] = Ca(e, t, t.args);
                return xt(r, m, qe) && xt(r, d, qe) ? Sl(r, [$G(e, ti(r, m), ti(r, d)), tu(r, m)]) : xt(r, m, G) && xt(r, d, G) ? $G(e, m, d) : r.Multiply([m, d])
            }
        case "Divide":
            return r.Divide(Ca(e, t, t.args));
        case "Exponent":
            {
                let m = Ca(e, t, t.args);
                if (n.isComplexEnabled()) {
                    let d = t.args[1];
                    if (KW(d)) {
                        let y = r.getInstruction(m[0]).valueType;
                        if (Ql(y, b) || Ql(y, Y))
                            return d.asValue() === 2 ? r.Square([m[0]]) : r.Exponent(m)
                    }
                    return r.NativeFunction("complexPow", m)
                } else
                    return r.Exponent(m)
            }
        case "Comparator['=']":
        case "Comparator['>']":
        case "Comparator['<']":
        case "Comparator['>=']":
        case "Comparator['<=']":
            return r.Comparator(t.operator, Ca(e, t, t.args));
        case "ComparatorChain":
            {
                let m = ql(e, t, t.args)
                  , d = r.Comparator(t.symbols[0], [m[0], m[1]]);
                for (let y = 1; y < t.symbols.length; y++)
                    d = r.And([d, r.Comparator(t.symbols[y], [m[y], m[y + 1]])]);
                return d
            }
        case "Or":
            return r.Or(Ca(e, t, t.args));
        case "PercentOf":
            return r.Divide([r.Multiply(Ca(e, t, t.args)), r.Constant(100)]);
        case "ParenSeq":
            return UW(e, t);
        case "BareSeq":
            return kW(e, t);
        case "NamedCoordinateAccess":
            {
                let[m] = oI(e, t, t.args)
                  , d = t.symbol;
                switch (d) {
                case "x":
                case "y":
                case "z":
                    return r.NamedSlot(d, [m]);
                case "p":
                    {
                        let y = r.getInstruction(m).valueType;
                        return Ti(rr(y)) ? r.NamedSlot(d, [_d(r, [m])]) : r.NamedSlot(d, [m])
                    }
                default:
                    {
                        let y = d;
                        throw new Error(`Programming Error: unexpected named coordinate: '${y}'.`)
                    }
                }
            }
        case "Norm":
            {
                let m = oI(e, t, t.args)[0];
                return xt(r, m, N) ? sI(r, m) : (p = (l = w_(e, m)) != null ? l : Sc(r, [m]) ? w_(e, ti(r, m)) : void 0) != null ? p : r.NativeFunction("abs", [m])
            }
        case "UpdateRule":
            {
                let m = t._symbol;
                if (o.isLocal(m))
                    throw L_(e, m);
                let d = o.getVisibleGlobalDefinition(m);
                if (d !== void 0 && d.type !== "Assignment" && d.type !== "Slider" && d.type !== "AssignmentImport")
                    throw L_(e, m);
                let y = Re(e, t.args[1]);
                return r.Action([m], [y])
            }
        case "List":
        case "TableColumnValue":
            {
                if (t.getDependencies().length > 0)
                    return Br(t.args),
                    r.List(ql(e, t, t.args));
                if (t.args.length === 0)
                    return Jd(r, n, s, t, []),
                    r.ConstantOfType(He, []);
                {
                    let m = r.instructionsLength(), d = [], y, g;
                    Br(t.args);
                    let f = !0;
                    for (let x of t.args) {
                        let T = Re(e, x)
                          , P = r.getInstruction(T);
                        if (y === void 0) {
                            if (y = P.valueType,
                            !jn(y))
                                throw gp([se(y)], {
                                    blockExport: f
                                });
                            g = $n(y)
                        } else if (P.valueType !== y) {
                            if (Uc(y, P.valueType) !== void 0)
                                return r.unsafelyTruncate(m),
                                r.List(ql(e, t, t.args));
                            throw ty({
                                blockExport: f
                            })
                        }
                        if (P.type !== 1)
                            throw new Error("Programming error: expected list with no dependencies to constant collapse.");
                        d.push(P.value),
                        r.unsafelyTruncate(m)
                    }
                    let h = R_(e.selection, t);
                    if (e.selection && h !== void 0 && g !== void 0 && h.positionWithinArg !== "empty-list") {
                        let x = Qe(g);
                        r.setCursorContext({
                            type: "expression-arguments",
                            expressionType: "List",
                            argIndex: h.argIndex,
                            argCount: t.args.length,
                            isLastValidArg: !1,
                            positionWithinArg: h.positionWithinArg,
                            allowedTypesForInsertedArg: [x]
                        })
                    }
                    return r.ConstantOfType(g, d)
                }
            }
        case "ListAccess":
            {
                let m = Re(e, t.args[0])
                  , d = r.getInstruction(m);
                if (t.args[1].type === "Range" && t.args[1].args[1].length === 0) {
                    if (!X(d.valueType))
                        throw Qf([se(d.valueType), se(b)], {
                            blockExport: Ye(d)
                        });
                    let y = Pr(r, m)
                      , g = F_(e, Re(e, t.args[1].args[0]), r.List([y]), {
                        stepMustBePositive: !0
                    });
                    return r.ListAccess([m, g])
                } else {
                    let y = Re(e, t.args[1])
                      , g = r.getInstruction(y);
                    if (eu(r, n, t, [m, y]),
                    g.valueType === yi)
                        return r.NativeFunction("select", [m, y]);
                    if (g.valueType === Fe && X(d.valueType)) {
                        let f = r.ConstantOfType(d.valueType, []);
                        return r.Piecewise([y, m, f])
                    }
                    return r.ListAccess([m, y])
                }
            }
        case "Range":
            {
                let[m,d] = Ca(e, t, t.args);
                return F_(e, m, d, {
                    stepMustBePositive: !1
                })
            }
        case "ListComprehension":
            return YW(e, t);
        case "Piecewise":
            {
                let m = Re(e, t.args[0]), d = r.getInstruction(m), y = d.type === 1 && d.value === !1, g = d.type === 1 && d.value === !0, f;
                f = r.getWarning();
                let h = Re(e, t.args[1]);
                y && r.restoreWarning(f),
                f = r.getWarning();
                let x = Re(e, t.args[2]);
                g && r.restoreWarning(f);
                let T = [m, h, x];
                Jd(e.chunk, e.policy, e.selection, t, T),
                eu(e.chunk, e.policy, t, T);
                let P = r.getInstruction(T[1])
                  , C = r.getInstruction(T[2])
                  , S = As(P.valueType, C.valueType) || As(C.valueType, P.valueType);
                if (d.type === 1 && d.valueType === Fe && S) {
                    let _ = T[d.value ? 1 : 2]
                      , U = r.getInstruction(_)
                      , Q = P.valueType !== He ? P.valueType : C.valueType;
                    return U.valueType === He && Q !== He ? r.ConstantOfType(Q, []) : _
                }
                let E = P.valueType
                  , M = rr(E);
                if (!S && Ye(C) && C.valueType === b && Xo(C.value) && ra(M)) {
                    if (ae(P.valueType, sn))
                        return r.NativeFunction("restriction", [r.And([T[0], r.NativeFunction("restrictionToBoolean", [T[1]])])]);
                    let _ = r.NanOfType(M);
                    T = [T[0], T[1], _]
                }
                return r.Piecewise(T)
            }
        case "Restriction":
            return r.NativeFunction("restriction", oI(e, t, t.args));
        case "Ans":
        case "Identifier":
            {
                let m = t._symbol
                  , d = t._errorSymbol;
                if (t.type === "Ans" && r.argNames.indexOf(m) !== -1)
                    throw Rv();
                let y = o.getSymbol(m);
                if (y !== void 0)
                    return y;
                e = QG(e, m),
                {scope: o, policy: n} = e;
                let g = o.getVisibleGlobalDefinition(m);
                if (g === void 0)
                    throw rt[m] ? rt[m].type === "Placeholder" ? Ga(d, e.policy) : my(d) : e.recursiveFunctionContext && e.recursiveFunctionContext.fnSymbols.includes(m) ? mb(m) : F(`Programming Error: reached undefined symbol ${m}`);
                if (o.isLocal(m) || cl(g))
                    throw mb(d);
                if (g.type === "RegressionParameter") {
                    let h = i.getRegressionDependencyError(d);
                    if (h)
                        throw h
                }
                let f;
                if (g instanceof xo)
                    f = Re(e, g);
                else {
                    let h = o.newLexicalScope()
                      , x = Ps(e, h);
                    f = Re(x, g)
                }
                return o.cacheGlobal(m, f, g),
                f
            }
        case "AssignmentImport":
            {
                let {_importFrom: m} = t
                  , d = JG(e, m.frameID);
                return Re(d, new dn(m.symbol))
            }
        case "FunctionCall":
        case "SeededFunctionCall":
            {
                let m = e4(e, t);
                if (m !== void 0)
                    return m;
                Br(t.args);
                let d = ql(e, t, t.args);
                return Br(d),
                iI(e, t._symbol, t._errorSymbol, d, t.args)
            }
        case "Substitution":
            return jW(e, t);
        case "FunctionExponent":
            {
                let m = t.args[0]._symbol
                  , d = o.getVisibleGlobalDefinition(m)
                  , y = o.getSymbol(m)
                  , g = y !== void 0 ? r.getInstruction(y) : void 0;
                return o.isLocal(m) && (g == null ? void 0 : g.type) === 4 || cl(d) ? Re(e, new O.Exponent([new O.FunctionCall(m,[t.args[1]]), t.args[2]])) : Re(e, new O.Multiply([t.args[0], new O.Exponent([t.args[1], t.args[2]])]))
            }
        case "FunctionFactorial":
            {
                let m = t.args[0]._symbol
                  , d = o.getVisibleGlobalDefinition(m)
                  , y = o.getSymbol(m)
                  , g = y !== void 0 ? r.getInstruction(y) : void 0;
                return o.isLocal(m) && (g == null ? void 0 : g.type) === 4 || cl(d) ? Re(e, new O.FunctionCall("\\factorial",[new O.FunctionCall(m,[t.args[1]])])) : Re(e, new O.Multiply([t.args[0], new O.FunctionCall("\\factorial",[t.args[1]])]))
            }
        case "DotAccess":
            {
                let m = t.args[0]
                  , d = t.args[1]
                  , y = o.getVisibleGlobalDefinition(d._symbol);
                if (m.type === "Identifier" && m._symbol === "construction")
                    return JW(e, d);
                if ((d.type === "Identifier" || d.type === "FunctionCall") && cl(y)) {
                    let g = d._symbol
                      , f = d._errorSymbol;
                    if (_y(y))
                        throw Kf(f);
                    let h = d.type === "Identifier" ? [m] : [m].concat(d.args)
                      , x = ql(e, t, h);
                    return iI(e, g, f, x, h)
                } else if (d.type === "SeededFunctionCall") {
                    let g = d._symbol
                      , f = d._errorSymbol
                      , h = [d.seed, m].concat(d.args.slice(1))
                      , x = ql(e, t, h);
                    return iI(e, g, f, x, h)
                } else
                    throw Mi(".")
            }
        case "Seed":
            return r.ConstantOfType(_t, t._stringValue);
        case "ExtendSeed":
            return r.ExtendSeed(t.tag, Ca(e, t, t.args));
        case "Integral":
            {
                let m = t._differential._symbol
                  , d = o.childScope();
                d.setErrorIfAccessed(m, vv(m));
                let y = Ps(e, d)
                  , g = Re(y, t.args[1])
                  , f = Re(y, t.args[2])
                  , h = r.getInstruction(g)
                  , x = r.getInstruction(f)
                  , T = r.SymbolicVar(b, m)
                  , P = o.childScope();
                P.addLexicalBinding(m, T);
                let C = Re(Ps(e, P), t.args[3]);
                if (eu(r, n, t, [g, f, C]),
                !Ig(r, C, T))
                    return r.Multiply([C, r.Subtract([Xi(r, f), Xi(r, g)])]);
                let S = Md(r, [g, f, C]);
                if (S !== void 0 && Ig(r, S, T))
                    throw Xv(m);
                let E = S !== void 0 ? r.BeginBroadcast([S]) : void 0
                  , M = g;
                E !== void 0 && X(h.valueType) && (M = Yu(r, g, E));
                let _ = f;
                E !== void 0 && X(x.valueType) && (_ = Yu(r, f, E));
                let U = r.getInstruction(C).valueType, Q = rr(U), K;
                if (hm(Q) && Q !== b) {
                    let w = []
                      , B = Q === N || Q === R ? 2 : 3;
                    for (let W = 0; W < B; W++) {
                        let oe = r.BeginIntegral({
                            indexSymbol: m
                        }, [M, _])
                          , te = Rc(r, oe, T, C)
                          , st = r.getInstruction(te);
                        E !== void 0 && X(st.valueType) && (te = Yu(r, te, E)),
                        te = r.Slot(W, [te]);
                        let Tt = r.EndIntegral([oe, te]);
                        w.push(r.BlockVar(b, [Tt]))
                    }
                    K = GG(r, Q, w)
                } else {
                    let w = r.BeginIntegral({
                        indexSymbol: m
                    }, [M, _])
                      , B = Rc(r, w, T, C)
                      , W = r.getInstruction(B);
                    E !== void 0 && X(W.valueType) && (B = Yu(r, B, E));
                    let oe = r.EndIntegral([w, B]);
                    K = r.BlockVar(b, [oe])
                }
                if (E !== void 0) {
                    let w = r.EndBroadcast([E, K]);
                    return r.BroadcastResult($n(Q), [w])
                } else
                    return K
            }
        case "Sum":
        case "Product":
            {
                let m = t._index._symbol
                  , d = t.type === "Sum"
                  , y = o.childScope();
                y.setErrorIfAccessed(m, d ? gv(m) : hv(m));
                let g = Ps(e, y)
                  , f = Re(g, t.args[1]);
                f = Xi(g.chunk, f);
                let h = Re(g, t.args[2]);
                if (h = Xi(g.chunk, h),
                !xt(r, f, b)) {
                    let _e = xl(r, [f])
                      , gt = r.areAllArgsConstant([f]);
                    throw d ? aE(_e, {
                        blockExport: gt
                    }) : lE(_e, {
                        blockExport: gt
                    })
                }
                if (!xt(r, h, b)) {
                    let _e = xl(r, [h])
                      , gt = r.areAllArgsConstant([h]);
                    throw d ? uE(_e, {
                        blockExport: gt
                    }) : pE(_e, {
                        blockExport: gt
                    })
                }
                let x = r.NativeFunction("round", [f])
                  , T = r.NativeFunction("round", [h])
                  , P = r.getInstruction(x)
                  , C = r.getInstruction(T);
                if (P.type === 1 && P.valueType === b && !isFinite(L(P.value)))
                    throw d ? rb() : ob();
                if (C.type === 1 && C.valueType === b && !isFinite(L(C.value)))
                    throw d ? rb() : ob();
                let S = r.SymbolicVar(b, m)
                  , E = o.childScope();
                E.addLexicalBinding(m, S);
                let M = Re(Ps(e, E), t.args[3])
                  , _ = r.getInstruction(M).valueType
                  , U = rr(_)
                  , K = (t.type === "Sum" ? gm : lh).find(_e => Ql(U, _e));
                if (K === void 0) {
                    let _e = xl(r, [M])
                      , gt = r.areAllArgsConstant([M]);
                    throw d ? cE(_e, {
                        blockExport: gt
                    }) : mE(_e, {
                        blockExport: gt
                    })
                }
                if (!Ig(r, M, S)) {
                    let _e = r.Add([r.Subtract([T, x]), r.Constant(1)]);
                    _e = r.NativeFunction("listMax", [_e, r.Constant(0)]);
                    let gt = d ? r.Multiply([M, _e]) : K === N ? r.NativeFunction("complexPow", [M, _e]) : r.RawExponent([M, _e]);
                    return r.Piecewise([r.Equal([_e, r.Constant(0)]), d ? r.ZeroOfType(K) : r.Constant(1), r.Piecewise([r.Less([_e, r.Constant(1 / 0)]), gt, r.NanOfType(K)])])
                }
                let w = Md(r, [x, T, M]);
                if (w !== void 0 && Ig(r, w, S))
                    throw d ? Yv(m) : Zv(m);
                let B = w !== void 0 ? r.BeginBroadcast([w]) : void 0
                  , W = x;
                B !== void 0 && X(P.valueType) && (W = Yu(r, x, B));
                let oe = T;
                B != null && X(C.valueType) && (oe = Yu(r, T, B));
                let te = d ? r.ZeroOfType(K) : K === N ? r.NativeFunction("complex", [r.Constant(1), r.Constant(0)]) : r.Constant(1)
                  , st = r.BeginLoop({
                    type: d ? "sum" : "product",
                    indexSymbol: m
                }, [W, oe, te])
                  , Tt = r.BlockVar(K, [st])
                  , ye = Rc(r, st, S, M)
                  , ee = r.getInstruction(ye);
                B !== void 0 && X(ee.valueType) && (ye = Yu(r, ye, B));
                let k = d ? r.Add([Tt, ye]) : r.Multiply([Tt, ye])
                  , ne = r.EndLoop([st, k])
                  , Ne = r.BlockVar(K, [ne]);
                if (B !== void 0) {
                    let _e = r.EndBroadcast([B, Ne]);
                    return r.BroadcastResult($n(K), [_e])
                } else
                    return Ne
            }
        case "Derivative":
            {
                let m = t._symbol
                  , d = Re(e, new O.Identifier(m))
                  , y = Vp(r, d)
                  , g = r.getInstruction(y)
                  , f = xg(g.valueType);
                if (!f)
                    throw bE(m, xl(r, [y]), {
                        blockExport: Ye(g)
                    });
                let h, x, T = !1;
                if ((g.type === 2 || g.type === 3) && g.valueType === b)
                    h = e,
                    x = y;
                else {
                    let E = o.childScope();
                    x = r.SymbolicVar(g.valueType),
                    E.addDynamicBinding(m, x),
                    T = !0,
                    h = Ps(e, E)
                }
                let P = 1;
                for (; t.args[0].type === "Derivative" && t.args[0]._symbol === t._symbol; )
                    P += 1,
                    t = t.args[0];
                let S = Wr(r, Re(h, t.args[0]));
                for (let E = 0; E < P; E++)
                    S = tI(r, S, x, f);
                return x === y ? S : (T && r.derivativeMaps.pruneIP(x),
                Rc(r, y, x, S))
            }
        case "Prime":
            {
                let m = t.args[0];
                if (o.isLocal(m._symbol))
                    throw db(m._symbol);
                let d = o.getVisibleGlobalDefinition(m._symbol);
                if (!d)
                    throw hb(m._symbol);
                if (!cl(d))
                    throw db(m._symbol);
                let y = Re(e, m.args[0])
                  , g = Vp(r, y)
                  , f = r.getInstruction(g)
                  , h = xg(f.valueType);
                if (!h)
                    throw TE(m._symbol, xl(r, [g]), {
                        blockExport: Ye(f)
                    });
                let x = !1, T;
                (f.type === 2 || f.type === 3) && f.valueType === b ? T = g : (T = r.SymbolicVar(f.valueType),
                x = !0);
                let P, C;
                if (m._symbol === "logbase") {
                    if (m.args.length !== 2)
                        throw bp();
                    P = [T, Re(e, m.args[1])],
                    C = [m.args[0], m.args[1]]
                } else {
                    if (m.args.length !== 1)
                        throw bp();
                    P = [T],
                    C = [m.args[0]]
                }
                let E = Wr(r, iI(e, m._symbol, m._errorSymbol, P, C));
                for (let M = 0; M < t.order; M++)
                    E = tI(r, E, T, h);
                return T === g ? E : (x && r.derivativeMaps.pruneIP(T),
                Rc(r, g, T, E))
            }
        case "Slider":
            return e.chunk.Constant(qo(wp, t, n, o.frame).asCompilerValue());
        case "Assignment":
            return D_(r, e.selection, t),
            Re(e, t._expression);
        case "FunctionDefinition":
            {
                let m = t;
                if (D_(r, e.selection, m),
                m.recursionInfo)
                    return a2(e, m, m.recursionInfo);
                {
                    let d = e.policy.isRecursionEnabled() && e.policy.assignmentForbidden(m._symbol)
                      , y = o.childScope();
                    return y.setErrorIfAccessed(m._symbol, xp([m._symbol], {
                        suggestAlternativeFunctionName: d
                    })),
                    Re(Ps(e, y), t._expression)
                }
            }
        case "RecursiveFunctionBaseCase":
            {
                let m = o.childScope()
                  , d = t;
                return m.setErrorIfAccessed(d._symbol, OC(d._symbol)),
                Re(Ps(e, m), t._expression)
            }
        case "Construction":
            throw Mi("construction");
        case "Placeholder":
            throw new Error("Programming error, unexpected placeholder");
        default:
            throw new Error(`Programming error, unimplemented node type ${a}`)
        }
    }
    function oI(e, t, n) {
        let r = [Re(e, n[0])];
        return Jd(e.chunk, e.policy, e.selection, t, r),
        eu(e.chunk, e.policy, t, r),
        r
    }
    function Ca(e, t, n) {
        let r = [Re(e, n[0]), Re(e, n[1])];
        return Jd(e.chunk, e.policy, e.selection, t, r),
        eu(e.chunk, e.policy, t, r),
        r
    }
    function sI(e, t) {
        return e.NativeFunction("hypot", [e.Slot(0, [t]), e.Slot(1, [t])])
    }
    function KG(e, t) {
        return xt(e, t, b) ? t : e.Slot(0, [t])
    }
    function e2(e, t) {
        return xt(e, t, b) ? e.Constant(0) : e.Slot(1, [t])
    }
    function t2(e, t) {
        return xt(e, t, b) ? t : e.NativeFunction("complex", [e.Slot(0, [t]), e.Negative([e.Slot(1, [t])])])
    }
    function Xs(e, t) {
        return n2(e, t, "mean")
    }
    function n2(e, t, n) {
        return zs(e, t, n, [{
            match: no(Pe, 0),
            build: () => e.NativeFunction(n, t)
        }, {
            match: no(N, 1),
            build: () => e.NativeFunction("complex", [e.NativeFunction(n, t.map(r => KG(e, r))), e.NativeFunction(n, t.map(r => e2(e, r)))])
        }, {
            match: no(R, 1),
            build: () => {
                let r = o => e.NativeFunction(n, t.map(i => e.Slot(o, [i])));
                return e.TupleOfType(R, [r(0), r(1)])
            }
        }, {
            match: no(G, 1),
            build: () => {
                let r = o => e.NativeFunction(n, t.map(i => e.Slot(o, [i])));
                return e.TupleOfType(G, [r(0), r(1), r(2)])
            }
        }])
    }
    function Pg(e, t) {
        return zs(e, t, "varp", [{
            match: no(Pe, 0),
            build: () => e.NativeFunction("varp", t)
        }, {
            match: no(N, 1),
            build: () => {
                let n = Xs(e, t);
                return Xs(e, t.map(r => BW(e, e.Subtract([r, n]))))
            }
        }])
    }
    function HG(e, t) {
        return aI(e, t) ? Sg(e, t, "var") : zs(e, t, "var", [{
            match: no(Pe, 1),
            build: () => e.NativeFunction("var", t)
        }, {
            match: no(N, 1),
            build: () => {
                let n = e.NativeFunction("count", t);
                return e.Divide([e.Multiply([Pg(e, t), n]), e.Subtract([n, e.Constant(1)])])
            }
        }])
    }
    function UG(e, t, n) {
        let r = e.BeginBroadcast([n])
          , o = e.InboundsListAccess([t, r])
          , i = e.EndBroadcast([r, o]);
        return e.BroadcastResult($n(e.getInstruction(o).valueType), [i])
    }
    function N_(e, t) {
        return zs(e, t, "covp", [{
            match: [na, na],
            noBroadcast: !0,
            build: () => e.NativeFunction("covp", t)
        }, {
            match: [ke, ke],
            noBroadcast: !0,
            build: () => {
                let n = e.NativeFunction("listMin", [Pr(e, t[0]), Pr(e, t[1])])
                  , r = UG(e, t[0], n)
                  , o = UG(e, t[1], n)
                  , i = Xs(e, [r])
                  , s = Xs(e, [o]);
                return Xs(e, [e.Multiply([e.Subtract([r, i]), t2(e, e.Subtract([o, s]))])])
            }
        }])
    }
    function BW(e, t) {
        return e.Add([e.Square([e.Slot(0, [t])]), e.Square([e.Slot(1, [t])])])
    }
    function w_(e, t) {
        let n = e.chunk;
        return xt(n, t, G) ? n.NativeFunction("hypot", [n.Slot(0, [t]), n.NativeFunction("hypot", [n.Slot(1, [t]), n.Slot(2, [t])])]) : xt(n, t, R) ? n.NativeFunction("hypot", [n.Slot(0, [t]), n.Slot(1, [t])]) : void 0
    }
    function kG(e, t, n) {
        let r = e.chunk;
        return xt(r, t, R) && xt(r, n, R) ? r.Add([r.Multiply([r.Slot(0, [t]), r.Slot(0, [n])]), r.Multiply([r.Slot(1, [t]), r.Slot(1, [n])])]) : xt(r, t, G) && xt(r, n, G) ? r.Add([r.Add([r.Multiply([r.Slot(0, [t]), r.Slot(0, [n])]), r.Multiply([r.Slot(1, [t]), r.Slot(1, [n])])]), r.Multiply([r.Slot(2, [t]), r.Slot(2, [n])])]) : void 0
    }
    function $G(e, t, n) {
        let r = e.chunk
          , o = r.Slot(0, [t])
          , i = r.Slot(1, [t])
          , s = r.Slot(2, [t])
          , a = r.Slot(0, [n])
          , u = r.Slot(1, [n])
          , c = r.Slot(2, [n]);
        return r.TupleOfType(G, [r.Subtract([r.Multiply([i, c]), r.Multiply([s, u])]), r.Subtract([r.Multiply([s, a]), r.Multiply([o, c])]), r.Subtract([r.Multiply([o, u]), r.Multiply([i, a])])])
    }
    function ql(e, t, n) {
        let r = [];
        for (let o of n)
            r.push(Re(e, o));
        return Jd(e.chunk, e.policy, e.selection, t, r),
        eu(e.chunk, e.policy, t, r),
        r
    }
    function iI(e, t, n, r, o) {
        var m;
        e = QG(e, t);
        let {chunk: i, scope: s, recursiveFunctionContext: a, substitutionContext: u, policy: c} = e;
        if (t = Ub(c, t),
        a && a.type === "type-inference" && a.definitions[t]) {
            let d = u.getFunctionBodySubstitution(a.fnSymbols);
            if (d && d.substitutedGlobals.length > 0)
                throw Qv(d.operator, d.substitutedGlobals[0], t);
            a.registerFunctionCall(t, r.map(f => i.getInstruction(f).valueType));
            let y = a.definitions[t];
            if (y instanceof v)
                throw y;
            let g = c2(e, a, y, r);
            return i.SymbolicVar(g.returnType)
        }
        let l = s.getSymbol(t);
        if (l !== void 0) {
            let d = i.getInstruction(l);
            if (d.type === 4) {
                if (d.signature.argTypes.length !== r.length)
                    throw Ba(t, d.signature.argTypes.length, r.length, {
                        includeUsageExample: !0
                    });
                for (let y = 0; y < r.length; y++) {
                    let g = i.getInstruction(r[y]).valueType
                      , f = d.signature.argTypes[y];
                    if (!ae(g, f))
                        throw BS(y, Ke(f), Ke(g), {
                            blockExport: Ye(i.getInstruction(r[y]))
                        })
                }
                return i.FunctionCall([l, ...r])
            } else if (ae(d.valueType, we))
                return cI(e.chunk, [l, ...r], n, !0);
            if (r.length >= 1)
                return jG(e, t, o, r);
            throw d.type === 2 ? hb(n) : d.valueType === Rn ? Mb(n) : vb(n)
        }
        let p = s.getVisibleGlobalDefinition(t);
        if (p === void 0 || !cl(p)) {
            if (((m = rt[t]) == null ? void 0 : m.type) === "Placeholder")
                throw t === "logbase" && s.isGlobal("ln") && s.isGlobal("log") ? Ov() : Ga(n, e.policy);
            if (p) {
                let d = Re(e, p);
                if (i.getInstruction(d).valueType === Rn)
                    throw Mb(n);
                if (ae(i.getInstruction(d).valueType, we))
                    return cI(e.chunk, [d, ...r], n, !0)
            }
            if (r.length >= 1)
                return jG(e, t, o, r);
            throw p ? vb(n) : F(`Programming Error: reached undefined symbol ${t}`)
        }
        if (_y(p)) {
            if (r.length !== p._argSymbols.length)
                throw Ba(n, p._argSymbols.length, r.length, {
                    includeUsageExample: !0
                });
            if (p.getDependencies().includes("globalRandomSeed") && c.shouldIncludeFunctionParametersInRandomSeed()) {
                let d = zG(e, p, r)
                  , y = r.filter( (g, f) => d[f] === 2);
                if (y.length > 0) {
                    let g = Md(i, y);
                    if (g === void 0)
                        throw F("Programming error: expected list length to be defined");
                    let f = i.BeginBroadcast([g])
                      , h = [];
                    for (let C = 0; C < r.length; C++)
                        d[C] === 2 ? h.push(Yu(i, r[C], f)) : h.push(r[C]);
                    let x = rI(e, p, h, o)
                      , T = i.EndBroadcast([f, x])
                      , P = i.getInstruction(x).valueType;
                    if (jn(P))
                        return i.BroadcastResult($n(P), [T])
                }
            }
            return rI(e, p, r, o)
        } else {
            if (qa.hasOwnProperty(t))
                return zW(e, t, n, r, o);
            if (ir.hasOwnProperty(t))
                return Ki(e, t, r);
            throw Ga(n, e.policy)
        }
    }
    function rI(e, t, n, r) {
        let {scope: o} = e
          , i = o.newLexicalScope().childScope();
        for (let a = 0; a < t._argSymbols.length; a++)
            i.addLexicalBinding(t._argSymbols[a], n[a], r && r[a]);
        let s = Ps(e, i);
        return t.recursionInfo ? a2(s, t, t.recursionInfo) : Re(s, t._expression)
    }
    function GW(e, t) {
        let n = tu(e, t)
          , r = e.Add([n, ti(e, t)]);
        return e.NativeFunction("segment", [n, r])
    }
    function Ki(e, t, n) {
        let {chunk: r} = e
          , o = ir[t]
          , i = n.length
          , {minArity: s, maxArity: a} = o;
        if (i > a || i < s)
            throw F("Unexpected arity mismatch");
        let u = r2(r, n, o);
        switch (o.tag) {
        case "default":
        case "reducer":
        case "doubleReducer":
        case "parameterizedReducer":
        case "color":
        case "never-broadcast":
            return r.NativeFunction(t, u);
        case "trig":
            {
                let c = Re(e, new O.Identifier("trigAngleMultiplier"))
                  , l = r.Multiply([u[0], c]);
                return r.NativeFunction(t, [l])
            }
        case "trig2":
            {
                let c = Re(e, new O.Identifier("trigAngleMultiplier"))
                  , l = r.Multiply([u[1], c]);
                return r.NativeFunction(t, [u[0], l])
            }
        case "inverseTrig":
            {
                let c = Re(e, new O.Identifier("trigAngleMultiplier"))
                  , l = r.NativeFunction(t, u);
                return r.Divide([l, c])
            }
        default:
            {
                let c = o.tag;
                throw new Error(`Programming Error: unexpected tag ${c}`)
            }
        }
    }
    function r2(e, t, {minArity: n, defaultArguments: r}) {
        if (!r || !(t.length - n < r.length))
            return t;
        let o = t.slice();
        for (; o.length - n < r.length; )
            o.push(e.copyLeafInstruction(r[o.length - n]));
        return o
    }
    function qW(e, t, n) {
        let r = [n.noBroadcast ? St(n.match) : q(n.match)];
        return Ax(r, t.map(o => e.getInstruction(o).valueType), 0).length > 0
    }
    function zs(e, t, n, r) {
        let o = r.find(i => qW(e, t, i));
        if (!o) {
            if (typeof n == "string")
                throw $i(n, Ka(e, t), {
                    blockExport: e.areAllArgsConstant(t)
                });
            return n(e, t)
        }
        return o.build(e, t)
    }
    function YG(e, t) {
        if (t.length !== 2)
            throw F("Can only take the midpoint of two points");
        let n = e.Constant(be(1, 2));
        return e.Multiply([n, e.Add(t)])
    }
    function zW(e, t, n, r, o) {
        var y, g;
        let {chunk: i, policy: s} = e
          , a = qa[t]
          , {minArity: u, maxArity: c} = a
          , l = r.length;
        if (l < u || l > c)
            throw Fy(t) ? WM(i, {
                symbol: t,
                errorSymbol: n,
                argsWithoutSeed: r,
                signatures: a.getSignatures(s),
                minArity: u,
                providedArgs: r,
                builtInTag: void 0,
                defaultArgumentCount: (g = (y = a.defaultArguments) == null ? void 0 : y.length) != null ? g : 0,
                isDotCall: !1,
                maxArity: c
            }) : new Error("Programming Error: unexpected arity mismatch");
        let p;
        if (t === "cdf")
            l === 2 ? p = [r[0], i.Constant(-1 / 0), r[1]] : p = r;
        else if (t === "random")
            if (l === 1 || l < 4 && !X(i.getInstruction(r[1]).valueType) && i.getInstruction(r[1]).valueType !== Rn) {
                let f = i.Distribution("uniformdist", [i.Constant(0), i.Constant(1)]);
                p = [r[0], f].concat(r.slice(1))
            } else
                p = r;
        else
            p = r2(i, r, a);
        let m = Py(s, t);
        if (t === "join") {
            let f = [];
            for (let x of p)
                f.push(i.getInstruction(x).valueType);
            let h = Dw(f);
            m = [St({
                type: "variadic",
                initial: [h, h],
                rest: h
            })]
        }
        if (m) {
            let f = s0(i, p, m);
            f.didCoerce && (p = f.args)
        }
        function d(f, h=n) {
            return zs(i, p, h, f)
        }
        switch (t) {
        case "length":
            if (s.isGeometryEnabled() || s.is3dPolicy()) {
                let f = p[0];
                return d([{
                    match: [en],
                    build: () => {
                        let h = i.Constant(0)
                          , x = i.Constant(1);
                        return i.NativeFunction("distanceThreeD", [i.NativeFunction("segmentThreeDGlider", [f, h]), i.NativeFunction("segmentThreeDGlider", [f, x])])
                    }
                }, {
                    match: [Ee],
                    build: () => {
                        let h = i.Constant(0)
                          , x = i.Constant(1);
                        return i.NativeFunction("distance", [i.NativeFunction("segmentGlider", [f, h]), i.NativeFunction("segmentGlider", [f, x])])
                    }
                }, {
                    match: [ce],
                    build: () => {
                        let h = i.NativeFunction("abs", [i.NativeFunction("arcOmega", [p[0]])])
                          , {radius: x, startPoint: T} = ZW(i, p[0])
                          , P = i.NativeFunction("arcThirdPoint", [p[0]]);
                        return i.Piecewise([i.Equal([h, i.Constant(0)]), i.NativeFunction("distance", [T, P]), i.Multiply([x, h])])
                    }
                }, {
                    match: [TP],
                    build: () => w_(e, ti(i, f))
                }])
            } else
                return i.NativeFunction("count", p);
        case "round":
            return d([{
                match: [Pe],
                build: () => i.NativeFunction("round", p)
            }, {
                match: [Pe, b],
                build: () => {
                    let f = i.NativeFunction("round", [p[1]])
                      , h = i.RawExponent([i.Constant(10), f]);
                    return i.Divide([i.NativeFunction("round", [i.Multiply([p[0], h])]), h])
                }
            }, {
                match: [N],
                build: () => i.NativeFunction("complexRound", p)
            }, {
                match: [N, b],
                build: () => {
                    let f = i.NativeFunction("round", [p[1]])
                      , h = i.RawExponent([i.Constant(10), f]);
                    return i.Divide([i.NativeFunction("complexRound", [i.Multiply([p[0], h])]), h])
                }
            }]);
        case "abs":
            return d([{
                match: [Pe],
                build: () => i.NativeFunction(t, p)
            }, {
                match: [N],
                build: () => sI(i, p[0])
            }]);
        case "coerceToReal":
            return d([{
                match: [N],
                build: () => i.NativeFunction("peelableCoerceComplexToReal", p)
            }, {
                match: [Dn],
                build: () => p[0]
            }]);
        case "real":
            return KG(i, p[0]);
        case "imag":
            return e2(i, p[0]);
        case "conj":
            return t2(i, p[0]);
        case "exp":
        case "sin":
        case "cos":
        case "tan":
        case "sinh":
        case "cosh":
        case "tanh":
        case "sec":
        case "csc":
        case "cot":
        case "sech":
        case "csch":
        case "coth":
        case "arccot":
        case "arcsinh":
        case "arccsch":
        case "floor":
        case "ceil":
            return d([{
                match: [Pe],
                build: () => Ki(e, t, p)
            }, {
                match: [N],
                build: () => Ki(e, Um[t], p)
            }]);
        case "arctan":
            return d([{
                match: [Pe],
                build: () => Ki(e, t, p.concat(i.Constant(1)))
            }, {
                match: [b, b],
                build: () => Ki(e, t, p)
            }, {
                match: [N],
                build: () => Ki(e, Um[t], p)
            }]);
        case "mod":
            return d([{
                match: [Pe, Pe],
                build: () => Ki(e, t, p)
            }, {
                match: [N, N],
                build: () => Ki(e, Um[t], p)
            }]);
        case "nthroot":
            return i.Exponent([p[0], i.Divide([i.Constant(1), p[1]])]);
        case "complexNthRoot":
            return i.NativeFunction("complexPow", [p[0], i.Divide([i.Constant(1), p[1]])]);
        case "sign":
            return d([{
                match: [Pe],
                build: () => Ki(e, t, p)
            }, {
                match: [N],
                build: () => {
                    let f = p[0];
                    return i.Piecewise([i.Equal([f, i.ZeroOfType(N)]), f, i.Divide([f, sI(i, f)])])
                }
            }]);
        case "midpoint":
            return d([{
                match: [Ee],
                build: () => {
                    let f = i.Constant(be(1, 2));
                    return i.NativeFunction("segmentGlider", [p[0], f])
                }
            }, {
                match: [en],
                build: () => {
                    let f = i.Constant(be(1, 2));
                    return i.NativeFunction("segmentThreeDGlider", [p[0], f])
                }
            }, {
                match: [R, R],
                build: YG
            }, {
                match: [G, G],
                build: YG
            }]);
        case "circle":
            return d([{
                match: [R, Ee],
                build: () => {
                    let f = i.Constant(0)
                      , h = i.Constant(1);
                    return i.NativeFunction("circle", [p[0], i.NativeFunction("distance", [i.NativeFunction("segmentGlider", [p[1], f]), i.NativeFunction("segmentGlider", [p[1], h])])])
                }
            }, {
                match: [R, R],
                build: () => i.NativeFunction("circle", [p[0], i.NativeFunction("distance", p)])
            }, {
                match: [R, b],
                build: () => i.NativeFunction("circle", p)
            }]);
        case "segment":
            return d(Uy("segment", "segmentThreeD"));
        case "vector":
            return d(Uy("vector", "vectorThreeD"));
        case "sphere":
            return d([{
                match: [G, b],
                build: (f, h) => f.NativeFunction("sphere", h)
            }, {
                match: [R, b],
                build: (f, h) => f.NativeFunction("sphere", [f.TupleOfType(G, [f.Slot(0, [h[0]]), f.Slot(1, [h[0]]), f.Constant(0)]), h[1]])
            }]);
        case "distance":
            return d(Uy("distance", "distanceThreeD"));
        case "center":
            return d([{
                match: [he],
                build: () => i.NativeFunction("center", [p[0]])
            }, {
                match: [ce],
                build: () => i.NativeFunction("arcCenter", [p[0]])
            }]);
        case "radius":
            return d([{
                match: [he],
                build: () => i.NativeFunction("radius", [p[0]])
            }, {
                match: [ce],
                build: () => i.NativeFunction("distance", [i.NativeFunction("arcFirstPoint", [p[0]]), i.NativeFunction("arcCenter", [p[0]])])
            }]);
        case "glider":
            return o2(e.chunk, p);
        case "intersection":
        case "strictintersection":
            {
                let f = 0;
                t === "strictintersection" && ((xt(i, p[0], Ee) || xt(i, p[0], ce)) && (f += 3),
                (xt(i, p[1], Ee) || xt(i, p[1], ce)) && (f += 12),
                xt(i, p[0], Ae) && (f += 1),
                xt(i, p[1], Ae) && (f += 4));
                let h = WW(e, o, p)
                  , x = h && ku(h);
                if (!h || !x)
                    return O_(i, p, f);
                let T = Re(e, new O.Identifier(x))
                  , P = Ja(h);
                return P !== void 0 && (T = i.ListAccess([T, i.Constant(P)])),
                i.NativeFunction("chooseNonIncidentPoint", [T, O_(i, [p[0], p[1]], f), O_(i, [p[1], p[0]], f << 2 & 12 | f >> 2 & 3)])
            }
        case "parallel":
        case "perpendicular":
            return d([{
                match: [ph, R],
                build: () => {
                    let h = [uI(i, p[0]), p[1]];
                    return i.NativeFunction(t, h)
                }
            }]);
        case "anglebisector":
            return d([{
                match: [Oe],
                build: () => i.NativeFunction("anglebisector", p)
            }, {
                match: [Se],
                build: () => i.NativeFunction("directedanglebisector", p)
            }]);
        case "start":
            return tu(i, p[0]);
        case "end":
            return i.Add([tu(i, p[0]), ti(i, p[0])]);
        case "translate":
        case "reflect":
        case "rotate":
        case "dilate":
            return XW(e, t, p);
        case "apply":
            return cI(i, p, n, !1);
        case "normaldist":
        case "tdist":
        case "chisqdist":
        case "poissondist":
        case "geodist":
        case "binomialdist":
        case "uniformdist":
            return i.Distribution(t, p);
        case "median":
        case "quantile":
            return aI(i, r) ? Sg(i, p, t) : Ki(e, t, r);
        case "stdev":
            return aI(i, r) ? Sg(i, p, t) : d([{
                match: no(Pe, 1),
                build: () => Ki(e, t, r)
            }, {
                match: no(N, 1),
                build: () => i.NativeFunction("sqrt", [HG(i, p)])
            }]);
        case "stdevp":
            return d([{
                match: no(Pe, 1),
                build: () => Ki(e, t, r)
            }, {
                match: no(N, 1),
                build: () => i.NativeFunction("sqrt", [Pg(i, p)])
            }]);
        case "var":
            return HG(i, p);
        case "cov":
            return d([{
                match: [na, na],
                noBroadcast: !0,
                build: () => Ki(e, t, r)
            }, {
                match: [ke, ke],
                noBroadcast: !0,
                build: () => {
                    let f = i.NativeFunction("listMin", [Pr(i, p[0]), Pr(i, p[1])]);
                    return i.Divide([i.Multiply([N_(i, p), f]), i.Subtract([f, i.Constant(1)])])
                }
            }]);
        case "corr":
            return d([{
                match: [na, na],
                noBroadcast: !0,
                build: () => Ki(e, t, r)
            }, {
                match: [ke, ke],
                noBroadcast: !0,
                build: () => i.Divide([N_(i, p), i.NativeFunction("sqrt", [i.Multiply([Pg(i, [p[0]]), Pg(i, [p[1]])])])])
            }]);
        case "mad":
            return d([{
                match: no(Pe, 1),
                build: () => Ki(e, t, r)
            }, {
                match: no(N, 1),
                build: () => {
                    let f = Xs(i, p);
                    return Xs(i, p.map(h => sI(i, i.Subtract([h, f]))))
                }
            }]);
        case "pdf":
        case "cdf":
            return Sg(i, p, t);
        case "varp":
            return Pg(i, p);
        case "covp":
            return N_(i, p);
        case "total":
        case "mean":
            return t === "mean" && aI(i, r) ? Sg(i, p, t) : n2(i, p, t);
        case "lcm":
        case "gcd":
            return d([{
                match: no(Pe, 1),
                build: () => i.NativeFunction(t, p)
            }, {
                match: no(N, 1),
                build: () => {
                    let f;
                    switch (t) {
                    case "lcm":
                        f = "complexLCM";
                        break;
                    case "gcd":
                        f = "complexGCD";
                        break
                    }
                    return i.NativeFunction(f, p)
                }
            }]);
        case "min":
            return d([{
                match: [b, b],
                build: () => i.NativeFunction("min", p)
            }, {
                match: no(b, 0),
                build: () => i.NativeFunction("listMin", p)
            }, {
                match: [Pt],
                build: () => i.NamedSlot("min", [p[0]])
            }]);
        case "lower":
            return d([{
                match: [Pt],
                build: () => i.NamedSlot("min", [p[0]])
            }]);
        case "max":
            return d([{
                match: [b, b],
                build: () => i.NativeFunction("max", p)
            }, {
                match: no(b, 0),
                build: () => i.NativeFunction("listMax", p)
            }, {
                match: [Pt],
                build: () => i.NamedSlot("max", [p[0]])
            }]);
        case "upper":
            return d([{
                match: [Pt],
                build: () => i.NamedSlot("max", [p[0]])
            }]);
        case "random":
            {
                let f = p[0]
                  , h = p[1]
                  , x = i.getInstruction(p[0])
                  , T = i.getInstruction(h);
                if (x.valueType !== _t)
                    throw F(`Unexpected value type for seed arg: ${x.valueType}`);
                if (T.valueType === gi)
                    throw QE();
                let P;
                if (X(T.valueType))
                    P = BG;
                else {
                    if (T.type !== 42 || T.valueType !== Rn)
                        throw F('Expected distribution argument to "random"');
                    P = Ea[T.symbol][t]
                }
                if (p.length > 2) {
                    let C = p[2]
                      , S = i.getInstruction(C);
                    if (S.valueType !== b)
                        throw F(`Expected numSamples argument to random() to be a number but got ${S.valueType}`);
                    if (p.length === 4) {
                        if (i.getInstruction(p[3]).valueType !== b)
                            throw F(`Expected userSeed argument to random() to be a number but got ${S.valueType}`);
                        f = i.ExtendSeed("us", [f, p[3]])
                    }
                    let E = i.Constant(1)
                      , M = i.NativeFunction("round", [i.NativeFunction("validateSampleCount", [C])])
                      , _ = i.BeginBroadcast([M]);
                    f = i.ExtendSeed("lc", [f, i.Subtract([_, E])]);
                    let U = P(i, h, [f])
                      , Q = i.EndBroadcast([_, U]);
                    return i.BroadcastResult($n(i.getInstruction(U).valueType), [Q])
                }
                return P(i, h, [f])
            }
        case "shuffle":
            {
                let f = p[0]
                  , h = p[1]
                  , x = p[2];
                if (!X(i.getInstruction(h).valueType) || x !== void 0 && i.getInstruction(x).valueType !== b)
                    throw F(`Unexpected args for "${t}"`);
                return x !== void 0 && (f = i.ExtendSeed("us", [f, x])),
                i.NativeFunction("shuffle", [f, h])
            }
        case "sort":
            return d([{
                match: [Y],
                noBroadcast: !0,
                build: () => ZG(e, p[0], p[0])
            }, {
                match: [Ui, Y],
                noBroadcast: !0,
                build: () => ZG(e, p[0], p[1])
            }]);
        case "join":
            return wx(i, p, n, r);
        case "unique":
            {
                let f = p[0]
                  , h = i.getInstruction(f);
                if (!X(h.valueType) || h.valueType === gi)
                    throw F(`Unexpected types for ${t}`);
                return i.NativeFunction("elementsAt", [f, i.NativeFunction("uniquePerm", [f])])
            }
        case "polygon":
            return d([{
                match: [],
                build: () => {
                    let f = i.ConstantOfType(zt, []);
                    return i.NativeFunction("polygon", [f])
                }
            }, {
                match: [b, b],
                noBroadcast: !0,
                build: () => {
                    throw ry()
                }
            }, {
                match: [b, b],
                build: () => {
                    let f = i.TupleOfType(R, p);
                    return i.NativeFunction("polygon", [f])
                }
            }, {
                match: {
                    type: "variadic",
                    initial: [],
                    rest: R
                },
                build: () => i.NativeFunction("polygon", p)
            }]);
        case "directedangle":
            return XG(e, p, n);
        case "angle":
            return i.NativeFunction("undirectedAngleMarker", [XG(e, p, n)]);
        case "angles":
            return i.NativeFunction("polygonInteriorUndirectedAngles", [p[0], Re(e, new O.Identifier("trigAngleMultiplier"))]);
        case "directedangles":
            return i.NativeFunction("polygonInteriorDirectedAngles", [p[0], Re(e, new O.Identifier("trigAngleMultiplier"))]);
        case "coterminal":
            {
                if (xt(i, p[0], Se))
                    return i.NativeFunction("directedCoterminalAngle", p);
                if (xt(i, p[0], Oe))
                    return i.NativeFunction("undirectedCoterminalAngle", p);
                throw F(`Unexpected types for ${t}`)
            }
        case "ttest":
            return d([{
                match: [Y],
                noBroadcast: !0,
                build: () => {
                    let f = p[0]
                      , h = i.NativeFunction("count", [f]);
                    return Fp(i, h, n),
                    i.TupleOfType($t, {
                        mean: Xs(i, [f]),
                        stdev: i.NativeFunction("stdev", [f]),
                        count: h,
                        dof: i.Subtract([h, i.Constant(1)])
                    })
                }
            }, {
                match: [b, b, b],
                build: () => {
                    let[f,h,x] = p;
                    return Fp(i, f, n),
                    i.TupleOfType($t, {
                        count: f,
                        mean: h,
                        stdev: x,
                        dof: i.Subtract([f, i.Constant(1)])
                    })
                }
            }, {
                match: [Y, Y],
                noBroadcast: !0,
                build: () => {
                    let f = p[0]
                      , h = p[1]
                      , x = {
                        mean: Xs(i, [f]),
                        count: i.NativeFunction("count", [f]),
                        stdev: i.NativeFunction("stdev", [f])
                    }
                      , T = {
                        mean: Xs(i, [h]),
                        count: i.NativeFunction("count", [h]),
                        stdev: i.NativeFunction("stdev", [h])
                    };
                    return Fp(i, x.count, n),
                    Fp(i, T.count, n),
                    i.TupleOfType(wt, {
                        mean1: x.mean,
                        stdev1: x.stdev,
                        count1: x.count,
                        mean2: T.mean,
                        stdev2: T.stdev,
                        count2: T.count,
                        dof: Vx(i, x, T)
                    })
                }
            }, {
                match: [b, b, b, b, b, b],
                build: () => {
                    let[f,h,x,T,P,C] = p
                      , S = {
                        count: f,
                        mean: h,
                        stdev: x
                    }
                      , E = {
                        count: T,
                        mean: P,
                        stdev: C
                    };
                    return Fp(i, S.count, n),
                    Fp(i, E.count, n),
                    i.TupleOfType(wt, {
                        count1: f,
                        mean1: h,
                        stdev1: x,
                        count2: T,
                        mean2: P,
                        stdev2: C,
                        dof: Vx(i, S, E)
                    })
                }
            }]);
        case "ztest":
            return d([{
                match: [Y, Fr(b)],
                noBroadcast: !0,
                build: () => {
                    let f = p[0];
                    return i.TupleOfType(Qt, {
                        mean: Xs(i, [f]),
                        count: i.NativeFunction("count", [f]),
                        stdevp: p[1]
                    })
                }
            }, {
                match: [b, b, b],
                build: () => {
                    let[f,h,x] = p;
                    return i.TupleOfType(Qt, {
                        count: f,
                        mean: h,
                        stdevp: x
                    })
                }
            }, {
                match: [Y, Fr(b), Y, Fr(b)],
                noBroadcast: !0,
                build: () => {
                    let f = p[0]
                      , h = p[2];
                    return i.TupleOfType(Ht, {
                        mean1: Xs(i, [f]),
                        count1: i.NativeFunction("count", [f]),
                        stdevp1: p[1],
                        mean2: Xs(i, [h]),
                        count2: i.NativeFunction("count", [h]),
                        stdevp2: p[3]
                    })
                }
            }, {
                match: [b, b, b, b, b, b],
                build: () => {
                    let[f,h,x,T,P,C] = p;
                    return i.TupleOfType(Ht, {
                        mean1: h,
                        count1: f,
                        stdevp1: x,
                        mean2: P,
                        count2: T,
                        stdevp2: C
                    })
                }
            }]);
        case "zproptest":
            return d([{
                match: [b, b],
                build: () => i.TupleOfType(an, {
                    successes: p[0],
                    count: p[1]
                })
            }, {
                match: [b, b, b, b],
                build: () => i.TupleOfType(Yt, {
                    successes1: p[0],
                    count1: p[1],
                    successes2: p[2],
                    count2: p[3]
                })
            }]);
        case "null":
            return _d(i, p);
        case "conf":
            return d([{
                match: [$t, b],
                build: () => {
                    let f = {
                        mean: i.NamedSlot("mean", [p[0]]),
                        stdev: i.NamedSlot("stdev", [p[0]]),
                        count: i.NamedSlot("count", [p[0]])
                    }
                      , h = p[1];
                    return kw(i, f, h)
                }
            }, {
                match: [wt, b],
                build: () => {
                    let f = {
                        mean: i.NamedSlot("mean1", [p[0]]),
                        stdev: i.NamedSlot("stdev1", [p[0]]),
                        count: i.NamedSlot("count1", [p[0]])
                    }
                      , h = {
                        mean: i.NamedSlot("mean2", [p[0]]),
                        stdev: i.NamedSlot("stdev2", [p[0]]),
                        count: i.NamedSlot("count2", [p[0]])
                    }
                      , x = p[1];
                    return Yw(i, f, h, x)
                }
            }, {
                match: [Kt, b],
                build: () => {
                    let f = {
                        estimate: i.NamedSlot("pointEstimate", [p[0]]),
                        standardError: i.NamedSlot("standardError", [p[0]]),
                        dof: i.NamedSlot("dof", [p[0]])
                    }
                      , h = p[1];
                    return $w(i, f, h)
                }
            }, {
                match: [Qt, b],
                build: () => {
                    let f = {
                        mean: i.NamedSlot("mean", [p[0]]),
                        count: i.NamedSlot("count", [p[0]])
                    }
                      , h = i.NamedSlot("stdevp", [p[0]])
                      , x = p[1];
                    return Zw(i, f, h, x)
                }
            }, {
                match: [Ht, b],
                build: () => {
                    let f = {
                        mean: i.NamedSlot("mean1", [p[0]]),
                        count: i.NamedSlot("count1", [p[0]])
                    }
                      , h = i.NamedSlot("stdevp1", [p[0]])
                      , x = {
                        mean: i.NamedSlot("mean2", [p[0]]),
                        count: i.NamedSlot("count2", [p[0]])
                    }
                      , T = i.NamedSlot("stdevp2", [p[0]])
                      , P = p[1];
                    return Xw(i, f, h, x, T, P)
                }
            }, {
                match: [an, b],
                build: () => Hw(i, {
                    successes: i.NamedSlot("successes", [p[0]]),
                    count: i.NamedSlot("count", [p[0]])
                }, p[1])
            }, {
                match: [Yt, b],
                build: () => Uw(i, {
                    successes: i.NamedSlot("successes1", [p[0]]),
                    count: i.NamedSlot("count1", [p[0]])
                }, {
                    successes: i.NamedSlot("successes2", [p[0]]),
                    count: i.NamedSlot("count2", [p[0]])
                }, p[1])
            }]);
        case "score":
            {
                let f = i.getInstruction(p[0]).valueType
                  , h = Ti(rr(f)) ? _d(i, p) : p[0];
                return i.NamedSlot("score", [h])
            }
        case "dof":
            return i.NamedSlot("dof", [p[0]]);
        case "estimate":
            return d([{
                match: [Kt],
                build: () => i.NamedSlot("pointEstimate", [p[0]])
            }, {
                match: [$t],
                build: () => i.NamedSlot("mean", [p[0]])
            }, {
                match: [Qt],
                build: () => i.NamedSlot("mean", [p[0]])
            }, {
                match: [wt],
                build: () => i.Subtract([i.NamedSlot("mean1", [p[0]]), i.NamedSlot("mean2", [p[0]])])
            }, {
                match: [Ht],
                build: () => i.Subtract([i.NamedSlot("mean1", [p[0]]), i.NamedSlot("mean2", [p[0]])])
            }, {
                match: [an],
                build: () => i.Divide([i.NamedSlot("successes", [p[0]]), i.NamedSlot("count", [p[0]])])
            }, {
                match: [Yt],
                build: () => i.Subtract([i.Divide([i.NamedSlot("successes1", [p[0]]), i.NamedSlot("count1", [p[0]])]), i.Divide([i.NamedSlot("successes2", [p[0]]), i.NamedSlot("count2", [p[0]])])])
            }]);
        case "stderr":
            return d([{
                match: [Kt],
                build: () => i.NamedSlot("standardError", [p[0]])
            }, {
                match: [$t],
                build: () => t0(i, {
                    stdev: i.NamedSlot("stdev", [p[0]]),
                    count: i.NamedSlot("count", [p[0]])
                })
            }, {
                match: [wt],
                build: () => n0(i, {
                    stdev: i.NamedSlot("stdev1", [p[0]]),
                    count: i.NamedSlot("count1", [p[0]])
                }, {
                    stdev: i.NamedSlot("stdev2", [p[0]]),
                    count: i.NamedSlot("count2", [p[0]])
                })
            }, {
                match: [Qt],
                build: () => r0(i, i.NamedSlot("stdevp", [p[0]]), i.NamedSlot("count", [p[0]]))
            }, {
                match: [Ht],
                build: () => o0(i, i.NamedSlot("stdevp1", [p[0]]), i.NamedSlot("count1", [p[0]]), i.NamedSlot("stdevp2", [p[0]]), i.NamedSlot("count2", [p[0]]))
            }, {
                match: [an],
                build: () => QM(i, {
                    successes: i.NamedSlot("successes", [p[0]]),
                    count: i.NamedSlot("count", [p[0]])
                })
            }, {
                match: [Yt],
                build: () => KM(i, {
                    successes: i.NamedSlot("successes1", [p[0]]),
                    count: i.NamedSlot("count1", [p[0]])
                }, {
                    successes: i.NamedSlot("successes2", [p[0]]),
                    count: i.NamedSlot("count2", [p[0]])
                })
            }]);
        case "pleft":
            {
                let f = i.getInstruction(p[0]).valueType
                  , h = Ti(rr(f)) ? _d(i, p) : p[0];
                return i.NamedSlot("pleft", [h])
            }
        case "pright":
            {
                let f = i.getInstruction(p[0]).valueType
                  , h = Ti(rr(f)) ? _d(i, p) : p[0];
                return i.NamedSlot("pright", [h])
            }
        case "chisqtest":
            return jw(i, p, n, r);
        case "chisqgof":
            return d([{
                match: [Y],
                noBroadcast: !0,
                build: () => {
                    let f = i.NativeFunction("mean", p)
                      , h = i.Piecewise([i.ConstantOfType(Fe, !0), f, p[0]]);
                    return i0(i, p[0], h, n)
                }
            }, {
                match: [Y, Y],
                noBroadcast: !0,
                build: () => i0(i, p[0], p[1], n)
            }]);
        case "histogram":
        case "dotplot":
        case "boxplot":
        case "stats":
        case "det":
        case "inv":
        case "transpose":
        case "rref":
        case "trace":
        case "points":
        case "lines":
        case "circles":
        case "polygons":
        case "rays":
        case "arcs":
        case "vectors":
            throw Mi(n);
        default:
            {
                let f = t;
                throw new Error(`Programming Error: unexpected compiler function ${f}`)
            }
        }
    }
    function o2(e, t) {
        return zs(e, t, "glider", [{
            match: [Ee, b],
            build: () => e.NativeFunction("segmentGlider", t)
        }, {
            match: [Ce, b],
            build: () => e.NativeFunction("lineGlider", t)
        }, {
            match: [Ae, b],
            build: () => e.NativeFunction("rayGlider", t)
        }, {
            match: [he, b],
            build: () => e.NativeFunction("circleGlider", t)
        }, {
            match: [ce, b],
            build: () => e.NativeFunction("arcGlider", t)
        }, {
            match: [De, b],
            build: () => e.NativeFunction("polygonGlider", t)
        }])
    }
    function ZG(e, t, n) {
        let {chunk: r} = e;
        if (Un(r, n) === 0)
            return n;
        let i = r.NativeFunction("listMin", [Pr(r, t), Pr(r, n)]);
        return n = r.ListAccess([n, F_(e, r.List([r.Constant(1)]), r.List([i]), {
            stepMustBePositive: !0
        })]),
        r.NativeFunction("elementsAt", [t, HW(e, [n])])
    }
    function HW(e, t) {
        let {chunk: n} = e
          , r = "sortPerm";
        return zs(n, t, "sort", [{
            match: [na],
            build: () => n.NativeFunction(r, t),
            noBroadcast: !0
        }, {
            match: [ke],
            build: () => n.NativeFunction(Um[r], t),
            noBroadcast: !0
        }])
    }
    function Sg(e, t, n) {
        let r = t[0]
          , o = e.getInstruction(r);
        if (!ae(o.valueType, Rn))
            throw F(`Unexpected args for "${n}"`);
        let i = t.slice(1);
        for (let s of i)
            if (!ae(e.getInstruction(s).valueType, b))
                throw F(`Unexpected args for "${n}"`);
        if (X(o.valueType)) {
            let s = []
              , a = 1 / 0;
            for (let c of t) {
                let l = Wr(e, c);
                s.push(l);
                let p = e.getInstruction(l);
                if (X(p.valueType)) {
                    let m = Un(e, l);
                    if (m === void 0)
                        throw fy(Go(e, l));
                    a = Math.min(a, m)
                }
            }
            let u = [];
            for (let c = 0; c < a; c++) {
                let l = By(e, s[0], c)
                  , p = e.getInstruction(l);
                if (p.type !== 42)
                    throw F(`Unexpected opcode for distribution arg: ${p.type}`);
                let m = [];
                for (let d of s.slice(1))
                    X(e.getInstruction(d).valueType) ? m.push(By(e, d, c)) : m.push(d);
                u.push(Ea[p.symbol][n](e, l, m))
            }
            return e.List(u)
        } else {
            if (o.type !== 42)
                throw F(`Unexpected opcode for distribution arg: ${o.type}`);
            return Ea[o.symbol][n](e, r, i)
        }
    }
    function aI(e, t) {
        return t.length !== 0 && e.getInstruction(t[0]).valueType !== He && ae(e.getInstruction(t[0]).valueType, Rn)
    }
    function UW(e, t) {
        Br(t.args);
        let n = ql(e, t, t.args);
        return i2(e, n)
    }
    function i2(e, t) {
        let {chunk: n} = e
          , r = !1
          , o = !1;
        for (let i = 0; i < t.length; i++) {
            let a = n.getInstruction(t[i]).valueType;
            r = r || a === pt,
            o = o || a !== pt
        }
        if (r && o)
            throw F("Unexpected mix of actions and non-actions");
        if (r)
            return s2(e, t);
        if (t.length === 2)
            return n.TupleOfType(R, t);
        if (t.length == 3)
            return n.TupleOfType(G, t);
        throw F(`Unexpected tuple dimensions: ${t.length}`)
    }
    function kW(e, t) {
        let {chunk: n} = e;
        Br(t.args);
        let r = ql(e, t, t.args);
        if (r.length < 1)
            throw F("Empty bare sequence");
        let o = n.getInstruction(r[0]).valueType;
        if (o === b)
            throw F("Ambiguous bare sequence");
        return o === pt ? s2(e, r) : n.List(r)
    }
    function s2(e, t) {
        let {chunk: n} = e
          , r = []
          , o = [];
        for (let i of t) {
            let s = n.getInstruction(i);
            switch (s.type) {
            case 49:
                {
                    Array.prototype.push.apply(r, s.symbols),
                    Array.prototype.push.apply(o, s.args);
                    break
                }
            case 1:
                {
                    let u = s.value.updateRules;
                    for (let c of ue(u)) {
                        let l = u[c];
                        r.push(c),
                        o.push(n.ConstantOfType(l.valueType, l.value))
                    }
                    break
                }
            default:
                {
                    let a = Go(n, i);
                    throw a.length > 0 ? wE(a) : F(`Unexpected opcode for action: ${s.type}`)
                }
            }
        }
        return n.Action(r, o)
    }
    function L_(e, t) {
        let {scope: n, policy: r} = e;
        if (n.isLocal(t))
            return sb(t);
        let o = n.getVisibleGlobalDefinition(t);
        return r.assignmentForbidden(t) ? OE(t) : o && o.type === "FunctionDefinition" ? AE(t) : NE(t).allowExport()
    }
    function $W(e, t) {
        switch (e.getInstruction(t).valueType) {
        case Ee:
        case he:
        case ce:
            return [e.Constant(0), e.Constant(1)];
        case Ce:
            return [e.Constant(-1 / 0), e.Constant(1 / 0)];
        case Ae:
            return [e.Constant(0), e.Constant(1 / 0)];
        case De:
            return [e.Constant(0), e.NativeFunction("count", [e.NativeFunction("vertices", [t])])];
        default:
            return
        }
    }
    function YW(e, t) {
        let {policy: n, chunk: r, scope: o, selection: i} = e;
        if (!(t instanceof Tc))
            throw new Error("Programming error: expected a ListComprehension node but got " + t.type);
        let s = t._body
          , a = []
          , u = []
          , c = r.Constant(1)
          , l = o.childScope();
        Br(t._inputLists);
        for (let {_symbol: x} of t._inputLists) {
            let T = x;
            l.setErrorIfAccessed(T, Uv(T))
        }
        for (let x of t.parameters) {
            let T = x.identifier._symbol;
            l.setErrorIfAccessed(T, kv(T))
        }
        let p = Ps(e, l);
        for (let x = t._inputLists.length - 1; x >= 0; x--) {
            let T = t._inputLists[x]
              , P = T._symbol
              , C = Re(p, T.args[1]);
            qG(r, i, T);
            let S = r.getInstruction(C);
            if (!X(S.valueType)) {
                let M = $W(r, C);
                if (M) {
                    a.push({
                        symbol: P,
                        object: C,
                        gliderBounds: M
                    });
                    continue
                }
                let _;
                if (jn(S.valueType)) {
                    let U = T.args[1].getInputSpan();
                    U && (_ = Ir(U))
                }
                throw zv(P, se(S.valueType), _, {
                    blockExport: Ye(S)
                })
            }
            let E = Pr(r, C);
            u.push({
                symbol: P,
                assignedList: C,
                lengthIndex: E
            }),
            c = r.Multiply([c, E])
        }
        let m = o.childScope(), d = [], y;
        if (u.length > 0) {
            let x = r.Constant(1);
            y = r.BeginBroadcast([c], {
                type: "list-comprehension",
                callData: {
                    inputListSymbols: u.map(P => P.symbol)
                }
            }),
            m.addLexicalBinding(t._index._symbol, y);
            let T = x;
            for (let P = u.length - 1; P >= 0; P--) {
                let {symbol: C, assignedList: S, lengthIndex: E} = u[P], M;
                if (u.length === 1)
                    M = y;
                else {
                    let _ = r.NativeFunction("floor", [r.Divide([r.Subtract([y, x]), T])]);
                    M = r.Add([r.NativeFunction("mod", [_, E]), x]),
                    P > 0 && (T = r.Multiply([T, E]))
                }
                m.addDynamicBinding(C, r.ListAccess([S, M])),
                d.push(C)
            }
        }
        let g;
        if (t.parameters.length > 0 || a.length > 0) {
            let x = []
              , T = [];
            for (let P of t.parameters)
                x.push(P.identifier._symbol),
                T.push(Re(p, P.bounds[0]), Re(p, P.bounds[1]));
            for (let P of a)
                x.push(P.symbol),
                T.push(P.gliderBounds[0], P.gliderBounds[1]);
            g = r.BeginMap({
                parameterSymbols: x
            }, T);
            for (let P = 0; P < t.parameters.length + a.length; P++)
                r.BlockVar(b, [g]);
            for (let P = 0; P < t.parameters.length; P++) {
                let C = t.parameters[P].identifier._symbol
                  , E = g + P + 1;
                m.addDynamicBinding(C, E),
                d.push(C)
            }
            for (let P = 0; P < a.length; P++) {
                let C = a[P].symbol
                  , S = g + t.parameters.length + P + 1;
                m.addDynamicBinding(C, o2(r, [a[P].object, S])),
                d.push(C)
            }
        }
        let h = Re({
            ...Ps(e, m),
            substitutionContext: e.substitutionContext.for(o, e.recursiveFunctionContext, d)
        }, s);
        if (g !== void 0) {
            let x = r.EndMap([g, h])
              , T = r.getInstruction(h).valueType;
            if (wa(T))
                throw nM();
            if (!PP(T))
                throw eM(T);
            let P = n.is3dPolicy() ? 2 : 1;
            if (t.parameters.length + a.length > P)
                throw T === G && !n.is3dPolicy() ? Kc(yo) : tM(T, t.parameters.length);
            let C = SP(T, t.parameters.length + a.length);
            h = r.BlockVar(C, [x])
        }
        if (y !== void 0) {
            let x = r.getInstruction(h);
            if (!jn(x.valueType))
                throw gp([se(x.valueType)], {
                    blockExport: Ye(x)
                });
            let T = r.EndBroadcast([y, h]);
            h = r.BroadcastResult($n(x.valueType), [T])
        } else
            t.shouldCoerceToList && (h = r.List([h]));
        return h
    }
    function F_(e, t, n, r) {
        let {stepMustBePositive: o} = r
          , {chunk: i} = e;
        t = Xi(i, t),
        n = Xi(i, n);
        let s = i.getInstruction(t)
          , a = i.getInstruction(n)
          , u = Qa(i, t, "Programming error: expected range start list to have constant length.")
          , c = Qa(i, n, "Programming error: expected range start list to have constant length.");
        if (s.valueType !== Y || a.valueType !== Y)
            throw cy();
        let l = i.Constant(1)
          , p = i.Constant(0)
          , m = i.ListAccess([t, l])
          , d = i.ListAccess([t, i.Constant(2)])
          , y = i.ListAccess([n, i.Constant(c)])
          , g = i.Subtract([y, m])
          , f = u > 1 ? i.Subtract([d, m]) : i.Piecewise([i.GreaterEqual([g, p]), l, i.Constant(-1)])
          , h = i.Add([l, i.NativeFunction("round", [i.Divide([g, f])])])
          , x = i.NativeFunction("validateRangeLength", [t, n, f, h]);
        o && (x = i.Piecewise([i.GreaterEqual([f, p]), x, p]));
        let T = i.BeginBroadcast([x])
          , P = i.Add([m, i.Multiply([f, i.Subtract([T, l])])])
          , C = i.EndBroadcast([T, P]);
        return i.addComments({
            [m]: "start",
            [d]: "second",
            [y]: "last",
            [h]: "proposedLength",
            [f]: "step",
            [P]: "body"
        }),
        i.BroadcastResult($n(i.getInstruction(P).valueType), [C])
    }
    function uI(e, t) {
        return xt(e, t, Ee) ? e.NativeFunction("lineFromSegment", [t]) : xt(e, t, Ie) ? e.NativeFunction("lineFromSegment", [GW(e, t)]) : xt(e, t, Ae) ? e.NativeFunction("lineFromRay", [t]) : t
    }
    function ZW(e, t) {
        let n = e.NativeFunction("arcCenter", [t])
          , r = e.NativeFunction("arcFirstPoint", [t])
          , o = e.NativeFunction("distance", [n, r]);
        return {
            center: n,
            radius: o,
            startPoint: r
        }
    }
    function XG(e, t, n) {
        let {chunk: r} = e;
        if (t.length === 3 && xt(r, t[0], R) && xt(r, t[1], R) && xt(r, t[2], R)) {
            let o = t[0]
              , i = t[1]
              , s = t[2]
              , a = r.Subtract([o, i])
              , u = r.Subtract([s, i])
              , c = r.Slot(0, [a])
              , l = r.Slot(1, [a])
              , p = r.Slot(0, [u])
              , m = r.Slot(1, [u])
              , d = r.NativeFunction("arctan", [l, c])
              , y = r.Subtract([r.Multiply([c, m]), r.Multiply([l, p])])
              , g = r.Add([r.Multiply([c, p]), r.Multiply([l, m])])
              , f = r.NativeFunction("arctan", [y, g])
              , h = r.NativeFunction("abs", [f])
              , x = r.Constant(Math.PI)
              , T = r.Constant(Math.PI * 2);
            f = r.Piecewise([r.Equal([h, x]), x, r.Piecewise([r.Less([h, x]), f, r.Multiply([r.Multiply([r.NativeFunction("sign", [f]), r.Constant(-1)]), r.Subtract([T, h])])])]);
            let P = r.NativeFunction("directedAngleMarker", [i, d, f, Re(e, new O.Identifier("trigAngleMultiplier"))])
              , C = r.Constant(0)
              , S = r.And([r.Equal([y, C]), r.Equal([g, C])]);
            return r.Piecewise([S, r.NanOfType(Se), P])
        } else
            throw F(`Unexpected types for ${n}`)
    }
    function nL(e, t) {
        return e.Divide([e.NativeFunction("directedAngleMarkerRawDelta", [t]), e.NativeFunction("directedAngleMarkerMultiplier", [t])])
    }
    function rL(e, t) {
        return e.NativeFunction("abs", [e.Divide([e.NativeFunction("undirectedAngleMarkerRawDelta", [t]), e.NativeFunction("undirectedAngleMarkerMultiplier", [t])])])
    }
    function XW(e, t, n) {
        let {chunk: r, policy: o} = e
          , i = n.slice(1)
          , s = Py(o, t);
        if (!s)
            throw new Error(`Unexpected transformation type: ${t}`);
        let a = s.map(p => {
            let m = 0;
            for (let d = 1; d < n.length; d++) {
                let y = r.getInstruction(n[d]).valueType
                  , g = p.argTypeAtIndex(d);
                g && np(y, g) && m++
            }
            return {
                signature: p,
                matchedArgsCount: m,
                signatureArgsCount: p.maxArity === void 0 ? p.initial.length + 1 : p.argTypes.length - 1,
                providedArgsCount: n.length - 1
            }
        }
        ).sort( (p, m) => m.matchedArgsCount !== p.matchedArgsCount ? m.matchedArgsCount - p.matchedArgsCount : p.signatureArgsCount - m.signatureArgsCount), u;
        switch (t) {
        case "translate":
            {
                u = [{
                    match: [Ie],
                    build: () => r.NativeFunction("translation", [r.NativeFunction("vectorDisplacementAsPoint", i)])
                }, {
                    match: [R, R],
                    build: () => r.NativeFunction("translation", [r.Subtract([i[1], i[0]])])
                }];
                break
            }
        case "reflect":
            {
                u = [{
                    match: [ph],
                    build: () => {
                        let p = uI(r, i[0]);
                        return r.NativeFunction("reflection", [p])
                    }
                }];
                break
            }
        case "rotate":
            {
                u = [{
                    match: [R, b],
                    build: () => {
                        let p = Re(e, new O.Identifier("trigAngleMultiplier"));
                        return r.NativeFunction("rotation", [i[0], r.Multiply([i[1], p])])
                    }
                }];
                break
            }
        case "dilate":
            {
                u = [{
                    match: [R, b],
                    build: () => r.NativeFunction("dilation", i)
                }];
                break
            }
        default:
            {
                let p = t;
                throw new Error(`Programming error: exhaustive check failed: ${p}`)
            }
        }
        let c = r.areAllArgsConstant(i)
          , l = zs(r, i, () => {
            throw tE(t, Ka(r, i), a[0].signature, {
                blockExport: c
            })
        }
        , u);
        return cI(r, [l, n[0]], t, !0)
    }
    function cI(e, t, n, r) {
        let o = [[we, "compose"], [R, "transformPoint"], [Ee, "transformSegment"], [Ce, "transformLine"], [Ae, "transformRay"], [Ie, "transformVector"], [he, "transformCircle"], [ce, "transformArc"], [De, "transformPolygon"], [Oe, "transformAngleMarker"], [Se, "transformDirectedAngleMarker"]].map( ([s,a]) => ({
            match: [we, s],
            build: (u, c) => u.NativeFunction(a, c)
        }));
        function i() {
            if (r) {
                let s = t.slice(1);
                throw nE(n, xl(e, s), {
                    blockExport: e.areAllArgsConstant(s)
                })
            } else
                throw $i(n, xl(e, t), {
                    blockExport: e.areAllArgsConstant(t)
                })
        }
        return zs(e, t, i, o)
    }
    function O_(e, t, n) {
        let r = uI(e, t[0])
          , o = uI(e, t[1])
          , i = [r, o, e.ConstantOfType(b, n)];
        if (xt(e, r, he)) {
            if (xt(e, o, he))
                return e.NativeFunction("circleCircleIntersection", i);
            if (xt(e, o, ce))
                return e.NativeFunction("circleArcIntersection", i);
            if (xt(e, o, Ce))
                return e.NativeFunction("circleLineIntersection", i)
        }
        if (xt(e, r, ce)) {
            if (xt(e, o, he))
                return e.NativeFunction("arcCircleIntersection", i);
            if (xt(e, o, ce))
                return e.NativeFunction("arcArcIntersection", i);
            if (xt(e, o, Ce))
                return e.NativeFunction("arcLineIntersection", i)
        }
        if (xt(e, r, Ce)) {
            if (xt(e, o, he))
                return e.NativeFunction("lineCircleIntersection", i);
            if (xt(e, o, ce))
                return e.NativeFunction("lineArcIntersection", i);
            if (xt(e, o, Ce))
                return e.NativeFunction("lineLineIntersection", i)
        }
        throw F("Invalid intersection types")
    }
    function WW(e, [t,n], [r,o]) {
        let {chunk: i, scope: s} = e
          , a = i.getInstruction(r).valueType
          , u = i.getInstruction(o).valueType
          , c = m => {
            var d;
            return (d = s.getParseNode(m)) != null ? d : s.getVisibleGlobalDefinition(m)
        }
          , l = Ha(t) ? c(t._symbol) : t
          , p = Ha(n) ? c(n._symbol) : n;
        if (!(!l || !p))
            return Mw({
                getGeometryTree: m => Rx(m).tree,
                lookup: c,
                isPointOrListOfPoints: m => {
                    if (cl(m))
                        return !1;
                    let d = Re(e, m);
                    return ae(i.getInstruction(d).valueType, R)
                }
                ,
                resolvesTo: (m, d) => s.getVisibleGlobalDefinition(m) === d
            }, l, a, p, u)
    }
    function jW(e, t) {
        let {policy: n, scope: r} = e
          , o = t._body
          , i = r.childScope()
          , s = [];
        for (let u = 0; u < t._assignments.length; u++) {
            let c = t._assignments[u]._lhs, l;
            if (c instanceof ze)
                l = c._symbol;
            else
                throw yy();
            let p = t._assignments[u].args[1]
              , m = r.getVisibleGlobalDefinition(l);
            if (m) {
                if (m.type === "FunctionDefinition")
                    throw hy(l);
                if (n.assignmentForbidden(l))
                    throw gy(l)
            }
            let d = Re(e, p);
            i.addDynamicBinding(l, d, p),
            s.push(l)
        }
        return Re({
            ...Ps(e, i),
            substitutionContext: e.substitutionContext.with(r, e.recursiveFunctionContext, s)
        }, o)
    }
    var WG = {
        points: zt,
        lines: bi,
        segments: Tr,
        polygons: Dr,
        circles: hi,
        arcs: mo,
        angles: Ar,
        directedangles: wr,
        rays: fo,
        vectors: xi
    };
    function JW(e, t) {
        let {chunk: n, scope: r} = e
          , o = r.getVisibleGlobalDefinition("construction");
        if (!o)
            throw F("Expected 'construction' to be defined in the frame");
        if (o.type !== "Construction" || !(o instanceof Z))
            throw F(`Expected construction node but found ${o.type}}`);
        if (!Ha(t))
            throw F(`Expected identifier but found ${t.type}`);
        let i = t._symbol;
        if (!(i in WG))
            throw Mi("construction");
        let s = WG[i];
        if (o.args.length === 0)
            return n.ConstantOfType(s, []);
        let a = Qe(s)
          , u = [];
        for (let c of o.args)
            try {
                let l = Re(e, c);
                n.getInstruction(l).valueType === a && u.push(l)
            } catch (l) {
                if (l instanceof v)
                    continue;
                throw l
            }
        return n.List(u)
    }
    function Eg(e, t) {
        let n = e.args
          , r = e instanceof _n ? e._symbol : e instanceof fl || e instanceof dl ? e.args[0]._symbol : void 0;
        if (r && t.definitions[r])
            return !1;
        if (e instanceof Io) {
            let a = [Eg(e.args[0], t) || new Vn(!0)]
              , u = Eg(e.args[1], t)
              , c = Eg(e.args[2], t);
            return u && a.push(u),
            c && a.push(c),
            a.length === 1 ? !1 : (a.length === 2 && a.push(a[1]),
            new Io(a))
        }
        let o = []
          , i = !1;
        for (let s of n) {
            let a = Eg(s, t);
            if (a === !1) {
                i = !0;
                continue
            }
            o.push(a)
        }
        return i ? !1 : e.copyWithArgs(o)
    }
    function a2(e, t, n) {
        let {chunk: r, scope: o} = e
          , i = {}
          , s = ue(n.definitions);
        for (let y of s) {
            let g = n.definitions[y];
            if (g instanceof v)
                throw g;
            i[y] = g
        }
        let a = t._argSymbols.map(y => Re(e, new dn(y)))
          , u = new A_(i,n.baseCases);
        try {
            c2(e, u, t, a)
        } catch (y) {
            throw u.isUnconditionallyRecursive && y instanceof v && !y.blocksExport ? s.length > 1 || u2(t, t._expression) ? xp(s, {
                suggestAlternativeFunctionName: !1
            }) : Qh(s) : y
        }
        let c = {}
          , l = {}
          , p = {}
          , m = o.childScope();
        for (let y of s) {
            let g = u.returnTypes[y];
            if (g === void 0)
                throw F(`Could not infer the return type for recursive function ${y}.`);
            let f = u.argTypes[y];
            if (f === void 0)
                throw F(`Could not infer the argument types for recursive function ${y}.`);
            l[y] = {
                argTypes: f
            },
            c[y] = g,
            p[y] = r.FunctionHeader(y, g, l[y], i[y]._argSymbols),
            m.addLexicalBinding(y, p[y])
        }
        let d = [];
        for (let y of s)
            d.push(p[y]);
        for (let y of d)
            r.getInstruction(y).recursionGroup = d;
        for (let y of s) {
            let g = m.childScope()
              , f = i[y]
              , h = p[y]
              , x = r.BeginFunction([h]);
            for (let C = 0; C < f._argSymbols.length; C++) {
                let S = f._argSymbols[C]
                  , E = r.BlockVar(l[y].argTypes[C], [x]);
                g.addLexicalBinding(S, E)
            }
            let T = {
                ...Ps(e, g),
                recursiveFunctionContext: {
                    type: "compile-general",
                    fnSymbols: s
                }
            }
              , P = l2(T, f, n.baseCases, Re(T, f._expression));
            if (r.getInstruction(P).valueType !== c[y])
                throw $i(y, Ka(r, a), {
                    blockExport: r.areAllArgsConstant(a)
                });
            P = Wr(r, P),
            r.EndFunction([x, P])
        }
        if (u.isUnconditionallyRecursive) {
            let y = r.getRecursiveFunctionMetadata(p[t._symbol])
              , g = y == null ? void 0 : y.recursiveStructure;
            throw g != null && g.canIterate ? new Error("Programming error: expected canIterate==false for unconditionally recursive function.") : g != null && g.maxRecursiveCallOffsets && s.every(f => g.maxRecursiveCallOffsets[f] === 0) ? xp(s, {
                suggestAlternativeFunctionName: !1
            }) : AS(s, {
                type: "missing-non-recursive-branch",
                recursionGroup: s,
                recursiveStructure: g
            })
        }
        return r.FunctionCall([p[t._symbol], ...a])
    }
    function u2(e, t) {
        return t instanceof _n && t._symbol === e._symbol ? t.args.every( (n, r) => n instanceof ze && n._symbol === e._argSymbols[r]) : t.args.every(n => u2(e, n))
    }
    function c2(e, t, n, r) {
        let {chunk: o} = e
          , i = t.returnTypes[n._symbol]
          , s = t.argTypes[n._symbol];
        if (i !== void 0 && s !== void 0)
            return {
                returnType: i,
                argTypes: s
            };
        let a = n._argSymbols.length
          , u = r.length;
        if (a !== u)
            throw Ba(n._symbol, a, u, {
                includeUsageExample: !0
            });
        let c = r.map(d => o.getInstruction(d).valueType)
          , l = `${n._symbol}:${c.join(",")}:${Object.keys(t.returnTypes).join(",")}`;
        if (t.stack.includes(l))
            return t.isUnconditionallyRecursive = !0,
            {
                returnType: b,
                argTypes: c
            };
        t.stack.push(l);
        let p = o.getReturnIndex(), m;
        return nI(e, d => {
            var C;
            let y = Eg(n._expression, t)
              , g = n._symbol
              , f = (C = t.baseCases[g]) != null ? C : []
              , h = {
                ...d,
                recursiveFunctionContext: t
            }
              , x = h.scope
              , T = [];
            for (let S = 0; S < n._argSymbols.length; S++) {
                let E = n._argSymbols[S]
                  , M = o.SymbolicVar(c[S]);
                T.push(M),
                x.addLexicalBinding(E, M)
            }
            if (!t.baseCaseTypes.hasOwnProperty(g)) {
                let S, E, M, _ = !0;
                for (let U of f) {
                    let Q = U.getRef();
                    if (!U.specifiedArg.valid || !Q)
                        continue;
                    let K = new dn(Q)
                      , w = Re(h, K);
                    M || (M = K);
                    let B = o.getInstruction(w)
                      , W = B.valueType;
                    if (Ye(B) || (_ = !1),
                    S === void 0)
                        S = U.specifiedArg.argIndex;
                    else if (S !== U.specifiedArg.argIndex)
                        throw Wf();
                    let oe = E;
                    if (oe === void 0)
                        E = W;
                    else {
                        let te = mc(oe, W);
                        if (te === void 0)
                            throw Xf({
                                blockExport: _
                            });
                        E = te
                    }
                }
                t.baseCaseTypes[g] = E,
                t.firstValidBaseCaseIdentifiers[g] = M
            }
            let P = t.firstValidBaseCaseIdentifiers[g];
            if (y || P) {
                let S = l2(h, n, t.baseCases, Re(h, y || P))
                  , {someArgBroadcasts: E, inferredArgTypes: M} = QW(o, T, p, S);
                if (c = M,
                m = o.getInstruction(S).valueType,
                E) {
                    if (!X(m))
                        throw F(`TODO: expected a list type but found ${Ke(m)}`);
                    m = Qe(m)
                }
                let _ = t.returnTypes[n._symbol];
                if (_ !== void 0 && m !== _)
                    throw Xf({
                        blockExport: !1
                    });
                t.argTypes[n._symbol] = M,
                t.returnTypes[n._symbol] = m
            }
        }
        ),
        nI(e, d => {
            let y = {
                ...d,
                recursiveFunctionContext: t
            }
              , g = y.scope;
            for (let T = 0; T < n._argSymbols.length; T++) {
                let P = n._argSymbols[T]
                  , C = o.SymbolicVar(c[T]);
                g.addLexicalBinding(P, C)
            }
            let f = Re(y, n._expression);
            t.stack.pop();
            let h = o.getInstruction(f).valueType
              , x = m === void 0 ? h : mc(m, h);
            if (x === void 0)
                throw F(`Mismatched return types: ${m && Ke(m)} vs ${Ke(h)}`);
            return t.returnTypes[n._symbol] = x,
            {
                returnType: x,
                argTypes: c
            }
        }
        )
    }
    function QW(e, t, n, r) {
        let o = []
          , u = [];
        for (let p = 0; p < r - n; p++)
            u.push(0);
        if (e.getInstruction(r).type === 48) {
            u.push(1);
            for (let p = r; p >= 0; p--) {
                let m = u[p - n];
                if (m === 0)
                    continue;
                let d = e.getInstruction(p);
                if (de(d)) {
                    if (d.type === 24 ? o.push(p) : d.type === 23 && o.pop(),
                    (d.type === 48 || d.type === 24) && (u[d.args[0] - n] |= m),
                    d.type === 39 || d.type === 41 || d.type === 40)
                        for (let y of o) {
                            let f = e.getInstruction(y).args[0];
                            if (d.args[1] === f) {
                                u[d.args[0] - n] |= m;
                                break
                            }
                        }
                    if (o.length > 0) {
                        let y = o[o.length - 1]
                          , f = e.getInstruction(y).args[0];
                        for (let h of d.args)
                            h >= f && (u[h - n] |= m);
                        d.type === 33 && d.args[0] >= f && (u[d.args[0] - n] |= 2)
                    }
                }
            }
        }
        let c = []
          , l = !1;
        for (let p = 0; p < t.length; p++) {
            let m = t[p]
              , d = e.getInstruction(m).valueType;
            if (u[m - n] & 2) {
                if (!X(d))
                    throw F(`Expected list type but found ${Ke(d)}`);
                l = !0,
                c.push(Qe(d))
            } else
                c.push(d)
        }
        return {
            inferredArgTypes: c,
            someArgBroadcasts: l
        }
    }
    function l2(e, t, n, r) {
        let {chunk: o} = e
          , i = !0
          , s = n[t._symbol];
        for (let a of s) {
            let u = a.specifiedArg;
            if (!u.valid)
                continue;
            let c = t._argSymbols[u.argIndex]
              , l = Re(e, new dn(c))
              , p = o.Equal([l, o.Constant(u.argValue)])
              , m = Re(e, a)
              , d = o.getInstruction(m);
            Ye(d) || (i = !1);
            let y = o.getInstruction(m).valueType
              , g = o.getInstruction(r).valueType;
            if (mc(y, g) === void 0)
                throw Xf({
                    blockExport: i
                });
            r = o.Piecewise([p, m, r])
        }
        return r
    }
    function KW(e) {
        return e.type === "Constant" && Number.isInteger(e.asValue())
    }
    function jG(e, t, n, r) {
        var m;
        let {policy: o, chunk: i, scope: s} = e, a = new O.Identifier(t), u, c;
        r.length === 1 ? (u = n[0],
        c = r[0]) : (u = new O.ParenSeq(n),
        eu(i, o, u, r),
        c = i2(e, r));
        let p = [(m = s.getSymbol(t)) != null ? m : Re(e, a), c];
        return eu(i, o, new O.Multiply([a, u]), p),
        i.Multiply(p)
    }
    function e4(e, t) {
        var d;
        let {chunk: n, scope: r} = e;
        if (t._symbol !== "ttest" || t.args.length !== 1 || t.args[0].type !== "Identifier" || t.args[0]._symbol === void 0)
            return;
        let o = r.getVisibleGlobalDefinition(t.args[0]._symbol);
        if ((o == null ? void 0 : o.type) !== "RegressionParameter")
            return;
        let i = o
          , s = i._optimizedRegression;
        if (!s.scaleFactors)
            throw OS();
        let a = i.asCompilerValue()
          , u = s.residuals.asValue()
          , c = u.length - Object.keys(s.parameters).length
          , l = (d = s.scaleFactors[i._symbol]) == null ? void 0 : d.asValue()
          , p = 0;
        for (let y of u)
            p += y * y;
        let m = Math.sqrt(l * (p / c));
        return n.TupleOfType(Kt, {
            pointEstimate: n.Constant(a),
            standardError: n.Constant(m),
            dof: n.Constant(c)
        })
    }
    function ja(e, t, n, r) {
        var i;
        if (e.type === "Error")
            return e;
        let o = Kd({
            policy: t,
            frame: n,
            wrapInList: r && r.wrapInList,
            coerceToNumber: r && r.coerceToNumber
        }, e);
        return t.isGeometryEnabled() && o.argNames.some(s => s[0] === "$") ? Kv() : (i = o.getError()) != null ? i : new An(o)
    }
    var uu = function(e, t="", n=0) {
        let r = Array(n + 1).join("  ")
          , o = r + "  ";
        return `[
` + o + e.map(i => i.repr(t, n + 1)).join(`,
` + o) + `
` + r + "]"
    }
      , br = function(e, t="") {
        return t = t || "",
        "new " + t + e
    };
    Z.prototype.repr = function(e, t) {
        return br(this.type, e) + "(" + uu(this.args, e, t) + ")"
    }
    ;
    bo.prototype.repr = function(e, t) {
        return e === "nodes." ? `new nodes["${this.type}"](` + uu(this.args, e, t) + ")" : br(this.type, e) + "(" + uu(this.args, e, t) + ")"
    }
    ;
    O.IRExpression.prototype.repr = function(e, t=0) {
        let n = Array(t + 1).join("  ")
          , r = n + "  "
          , o = this._chunk.print().split(`
`);
        return o.pop(),
        br(this.type, e) + "(`\n" + r + o.join(`
` + r) + `
` + n + "`)"
    }
    ;
    O.DoubleInequality.prototype.repr = function(e, t=0) {
        let n = Array(t + 1).join("  ")
          , r = n + "  ";
        return br(this.type, e) + `([
` + r + this.args[0].repr(e, t + 1) + `,
` + r + "'" + this.args[1] + `',
` + r + this.args[2].repr(e, t + 1) + `,
` + r + "'" + this.args[3] + `',
` + r + this.args[4].repr(e, t + 1) + `
` + n + "])"
    }
    ;
    O.ComparatorChain.prototype.repr = function(e, t=0) {
        return br(this.type, e) + "([" + this.symbols.map(n => `'${n}'`).join(",") + `],
` + uu(this.args, e, t) + ")"
    }
    ;
    ze.prototype.repr = function(e) {
        return br(this.type, e) + "('" + this._symbol + "')"
    }
    ;
    Hn.prototype.repr = function(e) {
        return br(this.type, e) + "(" + this.asValue() + ")"
    }
    ;
    O.ExtendSeed.prototype.repr = function(e, t) {
        return br(this.type, e) + "('" + this.tag + "', " + uu(this.args, e, t) + ")"
    }
    ;
    O.Seed.prototype.repr = function(e) {
        return br(this.type, e) + "(" + this.asValue() + ")"
    }
    ;
    _n.prototype.repr = function(e, t) {
        return br(this.type, e) + "('" + this._symbol + "', " + uu(this.args, e, t) + ")"
    }
    ;
    O.RecursiveFunctionBaseCase.prototype.repr = function(e, t) {
        return this.originalNode.repr(e, t)
    }
    ;
    Ln.prototype.repr = function(e, t) {
        return br(this.type, e) + "(" + new O.Identifier(this._symbol).repr(e, t) + ", " + this._expression.repr(e, t) + ")"
    }
    ;
    O.AssignmentImport.prototype.repr = function(e, t) {
        return br(this.type, e) + "(" + new O.Identifier(this._symbol).repr(e, t) + `, qualifiedName(${this._importFrom.frameID},${this._importFrom.frameID}))`
    }
    ;
    O.Regression.prototype.repr = O.Equation.prototype.repr = O.CallAssignment.prototype.repr = function(e, t) {
        return br(this.type, e) + "(" + this._lhs.repr(e, t) + ", " + this._rhs.repr(e, t) + ")"
    }
    ;
    O.FunctionDefinition.prototype.repr = function(e, t) {
        return br(this.type, e) + "(" + new O.Identifier(this._symbol).repr(e, t) + ", " + uu(this._argSymbols.map(n => new O.Identifier(n)), e, t) + ", " + this._expression.repr(e, t) + ")"
    }
    ;
    O.Error.prototype.repr = function(e, t) {
        return br(this.type, e) + "('" + this._msg + "')"
    }
    ;
    O.Derivative.prototype.repr = function(e, t) {
        return br(this.type, e) + "('" + this._symbol + "', " + uu(this.args, e, t) + ")"
    }
    ;
    O.SolvedEquation.prototype.repr = function(e, t) {
        return br(this.type, e) + "('" + this._symbol + "', " + this._expression.repr(e, t) + ")"
    }
    ;
    O.OptimizedRegression.prototype.repr = function(e, t=0) {
        return br(this.type, e) + "(" + JSON.stringify(this.parameters) + ", " + JSON.stringify(this.residuals) + ", " + JSON.stringify(this.statistics) + ", " + this.model.repr(e, t + 1) + ", " + JSON.stringify({
            isModelValid: this.isModelValid,
            residualVariable: this.residualVariable,
            residualSuggestionId: this.residualSuggestionId,
            shouldSuggestLogMode: this.shouldSuggestLogMode,
            isLinear: this.isLinear,
            parameterWarning: this.parameterWarning
        }) + ")"
    }
    ;
    O.Table.prototype.repr = function(e, t) {
        return br(this.type, e) + "(" + uu(this.columns, e, t) + ", " + this.tableFrameID + ")"
    }
    ;
    O.TableColumn.prototype.repr = function(e, t) {
        return br(this.type, e) + "(" + this.header.repr(e, t) + ", " + this.length + ", " + uu(this.values, e, t) + ", " + this.tableFrameID + ", " + this.columnIndex + ")"
    }
    ;
    O.TableColumnValue.prototype.repr = function(e, t) {
        return "TableColumnValue(" + uu(this.rawArgs, e, t) + ", " + this.headerSymbol + ")"
    }
    ;
    O.Image.prototype.repr = function(e, t=0) {
        let n = Array(t + 1).join("  ")
          , r = n + "  ";
        return br(this.type, e) + `({
` + r + "center: " + this.center.repr(e, t + 1) + `,
` + r + "radianAngle: " + this.radianAngle.repr(e, t + 1) + `,
` + r + "width: " + this.width.repr(e, t + 1) + `,
` + r + "height: " + this.height.repr(e, t + 1) + `},
` + r + "opacity: " + this.opacity.repr(e, t + 1) + `,
` + r + JSON.stringify(this.moveStrategy) + `
` + n + "})"
    }
    ;
    O.Ticker.prototype.repr = function(e, t=0) {
        let n = Array(t + 1).join("  ")
          , r = n + "  ";
        return br(this.type, e) + `({
` + r + "handler: " + this.handler.repr(e, t + 1) + `,
` + r + "minStep: " + this.minStep.repr(e, t + 1) + `
` + n + "})"
    }
    ;
    O.Slider.prototype.repr = function(e, t=0) {
        let n = Array(t + 1).join("  ")
          , r = n + "  ";
        return br(this.type, e) + `({
` + r + "sliderAssignment: " + this.sliderAssignment.repr(e, t + 1) + `,
` + r + "sliderMin: " + (this.sliderMin && this.sliderMin.repr(e, t + 1)) + `,
` + r + "sliderMax: " + (this.sliderMax && this.sliderMax.repr(e, t + 1)) + `,
` + r + "sliderStep: " + (this.sliderStep && this.sliderStep.repr(e, t + 1)) + `},
` + n + ")"
    }
    ;
    O.ImaginaryUnit.prototype.repr = function(e) {
        return br(this.type, e) + "()"
    }
    ;
    O.RegressionParameter.prototype.repr = function(e, t) {
        return br(this.type, e) + "('" + this._symbol + "', " + this._optimizedRegression.repr(e, t) + ")"
    }
    ;
    var lI = function(e, t) {
        return e.map(n => n.substitute(t))
    };
    ze.prototype.substitute = function(e) {
        return e[this._symbol] ? e[this._symbol] : this
    }
    ;
    _n.prototype.substitute = function(e) {
        let t = e[this._symbol];
        if (t) {
            if (t.type === "Identifier")
                return new O.FunctionCall(t,lI(this.args, e));
            if (t.type === "Constant")
                return new O.Multiply([t, this.args.length === 1 ? this.args[0].substitute(e) : new O.Constant(NaN)])
        }
        return Z.prototype.substitute.call(this, e)
    }
    ;
    Hn.prototype.substitute = function(e) {
        return this
    }
    ;
    Z.prototype.substitute = function(e) {
        return this.copyWithArgs(lI(this.args, e))
    }
    ;
    O.Derivative.prototype.substitute = function(e) {
        let t = e[this._symbol];
        if (t) {
            if (t.type === "Identifier")
                return new O.Derivative(t,lI(this.args, e));
            throw new Error("Cannot substitute for a derivative variable with a non-Identifier")
        }
        return new O.Derivative(this._symbol,lI(this.args, e))
    }
    ;
    Z.prototype.simpleFunctionExpression = function() {
        return this
    }
    ;
    Ln.prototype.simpleFunctionExpression = function() {
        return this._expression
    }
    ;
    O.FunctionDefinition.prototype.simpleFunctionExpression = function() {
        return this._expression
    }
    ;
    O.RecursiveFunctionBaseCase.prototype.simpleFunctionExpression = function() {
        return this._expression
    }
    ;
    O.Equation.prototype.simpleFunctionExpression = O.CallAssignment.prototype.simpleFunctionExpression = function() {
        return this.asComparator().simpleFunctionExpression()
    }
    ;
    $r();
    function m2(e) {
        return e instanceof Hn || e instanceof Gs && e.args.length === 1 && e.args[0]instanceof Hn
    }
    function p2(e) {
        return !!(e instanceof ze && e._symbol === Gr || (e instanceof O.Multiply || e instanceof O.CrossMultiply || e instanceof O.DotMultiply) && e.args.length === 2 && e.args.some(t => t instanceof ze && t._symbol === Gr) && e.args.some(t => m2(t)) || e instanceof O.Negative && e.args[0]instanceof ze && e.args[0]._symbol === Gr || e instanceof _n && e._symbol === Gr && e.args.length === 1 && e.args[0]instanceof Hn)
    }
    function d2(e) {
        return e instanceof Ln ? vg(e._expression) : vg(e)
    }
    function vg(e) {
        return p2(e) ? !0 : (e instanceof O.Add || e instanceof O.Subtract) && e.args.some(t => p2(t)) && e.args.some(t => m2(t))
    }
    function V_(e) {
        let t;
        for (let n = 0; n < e.length; n++)
            if (e[n].dependsOn(Gr)) {
                if (t !== void 0)
                    return;
                t = n
            }
        return t
    }
    function Cg(e, t) {
        var n;
        if (t.dependsOn(Gr))
            switch (t.type) {
            case "Identifier":
                return new O.Constant(1);
            case "Negative":
                {
                    let r = Cg(e, t.args[0]);
                    return r === void 0 ? void 0 : t.copyWithArgs([r])
                }
            case "Multiply":
            case "DotMultiply":
            case "CrossMultiply":
                switch (V_(t.args)) {
                case 0:
                    {
                        let o = Cg(e, t.args[0]);
                        return o === void 0 ? void 0 : t.copyWithArgs([o, t.args[1]])
                    }
                case 1:
                    {
                        let o = Cg(e, t.args[1]);
                        return o === void 0 ? void 0 : t.copyWithArgs([t.args[0], o])
                    }
                default:
                    return
                }
            case "Divide":
                {
                    if (V_(t.args) !== 0)
                        return;
                    let o = Cg(e, t.args[0]);
                    return o === void 0 ? void 0 : t.copyWithArgs([o, t.args[1]])
                }
            case "FunctionCall":
                return t._symbol === Gr && t.args.length === 1 && !t.args[0].dependsOn(Gr) ? t.args[0] : t.args.length === 1 && t.args[0].type === "Identifier" && t.args[0]._symbol === Gr && t._symbol !== void 0 && ((n = e[t._symbol]) == null ? void 0 : n.type) !== "Placeholder" ? new O.Identifier(t._symbol) : void 0;
            default:
                return
            }
    }
    function pI(e, t) {
        if (t.dependsOn(Gr))
            switch (t.type) {
            case "Add":
            case "Subtract":
                switch (V_(t.args)) {
                case 0:
                    {
                        let r = pI(e, t.args[0]);
                        return r === void 0 ? void 0 : [t.copyWithArgs([r[0], t.args[1]]), r[1]]
                    }
                case 1:
                    {
                        let r = pI(e, t.args[1]);
                        return r === void 0 ? void 0 : [t.copyWithArgs([t.args[0], r[0]]), t.type === "Subtract" ? new O.Negative([r[1]]) : r[1]]
                    }
                default:
                    return
                }
            default:
                {
                    let n = Cg(e, t);
                    return n === void 0 ? void 0 : [new O.Constant(0), n]
                }
            }
    }
    var f2 = new O.Constant(be(0, 1));
    function Mg(e, t) {
        var n;
        if (e.userData && e.userData.id) {
            let r = e.userData.id;
            return !!((n = Iy(t).viewportTransitiveDependencies) != null && n.has(r))
        }
        return !1
    }
    Ln.prototype.getMoveStrategy = function(e, t, n, r) {
        if (!Mg(this, t))
            return this._expression.getMoveStrategy(e, t, n, r)
    }
    ;
    function t4(e) {
        return {
            type: "updateSliderNonlinear",
            id: e.id,
            initialValue: e.initialValue,
            min: e.min,
            max: e.max,
            compiled: e.compiled,
            isComplex: e.isComplex
        }
    }
    function n4(e) {
        return {
            type: "updateGliderParameter",
            span: e.span,
            movesOn: e.movesOn
        }
    }
    function r4(e) {
        return {
            type: "updateSliderForGlider",
            id: e.sliderId,
            movesOn: e.movesOn,
            min: e.min,
            max: e.max
        }
    }
    function y2(e, t, n, r, o, i) {
        var a, u;
        let s = t.getDependencies();
        for (let c of s)
            if (o[c])
                return;
        for (let c = s.length - 1; c >= 0; c--) {
            let l = s[c];
            if (i[l])
                continue;
            let p = r[l];
            if (p === void 0)
                continue;
            let m = n[l];
            if (m.order !== 1)
                continue;
            let d = m.tree
              , y = d.type === "IRExpression" ? d.getPolynomialCoefficients(l) : void 0
              , g = (a = y == null ? void 0 : y[1]) != null ? a : f2
              , f = (u = y == null ? void 0 : y[0]) != null ? u : f2;
            if (!Wm(f) || !Wm(g) || !isFinite(f.asValue()) || !isFinite(g.asValue()) || g.asValue() === 0)
                continue;
            let h = [-f.asValue() / g.asValue(), 1 / g.asValue()];
            return {
                symbol: l,
                id: p,
                coefficients: h
            }
        }
    }
    function o4(e, t) {
        for (let n of ue(t))
            if (t[n].evaluationState.assignment === e)
                return n
    }
    function i4(e) {
        let t = {};
        for (let n = 0; n < e.length; n++)
            t[e[n]] = !0;
        return t
    }
    function B_(e, t, n) {
        var s;
        let r = i4(t)
          , o = Iy(e)
          , i = {};
        for (let a of ue(n)) {
            if ((s = o.viewportTransitiveDependencies) != null && s.has(a))
                continue;
            let u = n[a].evaluationState.assignment;
            n[a].evaluationState.is_slidable && r[u] && (i[u] = a)
        }
        return i
    }
    function g2(e, t, n, r) {
        let o = [];
        for (let i = 0; i < n.length; i++) {
            let s = n[i]
              , a = {};
            o.push(a);
            for (let u = 0; u < r.length; u++) {
                let c = r[u]
                  , l = Fn(t);
                l[c] = void 0;
                let p = pe(s, e, l);
                if (p.type === "Error") {
                    a[c] = {
                        tree: p,
                        order: 1 / 0
                    };
                    continue
                } else
                    a[c] = {
                        tree: p,
                        order: p.polynomialOrder(c)
                    }
            }
        }
        return o
    }
    function h2(e, t, n) {
        for (let r = 0; r < e.length; r++) {
            let o = e[r];
            t[o].order !== 0 && (n[o] = !0)
        }
    }
    Gs.prototype.getMoveStrategy = function(e, t, n, r) {
        if (!Mg(this, t))
            return b2(this, e, t, n, r)
    }
    ;
    function b2(e, t, n, r, o) {
        var T;
        let i = r.valueType === N;
        if (r.valueType !== R && !i || r.getDependencies().length !== 0)
            return;
        if (i && d2(e)) {
            let P = e.getInputSpan();
            return P ? [{
                type: "updateCoordinate",
                inputSpan: P
            }, {
                type: "updateCoordinate",
                inputSpan: P
            }] : [{
                type: "none"
            }, {
                type: "none"
            }]
        }
        let s = e.getDependencies(), a = B_(n, s, o), u = ue(a), c;
        i ? c = pI(n, e) : c = e.args;
        let l = [{
            type: "none"
        }, {
            type: "none"
        }];
        if (c) {
            let P = g2(t, n, c, u)
              , C = {}
              , S = {};
            for (let E = 0; E < 2; E++) {
                let M = c[E]
                  , _ = e.args[E];
                if (Wm(_) && !i) {
                    let Q = _ == null ? void 0 : _.getInputSpan();
                    l[E] = Q ? {
                        type: "updateCoordinate",
                        inputSpan: Q
                    } : {
                        type: "none"
                    };
                    continue
                }
                let U = y2(t, M, P[E], a, C, S);
                U && (l[E] = {
                    type: "updateSlider",
                    id: U.id,
                    coefficients: U.coefficients
                },
                C[U.symbol] = !0,
                h2(u, P[E], S)),
                l[E] || (l[E] = {
                    type: "none"
                })
            }
            i && (l[0].type === "updateSlider" && l[1].type === "none" ? pe(c[1], t, n).valueType !== b && (l[0] = {
                type: "none"
            }) : l[0].type === "none" && l[1].type === "updateSlider" && pe(c[0], t, n).valueType !== b && (l[1] = {
                type: "none"
            }))
        }
        let[p,m] = l, d;
        if (p.type === "none" && m.type === "none" && u.length === 1 && (d = u[0]),
        !d)
            return p.type !== "none" || m.type !== "none" ? l : void 0;
        let y = a[d]
          , g = Fn(n);
        g[d] = void 0;
        let f = pe(e, t, g);
        if (f.isError)
            return;
        let h = f.getCompiledFunction();
        EM(h);
        let x = o[y].evaluationState;
        return [t4({
            id: y,
            initialValue: (T = x.typed_constant_value) == null ? void 0 : T.value,
            min: x.slider_min_number,
            max: x.slider_max_number,
            compiled: h,
            isComplex: i
        }), {
            type: "none"
        }]
    }
    function s4(e, t, n, r, o) {
        if (!qs(r) || r.valueType !== R)
            return;
        let i, s, a;
        switch (e.args[1].type) {
        case "Constant":
            {
                if (typeof e.args[1].asValue() != "number" || (i = pe(e.args[0], t, n),
                !qs(i)))
                    return;
                a = Rr(i);
                let c = e.args[1].getInputSpan();
                return [c ? n4({
                    span: c,
                    movesOn: a
                }) : {
                    type: "none"
                }, {
                    type: "none"
                }]
            }
        case "Identifier":
            {
                let u = e.args[1]._symbol;
                if (!u)
                    return;
                let l = B_(n, [u], o)[u];
                if (l === void 0)
                    return;
                let p = o[l].evaluationState
                  , m = Fn(n);
                return m[u] = void 0,
                i = pe(e.args[0], t, m),
                qs(i) ? (a = Rr(i),
                s = {
                    min: p.slider_min_number,
                    max: p.slider_max_number
                },
                [r4({
                    min: s.min,
                    max: s.max,
                    movesOn: a,
                    sliderId: l
                }), {
                    type: "none"
                }]) : void 0
            }
        default:
            return
        }
    }
    function x2(e, t, n, r, o) {
        if (r.valueType === N)
            return b2(e, t, n, r, o)
    }
    Z.prototype.getMoveStrategy = function(e, t, n, r) {
        if (!Mg(this, t))
            return x2(this, e, t, n, r)
    }
    ;
    _n.prototype.getMoveStrategy = function(e, t, n, r) {
        if (!Mg(this, t))
            return this._symbol == "glider" ? s4(this, e, t, n, r) : x2(this, e, t, n, r)
    }
    ;
    O.Image.prototype.getMoveStrategy = function(e, t, n, r) {
        if (Mg(this, t) || n.center.valueType !== R || n.center.getDependencies().length !== 0 || n.radianAngle.type !== "IRExpression" || n.width.type !== "IRExpression" || n.height.type !== "IRExpression" || n.opacity.type !== "IRExpression" || !n.width.isConstant || !n.height.isConstant || !n.radianAngle.isConstant || !n.opacity.isConstant)
            return;
        let o = this.getDependencies()
          , i = B_(t, o, r)
          , s = ue(i)
          , a = [this.width, this.height];
        this.center.type === "ParenSeq" ? a.push(this.center.args[0], this.center.args[1]) : this.center.type === "Identifier" && (this.center.referencedStatementId = o4(this.center._symbol, r));
        let u = {}
          , c = {}
          , l = g2(e, t, a, s)
          , p = [{
            type: "none"
        }, {
            type: "none"
        }, {
            type: "none"
        }, {
            type: "none"
        }]
          , m = [2, 3, 0, 1];
        for (let d = 0; d < m.length; d++) {
            let y = m[d]
              , g = a[y];
            if (!g)
                continue;
            if (g.type === "Constant") {
                let h = g.getInputSpan();
                p[y] = h ? {
                    type: "updateCoordinate",
                    inputSpan: h
                } : {
                    type: "none"
                };
                continue
            }
            let f = y2(e, g, l[y], i, u, c);
            f && (p[y] = {
                type: "updateSlider",
                id: f.id,
                coefficients: f.coefficients
            },
            u[f.symbol] = !0,
            h2(s, l[y], c))
        }
        if (!(p[0].type === "none" && p[1].type === "none" && p[2].type === "none" && p[3].type === "none"))
            return p
    }
    ;
    var G_ = e => e == null ? void 0 : e.some(t => "isComplex"in t && t.isComplex);
    function Dg(e, t) {
        if (e instanceof _n || e instanceof Ln) {
            if (t[0].type !== "none" && t[1].type !== "none")
                return Jt.XY;
            if (t[0].type !== "none")
                return Jt.X;
            if (t[1].type !== "none")
                return Jt.Y
        } else if (e instanceof Z) {
            if (t[0].type === "updateSlider" && t[1].type === "updateSlider")
                return Jt.XY;
            if (t[0].type === "updateSlider")
                return Jt.X;
            if (t[1].type === "updateSlider")
                return Jt.Y;
            if (t[0].type === "updateSliderNonlinear" && t[0].isComplex)
                return Jt.X
        }
        return Jt.NONE
    }
    var a4 = ["ttest", "ztest", "zproptest", "chisqgof", "chisqtest"];
    function T2(e) {
        return !!e && a4.includes(e)
    }
    function u4(e, t, {firstArgIsList: n, firstArgIsRegressionParameter: r}) {
        switch (e) {
        case "ttest":
            if (n === void 0 && t <= 1)
                return {
                    type: "inference",
                    symbol: e,
                    params: ["list"],
                    samples: 1
                };
            if (n && t <= 2)
                switch (t) {
                case 1:
                    return {
                        type: "inference",
                        symbol: e,
                        params: ["list"],
                        samples: 1
                    };
                case 2:
                    return {
                        type: "inference",
                        symbol: e,
                        params: ["list"],
                        samples: 2
                    }
                }
            else {
                if (r && t <= 1)
                    return {
                        type: "inference",
                        symbol: e,
                        params: ["regression-parameter"],
                        samples: 1
                    };
                switch (t) {
                case 1:
                case 2:
                case 3:
                    return {
                        type: "inference",
                        symbol: e,
                        params: ["sample-size", "mean", "stdev"],
                        samples: 1
                    };
                case 4:
                case 5:
                case 6:
                    return {
                        type: "inference",
                        symbol: e,
                        params: ["sample-size", "mean", "stdev"],
                        samples: 2
                    }
                }
            }
            break;
        case "ztest":
            return n === void 0 && t <= 1 ? {
                type: "inference",
                symbol: e,
                params: ["list", "stdevp"],
                samples: 1
            } : n && t <= 4 ? t <= 2 ? {
                type: "inference",
                symbol: e,
                params: ["list", "stdevp"],
                samples: 1
            } : {
                type: "inference",
                symbol: e,
                params: ["list", "stdevp"],
                samples: 2
            } : t <= 3 ? {
                type: "inference",
                symbol: e,
                params: ["sample-size", "mean", "stdevp"],
                samples: 1
            } : {
                type: "inference",
                symbol: e,
                params: ["sample-size", "mean", "stdevp"],
                samples: 2
            };
        case "zproptest":
            return t <= 2 ? {
                type: "inference",
                symbol: e,
                params: ["successes", "sample-size"],
                samples: 1
            } : {
                type: "inference",
                symbol: e,
                params: ["successes", "sample-size"],
                samples: 2
            };
        case "chisqgof":
        case "chisqtest":
            return {
                type: "inference",
                symbol: e,
                params: []
            };
        default:
            throw new Error(`Unexpected symbol ${e}`)
        }
    }
    function I2(e, t, n) {
        return u4(e, t.args.length, n)
    }
    function P2(e, t, n) {
        var g, f, h, x, T, P, C, S;
        let {evaluationState: r, rawTree: o} = e
          , i = o.metaData
          , s = e.rawTree.userData;
        if (((g = r.top_level_function_spec) == null ? void 0 : g.type) !== "inference")
            return;
        let a = r.top_level_function_spec.symbol
          , u = r.typed_constant_value
          , c = o.type === "Assignment" ? o._expression : o
          , l = new Qn("estimate",[c])
          , p = new Qn("stderr",[c])
          , [m] = Ex(pe(l, t, n), b)
          , [d] = Ex(pe(p, t, n), b);
        r.point_estimate_value = m == null ? void 0 : m.value,
        r.standard_error_value = d == null ? void 0 : d.value,
        r.hypothesis_value !== void 0 && ((h = (f = s == null ? void 0 : s.inference) == null ? void 0 : f.significance) == null ? void 0 : h.hypothesis) === "" && (r.hypothesis_placeholder = r.hypothesis_value);
        let y = r.hypothesis_value;
        if (r.hypothesis_valid && (y === void 0 || Array.isArray(y) ? r.hypothesis_valid = !1 : a === "zproptest" && (E2(u) === 2 ? (y < -1 || y > 1) && (r.hypothesis_valid = !1) : (y < 0 || y > 1) && (r.hypothesis_valid = !1))),
        (x = s.inference) != null && x.significance.show) {
            if (e.evaluationState.hypothesis_valid) {
                let E = new Qn("null",[c, new Vn(r.hypothesis_value)])
                  , M = Rr(pe(E, t, n));
                r.significance_value = (M == null ? void 0 : M.valueType) === pn || (M == null ? void 0 : M.valueType) === mn ? M : void 0
            }
            r.hypothesis_variables = (T = i.hypothesis) == null ? void 0 : T.getSliderVariables(t, pe(i.hypothesis, t, n))
        }
        if ((P = s.inference) != null && P.confidence.show) {
            if (e.evaluationState.confidence_level_valid) {
                let E = new Qn("conf",[c, new Vn(r.confidence_level_value)])
                  , [M] = Ex(pe(E, t, n), Pt);
                r.confidence_value = M
            }
            r.confidence_level_variables = (C = i.confidenceLevel) == null ? void 0 : C.getSliderVariables(t, pe(i.confidenceLevel, t, n))
        }
        r.variables = (S = r.variables) == null ? void 0 : S.filter(E => {
            var M, _;
            return !((M = r.confidence_level_variables) != null && M.includes(E)) && !((_ = r.hypothesis_variables) != null && _.includes(E))
        }
        )
    }
    function q_(e) {
        e.type === "Assignment" && (e = e._expression);
        let t;
        return e.type !== "FunctionCall" ? t = void 0 : ["ttest", "ztest", "zproptest", "chisqgof", "chisqtest"].indexOf(e._symbol) !== -1 ? t = e._symbol : t = void 0,
        t
    }
    var S2 = (e, t) => {
        if (!e || !t)
            return 0;
        let n = q_(e)
          , r = Rr(t);
        return n === "zproptest" && E2(r) === 1 ? .5 : 0
    }
      , E2 = e => {
        if (!(!e || !Ti(e.valueType)))
            return Ru(e.valueType, [Yt, wt, Ht]) ? 2 : 1
    }
    ;
    var _g = {
        normaldist: {
            type: "distribution",
            symbol: "normaldist",
            params: ["mean", "stdev"],
            defaults: [0, 1],
            discrete: !1
        },
        tdist: {
            type: "distribution",
            symbol: "tdist",
            params: ["dof", "shift", "scale"],
            defaults: [void 0, 0, 1],
            discrete: !1
        },
        chisqdist: {
            type: "distribution",
            symbol: "chisqdist",
            params: ["dof"],
            defaults: [void 0],
            discrete: !1
        },
        binomialdist: {
            type: "distribution",
            symbol: "binomialdist",
            params: ["trials", "probsuccess"],
            defaults: [void 0, .5],
            discrete: !0
        },
        poissondist: {
            type: "distribution",
            symbol: "poissondist",
            params: ["mean"],
            defaults: [void 0],
            discrete: !0
        },
        geodist: {
            type: "distribution",
            symbol: "geodist",
            params: ["probsuccess"],
            defaults: [.5],
            discrete: !0
        },
        uniformdist: {
            type: "distribution",
            symbol: "uniformdist",
            params: ["min", "max"],
            defaults: [0, 1],
            discrete: !1
        }
    }
      , c4 = {
        Histogram: {
            type: "visualization",
            symbol: "histogram",
            params: ["data", "binwidth"],
            defaults: [void 0, 1]
        },
        DotPlot: {
            type: "visualization",
            symbol: "dotplot",
            params: ["data", "binwidth"],
            defaults: [void 0, 1]
        },
        BoxPlot: {
            type: "visualization",
            symbol: "boxplot",
            params: ["data"],
            defaults: [void 0]
        }
    };
    function jp(e, t, n) {
        var a;
        if (e.type === "Assignment")
            return jp(e._expression, t, n);
        if (e.type === "Error" && e.userData.latex)
            return jp(mi(e.userData.latex, {
                trailingComma: !0
            }), t, n);
        let r;
        switch (e.type) {
        case "Histogram":
        case "DotPlot":
        case "BoxPlot":
            r = c4[e.type];
            break;
        case "FunctionCall":
            let u = e._symbol;
            if (u in _g)
                r = _g[u];
            else if (T2(u)) {
                let c = e.args[0]
                  , l = !1;
                c ? (((a = e.args[0]) == null ? void 0 : a.type) === "List" || t && n && pe(e.args[0], t, n).isList) && (l = !0) : l = void 0;
                let p = c && c instanceof dn && (n == null ? void 0 : n[c._symbol])instanceof ul;
                r = I2(u, e, {
                    firstArgIsList: l,
                    firstArgIsRegressionParameter: p
                })
            }
            break;
        default:
            return
        }
        if (!r)
            return;
        let o = {}
          , i = r.params
          , s = e.args;
        for (let u = 0; u < i.length; u++) {
            let c = s[u];
            o[i[u]] = c && c.getInputString() || ""
        }
        return {
            ...r,
            span: e.getInputSpan(),
            values: o
        }
    }
    function Vbe(e, t) {
        switch (e) {
        case "normaldist":
            return t.map(n => n.type === "default" ? !0 : n.type === "error" ? !1 : isFinite(n.value));
        case "binomialdist":
            return t.map( (n, r) => r === 0 ? n.type === "number" && n.value > 0 && isFinite(n.value) : r === 1 ? n.type === "default" ? !0 : n.type === "number" && n.value >= 0 && n.value <= 1 : !1);
        case "chisqdist":
            return t.map( (n, r) => r === 0 ? n.type === "number" && n.value > 0 && isFinite(n.value) : !1);
        case "poissondist":
            return t.map( (n, r) => r === 0 ? n.type === "number" && n.value >= 0 && isFinite(n.value) : !1);
        case "geodist":
            return t.map( (n, r) => r === 0 ? n.type === "default" ? !0 : n.type === "number" && n.value > 0 && n.value <= 1 : !1);
        case "tdist":
            return t.map( (n, r) => r === 0 ? n.type === "number" && n.value > 0 && isFinite(n.value) : r === 1 || r === 2 ? n.type === "default" ? !0 : n.type === "number" && isFinite(n.value) : !1);
        case "uniformdist":
            return t.map( (n, r) => {
                if (n.type === "error")
                    return !1;
                if (n.type === "default")
                    return !0;
                if (!isFinite(n.value))
                    return !1;
                if (r === 0) {
                    let o = t[1]
                      , i = 1 / 0;
                    return o.type === "default" && (i = 1),
                    o.type === "number" && (i = o.value),
                    n.type === "number" && n.value < i
                } else if (r === 1) {
                    let o = t[0]
                      , i = -1 / 0;
                    return o.type === "default" && (i = 0),
                    o.type === "number" && (i = o.value),
                    n.type === "number" && n.value > i
                } else
                    return !1
            }
            );
        default:
            return t.map( () => !1)
        }
    }
    Z.prototype.tableInfo = function(e, t) {
        return !1
    }
    ;
    ze.prototype.tableInfo = function(e, t) {
        return e.validFirstColumnVariable(this._symbol) ? {
            independent_variable: this._symbol,
            dependent_column: this.getInputString(),
            by_reference: !1
        } : !1
    }
    ;
    Z.prototype.tableInfo = function(e, t) {
        let n = t.getDependencies();
        if (jp(this))
            return !1;
        switch (t.valueType) {
        case R:
        case zt:
            return n.length !== 0 || Zb(t) && (t.moveStrategy[0].type === "updateSlider" || t.moveStrategy[1].type === "updateSlider") ? !1 : {
                independent_variable: "x",
                dependent_column: "y",
                by_reference: !1,
                values: X(t.valueType) ? t.asValue() : [t.asValue()]
            };
        case b:
            if (n.length !== 1)
                return !1;
            let o = n[0];
            return e.validFirstColumnVariable(o) ? {
                independent_variable: o,
                dependent_column: this.getInputString(),
                by_reference: !1
            } : !1;
        default:
            return !1
        }
    }
    ;
    Ln.prototype.tableInfo = function(e, t) {
        if (!this.getInputString().length || jp(this) || _f(t.valueType))
            return !1;
        let n = t.getDependencies();
        if (n.length > 1)
            return !1;
        let r;
        if (n.length === 0) {
            if (!e.tableableAsConstant(this._symbol))
                return !1;
            r = e.implicitIndependent(this._symbol)
        } else
            r = n[0];
        if (!e.validFirstColumnVariable(r))
            return !1;
        let o = e.assignmentForbidden(this._symbol) ? Au(this.getInputString().replace(/[^=]*=/, "")) : Au(this.getInputString().split("=")[0]);
        return {
            independent_variable: r,
            dependent_column: o,
            by_reference: !e.assignmentForbidden(this._symbol)
        }
    }
    ;
    O.FunctionDefinition.prototype.tableInfo = function(e, t) {
        if (this._argSymbols.length !== 1 || !this.getInputString().length || t.getDependencies().length > 1)
            return !1;
        let r = this._argSymbols[0];
        if (!e.validFirstColumnVariable(r))
            return !1;
        let o = e.assignmentForbidden(this._symbol)
          , i = o ? Au(this.getInputString().replace(/[^=]*=/, "")) : Au(this.getInputString().split("=")[0]);
        return {
            independent_variable: r,
            dependent_column: i,
            by_reference: !o
        }
    }
    ;
    bo.prototype.tableInfo = function(e, t) {
        return !1
    }
    ;
    O.ComparatorChain.prototype.tableInfo = function(e, t) {
        return !1
    }
    ;
    O.DoubleInequality.prototype.tableInfo = function(e, t) {
        return !1
    }
    ;
    O.Equation.prototype.tableInfo = function(e, t) {
        return !1
    }
    ;
    ct.prototype.tableError = function() {
        return this.isInequality() ? I("shared-calculator-error-table-inequality-supplement") : !(this instanceof Z) && !(this instanceof O.IRExpression) ? I("shared-calculator-error-table-generic-supplement") : !1
    }
    ;
    Yi.prototype.tableError = function() {
        return I("shared-calculator-error-table-list-supplement")
    }
    ;
    O.Equation.prototype.tableError = Ln.prototype.tableError = function() {
        return I("shared-calculator-error-table-equation-supplement")
    }
    ;
    O.ComparatorChain.prototype.tableError = function() {
        return this.symbols.includes("=") ? I("shared-calculator-error-table-equation-supplement") : I("shared-calculator-error-table-inequality-supplement")
    }
    ;
    O.FunctionDefinition.prototype.tableError = function() {
        return I("shared-calculator-error-table-function-definition-supplement")
    }
    ;
    O.Regression.prototype.tableError = function() {
        return I("shared-calculator-error-table-regression-supplement")
    }
    ;
    function l4() {
        return go(this._symbol) + " "
    }
    ze.prototype.printLatex = l4;
    Hn.prototype.printLatex = function() {
        return ia(this.asValue())
    }
    ;
    O.Ticker.prototype.printLatex = function() {
        return "\\ticker\\left(" + this.args.map(es).join(", ") + "\\right)"
    }
    ;
    O.Negative.prototype.printLatex = function() {
        return "-\\left(" + this.args[0].printLatex() + "\\right)"
    }
    ;
    O.Add.prototype.printLatex = function() {
        return "\\left(" + this.args[0].printLatex() + "\\right)+\\left(" + this.args[1].printLatex() + "\\right)"
    }
    ;
    O.PercentOf.prototype.printLatex = function() {
        return this.args[0].printLatex() + " \\% \\operatorname{of} " + this.args[1].printLatex()
    }
    ;
    O.Subtract.prototype.printLatex = function() {
        return "\\left(" + this.args[0].printLatex() + "\\right)-\\left(" + this.args[1].printLatex() + "\\right)"
    }
    ;
    O.Multiply.prototype.printLatex = function() {
        return "\\left(" + this.args[0].printLatex() + "\\right)*\\left(" + this.args[1].printLatex() + "\\right)"
    }
    ;
    O.DotMultiply.prototype.printLatex = function() {
        return "\\left(" + this.args[0].printLatex() + "\\right)\\cdot\\left(" + this.args[1].printLatex() + "\\right)"
    }
    ;
    O.CrossMultiply.prototype.printLatex = function() {
        return "\\left(" + this.args[0].printLatex() + "\\right)\\times\\left(" + this.args[1].printLatex() + "\\right)"
    }
    ;
    O.Divide.prototype.printLatex = function() {
        return "\\frac{" + this.args[0].printLatex() + "}{" + this.args[1].printLatex() + "}"
    }
    ;
    Ny.prototype.printLatex = function() {
        return "\\left(" + this.args[0].printLatex() + "\\right)^{" + this.args[1].printLatex() + "}"
    }
    ;
    Ln.prototype.printLatex = function() {
        return go(this._symbol) + "=" + this._expression.printLatex()
    }
    ;
    O.Equation.prototype.printLatex = O.CallAssignment.prototype.printLatex = function() {
        return this._lhs.printLatex() + "=" + this._rhs.printLatex()
    }
    ;
    function mI(e) {
        switch (e) {
        case ">":
            return ">";
        case "<":
            return "<";
        case ">=":
            return "\\ge ";
        case "<=":
            return "\\le ";
        case "=":
            return "="
        }
        return ""
    }
    bo.prototype.printLatex = function() {
        return "\\left(" + this.args[0].printLatex() + "\\right)" + mI(this.operator) + "\\left(" + this.args[1].printLatex() + "\\right)"
    }
    ;
    O.ComparatorChain.prototype.printLatex = function() {
        let e = "";
        for (let t = 0; t < this.symbols.length; t++)
            e += `\\left(${this.args[t].printLatex()}\\right)${mI(this.symbols[t])}`;
        return e += `\\left(${this.args[this.args.length - 1].printLatex()}\\right)`,
        e
    }
    ;
    O.DoubleInequality.prototype.printLatex = function() {
        return "\\left(" + this.args[0].printLatex() + "\\right)" + mI(this.args[1]) + this.args[2].printLatex() + mI(this.args[3]) + "\\left(" + this.args[4].printLatex() + "\\right)"
    }
    ;
    O.Or.prototype.printLatex = function() {
        return this.args[0].printLatex() + "," + this.args[1].printLatex()
    }
    ;
    function es(e) {
        return e.printLatex()
    }
    function p4() {
        switch (this._symbol) {
        case "sqrt":
            return "\\sqrt{" + this.args[0].printLatex() + "}";
        case "nthroot":
            return "\\sqrt[" + this.args[1].printLatex() + "]{" + this.args[0].printLatex() + "}";
        case "logbase":
            return "\\log_{" + this.args[1].printLatex() + "}\\left(" + this.args[0].printLatex() + "\\right)";
        default:
            return go(this._symbol) + "\\left(" + this.args.map(es).join(", ") + "\\right)"
        }
    }
    _n.prototype.printLatex = p4;
    O.RecursiveFunctionBaseCase.prototype.printLatex = function() {
        return this.originalNode.printLatex()
    }
    ;
    O.SeededFunctionCall.prototype.printLatex = function() {
        return go(this._symbol) + "\\left(" + this.args.slice(1).map(es).join(", ") + "\\right)"
    }
    ;
    O.DotAccess.prototype.printLatex = function() {
        return "(" + this.args[0].printLatex() + ").(" + this.args[1].printLatex() + ")"
    }
    ;
    O.Prime.prototype.printLatex = function() {
        switch (this.args[0]._symbol) {
        case "logbase":
            return "\\log_{" + this.args[0].args[1].printLatex() + "}" + Array(this.order + 1).join("'") + "\\left(" + this.args[0].args[0].printLatex() + "\\right)";
        default:
            return go(this.args[0]._symbol) + Array(this.order + 1).join("'") + "\\left(" + this.args[0].args.map(es).join(", ") + "\\right)"
        }
    }
    ;
    Yi.prototype.printLatex = function() {
        return "\\left[" + this.args.map(es).join(", ") + "\\right]"
    }
    ;
    O.Range.prototype.printLatex = function() {
        return "\\left[" + this.args[0].args.map(es).join(", ") + " ... " + this.args[1].args.map(es).join(", ") + "\\right]"
    }
    ;
    O.UpdateRule.prototype.printLatex = function() {
        return this.args[0].printLatex() + "\\to(" + this.args[1].printLatex() + ")"
    }
    ;
    O.ListAccess.prototype.printLatex = function() {
        return "\\left(" + this.args[0].printLatex() + "\\right)\\left[" + this.args[1].printLatex() + "\\right]"
    }
    ;
    Gs.prototype.printLatex = function() {
        return "\\left(" + this.args.map(es).join(", ") + "\\right)"
    }
    ;
    O.BareSeq.prototype.printLatex = function() {
        return this.args.map(es).join(", ")
    }
    ;
    O.NamedCoordinateAccess.prototype.printLatex = function() {
        return "\\left(\\left(" + this.args[0].printLatex() + "\\right)." + this.symbol + "\\right)"
    }
    ;
    O.Norm.prototype.printLatex = function() {
        return "\\left|" + this.args[0].printLatex() + "\\right|"
    }
    ;
    O.Sum.prototype.printLatex = function() {
        return "\\sum_{" + this.args[0].printLatex() + "=" + this.args[1].printLatex() + "}^{" + this.args[2].printLatex() + "}\\left(" + this.args[3].printLatex() + "\\right)"
    }
    ;
    O.Product.prototype.printLatex = function() {
        return "\\prod_{" + this.args[0].printLatex() + "=" + this.args[1].printLatex() + "}^{" + this.args[2].printLatex() + "}\\left(" + this.args[3].printLatex() + "\\right)"
    }
    ;
    O.Integral.prototype.printLatex = function() {
        return "\\int_{" + this.args[1].printLatex() + "}^{" + this.args[2].printLatex() + "}\\left(" + this.args[3].printLatex() + "\\right)d" + this.args[0].printLatex()
    }
    ;
    O.FunctionExponent.prototype.printLatex = function() {
        return this.args[0].printLatex() + "\\left(" + this.args[1].printLatex() + "\\right)^{" + this.args[2].printLatex() + "}"
    }
    ;
    O.FunctionFactorial.prototype.printLatex = function() {
        return this.args[0].printLatex() + "\\left(" + this.args[1].printLatex() + "\\right)!"
    }
    ;
    function z_(e) {
        return e instanceof Hn && e.asValue() === !0
    }
    function m4(e) {
        return e instanceof Hn && e.isNaN()
    }
    O.Piecewise.prototype.printLatex = function() {
        let e = this;
        if (z_(e.args[0]))
            return e.args[1].printLatex();
        let t = ["\\left\\{"];
        for (; ; ) {
            if (z_(e.args[0])) {
                t.push(e.args[1].printLatex());
                break
            }
            if (t.push(e.args[0].printLatex(), ": "),
            m4(e.args[2])) {
                t.push(e.args[1].printLatex());
                break
            }
            if (t.push(e.args[1].printLatex(), ", "),
            !(e.args[2]instanceof O.Piecewise)) {
                t.push(e.args[2].printLatex());
                break
            }
            e = e.args[2]
        }
        return t.push("\\right\\}"),
        t.join("")
    }
    ;
    O.Restriction.prototype.printLatex = function() {
        return z_(this.args[0]) ? "\\left\\{\\right\\}" : "\\left\\{" + this.args[0].printLatex() + "\\right\\}"
    }
    ;
    O.FunctionDefinition.prototype.printLatex = function() {
        return go(this._symbol) + "\\left(" + this._argSymbols.map(go).join(", ") + "\\right) = " + this._expression.printLatex()
    }
    ;
    O.Derivative.prototype.printLatex = function() {
        return "\\frac{d}{d" + go(this._symbol) + "}\\left(" + this.args[0].printLatex() + "\\right)"
    }
    ;
    O.Regression.prototype.printLatex = function() {
        return "\\left(" + this._lhs.printLatex() + "\\right)\\sim\\left(" + this._rhs.printLatex() + "\\right)"
    }
    ;
    O.Histogram.prototype.printLatex = function() {
        return "\\histogram\\left(" + this.args.map(es).join(", ") + "\\right)"
    }
    ;
    O.DotPlot.prototype.printLatex = function() {
        return "\\dotplot\\left(" + this.args.map(es).join(", ") + "\\right)"
    }
    ;
    O.BoxPlot.prototype.printLatex = function() {
        return "\\boxplot\\left(" + this.args.map(es).join(", ") + "\\right)"
    }
    ;
    O.Stats.prototype.printLatex = function() {
        return "\\Stats\\left(" + this.args.map(es).join(", ") + "\\right)"
    }
    ;
    O.AssignmentExpression.prototype.printLatex = function() {
        return go(this._symbol) + "=" + this.args[1].printLatex()
    }
    ;
    O.ListComprehension.prototype.printLatex = function() {
        return "\\left[" + this._body.printLatex() + "\\operatorname{for}" + this._inputLists.map(es).join(", ") + "\\right]"
    }
    ;
    O.Substitution.prototype.printLatex = function() {
        return "\\left(\\left(" + this._body.printLatex() + "\\right)\\operatorname{with}" + this._assignments.map(es).join(", ") + "\\right)"
    }
    ;
    O.Construction.prototype.printLatex = function() {
        return "\\construction "
    }
    ;
    O.ImaginaryUnit.prototype.printLatex = function() {
        return Gr
    }
    ;
    O.MovableComplexNumber.prototype.printLatex = function() {
        return kf(this.asValue())
    }
    ;
    ct.prototype.getExpressionType = function(e, t) {
        switch (e) {
        case 114:
            return t && X(t) ? A.POINT3D_LIST : A.POINT3D;
        case 100:
        case 128:
            return A.CURVE3D_xyz_t;
        case 119:
            return A.SEGMENT3D;
        case 129:
            return A.VECTOR3D;
        case 130:
        case 103:
            return A.SURFACE_xyz_uv;
        case 110:
            return A.SURFACE_r_\u03B8z;
        case 124:
            return A.SURFACE_r_\u03B8z_AMBIGUOUS;
        case 109:
            return A.SURFACE_z_r\u03B8;
        case 111:
            return A.SURFACE_r_\u03B8\u03C6;
        case 107:
        case 108:
        case 106:
            return A.SURFACE;
        case 118:
            return A.SPHERE3D;
        case 117:
            return A.TRIANGLE3D;
        case 120:
        case 121:
            return A.SURFACE_AMBIGUOUS;
        case 122:
        case 123:
            return A.SURFACE_CONSTANT_AMBIGUOUS;
        case 112:
        case 113:
        case 210:
            return A.IMPLICIT_SURFACE;
        case 126:
        case 127:
            return A.IMPLICIT_SURFACE_AMBIGUOUS;
        case 3:
        case 4:
        case 25:
        case 26:
            return t && X(t) ? A.POINT_LIST : A.SINGLE_POINT;
        case 1:
        case 2:
            return A.X_OR_Y;
        case 5:
            return A.PARAMETRIC;
        case 6:
            return A.POLAR;
        case 8:
            return A.IMPLICIT;
        case 24:
        case 17:
            return A.VECTOR2D;
        case 200:
        case 201:
        case 202:
        case 205:
        case 209:
            return A.SLICE;
        case 211:
        case 206:
            return A.SLICE_r\u03B8z_at_z;
        case 203:
            return A.SLICE_zr\u03B8_at_r;
        case 204:
            return A.SLICE_zr\u03B8_at_\u03B8;
        case 213:
            return A.SLICE_zr\u03B8_at_xyz;
        case 207:
            return A.SLICE_r\u03B8\u03C6_at_\u03B8;
        case 208:
            return A.SLICE_r\u03B8\u03C6_at_\u03C6;
        case 212:
            return A.SLICE_r\u03B8\u03C6_at_xyz;
        case 214:
        case 215:
            return A.SLICE_xyz_uv;
        default:
            return t !== void 0 && ae(t, De) ? A.POLYGON : A.X_OR_Y
        }
    }
    ;
    O.Histogram.prototype.getExpressionType = function(e, t) {
        return A.HISTOGRAM
    }
    ;
    O.DotPlot.prototype.getExpressionType = function(e, t) {
        return A.DOTPLOT
    }
    ;
    O.BoxPlot.prototype.getExpressionType = function(e, t) {
        return A.BOXPLOT
    }
    ;
    function d4(e) {
        return function(n) {
            return new e(n)
        }
    }
    var f4 = [Qm, ll, ed, td, nd, Qo, ml, rd, id, dl, fl, sd, ud, Zm, $a, fd, yd, gd, hd, il, bd, Io, Sd, Td, Id, Pd, Jo, Ed];
    for (let e of f4)
        e.prototype.copyWithArgs = d4(e);
    Cp.prototype.copyWithArgs = function(e) {
        return new Cp(e)
    }
    ;
    bo.prototype.copyWithArgs = function(e) {
        return kb(this.operator, e)
    }
    ;
    pl.prototype.copyWithArgs = function(e) {
        return new pl(this.symbols,e)
    }
    ;
    Hn.prototype.copyWithArgs = function(e) {
        return new Vn(this._constantValue)
    }
    ;
    vp.prototype.copyWithArgs = function(e) {
        return new vp(this.constructedObjectIds)
    }
    ;
    Mp.prototype.copyWithArgs = function(e) {
        return new Mp(this._symbol,e)
    }
    ;
    Dp.prototype.copyWithArgs = function(e) {
        return new Dp(this.tag,e)
    }
    ;
    _n.prototype.copyWithArgs = function(e) {
        return new Qn(new dn(this._symbol),e)
    }
    ;
    ze.prototype.copyWithArgs = function(e) {
        return new dn(this._symbol)
    }
    ;
    Za.prototype.copyWithArgs = function(e) {
        return new Za
    }
    ;
    Tc.prototype.copyWithArgs = function(e) {
        return new Tc(e[0],e[1],e.slice(2),this.shouldCoerceToList,this.parameters)
    }
    ;
    Hu.prototype.copyWithArgs = function(e) {
        return new Hu(e,this.moveStrategy,this.defaultDragMode)
    }
    ;
    Ya.prototype.copyWithArgs = function(e) {
        return new Ya(e,this.moveStrategy,this.defaultDragMode)
    }
    ;
    Xa.prototype.copyWithArgs = function(e) {
        return new Xa(this.symbol,e)
    }
    ;
    Rp.prototype.copyWithArgs = function(e) {
        return new Rp(this.order,e)
    }
    ;
    Np.prototype.copyWithArgs = function(e) {
        return new Np(e)
    }
    ;
    zu.prototype.copyWithArgs = function(e) {
        return new zu(e[0],e.slice(1))
    }
    ;
    Op.prototype.copyWithArgs = function(e) {
        return new Op(this._stringValue)
    }
    ;
    Uu.prototype.copyWithArgs = function(e) {
        return new Uu(e,this.headerSymbol)
    }
    ;
    var ef = class {
        constructor({id: t, statement: n, moduleID: r, rootModuleId: o, origin: i}) {
            this.id = t,
            this.statement = n,
            this.statement.moduleID = r,
            this.rootModuleId = o,
            this.moduleID = r,
            this.origin = i
        }
    }
    ;
    var fI = {};
    cu(fI, {
        getFrame: () => h4
    });
    function h4(e) {
        let t = {};
        return e.additionalFunctions && e.additionalFunctions.indexOf("sqrt") !== -1 && (t.sqrt = rt.sqrt),
        e.width && (t.width = e.width),
        e.height && (t.height = e.height),
        t
    }
    var Rg = {};
    cu(Rg, {
        getFrame: () => E4,
        statsFunctionMathquillOperators: () => _2
    });
    $r();
    var C2 = {
        segment: !0,
        line: !0,
        ray: !0,
        circle: !0,
        arc: !0,
        vector: !0,
        glider: !0,
        parallel: !0,
        perpendicular: !0,
        center: !0,
        radius: !0,
        area: !0,
        perimeter: !0,
        start: !0,
        end: !0,
        angles: !0,
        angle: !0,
        directedangles: !0,
        directedangle: !0,
        coterminal: !0,
        supplement: !0,
        vertices: !0,
        segments: !0,
        intersection: !0,
        strictintersection: !0,
        translate: !0,
        dilate: !0,
        rotate: !0,
        reflect: !0,
        construction: !0,
        points: !0,
        lines: !0,
        circles: !0,
        arcs: !0,
        polygons: !0,
        rays: !0,
        anglebisector: !0
    };
    var v2 = {
        segment: !0,
        triangle: !0,
        vector: !0,
        start: !0,
        end: !0,
        sphere: !0
    };
    var M2 = ["csc", "sec", "cot", "arccsc", "arcsec", "arccot", "csch", "sech", "coth", "arccsch", "arcsech", "arccoth", "mad", "cov", "covp", "distance", "midpoint"]
      , D2 = ["histogram", "dotplot", "boxplot"]
      , b4 = [...D2, "polygon"]
      , _2 = ["chisqtest|chi-square-test", "chisqgof|chi-square-goodness-of-fit", "score", "conf|confidence", "pleft|p-left", "pright|p-right", "ztest|z-test", "zproptest|z-prop-test", "score", "dof|degrees-of-freedom", "estimate", "stderr|standard-error", "null", "upper", "lower"]
      , x4 = _2.map(e => e.split("|")[0])
      , T4 = ["erf", "ttest|t-test", "tscore|t-score", "normaldist|normal-distribution", "tdist|t-distribution", "chisqdist|chi-square-distribution", "poissondist|poisson-distribution", "binomialdist|binomial-distribution", "geodist|geometric-distribution", "pdf", "cdf", "random", ...D2, ...x4]
      , R2 = T4.map(e => e.split("|")[0])
      , I4 = ["distance", "midpoint"]
      , P4 = ["det", "inv", "transpose", "rref", "trace"]
      , N2 = Object.keys(C2).filter(e => e !== "construction")
      , O2 = Object.keys(Zf)
      , S4 = ["complexMultiplyPoints", "rawTransform", "rawTransformConj", "transformWithoutTranslation", "transformScaleFactor", "scaleTangentTransformation", "addTangentVector", "addTangentTransformation", "complex", "complexDivide", "coerceComplexToReal", "coerceComplexToRealWithTolerance", "coerceRealToComplex", "peelableCoerceComplexToRealWithTolerance", "peelableCoerceRealToComplex"];
    function yI(e, t) {
        for (let n of e)
            if (!t.hasOwnProperty(n))
                throw new Error("Programming Error: key '" + n + `' does not exist in table. Must be one of:
` + Object.keys(t).join(`
`))
    }
    yI(M2, rt);
    yI(R2, rt);
    yI(N2, rt);
    yI(O2, rt);
    function E4(e) {
        let t = {}, n;
        for (n of ue(rt)) {
            if (S4.includes(n) || e.restrictedFunctions === !0 && M2.indexOf(n) !== -1 && !(e.forceEnableGeometryFunctions === !0 && I4.indexOf(n) !== -1) || e.distributions === !1 && R2.indexOf(n) !== -1)
                continue;
            let r = N2.indexOf(n) !== -1
              , o = n in v2;
            if (r && o) {
                if (!(e.isGeometryCalculator || e.is3DCalculator))
                    continue
            } else if (r) {
                if (!e.isGeometryCalculator)
                    continue
            } else if (o) {
                if (!e.is3DCalculator)
                    continue
            } else if (b4.indexOf(n) !== -1 && e.is3DCalculator)
                continue;
            O2.indexOf(n) !== -1 && !e.isComplexEnabled || P4.indexOf(n) === -1 && (t[n] = rt[n])
        }
        return e.trigAngleMultiplier && (t.trigAngleMultiplier = e.trigAngleMultiplier),
        e.globalRandomSeed && (t.globalRandomSeed = e.globalRandomSeed),
        e.initialEvaluation && (t.initialEvaluation = e.initialEvaluation),
        e.globalEventCount && (t.globalEventCount = e.globalEventCount),
        e.width && (t.width = e.width),
        e.height && (t.height = e.height),
        e.isComplexEnabled && (t[Gr] = new Za),
        t
    }
    var H_ = {};
    cu(H_, {
        getFrame: () => M4
    });
    var A2 = ["pi", "e", "trigAngleMultiplier"]
      , w2 = ["sqrt", "nthroot", "abs", "ln", "sin", "cos", "tan", "log", "arcsin", "arccos", "arctan", "mean", "round", "stdev", "stdevp", "nCr", "nPr", "exp", "factorial"]
      , C4 = ["complexMultiplyPoints", "complex", "complexDivide", "coerceComplexToReal", "coerceComplexToRealWithTolerance", "coerceRealToComplex", "complexSqrt"]
      , v4 = Object.keys(Zf);
    function L2(e, t) {
        for (let n of e)
            if (!t.hasOwnProperty(n))
                throw new Error("Programming Error: key '" + n + `' does not exist in table. Must be one of:
` + Object.keys(t).join(`
`))
    }
    L2(A2, rt);
    L2(w2, rt);
    function M4(e) {
        let t = {};
        return A2.forEach(n => {
            t[n] = rt[n]
        }
        ),
        w2.forEach(n => {
            e.replaceRoundWithReciprocal && n === "round" || (t[n] = rt[n])
        }
        ),
        e.trigAngleMultiplier && (t.trigAngleMultiplier = e.trigAngleMultiplier),
        e.isComplexEnabled && (v4.forEach(n => t[n] = rt[n]),
        C4.forEach(n => t[n] = rt[n]),
        t[Gr] = new Za),
        e.width && (t.width = e.width),
        e.height && (t.height = e.height),
        t
    }
    var U_ = {};
    cu(U_, {
        getFrame: () => D4
    });
    var F2 = ["pi", "e", "trigAngleMultiplier"]
      , V2 = ["sqrt", "nthroot", "abs", "ln", "sin", "cos", "tan", "log", "arcsin", "arccos", "arctan", "exp", "factorial"];
    function B2(e, t) {
        for (let n = 0; n < e.length; n++) {
            let r = e[n];
            if (!t.hasOwnProperty(r))
                throw new Error("Programming Error: key '" + r + `' does not exist in table. Must be one of:
` + Object.keys(t).join(`
`))
        }
    }
    B2(F2, rt);
    B2(V2, rt);
    function D4(e) {
        let t = {};
        return F2.forEach(n => {
            t[n] = rt[n]
        }
        ),
        V2.forEach(n => {
            t[n] = rt[n]
        }
        ),
        e.trigAngleMultiplier && (t.trigAngleMultiplier = e.trigAngleMultiplier),
        e.width && (t.width = e.width),
        e.height && (t.height = e.height),
        t
    }
    var Ng = class {
        constructor(t) {
            this.singleExpression = t.singleExpression,
            this.complexEnabled = !!t.isComplexEnabled
        }
        isGeometryEnabled() {
            return !1
        }
        is3dProduct() {
            return !1
        }
        is3dPolicy() {
            return !1
        }
        isComplexEnabled() {
            return this.complexEnabled
        }
        isRecursionEnabled() {
            return !1
        }
        polygonUnsupportedPreferTriangle() {
            return !1
        }
        areAllScalesLinear() {
            return !0
        }
        assignmentForbidden(t) {
            return this.singleExpression ? t.slice(0, 3) !== "ans" : t.slice(0, 3) === "tmp"
        }
        isValidSlider(t) {
            return !1
        }
        sliderVariables() {
            return []
        }
        graphingEnabled() {
            return !1
        }
        ansEnabled() {
            return !this.singleExpression
        }
        dimensionVarsEnabled() {
            return !1
        }
        disabledFeatures() {
            return this.singleExpression ? ["Sum", "Product", "Integral", "Derivative", "Piecewise", "Substitution", "PercentOf"] : ["Sum", "Product", "Integral", "Derivative", "Piecewise", "Substitution"]
        }
        shouldIncludeFunctionParametersInRandomSeed() {
            return !0
        }
    }
    ;
    var {Constant: tf, Seed: G2} = O
      , _4 = {
        fourFunction: fI,
        singleExpressionFourFunction: fI,
        scientific: H_,
        singleExpressionScientific: U_,
        graphing: Rg,
        graphing_3d: Rg,
        geometry: Rg
    };
    function R4({evaluationMode: e, is3dProduct: t, isBeta3d: n, isComplexEnabled: r, scales: o, includeFunctionParametersInRandomSeed: i, customRegressions: s, isRecursionEnabled: a}) {
        switch (e) {
        case "fourFunction":
            return new dp({
                singleExpression: !1
            });
        case "singleExpressionFourFunction":
            return new dp({
                singleExpression: !0
            });
        case "scientific":
            return new Ng({
                singleExpression: !1,
                isComplexEnabled: r
            });
        case "singleExpressionScientific":
            return new Ng({
                singleExpression: !0,
                isComplexEnabled: r
            });
        case "graphing":
            return new kd({
                enableGeometry: !1,
                enable3d: t,
                scales: o,
                isComplexEnabled: r,
                includeFunctionParametersInRandomSeed: i,
                customRegressions: s,
                isRecursionEnabled: a
            });
        case "geometry":
            return new kd({
                enableGeometry: !0,
                enable3d: !1,
                scales: o,
                includeFunctionParametersInRandomSeed: i,
                isComplexEnabled: r,
                customRegressions: s,
                isRecursionEnabled: a
            });
        case "graphing_3d":
            return new CT({
                beta3d: n,
                includeFunctionParametersInRandomSeed: i,
                isComplexEnabled: r,
                customRegressions: s,
                isRecursionEnabled: a
            })
        }
    }
    var gI = class {
        constructor() {
            this.policyContexts = new Map;
            this.moduleToRootModule = new Map;
            this.parentFrameMap = new Map
        }
        getOrCreatePolicyContext(t) {
            let n = this.policyContexts.get(t);
            return n || (n = new k_,
            this.policyContexts.set(t, n)),
            n
        }
        setRootModule(t, n) {
            this.moduleToRootModule.set(t, n)
        }
        updateParentFrameMap(t) {
            this.parentFrameMap = this.buildParentFrameMap(t)
        }
        buildParentFrameMap(t) {
            let n = new Map;
            for (let r of this.rootModules())
                n.set(r, nl(r));
            for (let[r,o] of this.policyContexts)
                o.globParentId && n.set(nl(r), o.globParentId);
            for (let[r,o] of this.moduleToRootModule)
                n.set(r, o);
            for (let {id: r, moduleID: o, statement: i} of t.values())
                i instanceof Gu && n.set(r, o);
            return n
        }
        isRootModule(t) {
            return this.policyContexts.has(t)
        }
        rootModules() {
            return new Set(this.policyContexts.keys())
        }
        *policyContextEntries() {
            yield*this.policyContexts
        }
        getPolicyContextForFrame(t) {
            let n = hA(t);
            for (n && (t = n); ; ) {
                let r = this.policyContexts.get(t);
                if (r)
                    return r;
                let o = this.parentFrameMap.get(t);
                if (!o)
                    throw F(`Frame '${t}' does not have a policy specified`);
                t = o
            }
        }
        getPolicyContext(t) {
            return this.getPolicyContextForFrame(t)
        }
        getAllContexts() {
            return this.policyContexts.values()
        }
        deleteModule(t) {
            this.moduleToRootModule.delete(t),
            this.policyContexts.delete(t);
            for (let[n,r] of this.moduleToRootModule)
                r === t && this.moduleToRootModule.delete(n)
        }
    }
      , k_ = class {
        constructor() {
            this.use_degrees = !1;
            this.initialEvaluation = !1;
            this.evaluationMode = "graphing";
            this.product = "graphing";
            this.beta3d = !1;
            this.restrictedFunctions = !1;
            this.forceEnableGeometryFunctions = !1;
            this.functionDefinition = !0;
            this.replaceRoundWithReciprocal = !1;
            this.distributions = !0;
            this.actions = !0;
            this.substitutions = !0;
            this.intervalComprehensions = !0;
            this.recursion = !0;
            this.dimensions = {
                width: 0,
                height: 0
            };
            this.includeFunctionParametersInRandomSeed = !0;
            this.complex = !1;
            this.customRegressions = !0;
            this.globParentId = void 0;
            this.setPolicy(),
            this.setParentFrame()
        }
        getPolicyFrame(t) {
            return t ? this.getRegressionPolicyFrame() : this.policy_frame
        }
        getRegressionPolicyFrame() {
            if (!this.regressionPolicyFrame) {
                this.regressionPolicyFrame = {};
                for (let[t,n] of Object.entries(this.policy_frame))
                    this.regressionPolicyFrame[t] = n
            }
            return this.regressionPolicyFrame
        }
        markRegressionPolicyFrameDirty() {
            this.regressionPolicyFrame = void 0
        }
        setPolicy() {
            let t = this.viewState ? {
                xAxisScale: this.viewState.xAxisScale,
                yAxisScale: this.viewState.yAxisScale
            } : void 0;
            this.policy = R4({
                evaluationMode: this.evaluationMode,
                is3dProduct: this.product === "graphing-3d",
                isBeta3d: this.beta3d,
                isComplexEnabled: this.complex,
                scales: t,
                includeFunctionParametersInRandomSeed: this.includeFunctionParametersInRandomSeed,
                customRegressions: this.customRegressions,
                isRecursionEnabled: this.recursion
            }),
            this.policy.globParentId = this.globParentId
        }
        setParentFrame() {
            this.policy_frame = _4[this.evaluationMode].getFrame({
                restrictedFunctions: this.restrictedFunctions,
                forceEnableGeometryFunctions: this.forceEnableGeometryFunctions,
                isGeometryCalculator: this.evaluationMode === "geometry",
                is3DCalculator: this.product === "graphing-3d",
                isComplexEnabled: this.complex,
                replaceRoundWithReciprocal: this.replaceRoundWithReciprocal,
                distributions: this.distributions,
                additionalFunctions: this.additionalFunctions,
                disableParentheses: this.disableParentheses,
                trigAngleMultiplier: new tf(this.use_degrees ? Math.PI / 180 : be(1, 1)),
                initialEvaluation: new tf(this.initialEvaluation ? 1 : 0),
                globalEventCount: new tf(0),
                globalRandomSeed: new G2(this.globalRandomSeedString || ""),
                width: this.policy.dimensionVarsEnabled() ? new tf(be(this.dimensions.width, 1)) : Ob("width"),
                height: this.policy.dimensionVarsEnabled() ? new tf(be(this.dimensions.height, 1)) : Ob("height")
            }),
            this.policy_frame.construction = this.constructionNode,
            this.markRegressionPolicyFrameDirty()
        }
        markConstruction(t) {
            this.policy_frame.construction = t,
            this.constructionNode = t,
            this.markRegressionPolicyFrameDirty()
        }
        getParseOptions(t) {
            return {
                index: this.policy.ansEnabled() ? t.index : void 0,
                disabledFeatures: this.getDisabledFeatures(),
                disallowFrac: this.areFractionsDisallowed(),
                disableParentheses: !!this.disableParentheses,
                allowIntervalComprehensions: !!this.intervalComprehensions,
                seedPrefix: Mn(t.id),
                writeIntegral: this.evaluationMode === "geometry",
                specializeDoubleInequalities: !this.policy.is3dProduct(),
                includeFunctionParametersInRandomSeed: this.includeFunctionParametersInRandomSeed
            }
        }
        getViewState() {
            return this.viewState
        }
        setWorkerConfigProperty(t, n) {
            return n === ps[t] ? !1 : (ps[t] = n,
            !0)
        }
        processEvaluatorConfig(t) {
            let n = !!t.isCompleteState && !t.isUndoRedoState;
            n !== this.initialEvaluation && (this.initialEvaluation = n,
            this.policy_frame.initialEvaluation = new tf(n ? 1 : 0),
            this.markRegressionPolicyFrameDirty()),
            t.hasOwnProperty("logInternalErrors") && RS(t.logInternalErrors);
            let r = !1
              , o = !1;
            if (t.viewState && !$o(t.viewState, this.viewState)) {
                let s = t.viewState
                  , a = !!(this.viewState && s.xAxisScale === this.viewState.xAxisScale && s.yAxisScale === this.viewState.yAxisScale);
                this.viewState = s,
                a ? r = !0 : o = !0
            }
            if (t.hasOwnProperty("degreeMode") && (this.use_degrees = t.degreeMode,
            o = !0),
            t.hasOwnProperty("globalRandomSeed")) {
                let s = t.globalRandomSeed;
                this.globalRandomSeedString = s,
                this.policy_frame.globalRandomSeed = new G2(s),
                this.markRegressionPolicyFrameDirty()
            }
            if (t.hasOwnProperty("includeFunctionParametersInRandomSeed") && (this.includeFunctionParametersInRandomSeed = t.includeFunctionParametersInRandomSeed,
            this.setPolicy()),
            t.hasOwnProperty("evaluationMode") && (this.evaluationMode = t.evaluationMode,
            o = !0),
            t.hasOwnProperty("additionalFunctions") && (this.additionalFunctions = t.additionalFunctions,
            o = !0),
            t.hasOwnProperty("disableParentheses") && (this.disableParentheses = t.disableParentheses,
            o = !0),
            t.hasOwnProperty("restrictedFunctions") && (this.restrictedFunctions = t.restrictedFunctions,
            o = !0),
            t.hasOwnProperty("forceEnableGeometryFunctions") && (this.forceEnableGeometryFunctions = t.forceEnableGeometryFunctions,
            o = !0),
            t.hasOwnProperty("distributions") && (this.distributions = t.distributions,
            o = !0),
            t.hasOwnProperty("functionDefinition") && (this.functionDefinition = t.functionDefinition,
            o = !0),
            t.hasOwnProperty("replaceRoundWithReciprocal") && (this.replaceRoundWithReciprocal = t.replaceRoundWithReciprocal,
            o = !0),
            t.hasOwnProperty("pointsOfInterest")) {
                let s = this.setWorkerConfigProperty("pointsOfInterest", t.pointsOfInterest);
                o = o || s
            }
            if (t.hasOwnProperty("plotSingleVariableImplicitEquations")) {
                let s = this.setWorkerConfigProperty("plotSingleVariableImplicitEquations", t.plotSingleVariableImplicitEquations);
                o = o || s
            }
            if (t.hasOwnProperty("plotImplicits")) {
                let s = this.setWorkerConfigProperty("plotImplicits", t.plotImplicits);
                o = o || s
            }
            if (t.hasOwnProperty("plotInequalities")) {
                let s = this.setWorkerConfigProperty("plotInequalities", t.plotInequalities);
                o = o || s
            }
            if (t.hasOwnProperty("sliders")) {
                let s = this.setWorkerConfigProperty("sliders", t.sliders);
                o = o || s
            }
            t.hasOwnProperty("actions") && t.actions !== this.actions && (this.actions = !!t.actions,
            o = !0),
            t.hasOwnProperty("substitutions") && t.substitutions !== this.substitutions && (this.substitutions = !!t.substitutions,
            o = !0),
            t.hasOwnProperty("intervalComprehensions") && t.intervalComprehensions !== this.intervalComprehensions && (this.intervalComprehensions = !!t.intervalComprehensions,
            o = !0),
            t.hasOwnProperty("recursion") && t.recursion !== this.recursion && (this.recursion = !!t.recursion,
            o = !0);
            let i = t.recursionDepthLimit;
            return i !== void 0 && i > 0 && i <= 10 ** 6 && WP(i),
            t.hasOwnProperty("beta3d") && (this.beta3d = !!t.beta3d,
            o = !0),
            t.hasOwnProperty("product") && (this.product = t.product,
            o = !0),
            t.hasOwnProperty("dimensions") && t.dimensions !== void 0 && (this.dimensions = t.dimensions,
            o = !0),
            t.hasOwnProperty("complex") && t.complex !== this.complex && (this.complex = !!t.complex,
            o = !0),
            t.hasOwnProperty("customRegressions") && t.customRegressions !== this.customRegressions && (this.customRegressions = !!t.customRegressions,
            o = !0),
            t.hasOwnProperty("globParentId") && t.globParentId !== this.globParentId && (this.globParentId = t.globParentId ? t.globParentId : void 0,
            o = !0),
            o && (this.setPolicy(),
            this.setParentFrame()),
            {
                invalidateGraphs: r,
                invalidateAll: o
            }
        }
        updateEvaluatedViewport(t) {
            this.viewState && (this.viewState.viewport = t)
        }
        getDisabledFeatures() {
            let t = this.policy.disabledFeatures();
            this.functionDefinition === !1 && (t = t.concat("FunctionDefinition")),
            this.actions === !1 && (t = t.concat("UpdateRule")),
            this.substitutions === !1 && (t = t.concat(["Substitution", "ListComprehension"]));
            let n = this.additionalFunctions || [];
            return t = t.filter(r => !(r === "Exponent" && n.indexOf("exponent") !== -1 || r === "PercentOf" && n.indexOf("percent") !== -1)),
            t
        }
        areFractionsDisallowed() {
            let {evaluationMode: t} = this;
            return t !== "fourFunction" && t !== "singleExpressionFourFunction" ? !1 : !this.additionalFunctions || this.additionalFunctions.indexOf("fraction") === -1
        }
    }
    ;
    $r();
    function Jp(e, t, n=!1) {
        if (/^\s*(\-|\+)?([0-9]+(\.[0-9]+)?)\s*$/.test(e))
            return parseFloat(e);
        let o = {
            coerceToNumber: "all"
        }
          , i = Fn(rt);
        return i.trigAngleMultiplier = new Vn(t ? Math.PI / 180 : 1),
        +qo(Wa, mi(e), n ? OG : JT, i, o).asValue()
    }
    var $_ = 10
      , Y_ = 3;
    function hI(e, t) {
        return e + 1e-8 * (t - e) > e && t - e > 1e-300 && t - e < 1e300
    }
    function q2(e, t) {
        return e > 1e-300 && hI(e, t)
    }
    var bI = class e {
        constructor(t, n, r, o, i, s) {
            this.xmin = t,
            this.xmax = n,
            this.ymin = r,
            this.ymax = o,
            this.zmin = i,
            this.zmax = s
        }
        static evaluateFromLatex(t, n, r) {
            var i, s;
            let o = e.evaluateFromLatexPartial(t, n, r);
            if (!(isNaN(o.xmin) || isNaN(o.xmax) || isNaN(o.ymin) || isNaN(o.ymax) || t.zmin !== void 0 && isNaN((i = o.zmin) != null ? i : NaN) || t.zmax !== void 0 && isNaN((s = o.zmax) != null ? s : NaN)))
                return e.fromObject(o)
        }
        static evaluateFromLatexPartial(t, n, r) {
            return e.fromObject({
                xmin: Jp(t.xmin, n, r),
                xmax: Jp(t.xmax, n, r),
                ymin: Jp(t.ymin, n, r),
                ymax: Jp(t.ymax, n, r),
                zmin: t.zmin ? Jp(t.zmin, n, r) : void 0,
                zmax: t.zmax ? Jp(t.zmax, n, r) : void 0
            })
        }
        static fromObject({xmin: t, xmax: n, ymin: r, ymax: o, zmin: i, zmax: s}) {
            return new e(t,n,r,o,i,s)
        }
        toObject() {
            return {
                xmin: this.xmin,
                ymin: this.ymin,
                zmin: this.zmin,
                xmax: this.xmax,
                ymax: this.ymax,
                zmax: this.zmax
            }
        }
        equals(t) {
            return !(this.xmin !== t.xmin || this.ymin !== t.ymin || this.zmin !== t.zmin || this.xmax !== t.xmax || this.ymax !== t.ymax || this.zmax !== t.zmax)
        }
        isXValid(t) {
            return t === "linear" ? hI(this.xmin, this.xmax) : q2(this.xmin, this.xmax)
        }
        isYValid(t) {
            return t === "linear" ? hI(this.ymin, this.ymax) : q2(this.ymin, this.ymax)
        }
        isZValid() {
            return this.zmin === void 0 || this.zmax === void 0 ? !1 : hI(this.zmin, this.zmax)
        }
        isValid(t) {
            return this.isXValid(t.xAxisScale) && this.isYValid(t.yAxisScale)
        }
        isSquare(t, n) {
            return Math.abs(t.height - t.width * this.aspectRatio(n)) < 1
        }
        isSquare3D() {
            let {xmin: t, xmax: n, ymin: r, ymax: o, zmin: i, zmax: s} = this;
            if (i === void 0 || s === void 0)
                return !1;
            let a = [n - t, o - r, s - i];
            return Math.min(...a) / Math.max(...a) > .99999
        }
        aspectRatio(t) {
            let n = $_ / Y_
              , r = t.yAxisScale === "linear" ? this.ymax - this.ymin : Math.log10(this.ymax / this.ymin) * n
              , o = t.xAxisScale === "linear" ? this.xmax - this.xmin : Math.log10(this.xmax / this.xmin) * n;
            return r / o
        }
        getSquaredAxisLimits({axis: t, screen: n, settings: r}) {
            let[o,i,s,a,u] = t === "y" ? [{
                min: this.ymin,
                max: this.ymax
            }, {
                min: this.xmin,
                max: this.xmax
            }, n.height / n.width, r.yAxisScale, r.xAxisScale] : [{
                min: this.xmin,
                max: this.xmax
            }, {
                min: this.ymin,
                max: this.ymax
            }, n.width / n.height, r.xAxisScale, r.yAxisScale];
            if (a === "logarithmic") {
                let l = u === "logarithmic" ? Math.log(i.max) - Math.log(i.min) : (i.max - i.min) * Y_ / ($_ * Math.LOG10E)
                  , {min: p, max: m} = z2({
                    min: Math.log(o.min),
                    max: Math.log(o.max)
                }, s * l);
                return {
                    min: Math.exp(p),
                    max: Math.exp(m)
                }
            }
            let c = u === "logarithmic" ? (Math.log10(i.max) - Math.log10(i.min)) * $_ / Y_ : i.max - i.min;
            return z2(o, c * s)
        }
        squareXAxis(t, n) {
            let {min: r, max: o} = this.getSquaredAxisLimits({
                axis: "x",
                screen: t,
                settings: n
            })
              , i = new e(r,o,this.ymin,this.ymax);
            return i.isXValid(n.xAxisScale) ? i : this
        }
        squareYAxis(t, n) {
            let {min: r, max: o} = this.getSquaredAxisLimits({
                axis: "y",
                screen: t,
                settings: n
            })
              , i = new e(this.xmin,this.xmax,r,o);
            return i.isYValid(n.yAxisScale) ? i : this
        }
        squareCrop(t, n) {
            return this.aspectRatio({
                xAxisScale: n.xAxisScale,
                yAxisScale: n.yAxisScale
            }) > t.height / t.width ? this.squareYAxis(t, n) : this.squareXAxis(t, n)
        }
        polarDiameter() {
            let t = Math.abs(this.xmax)
              , n = Math.abs(this.xmin)
              , r = Math.abs(this.ymax)
              , o = Math.abs(this.ymin);
            return 1.5 * Math.max(t, n, r, o)
        }
        largestR() {
            return Math.sqrt(Math.pow(Math.max(-this.xmin, this.xmax), 2) + Math.pow(Math.max(-this.ymin, this.ymax), 2))
        }
        smallestR() {
            return this.xmin <= 0 && this.xmax >= 0 && this.ymin <= 0 && this.ymax >= 0 ? 0 : this.xmin <= 0 && this.xmax >= 0 ? Math.min(Math.abs(this.ymin), Math.abs(this.ymax)) : this.ymin <= 0 && this.ymax >= 0 ? Math.min(Math.abs(this.xmin), Math.abs(this.xmax)) : Math.sqrt(Math.pow(Math.max(this.xmin, -this.xmax), 2) + Math.pow(Math.max(this.ymin, -this.ymax), 2))
        }
    }
    ;
    function z2(e, t) {
        let n = .5 * (e.min + e.max)
          , [r,o] = [n - .5 * t, n + .5 * t];
        return Math.abs((o - r) / t - 1) > .1 ? {
            min: -.5 * t,
            max: .5 * t
        } : {
            min: r,
            max: o
        }
    }
    $r();
    function tr(e) {
        let {value: t, valueType: n} = e;
        if (aM(e)) {
            let r = [];
            for (let o = 0; o < e.value.length; o++)
                r.push(tr(vA(e, o)));
            return `\\left[${r.join(",")}\\right]`
        }
        switch (n) {
        case b:
            return ia(t);
        case N:
            let[r,o] = t
              , i = ia(r)
              , s = ia(Math.abs(o));
            return i === "\\frac{0}{0}" || s === "\\frac{0}{0}" ? "\\frac{0}{0}i" : i !== "0" ? `${i}${o >= 0 ? "+" : "-"}${s !== "1" ? `${s}` : ""}i` : `${o >= 0 ? "" : "-"}${s !== "1" ? `${s}` : ""}i`;
        case R:
            {
                let[l,p] = t;
                return `\\left(${ia(l)},${ia(p)}\\right)`
            }
        case G:
            {
                let[l,p,m] = t;
                return `\\left(${ia(l)},${ia(p)},${ia(m)}\\right)`
            }
        case bn:
            return "\\operatorname{rgb}\\left(" + [tr({
                valueType: b,
                value: t[0]
            }), tr({
                valueType: b,
                value: t[1]
            }), tr({
                valueType: b,
                value: t[2]
            })].join(",") + "\\right)";
        case De:
            {
                let l = [];
                for (let p of t)
                    l.push(tr({
                        valueType: R,
                        value: p
                    }));
                return "\\operatorname{polygon}\\left(" + l.join(",") + "\\right)"
            }
        case Ee:
            return "\\operatorname{segment}\\left(" + [tr({
                valueType: R,
                value: t[0]
            }), tr({
                valueType: R,
                value: t[1]
            })].join(",") + "\\right)";
        case Ce:
            return "\\operatorname{line}\\left(" + [tr({
                valueType: R,
                value: t[0]
            }), tr({
                valueType: R,
                value: t[1]
            })].join(",") + "\\right)";
        case Ae:
            return "\\operatorname{ray}\\left(" + [tr({
                valueType: R,
                value: t[0]
            }), tr({
                valueType: R,
                value: t[1]
            })].join(",") + "\\right)";
        case Ie:
            let a = t[0]
              , u = t[1]
              , c = [u[0] + a[0], u[1] + a[1]];
            return `\\operatorname{vector}\\left(${tr({
                valueType: R,
                value: u
            })},${tr({
                valueType: R,
                value: c
            })}\\right)`;
        case he:
            return "\\operatorname{circle}\\left(" + [tr({
                valueType: R,
                value: t[0]
            }), tr({
                valueType: b,
                value: t[1]
            })].join(",") + "\\right)";
        case ce:
            return "\\operatorname{arc}\\left(" + [tr({
                valueType: R,
                value: t[0]
            }), tr({
                valueType: R,
                value: t[1]
            }), tr({
                valueType: R,
                value: t[2]
            })].join(",") + "\\right)";
        case Oe:
            return "\\operatorname{angle}\\left(" + [tr({
                valueType: R,
                value: t[0]
            }), tr({
                valueType: b,
                value: t[1]
            }), tr({
                valueType: b,
                value: t[2]
            })].join(",") + "\\right)";
        case Se:
            return "\\operatorname{directedangle}\\left(" + [tr({
                valueType: R,
                value: t[0]
            }), tr({
                valueType: b,
                value: t[1]
            }), tr({
                valueType: b,
                value: t[2]
            })].join(",") + "\\right)";
        case cr:
            return `\\operatorname{tone}\\left(${tr({
                valueType: b,
                value: t[0]
            })},${tr({
                valueType: b,
                value: t[1]
            })}\\right)`;
        default:
            throw new Error("Cannot serialize a value of type " + se(n) + ".")
        }
    }
    function Z_(e) {
        let t = {};
        for (let n of ue(e.updateRules))
            t[n] = X_(e, n);
        return t
    }
    function X_(e, t) {
        return `${go(t)}=${tr(e.updateRules[t])}`
    }
    function N4(e) {
        return e.type !== "List" ? !1 : e.args.every(t => Yb(t))
    }
    function O4(e) {
        return e.type !== "List" ? !1 : e.args.every(t => Yb(t) || vg(t))
    }
    function A4(e) {
        return e.type !== "List" ? !1 : e.args.length === 0
    }
    var w4 = [b, R, zt, G, to, He, Y, N, ke, bn, Ao];
    function xI(e, t, n) {
        if (t.type === "FunctionDefinition" || t.type === "RecursiveFunctionBaseCase" || t.type === "Equation" || t.type === "ComparatorChain" || !Ru(e, w4))
            return !1;
        let r = t instanceof Ln;
        switch (e !== b && r && (t = t instanceof Ln ? t._expression : t),
        e) {
        case He:
            return !A4(t);
        case b:
            return t.type !== "Constant" && t.type !== "MixedNumber";
        case Y:
            return !N4(t);
        case N:
            return !vg(t);
        case ke:
            return !O4(t);
        case R:
        case G:
            return !H2(t);
        case zt:
        case to:
            return !L4(t);
        case bn:
        case Ao:
            return r;
        default:
            return !1
        }
    }
    function H2(e) {
        return e.type === "ParenSeq" && e.args.every(t => Wm(t))
    }
    function L4(e) {
        return e.type !== "List" ? !1 : e.args.every(t => H2(t))
    }
    function F4(e) {
        return e.type === "Error" ? e.getError() : e.valueType === N ? e.asValue() : +e.asValue()
    }
    function V4(e, t, n, r) {
        let o = []
          , i = !1;
        for (let s = 0; s < n.columns.length; s++) {
            let a = r.columns[s]
              , u = n.columns[s]
              , c = a.type === "Error" ? [] : a.rawArgs.map(F4)
              , l = To(a) ? a.isCyclicDependencyError && bc(u) && u.isFreeVariable(t) : Bu(a) && a.isIndependent
              , p = s >= 1 && r.columns[0].type !== "Error" && a.type !== "Error" && !u.header.userData.hidden;
            p && (i = !0);
            let m = {
                computed: !l,
                values: c,
                plotted: p
            };
            a.type === "Error" && (m.error = a.getError()),
            o.push(m)
        }
        return o[0].plotted = i,
        {
            column_data: o
        }
    }
    function B4(e, t, n) {
        let r = {
            variables: [],
            errorMap: {},
            dimensions: {}
        };
        if (e.areAllScalesLinear() || (r.errorMap.scale = !0),
        n.center.isError && (r.errorMap.center = !0),
        n.radianAngle.isError && (r.errorMap.angle = !0),
        n.width.isError && (r.errorMap.width = !0),
        n.height.isError && (r.errorMap.height = !0),
        n.opacity.isError && (r.errorMap.opacity = !0),
        Object.keys(r.errorMap).length > 0)
            return r.variables = t.getSliderVariables(e, n),
            r;
        r.dimensions.x = [],
        r.dimensions.y = [],
        r.dimensions.radianAngle = [],
        r.dimensions.width = [],
        r.dimensions.height = [],
        r.dimensions.opacity = [];
        let o = [n.center, n.radianAngle, n.width, n.height, n.opacity];
        return o.some(s => s && s.valueType && X(s.valueType)) && (r.is_concrete_list = !0),
        O.List.eachArgs(o, s => {
            let a = s[0].asValue()
              , u = +s[1].asValue()
              , c = Math.atan2(Math.sin(u), Math.cos(u));
            r.dimensions.x.push(+a[0]),
            r.dimensions.y.push(+a[1]),
            r.dimensions.radianAngle.push(c),
            r.dimensions.width.push(+s[2].asValue()),
            r.dimensions.height.push(+s[3].asValue()),
            r.dimensions.opacity.push(Math.max(0, Math.min(1, +s[4].asValue())))
        }
        ),
        (e.graphingEnabled() ? t.getGraphMode(e, n) : 10) !== 10 && (r.is_graphable = !0),
        n.moveStrategy && (r.move_strategy = n.moveStrategy),
        t.center && (t.center.type === "Identifier" ? (r.center_reference_id = t.center.referencedStatementId,
        r.center_reference_symbol = t.center._symbol) : t.center.type === "ParenSeq" && n.center.valueType === R && (r.center_is_point_literal = !0)),
        r
    }
    function G4(e, t, n) {
        let r = n.handler
          , o = n.minStep
          , i = {}
          , s = {};
        for (let p of r.getDependencies())
            e.validActionVariable(p) || (i[p] = !0);
        for (let p of o.getDependencies())
            s[p] = !0;
        let a;
        if (To(o))
            a = {
                status: "error",
                error: o.getError()
            };
        else {
            let p = o.asValue();
            typeof p == "number" && !isNaN(p) && p >= 0 ? a = {
                status: "valid",
                value: p
            } : a = {
                status: "error",
                error: AC().getError()
            }
        }
        let u = Object.keys(i);
        u.length > 0 && (r = xn(u).setDependencies(r.getDependencies()));
        let c;
        r.type === "Error" && !W_(e, r) ? c = {
            status: "error",
            error: r.getError()
        } : r.isEmptyAction ? c = {
            status: "empty"
        } : c = {
            status: "maybe-valid"
        };
        let l = {
            handler: c,
            minStep: a,
            variables: []
        };
        return Nc(l, e, {
            ...i,
            ...s
        }),
        l
    }
    function q4(e, t, n) {
        let r = e.is3dPolicy() ? {
            xmin: NaN,
            xmax: NaN,
            ymin: NaN,
            ymax: NaN,
            zmin: NaN,
            zmax: NaN
        } : {
            xmin: NaN,
            xmax: NaN,
            ymin: NaN,
            ymax: NaN
        }
          , o = {};
        for (let y in n.bounds) {
            let g = y
              , f = n.bounds[g];
            if (!f)
                continue;
            let h = Rr(f);
            f.type === "Error" ? o[g] = !0 : (h == null ? void 0 : h.valueType) === b ? r[g] = h.value : o[g] = !0
        }
        let {xAxisScale: i, yAxisScale: s} = e.getScales()
          , {xmin: a, xmax: u, ymin: c, ymax: l, zmin: p, zmax: m} = r
          , d = new bI(a,u,c,l,p,m);
        return isFinite(u) && !isFinite(a) ? o.xmin = !0 : isFinite(a) && !isFinite(u) ? o.xmax = !0 : d.isXValid(i) || (o.xmin = o.xmax = !0),
        isFinite(l) && !isFinite(c) ? o.ymin = !0 : isFinite(c) && !isFinite(l) ? o.ymax = !0 : d.isYValid(s) || (o.ymin = o.ymax = !0),
        e.is3dPolicy() && (isFinite(m) && !isFinite(p) ? o.zmin = !0 : isFinite(p) && !isFinite(m) ? o.zmax = !0 : d.isZValid() || (o.zmin = o.zmax = !0)),
        Object.keys(o).length > 0 ? {
            viewport: {
                status: "error",
                errors: o,
                value: r
            }
        } : {
            viewport: {
                status: "valid",
                value: r
            }
        }
    }
    function z4() {
        return {
            operator: "=",
            variables: []
        }
    }
    function k2(e, t, n, r) {
        var a;
        if (Vu(n))
            return V4(e, t, n, r);
        if ($b(n))
            return B4(e, n, r);
        let o = z4();
        if (o.evaluated_latex = n.userData.latex,
        (a = n.userData.latex) != null && a.startsWith("\\operatorname{export}") && (n._exports.length !== 1 && (r = xy()),
        n.type === "FunctionDefinition" && (r = F("Export functions not yet implemented"))),
        n instanceof O.Ticker)
            return e.graphingEnabled() ? G4(e, n, r) : (o.error = F("Ticker without graphing").getError(),
            o);
        if (n instanceof O.Viewport)
            return e.graphingEnabled() ? q4(e, n, r) : (o.error = F("Viewport without graphing").getError(),
            o);
        if (e.is3dProduct()) {
            let u = e
              , c = n.getGraphMode(u, r);
            if ((c === 100 || c === 5) && r.getDependencies().length === 1) {
                let l = r.getDependencies()[0];
                (l === "u" || l === "v" || l === "t") && (o.internal_domain_dependency = l)
            }
        }
        let i = Tg(n.userData);
        if (i) {
            let u = r.getCursorContext();
            if (u)
                o.cursor_context = {
                    ...u,
                    selection: i
                };
            else if (To(r)) {
                let c = U4(e, t, n);
                c && (o.cursor_context = {
                    ...c,
                    selection: i
                })
            }
        }
        if ((n instanceof O.FunctionDefinition || n instanceof Ln || n instanceof O.RecursiveFunctionBaseCase) && (n._symbol.startsWith("_") || (o.defined_name = n._symbol)),
        n instanceof _r && r instanceof An ? o.recursion = r.getRecursiveFunctionMetadata() : n instanceof _r && r instanceof v && r.recursionMetadata && (o.recursion = r.recursionMetadata),
        n instanceof xo && (o.recursion_base_case = {
            symbol: n._symbol,
            argValue: n.specifiedArg.valid ? n.specifiedArg.argValue : void 0
        }),
        r.warning !== void 0 && (o.warning = r.warning),
        o.top_level_function_spec = jp(n, e, t),
        r.type === "Error" && !((n instanceof O.FunctionDefinition || n instanceof O.RecursiveFunctionBaseCase) && !r.blocksExport) && !r.silent) {
            o.error = r.getError(),
            o.variables = n.getSliderVariables(e, r),
            o.is_single_identifier = n instanceof ze,
            r.actionValue && (o.action_value = Z_(r.actionValue));
            let u = U2(e, t, n, r);
            return u && (o.geometry = u),
            o
        }
        if (r.valueType === bn && r.getDependencies().length === 0) {
            let u = r.asValue();
            o.rgb_value = Wl(u[0], u[1], u[2]).formatHex()
        }
        r.valueType === pt && r.getDependencies().length === 0 && (o.action_value = Z_(r.asValue())),
        r.moveStrategy && (o.move_strategy = r.moveStrategy,
        o.default_drag_mode = r.defaultDragMode),
        n.isInequality() && (o.is_inequality = !0),
        o.operator = n.getOperator(),
        r instanceof O.SolvedEquation ? r._expression.asValue() !== !0 && r._expression.asValue() !== !1 && (o.assignment = r._symbol) : n instanceof Ln && (n._symbol.startsWith("_") || (o.assignment = n._symbol)),
        n instanceof O.FunctionDefinition && (o.function_definition = n._symbol);
        let s = e.graphingEnabled() ? n.getGraphMode(e, r) : 10;
        if (e.graphingEnabled() && e.is3dPolicy() && (!Zu(s) && !sF(s) && (s = 10),
        r instanceof O.OptimizedRegression && (s = 10)),
        s !== 10 && (o.is_graphable = !0,
        o.expression_type = n.getExpressionType(s, r.valueType),
        e.is3dPolicy() && (o.expression_type === A.SINGLE_POINT ? o.expression_type = A.POINT3D : o.expression_type === A.POINT_LIST && (o.expression_type = A.POINT3D_LIST)),
        r.valueType && wa(r.valueType) && (o.map_type = r.valueType),
        r.isShadeBetween() && (o.is_shade_between = !0),
        o.expression_type !== A.POINT3D && o.expression_type !== A.POINT3D_LIST)) {
            let u = n.tableInfo(e, r);
            u && (o.is_tableable = !0,
            o.table_info = u)
        }
        if (r.valueType !== void 0 && X(r.valueType) && (o.is_concrete_list = !0,
        r.valueType === Ao && r.getDependencies().length === 0)) {
            let u = r.asValue();
            u && (o.rgb_value = u.map(c => Wl(c[0], c[1], c[2]).formatHex()))
        }
        if (o.variables = o.is_graphable ? [] : n.getSliderVariables(e, r),
        o.is_single_identifier = n instanceof ze,
        qs(r)) {
            let u = Rr(r);
            o.typed_constant_value = u,
            H4(u == null ? void 0 : u.valueType) && (o.geometry = U2(e, t, n, r))
        }
        if (o.operator === "=" && r.getDependencies().length === 0 && xI(r.valueType, n, e) && (o.is_evaluable = !0),
        r instanceof O.OptimizedRegression) {
            let u = r
              , c = {};
            for (let l of ue(u.parameters))
                u.parameters.hasOwnProperty(l) && (c[go(l)] = +u.parameters[l].asValue());
            o.is_regression = !0,
            o.regression = {
                parameters: c,
                displayPrecision: u.displayPrecision,
                residualVariable: go(u.residualVariable),
                residualSuggestionId: u.residualSuggestionId,
                shouldSuggestLogMode: u.shouldSuggestLogMode,
                isLinear: u.isLinear,
                statistics: u.statistics,
                parameterWarning: u.parameterWarning
            }
        }
        return o
    }
    function H4(e) {
        switch (e) {
        case R:
        case zt:
        case Ce:
        case bi:
        case Ee:
        case Tr:
        case Ae:
        case fo:
        case Ie:
        case xi:
        case he:
        case hi:
        case ce:
        case mo:
        case De:
        case Dr:
        case Oe:
        case Ar:
        case Se:
        case wr:
        case we:
        case Ks:
            return !0;
        default:
            return !1
        }
    }
    function U2(e, t, n, r) {
        let o = {};
        r.valueType !== void 0 && (o.valueType = r.valueType),
        o.valueType && ae(o.valueType, R) && e.graphingEnabled() && El(n.getGraphMode(e, r)) && (o.isMovablePoint = !0);
        let {identifier: i, listAccess: s, tree: a} = Rx(n);
        if (i && (o.identifier = i),
        s && (o.listAccess = s),
        a && (o.call = a,
        r.valueType && ae(r.valueType, we) && n instanceof _r)) {
            let c = n._expression;
            o.transformation_preview_info = {
                type: a.symbol,
                args: c.args.slice(1).map(l => Rr(pe(l, e, t)))
            }
        }
        let u = r.moveStrategy && r.moveStrategy[0];
        if (u && "initialValue"in u && u.initialValue !== void 0 && (o.gliderParameter = u.initialValue),
        Object.keys(o).length > 0) {
            let c = n.getLegalExports(e);
            return {
                parentDependencies: n.getDependencies().filter(p => !rt[p] && !c.includes(p)),
                ...o
            }
        }
    }
    function U4(e, t, n) {
        let r = Tg(n.userData);
        if (!r)
            return;
        let {input: o, start: i, end: s} = r;
        if (o.trim() === "")
            return {
                type: "empty",
                allowedTypes: [Dn]
            };
        let a = "\\cursor"
          , u = o.slice(0, i) + a + " " + o.slice(s)
          , c = {
            start: i,
            end: i + a.length
        }
          , l = mi(u, {
            ...n.parseOptions
        });
        return l.userData = {
            ...n.userData,
            latex: u,
            latexSelection: c
        },
        l.isError ? l.getCursorContext() : Kd({
            policy: e,
            frame: t
        }, l).getCursorContext()
    }
    function Nc(e, t, n) {
        let r = e.variables;
        if (r && r.length) {
            let o = {};
            for (let i of r)
                o[i] = !0;
            for (let i of ue(n))
                o[i] = !0;
            n = o
        }
        e.variables = t.sliderVariables(ue(n))
    }
    function W_(e, t) {
        if (t.blocksExport)
            return !1;
        let n = t.getDependencies();
        if (n.length === 0)
            return !1;
        for (let r of n)
            if (!e.validActionVariable(r))
                return !1;
        return !0
    }
    function k4(e) {
        var n;
        let t = e.rawTree.userData;
        return !!(t.cdf && t.cdf.show && ((n = e.evaluationState.top_level_function_spec) == null ? void 0 : n.type) === "distribution")
    }
    var {Constant: Ur, FunctionCall: ts, Add: $4} = O;
    function $2(e, t, n, r, o, i, s) {
        var p, m;
        let a, u = 1 / 0, c = -1 / 0, l = e.defaults.map( (d, y) => {
            var g, f;
            return (f = (g = e.evaluatedParams) == null ? void 0 : g[y]) != null ? f : d
        }
        );
        switch (e.symbol) {
        case "normaldist":
            {
                let[d,y] = l;
                t === "left" || t === "right" ? a = {
                    bound1: d,
                    bound2: void 0,
                    p: .5
                } : a = {
                    bound1: d - y,
                    bound2: d + y,
                    p: t === "inner" ? .6826894921370859 : .31731050786291415
                };
                break
            }
        case "tdist":
            {
                let[d,y,g] = l;
                if (t === "left" || t === "right")
                    a = {
                        bound1: y,
                        bound2: void 0,
                        p: .5
                    };
                else {
                    let f = y - g
                      , h = y + g
                      , x = new ts("cdf",[o, new Ur(f), new Ur(h)]);
                    a = {
                        bound1: y - g,
                        bound2: y + g,
                        p: t === "inner" ? pe(x, i, s).asValue() : 1 - pe(x, i, s).asValue()
                    }
                }
                break
            }
        case "uniformdist":
            {
                let[d,y] = l;
                if (d > y) {
                    a = {
                        bound1: 0,
                        bound2: 1,
                        p: .5
                    };
                    break
                }
                u = y,
                c = d;
                let g = y - d;
                t === "left" || t === "right" ? a = {
                    bound1: d + .5 * g,
                    bound2: void 0,
                    p: .5
                } : a = {
                    bound1: d + .25 * g,
                    bound2: d + .75 * g,
                    p: .5
                };
                break
            }
        case "poissondist":
        case "binomialdist":
        case "chisqdist":
        case "geodist":
            if (c = 0,
            e.symbol === "binomialdist" && (u = (m = (p = e.evaluatedParams) == null ? void 0 : p[0]) != null ? m : 1 / 0),
            t === "left" || t === "right") {
                let d = new ts("quantile",[o, new Ur(.5)]);
                a = {
                    bound1: pe(d, i, s).asValue(),
                    bound2: void 0,
                    p: .5
                }
            } else {
                let d = new ts("quantile",[o, new Ur(.25)])
                  , y = new ts("quantile",[o, new Ur(3 / 4)]);
                a = {
                    bound1: pe(d, i, s).asValue(),
                    bound2: pe(y, i, s).asValue(),
                    p: .5
                }
            }
            break;
        default:
            throw new Error(`Unhandled distribution type ${e.symbol}`)
        }
        return (t === "inner" || t === "outer") && (n !== void 0 && !isNaN(n) && r === void 0 ? (a.bound2 = u,
        a.bound1 = n) : r !== void 0 && !isNaN(r) && n === void 0 && (a.bound1 = c,
        a.bound2 = r)),
        a
    }
    function Y2({distributionTree: e, tails: t, bound1Valid: n, bound1: r, bound2Valid: o, bound2: i, policy: s, frame: a}) {
        let u, c = Math.min(r, i), l = Math.max(r, i);
        switch (t) {
        case "left":
            n && (u = new ts("cdf",[e, new Ur(-1 / 0), new Ur(r)]));
            break;
        case "right":
            n && (u = new ts("cdf",[e, new Ur(r), new Ur(1 / 0)]));
            break;
        case "inner":
            n && o && (u = new ts("cdf",[e, new Ur(c), new Ur(l)]));
            break;
        case "outer":
            n && o && (c === l ? u = new Ur(1) : u = new $4([new ts("cdf",[e, new Ur(-1 / 0), new Ur(c)]), u = new ts("cdf",[e, new Ur(l), new Ur(1 / 0)])]));
            break
        }
        if (u)
            return pe(u, s, a).asValue()
    }
    function Y4(e, t, n, r) {
        var h, x, T;
        let {evaluationState: o, rawTree: i} = e
          , s = (x = (h = i.userData.cdf) == null ? void 0 : h.tails) != null ? x : "inner"
          , a = i.metaData.cdfBound1
          , u = i.metaData.cdfBound2
          , c = i.type === "Assignment" ? i._expression : i
          , l = o.top_level_function_spec;
        if ((l == null ? void 0 : l.type) !== "distribution")
            return;
        let p = Ss(t, n, a, r, void 0)
          , m = Ss(t, n, u, r, void 0)
          , d = $2(l, s, p, m, c, t, n);
        o.cdf_bound1_default = d.bound1,
        o.cdf_bound2_default = d.bound2,
        o.cdf_p_default = d.p,
        p === void 0 && (p = d.bound1),
        m === void 0 && (m = (T = d.bound2) != null ? T : NaN);
        let y = !0
          , g = !0;
        isNaN(p) && (y = !1,
        p = NaN),
        isNaN(m) && (g = !1,
        m = NaN),
        (!y || !g && (s === "inner" || s === "outer")) && (o.cdf_error = HC().getError()),
        i.metaData.evaluatedCDFBound1 = p,
        i.metaData.evaluatedCDFBound2 = m,
        o.cdf_bound1_valid = y,
        o.cdf_bound2_valid = g,
        o.cdf_bound1 = p,
        o.cdf_bound2 = m;
        let f = Y2({
            distributionTree: c,
            bound1Valid: y,
            bound1: p,
            bound2Valid: g,
            bound2: m,
            policy: t,
            frame: n,
            tails: s
        });
        f !== void 0 && (o.cdf_p = f)
    }
    function Z4(e, t, n, r) {
        var d, y;
        let {evaluationState: o, rawTree: i} = e
          , s = i.type === "Assignment" ? i._expression : i
          , a = o.top_level_function_spec;
        if ((a == null ? void 0 : a.type) !== "distribution")
            return;
        let u = i.metaData.cdfP
          , c = Ss(t, n, i.metaData.cdfBound1, r, void 0)
          , l = Ss(t, n, i.metaData.cdfBound2, r, void 0)
          , p = $2(a, i.userData.cdf.tails, c, l, s, t, n);
        c === void 0 && (c = p.bound1),
        l === void 0 && (l = p.bound2),
        o.cdf_p_default = p.p,
        o.cdf_bound1_default = p.bound1,
        o.cdf_bound2_default = p.bound2;
        let m = Ss(t, n, u, r, p.p);
        if (m === void 0 || isNaN(m) || m < 0 || m > 1) {
            o.cdf_error = NS().getError(),
            o.cdf_p_valid = !1;
            return
        } else
            o.cdf_p = m,
            o.cdf_p_valid = !0;
        if (i.metaData.cdfBound1 || i.metaData.cdfBound2) {
            let g = !0
              , f = !0;
            (c === void 0 || isNaN(c)) && (g = !1,
            c = NaN),
            (l === void 0 || isNaN(l)) && (f = !1,
            l = NaN);
            let h = (y = (d = i.userData.cdf) == null ? void 0 : d.tails) != null ? y : "inner"
              , x = Y2({
                bound1: c,
                bound1Valid: g,
                bound2: l,
                bound2Valid: f,
                distributionTree: s,
                tails: h,
                policy: t,
                frame: n
            });
            if (x !== void 0 && Math.abs(x - m) <= .001 * Math.abs(m)) {
                o.cdf_bound1 = c,
                o.cdf_bound2 = l,
                i.metaData.evaluatedCDFBound1 = c,
                i.metaData.evaluatedCDFBound2 = l;
                return
            }
        }
        switch (i.userData.cdf.tails) {
        case "inner":
            {
                let g = new ts("quantile",[s, new Ur((1 - m) / 2)])
                  , f = new ts("quantile",[s, new Ur((1 + m) / 2)]);
                o.cdf_bound1 = +pe(g, t, n).asValue(),
                o.cdf_bound2 = +pe(f, t, n).asValue();
                break
            }
        case "outer":
            {
                let g = new ts("quantile",[s, new Ur(m / 2)])
                  , f = new ts("quantile",[s, new Ur(1 - m / 2)]);
                o.cdf_bound1 = +pe(g, t, n).asValue(),
                o.cdf_bound2 = +pe(f, t, n).asValue();
                break
            }
        case "left":
            {
                let g = new ts("quantile",[s, new Ur(m)]);
                o.cdf_bound1 = +pe(g, t, n).asValue();
                break
            }
        case "right":
            {
                let g = new ts("quantile",[s, new Ur(1 - m)]);
                o.cdf_bound1 = +pe(g, t, n).asValue();
                break
            }
        }
        i.metaData.evaluatedCDFBound1 = o.cdf_bound1,
        i.metaData.evaluatedCDFBound2 = o.cdf_bound2
    }
    function X4(e, t, n, r) {
        var u;
        let {evaluationState: o, rawTree: i} = e
          , s = i.type === "Assignment" ? i._expression : i
          , a = e.evaluationState.top_level_function_spec;
        if ((a == null ? void 0 : a.type) === "distribution") {
            let c = {
                ...a,
                evaluatedParams: []
            };
            (u = s.args) == null || u.forEach( (l, p) => {
                let m = pe(l, t, n);
                for (let d of m.getDependencies())
                    r[d] = !0;
                m.type === "IRExpression" && m.isConstant ? c.evaluatedParams[p] = +m.asValue() : c.evaluatedParams[p] = void 0
            }
            ),
            o.top_level_function_spec = c,
            i.metaData.evaluatedDistributionSpec = c
        }
    }
    function Z2(e, t, n) {
        var i, s, a;
        let r = e.evaluationState
          , o = {};
        X4(e, t, n, o),
        k4(e) && ((i = e.rawTree.metaData.evaluatedDistributionSpec) != null && i.discrete || ((a = (s = e.rawTree.userData.cdf) == null ? void 0 : s.compute) != null ? a : "p") === "p" ? Y4(e, t, n, o) : Z4(e, t, n, o),
        r.is_single_identifier = !1,
        Nc(r, t, o))
    }
    $r();
    $r();
    var V = function() {};
    V.version = "1.2.6";
    V._myIndexOf = function(t) {
        var n = this.length, r;
        for (r = 0; r < n; ++r)
            if (this[r] === t)
                return r;
        return -1
    }
    ;
    V.myIndexOf = Array.prototype.indexOf ? Array.prototype.indexOf : V._myIndexOf;
    V.precision = 4;
    V.largeArray = 50;
    V.compile = function() {
        var e = Array.prototype.slice.call(arguments)
          , t = e.pop();
        return t = "return function (" + e.join(",") + ") {" + t + "}",
        new Function(["numeric"],t)(V)
    }
    ;
    V._dim = function(t) {
        for (var n = []; typeof t == "object"; )
            n.push(t.length),
            t = t[0];
        return n
    }
    ;
    V.dim = function(t) {
        var n, r;
        return typeof t == "object" ? (n = t[0],
        typeof n == "object" ? (r = n[0],
        typeof r == "object" ? V._dim(t) : [t.length, n.length]) : [t.length]) : []
    }
    ;
    V.mapreduce = function(t, n) {
        return V.compile("x", "accum", "_s", "_k", 'if(typeof accum === "undefined") accum = ' + n + `;
if(typeof x === "number") { var xi = x; ` + t + `; return accum; }
if(typeof _s === "undefined") _s = numeric.dim(x);
if(typeof _k === "undefined") _k = 0;
var _n = _s[_k];
var i,xi;
if(_k < _s.length-1) {
    for(i=_n-1;i>=0;i--) {
        accum = arguments.callee(x[i],accum,_s,_k+1);
    }    return accum;
}
for(i=_n-1;i>=1;i-=2) { 
    xi = x[i];
    ` + t + `;
    xi = x[i-1];
    ` + t + `;
}
if(i === 0) {
    xi = x[i];
    ` + t + `
}
return accum;`)
    }
    ;
    V.mapreduce2 = function(t, n) {
        return V.compile("x", `var n = x.length;
var i,xi;
` + n + `
for(i=n-1;i!==-1;--i) { 
    xi = x[i];
    ` + t + `
}
return accum;`)
    }
    ;
    V.rep = function(t, n, r) {
        typeof r == "undefined" && (r = 0);
        var o = t[r], i = Array(o), s;
        if (r === t.length - 1) {
            for (s = o - 2; s >= 0; s -= 2)
                i[s + 1] = n,
                i[s] = n;
            return s === -1 && (i[0] = n),
            i
        }
        for (s = o - 1; s >= 0; s--)
            i[s] = V.rep(t, n, r + 1);
        return i
    }
    ;
    V.dotMMsmall = function(t, n) {
        var r, o, i, s, a, u, c, l, p, m, d, y, g, f;
        for (s = t.length,
        a = n.length,
        u = n[0].length,
        c = Array(s),
        r = s - 1; r >= 0; r--) {
            for (l = Array(u),
            p = t[r],
            i = u - 1; i >= 0; i--) {
                for (m = p[a - 1] * n[a - 1][i],
                o = a - 2; o >= 1; o -= 2)
                    d = o - 1,
                    m += p[o] * n[o][i] + p[d] * n[d][i];
                o === 0 && (m += p[0] * n[0][i]),
                l[i] = m
            }
            c[r] = l
        }
        return c
    }
    ;
    V._getCol = function(t, n, r) {
        var o = t.length, i;
        for (i = o - 1; i > 0; --i)
            r[i] = t[i][n],
            --i,
            r[i] = t[i][n];
        i === 0 && (r[0] = t[0][n])
    }
    ;
    V.dotMMbig = function(t, n) {
        var r = V._getCol, o = n.length, i = Array(o), s = t.length, a = n[0].length, u = new Array(s), c, l = V.dotVV, p, m, d, y;
        for (--o,
        --s,
        p = s; p !== -1; --p)
            u[p] = Array(a);
        for (--a,
        p = a; p !== -1; --p)
            for (r(n, p, i),
            m = s; m !== -1; --m)
                y = 0,
                c = t[m],
                u[m][p] = l(c, i);
        return u
    }
    ;
    V.dotMV = function(t, n) {
        var r = t.length, o = n.length, i, s = Array(r), a = V.dotVV;
        for (i = r - 1; i >= 0; i--)
            s[i] = a(t[i], n);
        return s
    }
    ;
    V.dotVM = function(t, n) {
        var r, o, i, s, a, u, c, l, p, m, d, y, g, f, h, x, T, P, C;
        for (s = t.length,
        a = n[0].length,
        c = Array(a),
        i = a - 1; i >= 0; i--) {
            for (m = t[s - 1] * n[s - 1][i],
            o = s - 2; o >= 1; o -= 2)
                d = o - 1,
                m += t[o] * n[o][i] + t[d] * n[d][i];
            o === 0 && (m += t[0] * n[0][i]),
            c[i] = m
        }
        return c
    }
    ;
    V.dotVV = function(t, n) {
        var r, o = t.length, i, s = t[o - 1] * n[o - 1];
        for (r = o - 2; r >= 1; r -= 2)
            i = r - 1,
            s += t[r] * n[r] + t[i] * n[i];
        return r === 0 && (s += t[0] * n[0]),
        s
    }
    ;
    V.dot = function(t, n) {
        var r = V.dim;
        switch (r(t).length * 1e3 + r(n).length) {
        case 2002:
            return n.length < 10 ? V.dotMMsmall(t, n) : V.dotMMbig(t, n);
        case 2001:
            return V.dotMV(t, n);
        case 1002:
            return V.dotVM(t, n);
        case 1001:
            return V.dotVV(t, n);
        case 1e3:
            return V.mulVS(t, n);
        case 1:
            return V.mulSV(t, n);
        case 0:
            return t * n;
        default:
            throw new Error("numeric.dot only works on vectors and matrices")
        }
    }
    ;
    V.diag = function(t) {
        var n, r, o, i = t.length, s = Array(i), a;
        for (n = i - 1; n >= 0; n--) {
            for (a = Array(i),
            r = n + 2,
            o = i - 1; o >= r; o -= 2)
                a[o] = 0,
                a[o - 1] = 0;
            for (o > n && (a[o] = 0),
            a[n] = t[n],
            o = n - 1; o >= 1; o -= 2)
                a[o] = 0,
                a[o - 1] = 0;
            o === 0 && (a[0] = 0),
            s[n] = a
        }
        return s
    }
    ;
    V.getDiag = function(e) {
        var t = Math.min(e.length, e[0].length), n, r = Array(t);
        for (n = t - 1; n >= 1; --n)
            r[n] = e[n][n],
            --n,
            r[n] = e[n][n];
        return n === 0 && (r[0] = e[0][0]),
        r
    }
    ;
    V.identity = function(t) {
        return V.diag(V.rep([t], 1))
    }
    ;
    V.pointwise = function(t, n, r) {
        typeof r == "undefined" && (r = "");
        var o = [], i, s = /\[i\]$/, a, u = "", c = !1;
        for (i = 0; i < t.length; i++)
            s.test(t[i]) ? (a = t[i].substring(0, t[i].length - 3),
            u = a) : a = t[i],
            a === "ret" && (c = !0),
            o.push(a);
        return o[t.length] = "_s",
        o[t.length + 1] = "_k",
        o[t.length + 2] = 'if(typeof _s === "undefined") _s = numeric.dim(' + u + `);
if(typeof _k === "undefined") _k = 0;
var _n = _s[_k];
var i` + (c ? "" : ", ret = Array(_n)") + `;
if(_k < _s.length-1) {
    for(i=_n-1;i>=0;i--) ret[i] = arguments.callee(` + t.join(",") + `,_s,_k+1);
    return ret;
}
` + r + `
for(i=_n-1;i!==-1;--i) {
    ` + n + `
}
return ret;`,
        V.compile.apply(null, o)
    }
    ;
    V.pointwise2 = function(t, n, r) {
        typeof r == "undefined" && (r = "");
        var o = [], i, s = /\[i\]$/, a, u = "", c = !1;
        for (i = 0; i < t.length; i++)
            s.test(t[i]) ? (a = t[i].substring(0, t[i].length - 3),
            u = a) : a = t[i],
            a === "ret" && (c = !0),
            o.push(a);
        return o[t.length] = "var _n = " + u + `.length;
var i` + (c ? "" : ", ret = Array(_n)") + `;
` + r + `
for(i=_n-1;i!==-1;--i) {
` + n + `
}
return ret;`,
        V.compile.apply(null, o)
    }
    ;
    V._biforeach = function e(t, n, r, o, i) {
        if (o === r.length - 1) {
            i(t, n);
            return
        }
        var s, a = r[o];
        for (s = a - 1; s >= 0; s--)
            e(typeof t == "object" ? t[s] : t, typeof n == "object" ? n[s] : n, r, o + 1, i)
    }
    ;
    V._biforeach2 = function e(t, n, r, o, i) {
        if (o === r.length - 1)
            return i(t, n);
        var s, a = r[o], u = Array(a);
        for (s = a - 1; s >= 0; --s)
            u[s] = e(typeof t == "object" ? t[s] : t, typeof n == "object" ? n[s] : n, r, o + 1, i);
        return u
    }
    ;
    V._foreach = function e(t, n, r, o) {
        if (r === n.length - 1) {
            o(t);
            return
        }
        var i, s = n[r];
        for (i = s - 1; i >= 0; i--)
            e(t[i], n, r + 1, o)
    }
    ;
    V._foreach2 = function e(t, n, r, o) {
        if (r === n.length - 1)
            return o(t);
        var i, s = n[r], a = Array(s);
        for (i = s - 1; i >= 0; i--)
            a[i] = e(t[i], n, r + 1, o);
        return a
    }
    ;
    V.ops2 = {
        add: "+",
        sub: "-",
        mul: "*",
        div: "/",
        mod: "%",
        and: "&&",
        or: "||",
        eq: "===",
        neq: "!==",
        lt: "<",
        gt: ">",
        leq: "<=",
        geq: ">=",
        band: "&",
        bor: "|",
        bxor: "^",
        lshift: "<<",
        rshift: ">>",
        rrshift: ">>>"
    };
    V.opseq = {
        addeq: "+=",
        subeq: "-=",
        muleq: "*=",
        diveq: "/=",
        modeq: "%=",
        lshifteq: "<<=",
        rshifteq: ">>=",
        rrshifteq: ">>>=",
        bandeq: "&=",
        boreq: "|=",
        bxoreq: "^="
    };
    V.mathfuns = ["abs", "acos", "asin", "atan", "ceil", "cos", "exp", "floor", "log", "round", "sin", "sqrt", "tan", "isNaN", "isFinite"];
    V.mathfuns2 = ["atan2", "pow", "max", "min"];
    V.ops1 = {
        neg: "-",
        not: "!",
        bnot: "~",
        clone: ""
    };
    V.mapreducers = {
        any: ["if(xi) return true;", "var accum = false;"],
        all: ["if(!xi) return false;", "var accum = true;"],
        sum: ["accum += xi;", "var accum = 0;"],
        prod: ["accum *= xi;", "var accum = 1;"],
        norm2Squared: ["accum += xi*xi;", "var accum = 0;"],
        norminf: ["accum = max(accum,abs(xi));", "var accum = 0, max = Math.max, abs = Math.abs;"],
        norm1: ["accum += abs(xi);", "var accum = 0, abs = Math.abs;"],
        sup: ["accum = max(accum,xi);", "var accum = -Infinity, max = Math.max;"],
        inf: ["accum = min(accum,xi);", "var accum = Infinity, min = Math.min;"]
    };
    (function() {
        var e, t;
        for (e = 0; e < V.mathfuns2.length; ++e)
            t = V.mathfuns2[e],
            V.ops2[t] = t;
        for (e in V.ops2)
            if (V.ops2.hasOwnProperty(e)) {
                t = V.ops2[e];
                var n, r, o = "";
                V.myIndexOf.call(V.mathfuns2, e) !== -1 ? (o = "var " + t + " = Math." + t + `;
`,
                n = function(i, s, a) {
                    return i + " = " + t + "(" + s + "," + a + ")"
                }
                ,
                r = function(i, s) {
                    return i + " = " + t + "(" + i + "," + s + ")"
                }
                ) : (n = function(i, s, a) {
                    return i + " = " + s + " " + t + " " + a
                }
                ,
                V.opseq.hasOwnProperty(e + "eq") ? r = function(i, s) {
                    return i + " " + t + "= " + s
                }
                : r = function(i, s) {
                    return i + " = " + i + " " + t + " " + s
                }
                ),
                V[e + "VV"] = V.pointwise2(["x[i]", "y[i]"], n("ret[i]", "x[i]", "y[i]"), o),
                V[e + "SV"] = V.pointwise2(["x", "y[i]"], n("ret[i]", "x", "y[i]"), o),
                V[e + "VS"] = V.pointwise2(["x[i]", "y"], n("ret[i]", "x[i]", "y"), o),
                V[e] = V.compile(`var n = arguments.length, i, x = arguments[0], y;
var VV = numeric.` + e + "VV, VS = numeric." + e + "VS, SV = numeric." + e + `SV;
var dim = numeric.dim;
for(i=1;i!==n;++i) { 
  y = arguments[i];
  if(typeof x === "object") {
      if(typeof y === "object") x = numeric._biforeach2(x,y,dim(x),0,VV);
      else x = numeric._biforeach2(x,y,dim(x),0,VS);
  } else if(typeof y === "object") x = numeric._biforeach2(x,y,dim(y),0,SV);
  else ` + r("x", "y") + `
}
return x;
`),
                V[t] = V[e],
                V[e + "eqV"] = V.pointwise2(["ret[i]", "x[i]"], r("ret[i]", "x[i]"), o),
                V[e + "eqS"] = V.pointwise2(["ret[i]", "x"], r("ret[i]", "x"), o),
                V[e + "eq"] = V.compile(`var n = arguments.length, i, x = arguments[0], y;
var V = numeric.` + e + "eqV, S = numeric." + e + `eqS
var s = numeric.dim(x);
for(i=1;i!==n;++i) { 
  y = arguments[i];
  if(typeof y === "object") numeric._biforeach(x,y,s,0,V);
  else numeric._biforeach(x,y,s,0,S);
}
return x;
`)
            }
        for (e = 0; e < V.mathfuns2.length; ++e)
            t = V.mathfuns2[e],
            delete V.ops2[t];
        for (e = 0; e < V.mathfuns.length; ++e)
            t = V.mathfuns[e],
            V.ops1[t] = t;
        for (e in V.ops1)
            V.ops1.hasOwnProperty(e) && (o = "",
            t = V.ops1[e],
            V.myIndexOf.call(V.mathfuns, e) !== -1 && Math.hasOwnProperty(t) && (o = "var " + t + " = Math." + t + `;
`),
            V[e + "eqV"] = V.pointwise2(["ret[i]"], "ret[i] = " + t + "(ret[i]);", o),
            V[e + "eq"] = V.compile("x", 'if(typeof x !== "object") return ' + t + `x
var i;
var V = numeric.` + e + `eqV;
var s = numeric.dim(x);
numeric._foreach(x,s,0,V);
return x;
`),
            V[e + "V"] = V.pointwise2(["x[i]"], "ret[i] = " + t + "(x[i]);", o),
            V[e] = V.compile("x", 'if(typeof x !== "object") return ' + t + `(x)
var i;
var V = numeric.` + e + `V;
var s = numeric.dim(x);
return numeric._foreach2(x,s,0,V);
`));
        for (e = 0; e < V.mathfuns.length; ++e)
            t = V.mathfuns[e],
            delete V.ops1[t];
        for (e in V.mapreducers)
            V.mapreducers.hasOwnProperty(e) && (t = V.mapreducers[e],
            V[e + "V"] = V.mapreduce2(t[0], t[1]),
            V[e] = V.compile("x", "s", "k", t[1] + `if(typeof x !== "object") {    xi = x;
` + t[0] + `
    return accum;
}if(typeof s === "undefined") s = numeric.dim(x);
if(typeof k === "undefined") k = 0;
if(k === s.length-1) return numeric.` + e + `V(x);
var xi;
var n = x.length, i;
for(i=n-1;i!==-1;--i) {
   xi = arguments.callee(x[i]);
` + t[0] + `
}
return accum;
`))
    }
    )();
    V.inv = function(g) {
        var n = V.dim(g), r = Math.abs, o = n[0], i = n[1], s = V.clone(g), a, u, c = V.identity(o), l, p, m, d, y, g;
        for (d = 0; d < i; ++d) {
            var f = -1
              , h = -1;
            for (m = d; m !== o; ++m)
                y = r(s[m][d]),
                y > h && (f = m,
                h = y);
            for (u = s[f],
            s[f] = s[d],
            s[d] = u,
            p = c[f],
            c[f] = c[d],
            c[d] = p,
            g = u[d],
            y = d; y !== i; ++y)
                u[y] /= g;
            for (y = i - 1; y !== -1; --y)
                p[y] /= g;
            for (m = o - 1; m !== -1; --m)
                if (m !== d) {
                    for (a = s[m],
                    l = c[m],
                    g = a[d],
                    y = d + 1; y !== i; ++y)
                        a[y] -= u[y] * g;
                    for (y = i - 1; y > 0; --y)
                        l[y] -= p[y] * g,
                        --y,
                        l[y] -= p[y] * g;
                    y === 0 && (l[0] -= p[0] * g)
                }
        }
        return c
    }
    ;
    V.det = function(t) {
        var n = V.dim(t);
        if (n.length !== 2 || n[0] !== n[1])
            throw new Error("numeric: det() only works on square matrices");
        var r = n[0], o = 1, i, s, a, u = V.clone(t), c, l, p, m, d, y, g;
        for (s = 0; s < r - 1; s++) {
            for (a = s,
            i = s + 1; i < r; i++)
                Math.abs(u[i][s]) > Math.abs(u[a][s]) && (a = i);
            for (a !== s && (m = u[a],
            u[a] = u[s],
            u[s] = m,
            o *= -1),
            c = u[s],
            i = s + 1; i < r; i++) {
                for (l = u[i],
                p = l[s] / c[s],
                a = s + 1; a < r - 1; a += 2)
                    d = a + 1,
                    l[a] -= c[a] * p,
                    l[d] -= c[d] * p;
                a !== r && (l[a] -= c[a] * p)
            }
            if (c[s] === 0)
                return 0;
            o *= c[s]
        }
        return o * u[s][s]
    }
    ;
    V.transpose = function(t) {
        var n, r, o = t.length, i = t[0].length, s = Array(i), a, u, c;
        for (r = 0; r < i; r++)
            s[r] = Array(o);
        for (n = o - 1; n >= 1; n -= 2) {
            for (u = t[n],
            a = t[n - 1],
            r = i - 1; r >= 1; --r)
                c = s[r],
                c[n] = u[r],
                c[n - 1] = a[r],
                --r,
                c = s[r],
                c[n] = u[r],
                c[n - 1] = a[r];
            r === 0 && (c = s[0],
            c[n] = u[0],
            c[n - 1] = a[0])
        }
        if (n === 0) {
            for (a = t[0],
            r = i - 1; r >= 1; --r)
                s[r][0] = a[r],
                --r,
                s[r][0] = a[r];
            r === 0 && (s[0][0] = a[0])
        }
        return s
    }
    ;
    V.negtranspose = function(t) {
        var n, r, o = t.length, i = t[0].length, s = Array(i), a, u, c;
        for (r = 0; r < i; r++)
            s[r] = Array(o);
        for (n = o - 1; n >= 1; n -= 2) {
            for (u = t[n],
            a = t[n - 1],
            r = i - 1; r >= 1; --r)
                c = s[r],
                c[n] = -u[r],
                c[n - 1] = -a[r],
                --r,
                c = s[r],
                c[n] = -u[r],
                c[n - 1] = -a[r];
            r === 0 && (c = s[0],
            c[n] = -u[0],
            c[n - 1] = -a[0])
        }
        if (n === 0) {
            for (a = t[0],
            r = i - 1; r >= 1; --r)
                s[r][0] = -a[r],
                --r,
                s[r][0] = -a[r];
            r === 0 && (s[0][0] = -a[0])
        }
        return s
    }
    ;
    V.norm2 = function(t) {
        return Math.sqrt(V.norm2Squared(t))
    }
    ;
    V.linspace = function(t, n, r) {
        if (typeof r == "undefined" && (r = Math.max(Math.round(n - t) + 1, 1)),
        r < 2)
            return r === 1 ? [t] : [];
        var o, i = Array(r);
        for (r--,
        o = r; o >= 0; o--)
            i[o] = (o * n + (r - o) * t) / r;
        return i
    }
    ;
    V.getBlock = function(t, n, r) {
        var o = V.dim(t);
        function i(s, a) {
            var u, c = n[a], l = r[a] - c, p = Array(l);
            if (a === o.length - 1) {
                for (u = l; u >= 0; u--)
                    p[u] = s[u + c];
                return p
            }
            for (u = l; u >= 0; u--)
                p[u] = i(s[u + c], a + 1);
            return p
        }
        return i(t, 0)
    }
    ;
    V.setBlock = function(t, n, r, o) {
        var i = V.dim(t);
        function s(a, u, c) {
            var l, p = n[c], m = r[c] - p;
            if (c === i.length - 1)
                for (l = m; l >= 0; l--)
                    a[l + p] = u[l];
            for (l = m; l >= 0; l--)
                s(a[l + p], u[l], c + 1)
        }
        return s(t, o, 0),
        t
    }
    ;
    V.getRange = function(t, n, r) {
        var o = n.length, i = r.length, s, a, u = Array(o), c, l;
        for (s = o - 1; s !== -1; --s)
            for (u[s] = Array(i),
            c = u[s],
            l = t[n[s]],
            a = i - 1; a !== -1; --a)
                c[a] = l[r[a]];
        return u
    }
    ;
    V.blockMatrix = function(t) {
        var n = V.dim(t);
        if (n.length < 4)
            return V.blockMatrix([t]);
        var r = n[0], o = n[1], i, s, a, u, c;
        for (i = 0,
        s = 0,
        a = 0; a < r; ++a)
            i += t[a][0].length;
        for (u = 0; u < o; ++u)
            s += t[0][u][0].length;
        var l = Array(i);
        for (a = 0; a < i; ++a)
            l[a] = Array(s);
        var p = 0, m, d, y, g, f;
        for (a = 0; a < r; ++a) {
            for (m = s,
            u = o - 1; u !== -1; --u)
                for (c = t[a][u],
                m -= c[0].length,
                y = c.length - 1; y !== -1; --y)
                    for (f = c[y],
                    d = l[p + y],
                    g = f.length - 1; g !== -1; --g)
                        d[m + g] = f[g];
            p += t[a][0].length
        }
        return l
    }
    ;
    V.tensor = function(t, n) {
        if (typeof t == "number" || typeof n == "number")
            return V.mul(t, n);
        var r = V.dim(t)
          , o = V.dim(n);
        if (r.length !== 1 || o.length !== 1)
            throw new Error("numeric: tensor product is only defined for vectors");
        var i = r[0], s = o[0], a = Array(i), u, c, l, p;
        for (c = i - 1; c >= 0; c--) {
            for (u = Array(s),
            p = t[c],
            l = s - 1; l >= 3; --l)
                u[l] = p * n[l],
                --l,
                u[l] = p * n[l],
                --l,
                u[l] = p * n[l],
                --l,
                u[l] = p * n[l];
            for (; l >= 0; )
                u[l] = p * n[l],
                --l;
            a[c] = u
        }
        return a
    }
    ;
    V.epsilon = 2220446049250313e-31;
    V.LU = function(e, t) {
        t = t || !1;
        var n = Math.abs, r, o, i, s, a, u, c, l, p, m = e.length, d = m - 1, y = new Array(m);
        for (t || (e = V.clone(e)),
        i = 0; i < m; ++i) {
            for (c = i,
            u = e[i],
            p = n(u[i]),
            o = i + 1; o < m; ++o)
                s = n(e[o][i]),
                p < s && (p = s,
                c = o);
            for (y[i] = c,
            c != i && (e[i] = e[c],
            e[c] = u,
            u = e[i]),
            a = u[i],
            r = i + 1; r < m; ++r)
                e[r][i] /= a;
            for (r = i + 1; r < m; ++r) {
                for (l = e[r],
                o = i + 1; o < d; ++o)
                    l[o] -= l[i] * u[o],
                    ++o,
                    l[o] -= l[i] * u[o];
                o === d && (l[o] -= l[i] * u[o])
            }
        }
        return {
            LU: e,
            P: y
        }
    }
    ;
    V.LUsolve = function(t, n) {
        var r, o, i = t.LU, s = i.length, a = V.clone(n), u = t.P, c, l, p, m;
        for (r = s - 1; r !== -1; --r)
            a[r] = n[r];
        for (r = 0; r < s; ++r)
            for (c = u[r],
            u[r] !== r && (m = a[r],
            a[r] = a[c],
            a[c] = m),
            l = i[r],
            o = 0; o < r; ++o)
                a[r] -= a[o] * l[o];
        for (r = s - 1; r >= 0; --r) {
            for (l = i[r],
            o = r + 1; o < s; ++o)
                a[r] -= a[o] * l[o];
            a[r] /= l[r]
        }
        return a
    }
    ;
    V.solve = function(t, n, r) {
        return V.LUsolve(V.LU(t, r), n)
    }
    ;
    var fr = V;
    var W4 = Math.pow(2, -52);
    function TI(e) {
        for (let t of e)
            for (let n of t)
                if (!un(n))
                    return !1;
        return !0
    }
    function W2(e) {
        let t = [];
        for (let n of e)
            t.push(n.slice());
        return t
    }
    function j_(e) {
        let {numRows: t, numCols: n} = nf(e)
          , r = [];
        for (let o = 0; o < n; o++)
            r.push([]);
        for (let o = 0; o < t; o++)
            for (let i = 0; i < n; i++)
                r[i].push(e[o][i]);
        return r
    }
    function nf(e) {
        let t = e.length
          , n = t > 0 ? e[0].length : 0;
        return {
            numRows: t,
            numCols: n
        }
    }
    function j2(e) {
        let {numRows: t, numCols: n} = nf(e);
        return t === n
    }
    function J_(e) {
        if (!j2(e))
            return !0;
        let t = L(Q4(e));
        return !isFinite(t) || t === 0
    }
    function j4() {
        throw new Error("Matrix dimension mismatch")
    }
    function J4() {
        throw new Error("Expected square matrix")
    }
    function II(e, t) {
        let n = nf(e)
          , r = nf(t);
        n.numCols !== r.numRows && j4();
        let o = [];
        for (let i = 0; i < n.numRows; i++) {
            let s = [];
            for (let a = 0; a < r.numCols; a++) {
                let u = be(0, 1);
                for (let c = 0; c < e[i].length; c++)
                    u = Pi(u, Zr(e[i][c], t[c][a]));
                s.push(u)
            }
            o.push(s)
        }
        return o
    }
    function Q4(e) {
        let {determinant: t} = Q_(W2(e));
        return t
    }
    function J2(e) {
        if (j2(e) || J4(),
        J_(e))
            throw new Error("Cannot invert a singular matrix");
        let {numRows: t, numCols: n} = nf(e)
          , r = [];
        for (let i = 0; i < t; i++) {
            let s = e[i].slice();
            for (let a = 0; a < n; a++)
                s.push(be(i === a ? 1 : 0, 1));
            r.push(s)
        }
        Q_(r);
        let o = [];
        for (let i of r)
            o.push(i.slice(n));
        return o
    }
    function Q2(e) {
        let t = W2(e);
        return Q_(t),
        t
    }
    function K4(e) {
        let t = 0;
        for (let n of e)
            for (let r of n) {
                let o = Math.abs(L(r));
                if (!isFinite(o))
                    return NaN;
                o > t && (t = o)
            }
        return t
    }
    function X2(e) {
        for (let t = 0; t < e.length; t++)
            for (let n = 0; n < e[t].length; n++)
                e[t][n] = NaN
    }
    function Q_(e) {
        let {numRows: t, numCols: n} = nf(e)
          , r = K4(e);
        if (!isFinite(r))
            return X2(e),
            {
                determinant: NaN,
                rank: 0
            };
        let o = Math.max(t, n) * r * W4
          , i = be(1, 1)
          , s = 0
          , a = 0;
        for (; s < t && a < n; ) {
            let u = s
              , c = Math.abs(L(e[s][a]));
            for (let p = s + 1; p < t; p++) {
                let m = Math.abs(L(e[p][a]));
                (!isFinite(m) || m > c) && (c = m,
                u = p)
            }
            if (!isFinite(c))
                return X2(e),
                {
                    determinant: NaN,
                    rank: 0
                };
            if (c === 0) {
                i = be(0, 1),
                a += 1;
                continue
            }
            if (!un(e[u][a]) && c < o) {
                for (let p = s; p < t; p++)
                    e[s][p] = 0;
                i = 0,
                a += 1;
                continue
            }
            if (u !== s) {
                i = Ii(i);
                let p = e[s];
                e[s] = e[u],
                e[u] = p
            }
            for (let p = 0; p < t; p++) {
                if (p === s)
                    continue;
                let m = Fo(e[p][a], e[s][a]);
                e[p][a] = be(0, 1);
                for (let d = a + 1; d < n; d++)
                    e[p][d] = ki(e[p][d], Zr(m, e[s][d]))
            }
            let l = e[s][a];
            i = Zr(i, l),
            e[s][a] = be(1, 1);
            for (let p = a + 1; p < n; p++)
                e[s][p] = Fo(e[s][p], l);
            s += 1,
            a += 1
        }
        return {
            rank: s,
            determinant: s === t && s === n ? i : be(0, 1)
        }
    }
    function t6(e, t) {
        let n = e.length
          , r = t.length
          , o = 0
          , i = 0;
        for (let a = r - n; a < r; a++)
            o += e[a + n - r] * t[a],
            i += e[a + n - r] * e[a + n - r];
        let s = o / i;
        for (let a = r - n; a < r; a++)
            t[a] = 2 * s * e[a + n - r] - t[a]
    }
    function n6(e, t, n) {
        let r = e.length
          , o = t.length
          , i = 0
          , s = 0;
        for (let u = o - r; u < o; u++)
            i += e[u + r - o] * t[u][n],
            s += e[u + r - o] * e[u + r - o];
        let a = i / s;
        for (let u = o - r; u < o; u++)
            t[u][n] = 2 * a * e[u + r - o] - t[u][n]
    }
    function r6(e, t, n, r) {
        let o = Array(e.length - t);
        if (o.length === 1)
            return o[0] = 1,
            o;
        if (r === 0) {
            o[0] = 1;
            for (let s = 1; s < o.length; s++)
                o[s] = 0;
            return o
        }
        let i = e[t][n] < 0 ? -1 : 1;
        o[0] = e[t][n] + i * Math.sqrt(r);
        for (let s = t + 1; s < e.length; s++)
            o[s - t] = e[s][n];
        return o
    }
    function o6(e, t, n) {
        let r = 0;
        for (; t < e.length; t++)
            r += e[t][n] * e[t][n];
        return r
    }
    function PI(e, t) {
        if (!t || !t.mutateInput) {
            let i = e;
            e = Array(e.length);
            for (let s = 0; s < i.length; s++)
                e[s] = i[s].slice()
        }
        let n = Math.min(e.length, e[0].length)
          , r = Array(n)
          , o = [];
        for (let i = 0; i < n; i++) {
            let s = -1 / 0
              , a = i;
            for (let c = i; c < e[i].length; c++) {
                let l = o6(e, i, c);
                l > s && (s = l,
                a = c)
            }
            if (r[i] = a,
            a !== i)
                for (let c = 0; c < e.length; c++) {
                    let l = e[c][a];
                    e[c][a] = e[c][i],
                    e[c][i] = l
                }
            let u = r6(e, i, i, s);
            for (let c = i; c < e[i].length; c++)
                n6(u, e, c);
            o.push(u)
        }
        return {
            reflectors: o,
            r: e,
            p: r
        }
    }
    function K2(e, t, n) {
        let {reflectors: r, r: o, p: i} = e
          , s = t.slice();
        for (let c = 0; c < r.length; c++)
            t6(r[c], s);
        for (let c = r.length; c < o[0].length; c++)
            s[c] = 0;
        s.length = o[0].length;
        let a = Math.pow(2, -52)
          , u = n.regularize ? a * Math.abs(o[0][0]) * Math.max(o.length, o[0].length) : 0;
        for (let c = r.length - 1; c >= 0; c--) {
            let l = o[c];
            if (Math.abs(l[c]) <= u)
                s[c] = 0;
            else {
                for (let p = c + 1; p < r.length; p++)
                    s[c] -= s[p] * l[p];
                s[c] /= l[c]
            }
        }
        for (let c = i.length - 1; c >= 0; c--)
            if (i[c] !== c) {
                let l = s[c];
                s[c] = s[i[c]],
                s[i[c]] = l
            }
        return s
    }
    function i6(e, t, n) {
        let r = Array(e.r[0].length);
        for (let i = 0; i < r.length; i++)
            r[i] = Array(t[0].length);
        let o = Array(t.length);
        for (let i = 0; i < t[0].length; i++) {
            for (let a = 0; a < t.length; a++)
                o[a] = t[a][i];
            let s = K2(e, o, n);
            for (let a = 0; a < s.length; a++)
                r[a][i] = s[a]
        }
        return r
    }
    function Qp(e, t, n) {
        return Array.isArray(t[0]) ? i6(e, t, n) : K2(e, t, n)
    }
    function s6(e) {
        let t = e.r
          , n = Math.min(t.length, t[0].length)
          , r = t[0][0]
          , o = t[n - 1][n - 1];
        return r === 0 ? 1 / 0 : Math.abs(r / o)
    }
    function e3(e) {
        let t = Math.pow(2, -52);
        return Math.max(e.r.length, e.r[0].length) * t * s6(e) < 1
    }
    function EI(e, t) {
        let n = [];
        for (let r = 0; r < t; r++)
            n.push(e);
        return n
    }
    function Og(e, t) {
        let n = zl(e, t)
          , r = 0;
        for (let o of n) {
            let i = o;
            r += i * i
        }
        return r / n.length
    }
    function zl(e, t) {
        return e.apply(void 0, t)
    }
    function SI(e, t) {
        let n = [];
        for (let r of e) {
            let o = r.apply(void 0, t);
            n.push(o)
        }
        return n
    }
    function t3(e, t) {
        let n = [];
        for (let r = 0; r < e.length; r++)
            t[r] && n.push(e[r]);
        return n
    }
    function K_(e, t, n) {
        let r = [];
        for (let o = 0, i = 0; o < e.length; o++) {
            let s = 0;
            n[o] && (s = t[i],
            i += 1),
            r.push(e[o] + s)
        }
        return r
    }
    function nR(e, t) {
        let n = t.solution.map(u => Math.abs(u) < 1e-6 ? 0 : u)
          , r = t.solution.map( () => 0)
          , o = Og(e, n)
          , i = zl(e, n)
          , s = zl(e, r)
          , a = 0;
        for (let u = 0; u < i.length; u++) {
            let c = s[u] * 1e-15;
            a += Math.abs(i[u] * c) + c * c
        }
        return a /= i.length,
        isFinite(a) || (a = 0),
        isFinite(t.MSE) && !isFinite(o) ? t : o <= t.MSE + a ? {
            solution: n,
            MSE: o
        } : t
    }
    function rR(e, t) {
        if (!TI(t) || !TI([e]))
            return;
        let n = j_(t)
          , r = II([e], n)[0]
          , o = II(t, n);
        for (let c = 0; c < r.length; c++)
            o[c].push(Ii(r[c]));
        let i = Q2(o);
        if (!TI(i))
            return;
        let s = []
          , a = r.length
          , u = 0;
        for (let c of i)
            for (; u < a; )
                if (L(c[u]) === 1) {
                    s.push(c[c.length - 1]),
                    u++;
                    break
                } else
                    s.push(be(0, 1)),
                    u++;
        for (; u < a; )
            s.push(be(0, 1)),
            u++;
        return s
    }
    function oR(e) {
        let t = II(e, j_(e));
        if (J_(t)) {
            let o = [];
            for (let i = 0; i < t.length; i++)
                o.push(NaN);
            return o
        }
        let n = J2(t)
          , r = [];
        for (let o = 0; o < n.length; o++)
            r.push(n[o][o]);
        return r
    }
    function iR(e, t) {
        let n = EI(0, t.length)
          , r = SI(t, n)
          , o = PI(fr.transpose(r), {
            mutateInput: !0
        });
        for (let u = 0; u < 2; u++) {
            let c = zl(e, n)
              , l = fr.neg(Qp(o, c, {
                regularize: !1
            }));
            n = fr.add(n, l)
        }
        let i = Og(e, n);
        if (e3(o))
            return {
                solution: n,
                MSE: i
            };
        let s = EI(0, t.length);
        for (let u = 0; u < 2; u++) {
            let c = zl(e, s)
              , l = fr.neg(Qp(o, c, {
                regularize: !0
            }));
            s = fr.add(s, l)
        }
        let a = Og(e, s);
        return .999 * a <= i ? {
            solution: s,
            MSE: a
        } : {
            solution: n,
            MSE: i
        }
    }
    function eR(e, t, n, r) {
        let o = r.maxIterations, i = r.linearSubset || EI(!1, n.length), s = fr.not(i), a = t3(t, i), u = t3(t, s), c = 2, l = .1, p = n, m = 0, d = .001, y;
        if (a.length > 0) {
            let h = fr.transpose(SI(a, p))
              , x = PI(h);
            y = {
                Jv: h,
                F: x
            };
            let T = zl(e, p)
              , P = fr.neg(Qp(x, T, {
                regularize: !0
            }));
            p = K_(p, P, i)
        }
        let g = !1
          , f = Og(e, p);
        for (; m < o && !g && isFinite(f); ) {
            let h = zl(e, p), x = SI(u, p), T = fr.transpose(x), P, C;
            if (y) {
                let {F: M, Jv: _} = y;
                P = fr.dot(x, fr.sub(h, fr.dot(_, Qp(M, h, {
                    regularize: !0
                })))),
                C = fr.dot(x, fr.sub(T, fr.dot(_, Qp(M, T, {
                    regularize: !0
                }))))
            } else
                P = fr.dot(x, h),
                C = fr.dot(x, T);
            let S = p
              , E = !1;
            for (; m < o && !g && !E; ) {
                m += 1;
                let M = fr.add(C, fr.diag(EI(d, u.length)))
                  , _ = fr.neg(fr.solve(M, P, !0));
                S = K_(p, _, s),
                g = fr.all(fr.eq(S, p));
                let U;
                if (y) {
                    let K = fr.transpose(SI(a, S))
                      , w = PI(K);
                    U = {
                        Jv: K,
                        F: w
                    };
                    let B = zl(e, S)
                      , W = fr.neg(Qp(w, B, {
                        regularize: !0
                    }));
                    S = K_(S, W, i)
                }
                let Q = Og(e, S);
                E = Q < f,
                E ? (p = S,
                f = Q,
                y = U,
                d *= l) : (d = Math.max(d, 1e-64),
                d *= c)
            }
        }
        return {
            solution: p,
            MSE: f
        }
    }
    var tR = [18.9, .105, .0113, .089, 4.414, .373, .06, .149, 1.84, 9.26, 5, .7, .2, 1.13, 2.61, 1, .007, 30, 120, 1500, 4e-4, 7.23, -1, -.0081, -.03, -28.6, -1.71, -.4, -6.94, -.777, -500];
    function a6(e) {
        let t = e * 503 % tR.length;
        return tR[t]
    }
    function u6(e) {
        let t = [];
        for (let n = 0; n < tR.length; n++) {
            let r = [];
            for (let o = 0; o < e; o++)
                n === 0 && e !== 1 ? r[o] = 0 : n === 1 && e !== 1 ? r[o] = 1 : r[o] = a6(n * e + o);
            t.push(r)
        }
        return t
    }
    function n3(e, t, n, r, o) {
        let i = [];
        for (let a of n)
            i.push({
                soln: eR(e, t, a, o),
                initialGuess: a
            });
        i.sort( (a, u) => isNaN(a.soln.MSE) ? 1 : isNaN(u.soln.MSE) ? -1 : a.soln.MSE - u.soln.MSE);
        let s = [];
        for (let a = 0; a < r; a++)
            s.push(i[a].initialGuess);
        return s
    }
    function c6(e, t, n, r) {
        if (!t || Ei(t))
            return e;
        let o = t.bounds;
        return o[0] === -1 / 0 && o[1] === 1 / 0 ? e : o[0] === -1 / 0 ? o[1] - Math.exp(-e) : o[1] === 1 / 0 ? o[0] + Math.exp(e) : n / (r - 1) * o[1] + (r - 1 - n) / (r - 1) * o[0]
    }
    var r3 = [3, 5, 7, 11, 13, 17, 19];
    function l6(e, t) {
        let n = [];
        for (let r = 0; r < e.length; r++) {
            let o = e[r]
              , i = [];
            for (let s = 0; s < o.length; s++) {
                let a = r3[s % r3.length] * r % e.length;
                i.push(c6(o[s], t[s], a, e.length))
            }
            n.push(i)
        }
        return n
    }
    function o3(e, t, n) {
        n || (n = {});
        let {linearSubset: r, bounds: o, preferredInitialGuess: i} = n
          , s = u6(t.length);
        o && (s = l6(s, o));
        let a = n3(e, t, s, 5, {
            maxIterations: 3,
            linearSubset: r
        })
          , u = n3(e, t, a, 1, {
            maxIterations: 60,
            linearSubset: r
        })
          , c = eR(e, t, u[0], {
            maxIterations: 250,
            linearSubset: r
        });
        if (!i)
            return c;
        let l = eR(e, t, i, {
            maxIterations: 100,
            linearSubset: r
        });
        return isFinite(l.MSE) && (l.MSE < c.MSE || Bi(l.MSE, c.MSE, 8)) ? l : c
    }
    function sR(e) {
        return {
            chunk: e,
            isLazy: !0
        }
    }
    function i3(e) {
        return e.slice()
    }
    function vI(e) {
        if (!e.isLazy)
            return e;
        let t = e.chunk.copy();
        return t.reopenFinalBlock(),
        {
            chunk: t,
            forwardParameterMap: i3,
            reverseParameterMap: i3,
            isLazy: !1,
            valueMap: g6(e.chunk.instructionsLength()),
            replacementMask: rf(e.chunk.argNames.length)
        }
    }
    function s3(e) {
        let {chunk: t, forwardParameterMap: n, reverseParameterMap: r, isLazy: o, valueMap: i, replacementMask: s, didShiftScale: a} = e;
        return {
            chunk: t.copy(),
            forwardParameterMap: n,
            reverseParameterMap: r,
            isLazy: o,
            valueMap: i.slice(),
            replacementMask: s.slice(),
            didShiftScale: a
        }
    }
    function p6(e) {
        let t = 1 / 0
          , n = -1 / 0
          , r = e.length;
        for (let o of e)
            t = Math.min(t, o),
            n = Math.max(n, o);
        return {
            min: t,
            max: n,
            length: r
        }
    }
    function c3(e) {
        let t = e.getInstruction(e.getReturnIndex());
        if (t.type !== 48)
            return;
        let n = t.args[0]
          , r = e.getReturnIndex() - n
          , o = e.getInstruction(n);
        if (o.args.length !== 2)
            return;
        let i = o.args[0]
          , s = o.args[r]
          , a = []
          , u = [];
        a.push(i),
        u.push({
            min: 1,
            max: Qa(e, e.getReturnIndex(), "Programming error: cannot optimize regression on non-constant-length list"),
            length: Qa(e, e.getReturnIndex(), "Programming error: cannot optimize regression on non-constant-length list")
        });
        let c = !1
          , l = !1;
        for (let f = i + 1; f <= s; f++) {
            let h = e.getInstruction(f);
            if (h.type === 39 || h.type === 41 || h.type === 40) {
                if (h.args[1] !== i)
                    continue;
                let x = h.args[0];
                if (e.getInstruction(x).valueType !== Y || !Ye(e.getInstruction(x)))
                    continue;
                let T = Xr(e, x)
                  , P = p6(T);
                if (!isFinite(P.min) || !isFinite(P.max))
                    continue;
                a.push(f),
                u.push(P)
            } else if (h.type === 37)
                h.symbol === "exp" ? l = !0 : u3(h) && (c = !0);
            else if (h.type === 12 || h.type === 13)
                l = !0;
            else if (Po(h) || Bo(h))
                return
        }
        if (a.length === 0 || !l && !c)
            return;
        let p = [];
        for (let f = 0; f <= s; f++) {
            let h = a.indexOf(f);
            if (h !== -1) {
                let x = rf(a.length);
                x[h] = !0,
                p.push(x)
            } else
                p.push(CI(e, p, a.length, f))
        }
        let m = [];
        for (let f = 0; f <= e.getReturnIndex(); f++)
            if (e.getInstruction(f).type === 2) {
                let x = rf(e.argNames.length);
                x[f] = !0,
                m.push(x)
            } else
                m.push(CI(e, m, e.argNames.length, f));
        let d = {
            listAccessDependencyTable: p,
            listAccesses: a,
            listStatisticsTable: u
        }, y;
        for (let f = i + 1; f <= e.getReturnIndex(); f++) {
            let h = e.getInstruction(f);
            switch (h.type) {
            case 37:
                {
                    if (h.symbol === "exp") {
                        let W = h.args[0]
                          , oe = aR(d, W);
                        if (oe === void 0) {
                            Oc(e, m, y, f);
                            break
                        }
                        let {listStatistics: te, listAccessIndex: st} = oe
                          , Tt = Ag(sR(e), f, W, st, te);
                        Tt ? y = [Tt] : Oc(e, m, y, f)
                    }
                    break
                }
            case 12:
            case 13:
                {
                    let[W,oe] = h.args
                      , te = aR(d, oe);
                    if (te === void 0 || a3(d, W)) {
                        Oc(e, m, y, f);
                        break
                    }
                    let {listStatistics: st, listAccessIndex: Tt} = te
                      , ye = d6(sR(e), f, Tt, st);
                    ye ? y = [ye] : Oc(e, m, y, f);
                    break
                }
            case 10:
                if (y && y.length > 1) {
                    Oc(e, m, y, f);
                    break
                }
                let x = y && y.length > 0 ? y[0] : sR(e), [T,P] = h.args, C = x.isLazy ? T : x.valueMap[T], S = x.isLazy ? P : x.valueMap[P], E = x.chunk.getInstruction(C), M = x.chunk.getInstruction(S), _, U, Q;
                if (E.type === 37)
                    _ = T,
                    Q = E,
                    U = P;
                else if (M.type === 37)
                    _ = P,
                    Q = M,
                    U = T;
                else {
                    Oc(e, m, y, f);
                    break
                }
                let K = aR(d, _);
                if (K === void 0 || a3(d, U)) {
                    Oc(e, m, y, f);
                    break
                }
                let {listAccessIndex: w, listStatistics: B} = K;
                if (Q.symbol === "exp") {
                    let W = f6(x, f, U, _, w, B);
                    if (W) {
                        y = W;
                        break
                    }
                } else if (u3(Q)) {
                    let W = m6(x, f, U, _, w);
                    if (W) {
                        y = [W];
                        break
                    }
                }
                Oc(e, m, y, f);
                break;
            default:
                {
                    Oc(e, m, y, f);
                    break
                }
            }
        }
        if (y === void 0 || y.length === 0)
            return;
        let g = [];
        for (let f of y)
            g.push({
                chunk: f.chunk,
                forwardParameterMap: f.forwardParameterMap,
                reverseParameterMap: f.reverseParameterMap
            });
        return g
    }
    function Oc(e, t, n, r) {
        if (n === void 0)
            return;
        let o = e.getInstruction(r);
        if (de(o))
            for (let i of n) {
                let {chunk: s, valueMap: a} = i
                  , u = []
                  , c = 0;
                for (let l of o.args) {
                    if (a[l] !== l) {
                        if (c += 1,
                        c > 1) {
                            n.length = 0;
                            return
                        }
                    } else {
                        let p = t[l];
                        for (let m = 0; m < p.length; m++)
                            if (p[m] && i.replacementMask[m]) {
                                n.length = 0;
                                return
                            }
                    }
                    u.push(a[l])
                }
                a[r] = c > 0 ? Nd(s, o, u) : r
            }
        else
            for (let i of n)
                i.valueMap[r] = r
    }
    function aR(e, t) {
        let {listAccessDependencyTable: n, listAccesses: r, listStatisticsTable: o} = e, i, s = n[t];
        for (let a = 0; a < s.length; a++)
            if (s[a]) {
                if (i)
                    return;
                i = {
                    listAccessIndex: r[a],
                    listStatistics: o[a]
                }
            }
        return i
    }
    function a3(e, t) {
        let {listAccessDependencyTable: n} = e
          , r = n[t];
        for (let o of r)
            if (o)
                return !0;
        return !1
    }
    function uR(e, t) {
        let n = [];
        for (let i = 0; i <= t; i++)
            if (e.getInstruction(i).type === 2) {
                let a = rf(e.argNames.length);
                a[i] = !0,
                n.push(a)
            } else
                n.push(CI(e, n, e.argNames.length, i));
        let r, o = n[t];
        for (let i = 0; i < o.length; i++)
            if (o[i]) {
                if (r !== void 0)
                    return;
                r = i
            }
        return r
    }
    function m6(e, t, n, r, o) {
        let i = e.chunk
          , s = uR(i, n);
        if (s === void 0)
            return;
        let a = cR(e, n, s);
        if (a === void 0)
            return;
        let u = i.getInstruction(r)
          , c = u.args[0];
        if (a = l3(a, c, o),
        a === void 0)
            return;
        let {chunk: l, valueMap: p} = a
          , m = l.getInstruction(p[c]);
        if (m.type !== 8)
            return;
        let d = m.args[1]
          , y = l.getInstruction(m.args[0]);
        if (y.type !== 10)
            return;
        let[g,f] = y.args
          , h = s
          , x = d
          , T = g
          , P = f
          , C = l.Multiply([T, P])
          , S = l.NativeFunction("cos", [C])
          , E = l.NativeFunction("sin", [C])
          , M = u.symbol === "sin" ? l.Add([l.Multiply([h, E]), l.Multiply([x, S])]) : l.Subtract([l.Multiply([h, S]), l.Multiply([x, E])]);
        p[t] = M;
        function _(K) {
            let w = a.forwardParameterMap(K)
              , B = w[s]
              , W = w[d]
              , oe = B * Math.cos(W)
              , te = B * Math.sin(W);
            return w[s] = oe,
            w[d] = te,
            w
        }
        function U(K) {
            let w = K.slice()
              , B = K[s]
              , W = K[d]
              , oe = Wo(B, W)
              , te = Math.atan2(W, B);
            return w[s] = oe,
            w[d] = te,
            a.reverseParameterMap(w)
        }
        let Q = a.replacementMask.slice();
        return Q[s] = !0,
        Q[g] = !0,
        Q[d] = !0,
        {
            chunk: l,
            forwardParameterMap: _,
            reverseParameterMap: U,
            valueMap: p,
            replacementMask: Q,
            isLazy: !1
        }
    }
    function d6(e, t, n, r) {
        let o = e.chunk
          , i = o.getInstruction(t)
          , [s,a] = i.args
          , u = o.getInstruction(s);
        if (u.type === 1 && u.valueType === b && L(u.value) > 0) {
            let x = vI(e)
              , {chunk: T, valueMap: P} = x
              , C = T.Multiply([T.NativeFunction("ln", [P[s]]), P[a]]);
            return P[a] = C,
            P[t] = T.NativeFunction("exp", [C]),
            Ag(x, t, a, n, r) || x
        }
        let c = uR(o, s);
        if (c === void 0)
            return;
        let l = cR(e, s, c);
        if (l === void 0)
            return;
        let {chunk: p, valueMap: m} = l
          , d = p.Multiply([m[s], m[a]]);
        m[a] = d,
        m[t] = p.NativeFunction("exp", [d]);
        function y(x) {
            let T = l.forwardParameterMap(x)
              , P = T[c]
              , C = Math.log(P);
            return T[c] = C,
            T
        }
        function g(x) {
            let T = x.slice()
              , P = T[c]
              , C = Math.exp(P);
            return T[c] = C,
            l.reverseParameterMap(T)
        }
        let f = l.replacementMask.slice();
        f[c] = !0;
        let h = {
            chunk: p,
            forwardParameterMap: y,
            reverseParameterMap: g,
            isLazy: !1,
            valueMap: m,
            replacementMask: f
        };
        return Ag(h, t, a, n, r) || h
    }
    function f6(e, t, n, r, o, i) {
        if (!e.isLazy && e.didShiftScale)
            return;
        let s = e.isLazy ? e : s3(e)
          , a = e.chunk
          , u = uR(a, n);
        if (u === void 0)
            return;
        let c = cR(e, n, u);
        if (c === void 0)
            return;
        let {chunk: l, valueMap: p} = c
          , m = l.getInstruction(p[r]).args[0]
          , d = l.Add([m, p[n]]);
        p[n] = d,
        p[t] = l.NativeFunction("exp", [d]);
        function y(S) {
            let E = c.forwardParameterMap(S)
              , M = E[u]
              , _ = Math.log(M);
            return E[u] = _,
            E
        }
        function g(S) {
            let E = S.slice()
              , M = E[u]
              , _ = Math.exp(M);
            return E[u] = _,
            c.reverseParameterMap(E)
        }
        function f(S) {
            let E = c.forwardParameterMap(S)
              , M = E[u]
              , _ = Math.log(-M);
            return E[u] = _,
            E
        }
        function h(S) {
            let E = S.slice()
              , M = E[u]
              , _ = -Math.exp(M);
            return E[u] = _,
            c.reverseParameterMap(E)
        }
        let x = c.replacementMask.slice();
        x[u] = !0;
        let T = vI(s);
        T.valueMap[t] = T.chunk.Multiply([T.valueMap[n], T.valueMap[r]]);
        let P = {
            chunk: l,
            forwardParameterMap: y,
            reverseParameterMap: g,
            isLazy: !1,
            valueMap: p,
            replacementMask: x
        }
          , C = s3(P);
        return C.forwardParameterMap = f,
        C.reverseParameterMap = h,
        P = Ag(P, t, n, o, i) || P,
        C = Ag(C, t, n, o, i) || C,
        C.valueMap[t] = C.chunk.Negative([C.valueMap[t]]),
        [T, P, C]
    }
    function Ag(e, t, n, r, o) {
        let i = y6(e, n, r, o);
        if (i !== void 0)
            return i.valueMap[t] = i.chunk.NativeFunction("exp", [i.valueMap[n]]),
            i
    }
    function y6(e, t, n, r) {
        let o = l3(e, t, n);
        if (o === void 0)
            return;
        let {chunk: i, valueMap: s} = o
          , a = i.getInstruction(s[t]);
        if (a.type !== 8)
            return;
        let u = a.args[1]
          , c = i.getInstruction(a.args[0]);
        if (c.type !== 10)
            return;
        let[l,p] = c.args
          , {min: m, max: d} = r
          , y = d - m
          , g = .5 * (d + m)
          , f = i.Divide([i.Subtract([p, i.Constant(g)]), i.Constant(y)])
          , h = i.Add([i.Multiply([l, f]), u]);
        s[t] = h;
        function x(P) {
            let C = o.forwardParameterMap(P)
              , S = C[l]
              , E = C[u]
              , M = S * y
              , _ = E + g * S;
            return C[l] = M,
            C[u] = _,
            C
        }
        function T(P) {
            let C = P.slice()
              , S = P[l]
              , E = P[u]
              , M = S / y
              , _ = E - M * g;
            return C[l] = M,
            C[u] = _,
            o.reverseParameterMap(C)
        }
        return {
            chunk: i,
            forwardParameterMap: x,
            reverseParameterMap: T,
            isLazy: !1,
            valueMap: s,
            replacementMask: o.replacementMask,
            didShiftScale: !0
        }
    }
    function cR(e, t, n) {
        let r = e.chunk
          , o = Eo(r, n, {
            allowRestriction: !1,
            allowClosedBlockReferences: !1
        });
        if (Pn(o, t) !== 1)
            return;
        let i = ua(o, t)
          , [s,a] = gr(i, t);
        if (a === void 0)
            return;
        let u = i.newChunk.getInstruction(s);
        if (u.type !== 1 || u.valueType !== b)
            return;
        let c = i.newChunk.getInstruction(a);
        if (c.type !== 1 || c.valueType !== b)
            return;
        let l = vI(e)
          , {chunk: p, valueMap: m} = l
          , d = L(u.value)
          , y = L(c.value);
        m[t] = n;
        function g(x) {
            let T = l.forwardParameterMap(x)
              , P = T[n]
              , C = d + y * P;
            return T[n] = C,
            T
        }
        function f(x) {
            let T = x.slice()
              , C = (T[n] - d) / y;
            return T[n] = C,
            l.reverseParameterMap(T)
        }
        let h = l.replacementMask.slice();
        return h[n] = !0,
        {
            chunk: p,
            forwardParameterMap: g,
            reverseParameterMap: f,
            isLazy: !1,
            valueMap: m,
            replacementMask: h
        }
    }
    function l3(e, t, n) {
        let r = e.chunk
          , o = e.isLazy ? t : e.valueMap[t]
          , i = Eo(r, n, {
            allowRestriction: !1,
            allowClosedBlockReferences: !0
        });
        if (Pn(i, o) !== 1)
            return;
        e.isLazy && (i = Eo(r.copy().reopenFinalBlock(), n, {
            allowRestriction: !1,
            allowClosedBlockReferences: !1
        }));
        let s = ua(i, o)
          , [a,u] = gr(s, o);
        if (u === void 0)
            return;
        let c = s.newChunk
          , l = Math.max(u, a)
          , p = [];
        for (let ee = 0; ee <= l; ee++)
            if (c.getInstruction(ee).type === 2) {
                let ne = rf(c.argNames.length);
                ne[ee] = !0,
                p.push(ne)
            } else
                p.push(CI(c, p, c.argNames.length, ee));
        let m, d;
        for (let ee = 0; ee < r.argNames.length; ee++)
            if (p[u][ee])
                if (m === void 0)
                    m = ee;
                else
                    return;
            else if (p[a][ee])
                if (d === void 0)
                    d = ee;
                else
                    return;
        if (m === void 0 || d === void 0)
            return;
        let y = Eo(c, m, {
            allowRestriction: !1,
            allowClosedBlockReferences: !1
        });
        if (Pn(y, u) !== 1)
            return;
        let g = Eo(c, d, {
            allowRestriction: !1,
            allowClosedBlockReferences: !1
        });
        if (Pn(g, a) !== 1)
            return;
        let f = ua(y, u)
          , h = ua(g, a)
          , [x,T] = gr(f, u)
          , P = f.newChunk.getInstruction(x);
        if (P.type !== 1 || P.valueType !== b)
            return;
        let C = f.newChunk.getInstruction(T);
        if (C.type !== 1 || C.valueType !== b)
            return;
        let S = vI(e)
          , {chunk: E, valueMap: M} = S
          , _ = E.Add([E.Multiply([m, n]), d]);
        M[t] = _;
        let U = c.copy();
        U.List([u, a]);
        let Q = U.getCompiledFunction().fn;
        function K(ee) {
            let k = S.forwardParameterMap(ee)
              , [ne,Ne] = Q.apply(null, k);
            return k[m] = ne,
            k[d] = Ne,
            k
        }
        let w = L(P.value)
          , B = L(C.value)
          , [W,oe] = gr(h, a)
          , te = h.newChunk.copy();
        te.List([W, oe]);
        let st = te.getCompiledFunction().fn;
        function Tt(ee) {
            let k = ee.slice()
              , ne = ee[m]
              , Ne = ee[d]
              , _e = (ne - w) / B
              , gt = ee.slice();
            gt[m] = _e,
            gt.splice(d, 1);
            let[At,Fi] = st.apply(null, gt)
              , Cr = (Ne - At) / Fi;
            return k[m] = _e,
            k[d] = Cr,
            S.reverseParameterMap(k)
        }
        let ye = S.replacementMask.slice();
        return ye[m] = !0,
        ye[d] = !0,
        {
            chunk: E,
            forwardParameterMap: K,
            reverseParameterMap: Tt,
            isLazy: !1,
            valueMap: M,
            replacementMask: ye
        }
    }
    function CI(e, t, n, r) {
        let o = e.getInstruction(r)
          , i = rf(n);
        if (!de(o))
            return i;
        for (let s of o.args) {
            let a = t[s];
            for (let u = 0; u < a.length; u++)
                i[u] = i[u] || a[u]
        }
        return i
    }
    function rf(e) {
        let t = [];
        for (let n = 0; n < e; n++)
            t.push(!1);
        return t
    }
    function g6(e) {
        let t = [];
        for (let n = 0; n < e; n++)
            t.push(n);
        return t
    }
    function u3(e) {
        return e.type === 37 && (e.symbol === "sin" || e.symbol === "cos")
    }
    function P3(e, t) {
        try {
            return x6(e, t)
        } catch (n) {
            return n instanceof O.Error ? n : F(n)
        }
    }
    var of = {
        coerceToNumber: "all-except-complex"
    }
      , lR = {
        ...of,
        wrapInList: !0
    };
    function p3(e) {
        return e === b || e === Y || e === N || e === ke
    }
    function h6(e) {
        return !!e.tableRegressionData
    }
    function b6(e, t) {
        return e === He || t === He ? !1 : p3(e) && p3(t)
    }
    function x6(e, t) {
        let {policy: n, frame: r, lastExportFrame: o} = e
          , i = ja(t._lhs, n, r, of)
          , s = ja(t._rhs, n, r, of);
        if (i.isError)
            throw i;
        if (s.isError)
            throw s;
        if (!b6(i.valueType, s.valueType))
            throw ME([se(i.valueType), se(s.valueType)]);
        let a = ja(t._difference, n, r, lR);
        if (a.isError)
            throw a;
        for (let S of a.getDependencies())
            if (!n.validRegressionParameter(S))
                throw av(S);
        let u = a.valueType
          , l = !h6(t) ? d3(a.getDependencies(), t.userData.regressionParameters, o) : d3(a.getDependencies(), {}, {})
          , {parameters: p, scaleFactors: m, residuals: d, isLinear: y, parameterWarning: g, displayPrecision: f} = I3(l, a, i)
          , h = {
            policy: n,
            frame: r
        }
          , x = m3(h, t, p)
          , T = Oo.NONE;
        u === Y && (T = v6(t, i, x));
        let P;
        if (t.userData.isLogModeRegression && (T === Oo.LOGLIN || T === Oo.LOGLOG)) {
            let S = ja(t._logDifference, n, r, lR);
            if (S.isError)
                throw S;
            let E = ja(t._logLhs, n, r, lR);
            if (E.isError)
                throw E;
            ({parameters: p, isLinear: y, parameterWarning: g, displayPrecision: f} = I3(l, S, i)),
            x = m3(h, t, p),
            d = b3(h, t._difference, p);
            let M = b3(h, t._logDifference, p);
            P = g3(t, E, x, M, t.userData.isLogModeRegression, T, u)
        } else
            P = g3(t, i, x, d, t.userData.isLogModeRegression, T, u);
        let C = {
            isModelValid: !!x.uniqueRHSNumberList,
            shouldSuggestLogMode: T !== Oo.NONE,
            isLinear: y,
            scaleFactors: m,
            displayPrecision: f,
            parameterWarning: g
        };
        return {
            concreteDifference: a,
            plannedOpts: C,
            statistics: P,
            residuals: d,
            model: x,
            parameters: p
        }
    }
    function S3(e, t, n) {
        let {residualVariable: r, tableStatements: o} = e
          , {concreteDifference: i, plannedOpts: s, statistics: a, residuals: u, model: c, parameters: l} = n
          , p = i.valueType
          , m = C6(t, r, o, u);
        return t.userData.residualVariable = go(r),
        new O.OptimizedRegression(l,dt({
            valueType: p,
            value: u
        }),a,c.substituted,{
            ...s,
            residualVariable: r,
            residualSuggestionId: m
        })
    }
    function T6(e) {
        return !e.startsWith("dcgcolumnstmt")
    }
    function E3(e, t, n) {
        function r(a) {
            var u;
            return !n.has(a) && !((u = t.get(a)) != null && u.some(T6))
        }
        if (e.userData && e.userData.residualVariable) {
            let a = Bs(e.userData.residualVariable);
            if (r(a))
                return a
        }
        let o = e.getDependencies().filter(a => a[0] !== "_" && !a.startsWith("regressionparameter_") && !a.startsWith("idref_")), i;
        for (let a of o) {
            let u = a.match(/_(.*)/);
            if (u && (i = "e_" + u[1],
            r(i)))
                return i
        }
        let s = 1;
        for (; ; ) {
            if (i = "e_" + s,
            r(i))
                return i;
            s++
        }
    }
    function m3({policy: e, frame: t}, n, r) {
        let o = n._rhs.getDependencies(), i, s;
        for (let p of o) {
            if (r.hasOwnProperty(p))
                continue;
            let m = t[p];
            if (!m || m.type === "Placeholder")
                continue;
            m.type === "Assignment" && (m = m._expression);
            let d = ja(m, e, t, of);
            if (!d.isError && ur(d.valueType, Y)) {
                if (i !== void 0) {
                    i = void 0,
                    s = void 0;
                    break
                }
                d.getDependencies().length === 0 && (i = p,
                s = d)
            }
        }
        let a = Fn(t);
        i !== void 0 && (a[i] = void 0);
        let u = ja(n._rhs, e, a, of)
          , c = Fn(a);
        for (let p of ue(r))
            c[p] = r[p];
        let l = ja(n._rhs, e, c, of);
        return {
            node: u,
            substituted: l,
            uniqueRHSNumberList: s
        }
    }
    function d3(e, t, n) {
        let r = [];
        if (t || (t = {}),
        n || (n = {}),
        !e.every(o => o in n || o in t))
            return e.map(o => 1);
        for (let o of e) {
            let i = go(o)
              , s = n[o];
            s && isFinite(s.asValue()) ? r.push(+s.asValue()) : t.hasOwnProperty(i) && isFinite(+t[i]) ? r.push(+t[i]) : r.push(1)
        }
        return r
    }
    function dR(e, t) {
        switch (t) {
        case Y:
            return e;
        case ke:
            return function(...r) {
                let o = e.apply(void 0, r);
                return I6(o)
            }
            ;
        default:
            throw F("Regression with invalid value type.")
        }
    }
    function f3(e, t) {
        switch (t) {
        case Y:
            return e;
        case ke:
            return P6(e);
        default:
            throw F("Regression with invalid value type.")
        }
    }
    function I6(e) {
        let t = [];
        for (let[n,r] of e)
            t.push(n, r);
        return t
    }
    function P6(e) {
        let t = [];
        for (let[n,r] of e)
            t.push(n, r);
        return t
    }
    function y3(e, t) {
        let n = t.getDependencies()
          , r = t.getCompiledFunction(n).fn
          , o = t.valueType
          , i = dR(r, o);
        if (n.length) {
            let s = t.findLinearSubset(n)
              , a = s.every(c => c)
              , u = [];
            for (let c of n) {
                let l = t.takeDerivative(c).getCompiledFunction(n).fn;
                u.push(dR(l, o))
            }
            if (a) {
                let c = n.map( () => be(0, 1))
                  , l = t.interpretWithParameters(c)
                  , p = f3(l, o)
                  , m = [];
                for (let f of n) {
                    let h = t.takeDerivative(f).interpretWithParameters(c);
                    m.push(f3(h, o))
                }
                let d = rR(p, m);
                if (d) {
                    let f = t.interpretWithParameters(d);
                    return {
                        solution: d,
                        scaleFactors: oR(m),
                        residuals: f,
                        MSE: MI(f, o),
                        isLinear: a
                    }
                }
                let {solution: y, MSE: g} = nR(i, iR(i, u));
                return {
                    solution: y,
                    scaleFactors: oR(m),
                    residuals: r.apply(void 0, y),
                    MSE: x3(g, o),
                    isLinear: a
                }
            } else {
                let c = [];
                for (let d of n)
                    c.push(t.boundDomain(d));
                let l = {
                    linearSubset: s,
                    bounds: c,
                    preferredInitialGuess: e
                }
                  , {solution: p, MSE: m} = nR(i, o3(i, u, l));
                return {
                    solution: p,
                    residuals: r.apply(void 0, p),
                    MSE: x3(m, o),
                    isLinear: a
                }
            }
        } else
            return {
                solution: [],
                residuals: t.interpretWithParameters([]),
                MSE: C3(r, [], o),
                isLinear: !0
            }
    }
    function pR(e, t) {
        let n = {}
          , r = t.getDependencies();
        for (let o = 0; o < r.length; o++) {
            let i = new O.Constant(e[o]);
            n[r[o]] = i
        }
        return n
    }
    function g3(e, t, n, r, o, i, s) {
        let a = MI(r, s);
        if (!isFinite(a))
            throw uv();
        if (t.getDependencies().length > 0)
            return {
                RMSE: Math.sqrt(a)
            };
        let u = M6(t.asValue(), t.valueType);
        if (t.getDependencies().length || !isFinite(u) || u <= 0 || !e.isLhsSimple)
            return {
                RMSE: Math.sqrt(a)
            };
        {
            let c = 1 - a / u
              , l = S6(t, n, o, i, a);
            return l !== void 0 ? {
                r: l,
                rsquared: l * l
            } : {
                Rsquared: c
            }
        }
    }
    function h3(e) {
        if (!qs(e))
            return NaN;
        let t = {
            valueType: e.valueType,
            value: e.asCompilerValue()
        }
          , {value: n, valueType: r} = t;
        switch (r) {
        case b:
            return n;
        case N:
            return L(n[1]) === 0 ? n[0] : NaN;
        default:
            return NaN
        }
    }
    function S6(e, t, n, r, o) {
        if (!t.uniqueRHSNumberList)
            return;
        let i = []
          , s = []
          , a = n && (r === Oo.LINLOG || r === Oo.LOGLOG);
        Vo.eachArgs([t.uniqueRHSNumberList, e], l => {
            let p = h3(l[0])
              , m = h3(l[1]);
            i.push(a ? Math.log(L(p)) : p),
            s.push(m)
        }
        );
        let u = Hh(i.map(L), s.map(L));
        if (!isFinite(u))
            return;
        let c = E6(i, s);
        if (Bi(c.MSE, o, 8))
            return u
    }
    function E6(e, t) {
        let n = t
          , r = [e.map(a => Ii(a)), e.map( () => be(-1, 1))]
          , o = rR(n, r);
        if (o) {
            let[a,u] = o
              , c = [];
            for (let l = 0; l < t.length; l++)
                c.push(ki(t[l], Pi(Zr(a, e[l]), u)));
            return {
                solution: o,
                MSE: MI(c, Y)
            }
        }
        function i(a, u) {
            let c = [];
            for (let l = 0; l < e.length; l++)
                c.push(L(t[l]) - (a * L(e[l]) + u));
            return c
        }
        return iR(i, [function() {
            return e.map(a => -L(a))
        }
        , function() {
            return e.map( () => -1)
        }
        ])
    }
    function C6(e, t, n, r) {
        var a, u;
        let o = e._rhs.getDependencies(), i;
        (a = e.tableRegressionData) != null && a.tableId && (i = (u = e.tableRegressionData) == null ? void 0 : u.tableId);
        for (let c in n) {
            let l = n[c];
            if (l.columns.length === 0)
                continue;
            let p = l.columns[0];
            i === void 0 && bc(p) && Ha(p.header) && o.includes(p.header._symbol) && (i = c);
            for (let m = 1; m < l.columns.length; m++)
                if (l.columns[m].getDependencies().includes(t))
                    return
        }
        if (!r.some(c => Array.isArray(c) && L(c[1]) !== 0))
            return i
    }
    function mR(e, t) {
        let n = e.length
          , r = e[0]
          , o = t[0]
          , i = e[n - 1]
          , s = t[n - 1];
        if (!isFinite(r) || !isFinite(i) || !isFinite(o) || !isFinite(s) || s - o === 0)
            return !1;
        let a = i - r;
        if (a === 0)
            return !1;
        for (let u = 1; u < n - 1; u++) {
            let c = e[u]
              , l = t[u]
              , p = (s * (c - r) + o * (i - c)) / a;
            if (!Bi(l, p, 5))
                return !1
        }
        return !0
    }
    var Oo = {
        NONE: 0,
        LOGLIN: 1,
        LOGLOG: 2,
        LINLOG: 3
    };
    function v6(e, t, n) {
        if (!e.isLhsSimple || !n.uniqueRHSNumberList || ae(t.valueType, N))
            return Oo.NONE;
        let r = n.substituted;
        if (r.isError || r.valueType !== b)
            return Oo.NONE;
        let o = r.getDependencies();
        if (o.length !== 1 || n.node.type === "IRExpression" && isFinite(n.node.polynomialOrder(o[0])))
            return Oo.NONE;
        let i = r.getCompiledFunction(o).fn
          , s = n.uniqueRHSNumberList;
        if (r.valueType !== b)
            return Oo.NONE;
        let a = s.mapElements(m => +m.asValue());
        if (a.length < 3)
            return Oo.NONE;
        a.sort( (m, d) => m - d);
        let u = a.map(i)
          , c = u.map(Math.log)
          , l = a.map(Math.log)
          , p = !0;
        return Vo.wrap(t).eachElement(m => {
            isFinite(Math.log(+m.asValue())) || (p = !1)
        }
        ),
        mR(a, c) && p ? Oo.LOGLIN : mR(l, c) && p ? Oo.LOGLOG : mR(l, u) ? Oo.LINLOG : Oo.NONE
    }
    function b3({policy: e, frame: t}, n, r) {
        let o = Fn(t);
        for (let a of ue(r))
            o[a] = r[a];
        let i = Kd({
            policy: e,
            frame: o,
            wrapInList: !0
        }, n)
          , s = i.getError();
        if (s)
            throw s;
        return i.asCompilerValue()
    }
    function MI(e, t) {
        switch (t) {
        case Y:
            {
                let n = 0;
                for (let r of e) {
                    let o = L(r);
                    n += o * o
                }
                return n / e.length
            }
        case ke:
            {
                let n = 0;
                for (let[r,o] of e) {
                    let i = L(r);
                    n += i * i;
                    let s = L(o);
                    n += s * s
                }
                return n / e.length
            }
        default:
            throw F("Regression with invalid value type.")
        }
    }
    function M6(e, t) {
        switch (t) {
        case b:
        case N:
            return 0;
        case Y:
            return zf(e);
        case ke:
            {
                let n = e
                  , r = 0
                  , o = 0;
                for (let[u,c] of n)
                    r += u,
                    o += c;
                let i = r / n.length
                  , s = o / n.length
                  , a = 0;
                for (let[u,c] of n) {
                    let l = L(u) - i;
                    a += l * l;
                    let p = L(c) - s;
                    a += p * p
                }
                return a / n.length
            }
        default:
            throw F("Regression with invalid value type.")
        }
    }
    function C3(e, t, n) {
        let r = e.apply(void 0, t);
        return MI(r, n)
    }
    function x3(e, t) {
        switch (t) {
        case Y:
            return e;
        case ke:
            return e * Math.SQRT2;
        default:
            throw F("Regression with invalid value type.")
        }
    }
    function T3(e, t, n, r) {
        let o = 5;
        if (!r)
            return o;
        let i = t.apply(void 0, e);
        for (let s = 4; s < 15; s++) {
            let a = e.map(l => parseFloat(l.toPrecision(s)))
              , u = t.apply(void 0, a)
              , c = 0;
            for (let l = 0; l < i.length; l++) {
                let p = Math.abs(i[l] - u[l]);
                p > c && (c = p)
            }
            if (c < n) {
                o = s;
                break
            }
        }
        return o
    }
    function D6(e) {
        let t = 0;
        if (X(e == null ? void 0 : e.valueType)) {
            let n = e.asValue()
              , r = qh(n)
              , o = Gh(n);
            t = (o < 0 && 0 < r ? r - o : Math.max(Math.abs(o), Math.abs(r))) / 500
        }
        return t
    }
    function I3(e, t, n) {
        let r, o, i = t._chunk;
        i && (o = c3(i));
        let s = X(n == null ? void 0 : n.valueType)
          , a = D6(n);
        if (!o || o.length === 0) {
            t = t.deriveRegressionRestrictions(),
            r = y3(e, t);
            let P = t.getCompiledFunction(t.getDependencies()).fn
              , C = T3(r.solution.map(S => L(S)), P, a, s);
            return {
                parameters: pR(r.solution, t),
                scaleFactors: r.scaleFactors ? pR(r.scaleFactors, t) : void 0,
                displayPrecision: C,
                residuals: r.residuals,
                isLinear: r.isLinear,
                parameterWarning: !1
            }
        }
        let u = t.getDependencies(), c = t.valueType, l = t.getCompiledFunction(u).fn, p = dR(l, c), m = 1 / 0, d = {}, y, g = !1, f = 1 / 0, h = 5;
        for (let P of o) {
            let C = new An(P.chunk);
            if (C = C.deriveRegressionRestrictions(),
            r = y3(P.forwardParameterMap(e), C),
            r.MSE < m) {
                let S = P.reverseParameterMap(r.solution.map(M => L(M)))
                  , E = C3(l, S, c);
                if (d && (!isFinite(E) || E >= m)) {
                    isFinite(E) || (g = !0,
                    r.MSE < f && (f = r.MSE));
                    continue
                }
                m = r.MSE,
                d = pR(S, t),
                y = p.apply(void 0, S),
                h = T3(S, p, a, s)
            }
        }
        let x = Object.keys(d).length
          , T = s ? n.asValue().length : 1;
        return {
            parameters: d,
            displayPrecision: h,
            residuals: y,
            isLinear: !1,
            parameterWarning: g && f < m && T > x
        }
    }
    var j = class {
        constructor(t, n, r, o) {
            this.policy = t,
            this.rawTree = r,
            this.concreteTree = o,
            this.evaluationState = k2(t, n, r, o)
        }
        graph(t, n) {
            return vV(this.rawTree, this.policy, this.concreteTree, t, n)
        }
        getGraphMode() {
            return this.policy.graphingEnabled() ? this.rawTree.getGraphMode(this.policy, this.concreteTree) : 10
        }
        getGraphInfo() {
            return co(this.rawTree, this.policy, this.concreteTree)
        }
        shouldIntersect() {
            if (!this.evaluationState.is_graphable || !this.rawTree.userData.shouldGraph || !ps.pointsOfInterest)
                return !1;
            let t = this.getGraphMode();
            return t === 1 || t === 2
        }
    }
    ;
    function sf(e, t, n, r) {
        switch (e.type) {
        case "Assignment":
            return w6(e, t, n, r);
        case "Equation":
        case "CallAssignment":
        case "Comparator['<']":
        case "Comparator['>']":
        case "Comparator['<=']":
        case "Comparator['>=']":
        case "Comparator['=']":
            return DI(e, t, n);
        case "ComparatorChain":
            return k6(e, t, n);
        case "DoubleInequality":
            return U6(e, t, n);
        case "FunctionCall":
        case "SeededFunctionCall":
            return N6(e, t, n, r);
        case "FunctionDefinition":
            return A6(e, t, n);
        case "Identifier":
        case "Ans":
            return R6(e, t, n, r);
        case "Image":
            return Z6(e, t, n, r);
        case "MovablePoint":
        case "ParenSeq":
            return $6(e, t, n, r);
        case "RecursiveFunctionBaseCase":
            return L6(e, t, n);
        case "Slider":
            return X6(e, t, n);
        case "Table":
            return Y6(e, t, n);
        case "TableColumn":
            return B6(e, t, n);
        case "Ticker":
            return G6(e, t, n);
        case "Viewport":
            return q6(e, t, n);
        case "Stats":
            return H6(e, t, n);
        case "Histogram":
        case "DotPlot":
        case "BoxPlot":
            return z6(e, t, n);
        case "Placeholder":
            throw new Error("Unexpected placeholder");
        default:
            return e instanceof Z ? O6(e, t, n, r) : _6(e, t, n, r)
        }
    }
    function _6(e, t, n, r) {
        return di(e) ? wi(t, n, e) : new j(t,n,e,pe(e, t, n))
    }
    function _I(e, t, n, r) {
        var u;
        if (r.isError)
            return new j(e,t,n,r);
        if (!e.areAllScalesLinear() && !tp(r.valueType)) {
            let c = Am(se(r.valueType));
            return c.setCursorContext(r.getCursorContext()),
            new j(e,t,n,c)
        }
        let o = Pa(e, r), i = r.getDependencies(), s, a = ae(r.valueType, N) && o.some(c => e.validParametricVariable(c));
        switch (i.length > 0 && !a && (r = r.coerceToNumericIfPossibleWithTolerance()),
        r.valueType) {
        case Rn:
        case gi:
        case He:
            {
                s = r;
                break
            }
        case bn:
        case Ao:
        case Ee:
        case Tr:
        case he:
        case hi:
        case ce:
        case mo:
        case Ce:
        case bi:
        case Ae:
        case fo:
        case Ie:
        case xi:
        case Oe:
        case Ar:
        case Se:
        case wr:
        case we:
        case Ks:
        case pt:
        case De:
        case Dr:
        case en:
        case Gi:
        case qe:
        case qi:
        case lr:
        case Zo:
        case Lr:
        case ea:
        case cr:
        case hu:
        case Pt:
        case bu:
        case $t:
        case xu:
        case wt:
        case Tu:
        case Kt:
        case Cu:
        case Qt:
        case Iu:
        case Ht:
        case Pu:
        case an:
        case Su:
        case Yt:
        case Eu:
        case pn:
        case mn:
        case Du:
        case _u:
        case zn:
        case Mu:
        case qn:
        case vu:
            !e.is3dPolicy() && (r.valueType === en || r.valueType === Gi) ? s = Kc(en) : !e.is3dPolicy() && (r.valueType === qe || r.valueType === qi) ? s = Kc(qe) : o.length ? s = xn(n.getSliderVariables(e, r)).setDependencies(o) : s = r;
            break;
        case R:
        case G:
        case zt:
        case to:
        case N:
        case ke:
            if (!e.is3dPolicy() && (r.valueType === G || r.valueType === to))
                r.isTypedConstant && xI(r.valueType, n, e) ? s = r : s = Kc(G);
            else if (o.length)
                if (e.validParametricVariables(o))
                    s = r;
                else {
                    let c = n.getSliderVariables(e, r);
                    s = xn(c).setDependencies(c)
                }
            else
                s = r;
            break;
        case zi:
        case Hi:
        case ws:
        case Fs:
        case yo:
        case Ls:
        case _a:
        case Oa:
        case Ra:
        case Aa:
        case ta:
        case Na:
            {
                !e.is3dPolicy() && (r.valueType === yo || r.valueType === ta) ? s = Kc(yo) : o.length === 0 ? s = r : s = xn(n.getSliderVariables(e, r)).setDependencies(o);
                break
            }
        case b:
        case Y:
            o.length === 0 ? s = r : o.length <= (e.is3dPolicy() ? 2 : 1) ? e.is3dPolicy() && i.length > o.length && !e.validImplicitVariables(i) ? s = xn(n.getSliderVariables(e, r)).setDependencies(i) : e.validExpressionVariables(o) ? s = r : (u = n.userData) != null && u.disallowAssignment ? s = xn(n.getSliderVariables(e, r)).setDependencies(i) : s = Cb(e.implicitDependency(o)).setDependencies(o) : e.validImplicitVariables(o) ? s = Cb().setDependencies(o) : s = xn(n.getSliderVariables(e, r)).setDependencies(i);
            break;
        default:
            s = F(`Programming error: unexpected value type ${r.valueType}`)
        }
        return To(s) && s.setCursorContext(r.getCursorContext()),
        s = $d(e, n, s),
        new j(e,t,n,s)
    }
    function D3(e) {
        return e._symbol === "chisqdist" ? new O.FunctionCall("pdf",[e, new O.Multiply([new O.Identifier("x"), new O.Restriction([new O["Comparator['>=']"]([new O.Identifier("x"), new O.Constant(0)])])])]) : new O.FunctionCall("pdf",[e, new O.Identifier("x")])
    }
    function R6(e, t, n, r) {
        if (e._symbol === Gr) {
            let s = fR(e, t, n, pe(e, t, n), r);
            if (s)
                return new j(t,n,e,s)
        }
        let o = pe(e, t, n, {
            coerceToNumber: "all-except-complex"
        })
          , i = _I(t, n, e, o);
        return di(e) && !yR(i) ? wi(t, n, e) : i
    }
    function N6(e, t, n, r) {
        let o;
        _g[e._symbol] && Yp(n, e).length === 0 && !t.is3dPolicy() ? o = pe(D3(e), t, n) : o = pe(e, t, n);
        let i = _I(t, n, e, o);
        if (di(e) && !yR(i))
            return wi(t, n, e);
        let s = e.getMoveStrategy(t, n, o, r);
        if (s) {
            let a = Dg(e, s)
              , u = o.asCompilerValue()
              , c = [new O.Constant(u[0]), new O.Constant(u[1])];
            return o = RI(o, G_(s) ? new Hu(c,s,a) : new Ya(c,s,a)),
            new j(t,n,e,o)
        }
        return i
    }
    function fR(e, t, n, r, o, i) {
        if (r.valueType !== N)
            return;
        let s = e.getMoveStrategy(t, n, r, o);
        if (!s)
            return;
        let a = Dg(i != null ? i : e, s)
          , u = r.asCompilerValue()
          , c = RI(r, new O.MovableComplexNumber([new O.Constant(u[0]), new O.Constant(u[1])],s,a));
        return c.metaData = e.metaData,
        c
    }
    function O6(e, t, n, r) {
        let o = _I(t, n, e, pe(e, t, n));
        if (di(e) && !yR(o))
            return wi(t, n, e);
        let i = fR(e, t, n, o.concreteTree, r);
        return i ? new j(t,n,e,i) : o
    }
    function A6(e, t, n) {
        var u;
        if (di(e))
            return wi(t, n, e);
        if (rt[e._symbol])
            return DI(e.asEquation(), t, n);
        let r = e._symbol.split("_")[0];
        if (((u = rt[r]) == null ? void 0 : u.type) === "Placeholder")
            return new j(t,n,e,Fm(e._symbol, r));
        let o = pe(e, t, n);
        if (o instanceof O.Error && !o.blocksExport && e._argSymbols.length === 1) {
            let c = Fn(n);
            c[e._argSymbols[0]] = new dn("identityTransformation");
            let l = pe(e._expression, t, c);
            if (l instanceof An && ae(l.valueType, we))
                return new j(t,n,e,l)
        }
        if (t.is3dPolicy() && t.assignmentForbidden(e._symbol))
            return new j(t,n,e,Ab(e._symbol));
        if (o.isError)
            return new j(t,n,e,o);
        let i = e._argSymbols
          , s = o.getDependencies();
        s.length > 0 && (o = o.coerceToNumericIfPossibleWithTolerance());
        let a = s.filter(c => i.indexOf(c) === -1);
        if (t.unplottablePolarFunction(e._symbol, s))
            return new j(t,n,e,jC());
        if (a.some(c => t.assignmentForbidden(c)))
            return new j(t,n,e,ay(a, e._symbol, i).setDependencies(s));
        if (a.length) {
            let c = e.getSliderVariables(t, o);
            return new j(t,n,e,xn(c).setDependencies(c))
        }
        return !t.areAllScalesLinear() && !tp(o.valueType) ? new j(t,n,e,Am(se(o.valueType))) : (o = $d(t, e, o),
        new j(t,n,e,o))
    }
    function w6(e, t, n, r) {
        if (di(e))
            return wi(t, n, e);
        let o = e._symbol;
        if (!t.validLHS(o))
            return new j(t,n,e,WC(o));
        if (rt.hasOwnProperty(o) || t.isComplexEnabled() && o === Gr)
            return DI(e.asEquation(), t, n);
        let i;
        if (e._expression instanceof _n && _g[e._expression._symbol] && Yp(n, e).length === 0 && !t.is3dPolicy())
            i = pe(D3(e._expression), t, n);
        else {
            let y = Fn(n);
            y[o] = t.validSolvedVariable(o) ? void 0 : Tp(),
            i = pe(e, t, y)
        }
        if (i.isError)
            return new j(t,n,e,i);
        if (!t.areAllScalesLinear() && !tp(i.valueType))
            return new j(t,n,e,Am(se(i.valueType)));
        if (e.isEquation(t, i))
            return DI(e.asEquation(), t, n);
        let s = i.valueType === bn || i.valueType === Ao;
        if (t.assignmentForbidden(o) && s) {
            let y = ZC(o).allowExport().setDependencies([o]);
            return new j(t,n,e,y)
        }
        let a = i.getDependencies()
          , u = Pa(t, i);
        if (!(e.getGraphMode(t, i) === 5 && !t.assignmentForbidden(o)) && (a.length > 0 || t.graphMode(o, u, a) !== 10)) {
            let y = i._chunk
              , g = y.getInstruction(y.getReturnIndex());
            if (g.valueType === N && Ye(g) && L(g.value[1]) !== 0)
                return new j(t,n,e,Vm("="));
            i = i.coerceToNumericIfPossibleWithTolerance()
        }
        let c = u.includes("x") || u.includes("y")
          , l = u.includes("r") || u.includes("theta");
        if (o === "r" && a.includes("phi")) {
            let y = u.includes("z") ? Tb() : UC();
            return new j(t,n,e,y)
        }
        if (o === "rho" && u.includes("z")) {
            let y = a.includes("phi") ? Tb() : kC();
            return new j(t,n,e,y)
        }
        let p = e.getSliderVariables(t, i, a);
        if (t.tooManySliderVariables(a, p, s) || c && l) {
            let y = xn(p).allowExport().setDependencies(p);
            return new j(t,n,e,y)
        }
        let m = fR(e._expression, t, n, i, r, e);
        if (m)
            return new j(t,n,e,m);
        let d = e.getMoveStrategy(t, n, i, r);
        if (d) {
            let y = Dg(e, d)
              , g = [i.slot(0), i.slot(1)];
            return i = RI(i, G_(d) ? new Hu(g,d,y) : new Ya(g,d,y)),
            new j(t,n,e,i)
        }
        return i = $d(t, e, i),
        new j(t,n,e,i)
    }
    function L6(e, t, n) {
        if (di(e))
            return wi(t, n, e);
        if (!e.specifiedArg.valid)
            return new j(t,n,e,e.specifiedArg.error);
        let r = pe(e, t, n);
        if (r.isError)
            return new j(t,n,e,r);
        let o = e._argSymbols
          , i = r.getDependencies();
        if (t.is3dPolicy() && t.assignmentForbidden(e._symbol))
            return new j(t,n,e,Ab(e._symbol));
        let s = i.filter(a => o.indexOf(a) === -1);
        if (s.includes(e.specifiedArg.argSymbol))
            return new j(t,n,e,LS(e.specifiedArg.argSymbol));
        for (let a of s)
            if (t.assignmentForbidden(a))
                return new j(t,n,e,wS(a));
        if (s.length) {
            let a = e.getSliderVariables(t, r);
            return new j(t,n,e,xn(a).setDependencies(a))
        }
        return !t.areAllScalesLinear() && !tp(r.valueType) ? new j(t,n,e,Am(se(r.valueType))) : new j(t,n,e,r)
    }
    function v3(e, t, n) {
        let r = pe(new dn(n), e, t);
        if (To(r))
            return r;
        if (r.isTypedConstant) {
            let o = Rr(r);
            if (o !== void 0)
                return o
        }
        return vE()
    }
    function F6(e) {
        return e[1] !== 0 && !isNaN(e[1])
    }
    function M3(e) {
        return e.valueType === ke && e.value.some(F6)
    }
    function V6(e, t, n) {
        let[r,o] = n.variables
          , i = v3(e, t, r)
          , s = v3(e, t, o);
        if (!("value"in i))
            return i;
        if (!("value"in s))
            return s;
        if (M3(i) || M3(s))
            return CE(se(N))
    }
    function _3(e, t, n, r) {
        if (!t.isCustomRegressionSupported() && !e.tableRegressionData)
            return Vv();
        if (di(e))
            return Lm("=");
        let o = {
            policy: t,
            frame: n,
            lastExportFrame: r
        };
        if (e.tableRegressionData) {
            let i = V6(t, n, e.tableRegressionData);
            if (i)
                return i
        }
        return P3(o, e)
    }
    function R3(e, t, n, r, o) {
        if (o instanceof O.Error)
            return new j(t,n,e,o);
        let i = S3(r, e, o);
        if (i.model instanceof O.IRExpression && (i.model = i.model.coerceToNumericIfPossibleWithTolerance()),
        e.tableRegressionData) {
            let s = ue(i.parameters).filter(a => !/^regressionparameter_/.test(a));
            if (s.length)
                return new j(t,n,e,xn(s))
        }
        return new j(t,n,e,i)
    }
    function B6(e, t, n) {
        return di(e) ? wi(t, n, e) : new j(t,n,e,qo(Dx, e, t, n))
    }
    function G6(e, t, n) {
        return di(e) ? wi(t, n, e) : new j(t,n,e,qo(HM, e, t, n))
    }
    function q6(e, t, n) {
        return new j(t,n,e,qo(Sw, e, t, n))
    }
    function z6(e, t, n) {
        if (di(e))
            return wi(t, n, e);
        if (!t.areAllScalesLinear()) {
            let i;
            switch (e.type) {
            case "BoxPlot":
                i = VE();
                break;
            case "DotPlot":
                i = FE();
                break;
            case "Histogram":
                i = LE();
                break;
            default:
                throw new Error(`Unexpected node type ${e}`)
            }
            return new j(t,n,e,i)
        }
        let r = e.type === "BoxPlot" ? qo(kM, e, t, n) : qo(UM, e, t, n)
          , o = r.getDependencies();
        return o.length ? new j(t,n,e,xn(e.getSliderVariables(t, r)).setDependencies(o)) : new j(t,n,e,r)
    }
    function H6(e, t, n) {
        if (di(e))
            return wi(t, n, e);
        let r = qo($M, e, t, n)
          , o = r.getDependencies();
        if (o.length)
            return new j(t,n,e,xn(e.getSliderVariables(t, r)).setDependencies(o));
        let i = new j(t,n,e,r);
        return r.type !== "Error" && (i.evaluationState.expression_type = A.STATS,
        i.evaluationState.stats_results = iS(r.args[0].asValue())),
        i
    }
    function DI(e, t, n) {
        if (di(e))
            return wi(t, n, e);
        if (e.getOperator() !== "=" && !ps.plotInequalities)
            return new j(t,n,e,Ib());
        let o = fV({
            policy: t,
            frame: n
        }, e);
        if (o.type === "Error")
            return new j(t,n,e,o);
        let i = Pa(t, o);
        if (o instanceof O.SolvedEquation && i.length) {
            let s = i.concat(o._symbol);
            if (!t.validImplicitVariables(s))
                return new j(t,n,e,Tp().setDependencies(s))
        }
        return e.getGraphMode(t, o) === 8 && !t.validImplicitVariables(i) ? new j(t,n,e,Tp().setDependencies(i)) : (o = $d(t, e, o),
        new j(t,n,e,o))
    }
    function U6(e, t, n) {
        if (di(e))
            return wi(t, n, e);
        if (!ps.plotInequalities)
            return new j(t,n,e,Ib());
        let r = qo(qM, e, t, n);
        if (r.type === "Error")
            return new j(t,n,e,r);
        let o = r.getDependencies();
        return ro[e._operators[0]].direction !== ro[e._operators[1]].direction ? new j(t,n,e,Sb()) : t.validDoubleInequalitySymbol(r._symbol) ? t.validDoubleInequalityVariables(o) ? o.length > 2 ? new j(t,n,e,xn(e.getSliderVariables(t, r)).setDependencies(o)) : r._expressions[0].getDependencies().indexOf(r._symbol) !== -1 || r._expressions[1].getDependencies().indexOf(r._symbol) !== -1 ? new j(t,n,e,Eb().setDependencies(o)) : new j(t,n,e,r) : new j(t,n,e,Pb().setDependencies(o)) : new j(t,n,e,Pb().setDependencies(o))
    }
    function k6(e, t, n) {
        let r = e.withArgsCoerced();
        if (di(r))
            return wi(t, n, r);
        let o = pe(r, t, n);
        if (o.isError)
            return new j(t,n,r,o);
        let i = o.getDependencies();
        if (i.length)
            if (t.is3dPolicy()) {
                if (!t.validImplicitVariables(i))
                    return new j(t,n,r,(r.symbols.includes("=") ? QC() : nv()).setDependencies(i));
                if (!(r.symbols.every(a => a === "<" || a === "<=") || r.symbols.every(a => a === ">" || a === ">=") || r.symbols.every(a => a === "=")))
                    return new j(t,n,r,Sb().setDependencies(i));
                if (r.symbols.some(a => a === "=") && !i.includes("z"))
                    return new j(t,n,r,rv().setDependencies(i));
                let s = pe(r.getRestrictedDifference(), t, n);
                return o.warning && (s.warning = o.warning),
                s = $d(t, r, s),
                new j(t,n,r,s)
            } else
                return r.symbols.includes("=") ? new j(t,n,r,ov()) : r.symbols.length > 2 ? new j(t,n,r,WS()) : t.validDoubleInequalityVariables(i) ? new j(t,n,r,Eb()) : new j(t,n,r,xn(r.getSliderVariables(t, o)).setDependencies(i));
        return new j(t,n,r,o)
    }
    function $6(e, t, n, r) {
        if (di(e))
            return wi(t, n, e);
        let o = pe(e, t, n);
        if (o.isError)
            return new j(t,n,e,o);
        let i = e.getMoveStrategy(t, n, o, r);
        if (i) {
            let s = Dg(e, i)
              , a = o.asCompilerValue()
              , u = [new O.Constant(a[0]), new O.Constant(a[1])];
            return o = RI(o, new Ya(u,i,s)),
            new j(t,n,e,o)
        }
        return _I(t, n, e, o)
    }
    function Y6(e, t, n) {
        let r = qo(YM, e, t, n)
          , o = new j(t,n,e,r);
        return o.evaluationState.is_graphable = !0,
        o
    }
    function Z6(e, t, n, r) {
        let o = qo(zM, e, t, n);
        if (o.type === "Error" || o.radianAngle.type === "Error" || o.center.type === "Error" || o.width.type === "Error" || o.height.type === "Error" || o.opacity.type === "Error")
            return new j(t,n,e,o);
        let i = o.center.getDependencies()
          , s = o.radianAngle.getDependencies()
          , a = o.width.getDependencies()
          , u = o.height.getDependencies()
          , c = o.opacity.getDependencies();
        return i.length || s.length || a.length || u.length || c.length ? new j(t,n,e,new ad({
            center: i.length ? xn(s).setDependencies(i) : o.center,
            radianAngle: s.length ? xn(s).setDependencies(s) : o.radianAngle,
            width: a.length ? xn(a).setDependencies(a) : o.width,
            height: u.length ? xn(u).setDependencies(u) : o.height,
            opacity: c.length ? xn(c).setDependencies(c) : o.opacity
        })) : (o.moveStrategy = e.getMoveStrategy(t, n, o, r),
        new j(t,n,e,o))
    }
    function X6(e, t, n) {
        if (di(e))
            return wi(t, n, e);
        let r = qo(wp, e, t, n), o = r.type === "IRExpression" || r instanceof Om ? r.sliderInfo : void 0, i;
        if (o != null && o.missingVars.length) {
            let a = QI(o.missingVars);
            i = new j(t,n,e,xn(t.sliderVariables(a)).setDependencies(a).allowExport())
        } else
            i = new j(t,n,e,r);
        let s = i.evaluationState;
        if (ps.sliders) {
            s.assignment = o == null ? void 0 : o.exportedSymbol,
            s.slider_min_number = o == null ? void 0 : o.values.min,
            s.slider_max_number = o == null ? void 0 : o.values.max,
            s.slider_step_number = o == null ? void 0 : o.values.step,
            s.slider_min_valid = o == null ? void 0 : o.valids.min,
            s.slider_max_valid = o == null ? void 0 : o.valids.max,
            s.slider_step_valid = o == null ? void 0 : o.valids.step;
            let a = s.slider_min_valid && s.slider_max_valid && s.slider_step_valid;
            s.is_slider = !0,
            s.raw_slider_latex = e.getInputString(),
            s.is_slidable = a,
            s.is_animatable = s.is_slidable && !s.is_graphable,
            o != null && o.errMsg && (s.error = o == null ? void 0 : o.errMsg.getError())
        }
        return delete s.is_evaluable,
        i
    }
    function di(e) {
        return e.userData && "latex"in e.userData && Au(e.userData.latex).slice(-1) === "="
    }
    function wi(e, t, n) {
        return new j(e,t,n,Lm("="))
    }
    function yR(e) {
        return e.concreteTree.type === "IRExpression" && qs(e.concreteTree) && (e.concreteTree.valueType === b || e.concreteTree.valueType === N)
    }
    function RI(e, t) {
        return t.warning = e.warning,
        t
    }
    $r();
    function N3(e, t, n) {
        try {
            return W6(e, t, n)
        } catch (r) {
            if (!(r instanceof v))
                throw r;
            let o = [];
            for (let i of ue(n))
                o.push({
                    id: i,
                    stmtAnalysis: new j(e,t,n[i],r)
                });
            return o
        }
    }
    function W6(e, t, n) {
        let r = {};
        for (let c of ue(n))
            r[n[c]._symbol] = n[c];
        let o = new gR(r)
          , i = {}
          , s = {
            definitions: i,
            baseCases: o.getBaseCases()
        };
        for (let c of ue(n)) {
            let l = n[c];
            j6(o, l, s)
        }
        for (let c of o.getBaseCaseExports()) {
            let l = sf(c, e, t, {});
            for (let p of c.getLegalExports(e))
                delete t[p];
            l.rawTree.exportTo(e, l.concreteTree, t)
        }
        let a = Fn(t);
        for (let c of ue(i))
            a[c] = i[c];
        let u = [];
        for (let c of ue(n)) {
            let l = n[c]
              , p = l._symbol
              , m = i[p];
            m.userData = l.userData,
            m.metaData = l.metaData,
            m instanceof v ? u.push({
                id: c,
                stmtAnalysis: new j(e,t,l,m)
            }) : u.push({
                id: c,
                stmtAnalysis: sf(m, e, a, {})
            })
        }
        return u
    }
    var gR = class {
        constructor(t) {
            this.baseCases = {};
            this.baseCaseExports = [];
            this.analyzedFunctions = {};
            this.recursiveFunctionGroup = t;
            for (let n in t)
                this.baseCases[n] = [];
            for (let n in this.recursiveFunctionGroup)
                this.analyzeRecursiveFunctionDefinition(this.recursiveFunctionGroup[n])
        }
        analyzeRecursiveFunctionDefinition(t) {
            let n;
            for (let r of t.getExternalBaseCases())
                this.addBaseCase(r);
            if (t._expression instanceof Io) {
                n = t._expression;
                do {
                    let r = n.args[0]
                      , o = n.args[1];
                    if (this.recursiveParameterIndex !== void 0 && r instanceof za) {
                        let i = t._argSymbols[this.recursiveParameterIndex]
                          , s = r.args.findIndex(p => p instanceof ze && p._symbol === i);
                        if (s === -1)
                            break;
                        let a = r.args[1 - s];
                        if (!(a instanceof Hn))
                            break;
                        let u = a.asValue()
                          , c = t._argSymbols.filter( (p, m) => m !== this.recursiveParameterIndex).map(p => new dn(p))
                          , l = new xo(t._symbol,c,{
                            valid: !0,
                            argIndex: this.recursiveParameterIndex,
                            argValue: u,
                            functionDefArgSymbols: t._argSymbols,
                            argSymbol: t._argSymbols[this.recursiveParameterIndex]
                        },o,o);
                        this.baseCaseExports.push(l),
                        this.addBaseCase(l)
                    } else
                        break;
                    n = n.args[2]
                } while (n instanceof Io)
            } else if (t._expression instanceof zu) {
                let r = [];
                for (let o of t._expression._assignments) {
                    let i = xo.fromCallAssignment(this.recursiveFunctionGroup, o);
                    if ((i == null ? void 0 : i.specifiedArg.valid) === !1)
                        throw i.specifiedArg.error;
                    i && t._symbol === i._symbol ? (this.baseCaseExports.push(i),
                    this.addBaseCase(i)) : r.push(o)
                }
                r.length > 0 ? n = new zu(t._expression._body,r) : n = t._expression._body
            } else
                n = t._expression;
            this.analyzedFunctions[t._symbol] = {
                recursiveExpression: n
            }
        }
        addBaseCase(t) {
            this.baseCases[t._symbol].push(t)
        }
        getBaseCases() {
            return this.baseCases
        }
        getBaseCaseExports() {
            return this.baseCaseExports
        }
        getFunctionAnalysis(t) {
            return this.analyzedFunctions[t]
        }
    }
    ;
    function j6(e, t, n) {
        let r = e.getFunctionAnalysis(t._symbol);
        if (!r) {
            n.definitions[t._symbol] = t;
            return
        }
        let o = new _r(new dn(t._symbol),t._argSymbols.map(i => new dn(i)),r.recursiveExpression,n);
        o.setExternalBaseCases(t.getExternalBaseCases()),
        n.definitions[t._symbol] = o
    }
    function hR(e, t, n) {
        switch (e.type) {
        case "ParenSeq":
        case "MovablePoint":
            return new j(t,n,e,Bv());
        case "Regression":
            return new j(t,n,e,Fv());
        case "DoubleInequality":
        case "ComparatorChain":
        case "Comparator['<']":
        case "Comparator['>']":
        case "Comparator['<=']":
        case "Comparator['>=']":
        case "Comparator['=']":
            return new j(t,n,e,Lv());
        case "Equation":
        case "CallAssignment":
            return new j(t,n,e,dy())
        }
    }
    function O3(e, t, n) {
        let r = hR(e, t, n);
        if (r)
            return r;
        if (e instanceof _r) {
            if (rt[e._symbol])
                return new j(t,n,e,Fm(e._symbol));
            let o = pe(e, t, n);
            if (o.isError)
                return new j(t,n,e,o);
            let i = e._argSymbols
              , s = o.getDependencies();
            if (s.indexOf(e._symbol) !== -1)
                return new j(t,n,e,xp([e._symbol], {
                    suggestAlternativeFunctionName: !1
                }));
            let a = s.filter(u => i.indexOf(u) === -1);
            return a.length ? new j(t,n,e,ay(a, e._symbol, i)) : new j(t,n,e,o)
        } else if (e instanceof Ln) {
            let o = e._symbol;
            if (rt[o])
                return new j(t,n,e,Fm(o));
            let i = Fn(n);
            i[o] = dy();
            let s = e.type === "Slider" ? qo(wp, e, t, i) : pe(e, t, i);
            if (s.isError)
                return new j(t,n,e,s);
            let a = s.getDependencies();
            return e.isEquation(t, s) ? new j(t,n,e,dy()) : a.length > 0 ? new j(t,n,e,xn(a)) : new j(t,n,e,s)
        } else if (e instanceof Z) {
            let o = pe(e, t, n);
            if (o.isError)
                return new j(t,n,e,o);
            let i = o.getDependencies();
            return i.length > 0 ? new j(t,n,e,xn(i)) : new j(t,n,e,o)
        } else {
            let o = hl(e, t, n);
            return o.type === "Error" ? new j(t,n,e,o) : new j(t,n,e,F(`Unexpected node type ${e.type}`))
        }
    }
    function NI(e, t, n) {
        let r = hR(e, t, n);
        if (r)
            return r;
        switch (e.type) {
        case "FunctionDefinition":
            return new j(t,n,e,wv());
        case "Assignment":
        case "Slider":
            return new j(t,n,e,Av())
        }
        if (e instanceof Z) {
            let i = pe(e, t, n);
            if (i.isError)
                return new j(t,n,e,i);
            let s = i.getDependencies();
            if (s.length > 0) {
                let a = s[0], u, c = rt[a];
                return c ? u = c.type === "Placeholder" ? Ga(a, t) : my(a) : u = Nv(a),
                new j(t,n,e,u)
            }
            return new j(t,n,e,i)
        }
        let o = hl(e, t, n);
        return o.type === "Error" ? new j(t,n,e,o) : new j(t,n,e,F(`Unexpected node type ${e.type}`))
    }
    function A3(e, t, n) {
        return NI(e, t, n)
    }
    $r();
    function L3(e, t) {
        let n = new Ip;
        for (let r of t.values()) {
            let o = r.id
              , i = r.statement
              , s = i.metaData
              , a = e.getPolicyContext(r.moduleID).policy;
            if (wg(n, o, i.getDependencies()),
            wg(n, o, i.getLegalExports(a)),
            ss(i) && i.userData && i.userData.residualVariable && wg(n, o, [Bs(i.userData.residualVariable)]),
            w3(n, o, s),
            Vu(i) && i.columns)
                for (let u = 0; u < i.columns.length; u++) {
                    let c = i.columns[u];
                    if (Bu(c))
                        throw F("Unexpected concrete column.");
                    !To(c) && c.header && c.header.metaData && w3(n, o, c.header.metaData)
                }
        }
        return n
    }
    function wg(e, t, n) {
        let r = or;
        for (let o of n)
            e.getOrInsert(Gn(r, o), []).push(t)
    }
    function w3(e, t, n) {
        if (n.extraDepNodes)
            for (let r of n.extraDepNodes)
                r && wg(e, t, r.getDependencies());
        n.clickHandler && wg(e, t, n.clickHandler.getDependencies())
    }
    function Kp(e, t, n, r, o) {
        let i = new ho
          , s = {}
          , a = []
          , u = [];
        for (let c of ue(r))
            r[c] && (s[c] = !0,
            a.push(c));
        for (let c of o)
            i.add(c),
            u.push(c);
        for (; a.length || u.length; ) {
            for (; a.length; ) {
                let c = a.pop()
                  , l = t.get(c);
                if (!l)
                    continue;
                let p = e.getPolicyContext(l.moduleID).policy;
                for (let m of l.statement.getLegalExports(p)) {
                    let d = Gn(or, m);
                    i.has(d) || (i.add(d),
                    u.push(d))
                }
            }
            for (; u.length; ) {
                let c = u.pop()
                  , l = n.get(c);
                if (l)
                    for (let p of l)
                        s[p] || (s[p] = !0,
                        a.push(p))
            }
        }
        return {
            ids: s,
            symbols: i
        }
    }
    function F3(e) {
        var t;
        return (t = e.get(Gn(or, "globalRandomSeed"))) != null ? t : []
    }
    var J6 = 100;
    function OI(e) {
        let t = [];
        for (let n = 0; n < e; n++)
            t[n] = {
                x: [],
                y: [],
                intersects: []
            };
        return t
    }
    function Q6(e, t, n, r) {
        return n === 1 && r === 1 || n === 2 && r === 2 ? function(o) {
            return t(o) - e(o)
        }
        : n === 1 && r === 2 || n === 2 && r === 1 ? function(o) {
            return o - t(e(o))
        }
        : !1
    }
    function V3(e, t) {
        t instanceof O.SolvedEquation ? t = t._expression : t instanceof O.OptimizedRegression && (t = t.model);
        let n = []
          , r = [];
        return t instanceof od ? Vo.eachArgs(t._expressions, o => {
            n.push(o[0].getCompiledFunction()),
            r.push(o[0].isConstant && o[1].isNaN()),
            n.push(o[1].getCompiledFunction()),
            r.push(o[1].isConstant && o[1].isNaN())
        }
        ) : Vo.wrap(t).eachElement(o => {
            n.push(o.getCompiledFunction()),
            r.push(o.isConstant && o.isNaN())
        }
        ),
        {
            functions: n,
            skipIntersecting: r
        }
    }
    function K6(e, t) {
        let n = [];
        for (let r in e) {
            if (!e.hasOwnProperty(r) || String(r) === String(t) || !e[r].shouldIntersect())
                continue;
            let o = e[r]
              , i = V3(o.policy, o.concreteTree);
            n.push({
                id: r,
                graphMode: o.getGraphMode(),
                functions: i.functions,
                skipIntersecting: i.skipIntersecting
            })
        }
        return n
    }
    function e9(e, t) {
        e.intersects = Array(e.x.length);
        for (let n = 0; n < e.x.length; n++)
            e.intersects[n] = t
    }
    function t9(e, t) {
        if (t === 1) {
            let n = e.y;
            e.y = e.x,
            e.x = n
        }
    }
    function n9(e, t) {
        Array.prototype.push.apply(e.x, t.x),
        Array.prototype.push.apply(e.y, t.y),
        e.intersects && t.intersects && Array.prototype.push.apply(e.intersects, t.intersects)
    }
    function r9(e, t, n) {
        let r = xD(e, t)
          , o = r.poi.zeros
          , i = r.poi.extrema
          , s = []
          , a = 0
          , u = 0;
        for (a = 0; a < o.x.length; a++) {
            for (; u < i.x.length && i.x[u] < o.x[a]; u++)
                Bi(i.y[u], 0) && s.push(i.x[u]);
            s.push(o.x[a])
        }
        for (; u < i.x.length; u++)
            Bi(i.y[u], 0) && s.push(i.x[u]);
        return {
            x: s,
            y: s.map(n)
        }
    }
    function B3(e, t, n) {
        let r = e[n], o = r.getGraphInfo(), i = r.getGraphMode(), s, a, u;
        try {
            s = V3(r.policy, r.concreteTree),
            a = OI(s.functions.length),
            u = K6(e, n)
        } catch (l) {
            return OI(0)
        }
        if (!u)
            return a;
        let c = 0;
        for (let l = 0; l < u.length; l++) {
            let p = u[l];
            for (let m = 0; m < s.functions.length; m++) {
                if (s.skipIntersecting[m])
                    continue;
                let d = s.functions[m].fn
                  , y = Hp(t, o, d);
                for (let g = 0; g < p.functions.length; g++) {
                    if (u[l].skipIntersecting[g])
                        continue;
                    let f = p.functions[g].fn
                      , h = Q6(d, f, i, p.graphMode);
                    if (!h)
                        continue;
                    let x;
                    try {
                        x = r9(h, y, d)
                    } catch (T) {
                        return OI(0)
                    }
                    if (c += x.x.length,
                    c > J6)
                        return OI(s.functions.length);
                    e9(x, p.id),
                    t9(x, i),
                    n9(a[m], x)
                }
            }
        }
        return a
    }
    $r();
    var af = class {
        constructor(t, n) {
            this.moduleContexts = t;
            this.isRegressionFrame = n;
            this.frames = new Map;
            this.syncPolicyFramesAndFixPrototypes()
        }
        getFrame(t) {
            return this._getFrame(t != null ? t : or)
        }
        getPolicyContextForFrame(t) {
            return this.moduleContexts.getPolicyContextForFrame(t)
        }
        getOrCreateParentFrame(t) {
            let n = this.moduleContexts.parentFrameMap.get(t);
            return n ? this._getFrame(n) : {}
        }
        _getFrame(t) {
            let n = this.frames.get(t);
            if (n)
                return n;
            let r = this.getOrCreateParentFrame(t)
              , o = Fn(r);
            return this.moduleContexts.isRootModule(t) && EA(o, t),
            PA(o, this),
            this.frames.set(t, o),
            o
        }
        syncPolicyFramesAndFixPrototypes() {
            for (let[t,n] of this.moduleContexts.policyContextEntries()) {
                let r = nl(t)
                  , o = n.getPolicyFrame(this.isRegressionFrame);
                this.frames.set(r, o)
            }
            for (let[t,n] of this.moduleContexts.parentFrameMap)
                Object.setPrototypeOf(this._getFrame(t), this._getFrame(n))
        }
        markDependencyOrder(t) {
            for (let n of this.moduleContexts.rootModules()) {
                let r = this._getFrame(nl(n));
                xA(r, t)
            }
        }
        cloneFrameMapWithoutPrototypes() {
            let t = new Map;
            for (let[n,r] of this.frames) {
                let o = {};
                for (let i of ue(r))
                    o[i] = r[i];
                t.set(n, o)
            }
            return t
        }
        deleteTableFrame(t) {
            return t === void 0 || !this.frames.has(t) ? !1 : (this.frames.delete(t),
            !0)
        }
        deleteFrame(t) {
            this.frames.delete(t)
        }
        deleteName(t) {
            let n = this.getFrame(t.frameID);
            n && delete n[t.symbol]
        }
        resolveDefiningFrameID(t) {
            let {frameID: n, symbol: r} = t;
            for (; ; ) {
                let o = this.getFrame(n);
                if (!o)
                    return;
                if (o.hasOwnProperty(r))
                    return n;
                let i = this.moduleContexts.parentFrameMap.get(n);
                if (!i)
                    return;
                n = i
            }
        }
    }
    ;
    function G3(e, t) {
        var a;
        let n = {}
          , r = {}
          , o = {}
          , i = []
          , s = {};
        for (let u of e.values()) {
            let c = u.statement
              , l = u.id;
            if (c instanceof sa) {
                let p = c.tableFrameID;
                if (!p)
                    throw new Error(`Programming error: missing tableFrameID on table column ${l}`);
                s[p] || (s[p] = []),
                s[p].push(c)
            }
        }
        for (let u of e.values()) {
            let c = u.statement
              , l = u.id;
            if (!(c.type === "Construction" && !t.isGeometryEnabled()) && c.type !== "Ticker" && c.type !== "Viewport")
                switch (c.type) {
                case "Error":
                    break;
                case "Regression":
                    {
                        o[l] = [],
                        i.push(l);
                        break
                    }
                case "TableColumn":
                    continue;
                default:
                    {
                        let p = c.getLegalExports(t);
                        if (c.type === "Table") {
                            let m = s[l] || [];
                            for (let d of m)
                                for (let y of d.getLegalExports(t))
                                    !y.startsWith("idref_") && !p.includes(y) && p.push(y)
                        }
                        if (p) {
                            for (let d of p)
                                c.tableFrameID !== void 0 ? r[d] = l : n[d] = l;
                            let m = [];
                            for (let d of c.getDependencies())
                                m.push(d);
                            o[l] = KI(m, c.getOptionalDependencies(), p)
                        }
                        break
                    }
                }
        }
        for (let u of i) {
            let c = (a = e.get(u)) == null ? void 0 : a.statement;
            if (!c)
                continue;
            let l = Bs(c.userData.residualVariable);
            l && (r[l] = u);
            let p = c.getDependencies().slice(), m = {}, d;
            for (; d = p.pop(); ) {
                if (m[d])
                    continue;
                m[d] = !0;
                let y = n[d] || r[d];
                if (y) {
                    p.push(...o[y]),
                    o[u].push(d);
                    continue
                }
                r[d] = u
            }
        }
        return {
            exportMap: n,
            weakExportMap: r,
            dependencyMap: o
        }
    }
    function q3(e) {
        if (e.length < 2)
            return "text";
        let t = e.split("`").length - 1;
        return t < 2 ? "text" : t === 2 && e[0] === "`" && e[e.length - 1] === "`" ? "latex" : "mixed"
    }
    function z3(e) {
        if (e.length === 0)
            return [""];
        let t = []
          , n = e.split(/(`)/)
          , r = !1
          , o = "";
        for (let i = 0; i < n.length; i++) {
            let s = n[i];
            s.length && (s === "`" ? (o += "`",
            r = !r,
            r || (t.push(o),
            o = "")) : (o += s,
            r || (t.push(o),
            o = "")))
        }
        return o.length && t.push(o),
        t
    }
    function bR(e) {
        return z3(e).map(o9)
    }
    function o9(e) {
        let n = "\\$({" + ["[a-zA-Z][0-9]*", "[a-zA-Z]_[a-zA-Z0-9]+", "[a-zA-Z]_\\{[a-zA-Z0-9]+\\}", "\\\\[a-zA-Z]+", "\\\\[a-zA-Z]+_{[a-zA-Z0-9]+}", "\\\\[a-zA-Z]+_[a-zA-Z0-9]+"].join("})|\\$({") + "})", r = new RegExp(n,"g"), o = [], i = 0, s = 0, a;
        for (; a = r.exec(e); ) {
            s = a.index,
            s > i && o.push(e.substr(i, s - i));
            let u = a[0]
              , c = u.replace(/[{}\$]/g, "").replace(/^([a-zA-Z])([0-9]+)$/, "$1_$2");
            o.push({
                symbol: c,
                str: u
            }),
            i = a.index + u.length
        }
        return i < e.length && o.push(e.substr(i)),
        {
            raw: e,
            parts: o
        }
    }
    var H3 = {
        bigCutoff: 1e7,
        digits: 8
    };
    function U3(e, t) {
        let n = t ? Jc(e, H3) : Rm(e, H3);
        return t ? `{${n}}` : n
    }
    function k3(e, t) {
        let n = {
            ...MS,
            digits: 8,
            scientificNotationDigits: 3
        }
          , r = t ? kf(e, n) : DS(e, n);
        return t ? `{${r}}` : r
    }
    function xR(e, t, n, r) {
        return e.map(o => i9(o, t, n, r)).join("")
    }
    function i9(e, t, n, r) {
        var s, a, u, c;
        let o = []
          , i = q3(e.raw) === "latex";
        for (let l of e.parts)
            if (typeof l == "string")
                o.push(l);
            else {
                let p = pe(new O.Identifier(l.symbol), t, n, {
                    coerceToNumber: "all-except-complex"
                });
                if (p.type === "IRExpression") {
                    if (p.valueType === b && p.getDependencies().length === 0) {
                        let m = p.asValue();
                        if (typeof m == "number") {
                            o.push(U3(m, i));
                            continue
                        }
                    } else if (p.valueType === Y && r < ((s = p.length) != null ? s : 0) && p.getDependencies().length === 0) {
                        let m = (a = p.elementAt) == null ? void 0 : a.call(p, r).asValue();
                        if (typeof m == "number") {
                            o.push(U3(m, i));
                            continue
                        }
                    } else if (p.valueType === N && p.getDependencies().length === 0) {
                        let m = Rr(p);
                        if ((m == null ? void 0 : m.valueType) === N) {
                            o.push(k3(m.value, i));
                            continue
                        }
                    } else if (p.valueType === ke && r < ((u = p.length) != null ? u : 0) && p.getDependencies().length === 0) {
                        let m = Rr((c = p.elementAt) == null ? void 0 : c.call(p, r));
                        if ((m == null ? void 0 : m.valueType) === N) {
                            o.push(k3(m.value, i));
                            continue
                        }
                    }
                }
                i ? o.push("{?}") : o.push("?")
            }
        return o.join("")
    }
    function a9(e) {
        let t = Jc(e, {
            bigCutoff: 1e9,
            smallCutoff: 1e-6,
            digits: 12
        });
        return t.indexOf("\\times") === -1 ? t : t[0] === "-" ? "-\\left(" + t.substring(1) + "\\right)" : "\\left(" + t + "\\right)"
    }
    function u9(e) {
        switch (e) {
        case "exponential":
        case "power":
        case "logarithmic":
            return !0;
        case "cubic":
        case "linear":
        case "logistic":
        case "sinusoidal":
        case "quadratic":
        case "quartic":
            return !1
        }
    }
    function c9(e, t) {
        let n = t.parameterValues || {}, [r,o] = t.variables, i = a => {
            if (n === "canonical")
                return a;
            let u = p9(a)
              , c = n && n[u];
            return c !== void 0 ? a9(c) : u
        }
        , s;
        switch (e) {
        case "linear":
            {
                let[a,u] = [i("m"), i("b")];
                s = `${[`${a}${r}`, `${u}`].join("+")}`;
                break
            }
        case "quadratic":
            {
                let[a,u,c] = [i("a"), i("b"), i("c")];
                s = `${[`${a}${r}^2`, `${u}${r}`, `${c}`].join("+")}`;
                break
            }
        case "cubic":
            {
                let[a,u,c,l] = [i("a"), i("b"), i("c"), i("d")];
                s = `${[`${a}${r}^3`, `${u}${r}^2`, `${c}${r}`, `${l}`].join("+")}`;
                break
            }
        case "quartic":
            {
                let[a,u,c,l,p] = [i("a"), i("b"), i("c"), i("d"), i("f")];
                s = `${[`${a}${r}^4`, `${u}${r}^3`, `${c}${r}^2`, `${l}${r}`, `${p}`].join("+")}`;
                break
            }
        case "exponential":
            {
                let[a,u] = [i("a"), i("b")];
                s = `${a}\\cdot ${u}^{${r}}`;
                break
            }
        case "logarithmic":
            {
                let[a,u] = [i("a"), i("b")];
                s = `${a}+${u}\\cdot \\ln\\left(${r}\\right)`;
                break
            }
        case "logistic":
            {
                let[a,u,c] = [i("a"), i("b"), i("c")];
                s = `\\frac{${a}}{1+e^{-\\left(${u}${r}+${c}\\right)}}`;
                break
            }
        case "power":
            {
                let[a,u] = [i("a"), i("b")];
                s = `${a}\\cdot ${r}^{${u}}`;
                break
            }
        case "sinusoidal":
            {
                let[a,u,c,l] = [i("a"), i("b"), i("c"), i("d")];
                s = `${a}\\cdot \\sin\\left(${u}${r}+${c}\\right)+${l}`;
                break
            }
        default:
            throw new Error(`Unknown regression type: ${e}`)
        }
        return `${o}${t.operator}${l9(s)}`
    }
    function l9(e) {
        return e.replace(/\+-/g, "-").replace(/--/g, "")
    }
    function p9(e) {
        return `\\regressionparameter_{${e}}`
    }
    var $3 = /\\regressionparameter_{([^}]+)}/g;
    function ZSe(e) {
        var n;
        return ((n = e.match($3)) != null ? n : []).map(r => r.replace($3, (o, i) => i))
    }
    function Y3(e, t, n, r) {
        let o = e.regression;
        if (!o)
            return;
        u9(o.type) || (o.isLogMode = !1);
        let i = e.columns
          , {columnIds: s} = o
          , a = r.get(s.x)
          , u = r.get(s.y);
        if (!(a && u))
            return F("Missing columns for table regression");
        let c = [{
            id: a.userData.id,
            isIdentifier: Ha(a.header),
            latex: i[a.columnIndex].latex
        }, {
            id: u.userData.id,
            isIdentifier: Ha(u.header),
            latex: i[u.columnIndex].latex
        }]
          , l = [c[0].isIdentifier ? c[0].latex : `\\idref_{${c[0].id}}`, c[1].isIdentifier ? c[1].latex : `\\idref_{${c[1].id}}`]
          , p = c9(o.type, {
            operator: "~",
            variables: l
        })
          , m = mi(p, n);
        if (To(m))
            return m;
        if (!ss(m))
            return F(`Expected table regression to parse as Regression, but got ${m.type}`);
        let d = m;
        return d.tableRegressionData = {
            tableId: t,
            columnInfo: c != null ? c : [],
            variables: l
        },
        d.metaData = {
            extraDepNodes: []
        },
        d.userData = {
            id: o.id,
            color: o.color,
            lineStyle: o.lineStyle,
            isLogModeRegression: o.isLogMode,
            shouldGraph: !o.hidden,
            residualVariable: o.residualVariable
        },
        d
    }
    var Hl = typeof performance != "undefined" ? () => performance.now() : () => Date.now();
    function tq() {
        return {
            intersections: {},
            graphs: {}
        }
    }
    var {Constant: wI, Image: g9, Slider: h9, Construction: b9} = O
      , rc = Ws("**dcg_geo_construction_statement_id**");
    function kr(e, t) {
        let n = mi(e, t);
        return n.isError || n instanceof Z ? n : jf()
    }
    function x9(e) {
        let t = e.evaluationState.expression_type
          , n = e.rawTree.userData;
        return !n.clickableInfo || !n.clickableInfo.enabled ? !1 : $b(e.rawTree) ? !0 : El(e.getGraphMode()) ? !1 : AL(t)
    }
    function Mn(e, t) {
        let n = "id" + e;
        for (let[r,o] of t || [])
            n += "::" + r + o;
        return n
    }
    var T9 = new wI(be(0, 1))
      , I9 = new wI(be(1, 1))
      , P9 = new wI(NaN);
    function Li(e, t) {
        return e ? e === "0" ? T9 : e === "1" ? I9 : kr(e, t) : P9
    }
    function Ac(e, t) {
        if (e)
            return kr(e, t)
    }
    function S9(e) {
        return e.slice(0, 3) !== "ans"
    }
    function E9(e) {
        return e.slice(0, 6) !== "idref_"
    }
    function X3(e, t, n) {
        let {cycles: r, recursiveFunctionSymbols: o, assignmentMaps: i} = e;
        for (let s of r) {
            let a = [...new Set(s.map( ({symbol: u}) => u))].filter(S9).filter(E9).sort();
            for (let u of s) {
                let {symbol: c, frameID: l} = u;
                if (n.getPolicyContextForFrame(l).recursion && o.has(u))
                    continue;
                let m = NC(a)
                  , d = t.getFrame(l);
                d[c] = m
            }
        }
        for (let s of i.multiplyDefined) {
            let a = t.getFrame(s.frameID);
            a[s.symbol] = sy(s.symbol)
        }
    }
    function Lg(e) {
        var t;
        return (t = e.statement.tableFrameID) != null ? t : e.moduleID
    }
    function wc(e, t) {
        return e.getFrame(Lg(t))
    }
    function Es(e, t) {
        return e.getPolicyContext(t.moduleID).policy
    }
    var ER = {
        coerceToNumber: "all"
    };
    function C9(e, t, n, r, o) {
        let i = {}, s = !0, a = NaN, u, c = !1;
        if (n) {
            let l = pe(n, e, t, ER);
            u = l.getDependencies().length === 0 ? l.asValue() : NaN,
            c = Array.isArray(u),
            a = c ? u : +u;
            for (let p of l.getDependencies())
                i[p] = !0
        }
        if (c) {
            for (let l of a)
                if (!isFinite(+l)) {
                    s = !1,
                    a = NaN;
                    break
                }
        } else
            isFinite(+a) ? o !== void 0 && a > o && (a = o) : (s = !1,
            a = NaN);
        return n || (s = !0,
        r !== void 0 && (a = r)),
        {
            value: a,
            valid: s,
            missingVarsMap: i
        }
    }
    var Fg = {
        lineWidth: {
            parseNode: "lineWidth",
            valueOutputProp: "computedLineWidth",
            formulaOutputProp: "",
            validOutputProp: "line_width_valid",
            default: e => e.is3dPolicy() ? 1 : 2.5,
            transform: void 0,
            shouldEvaluate: void 0,
            getLatex: void 0,
            seed: "lw"
        },
        resolution: {
            parseNode: "resolution",
            valueOutputProp: "computedResolution",
            formulaOutputProp: "",
            validOutputProp: "resolution_valid",
            default: () => {}
            ,
            transform: void 0,
            shouldEvaluate: void 0,
            getLatex: void 0,
            seed: "re"
        },
        lineOpacity: {
            parseNode: "lineOpacity",
            valueOutputProp: "computedLineOpacity",
            formulaOutputProp: "",
            validOutputProp: "line_opacity_valid",
            default: () => 1,
            transform: void 0,
            shouldEvaluate: void 0,
            getLatex: void 0,
            seed: "lo"
        },
        pointOpacity: {
            parseNode: "pointOpacity",
            valueOutputProp: "computedPointOpacity",
            formulaOutputProp: "",
            validOutputProp: "point_opacity_valid",
            default: () => 1,
            transform: void 0,
            shouldEvaluate: void 0,
            getLatex: void 0,
            seed: "po"
        },
        pointSize: {
            parseNode: "pointSize",
            valueOutputProp: "computedPointSize",
            formulaOutputProp: "",
            validOutputProp: "point_size_valid",
            default: e => e.is3dProduct() ? 3 : 8,
            shouldEvaluate: void 0,
            transform: void 0,
            getLatex: void 0,
            seed: "ps"
        },
        movablePointSize: {
            parseNode: "movablePointSize",
            valueOutputProp: "computedMovablePointSize",
            formulaOutputProp: "",
            validOutputProp: "movable_point_size_valid",
            default: () => 8,
            shouldEvaluate: void 0,
            transform: void 0,
            getLatex: void 0,
            seed: "ps"
        },
        fillOpacity: {
            parseNode: "fillOpacity",
            valueOutputProp: "computedFillOpacity",
            formulaOutputProp: "",
            validOutputProp: "fill_opacity_valid",
            default: () => .4,
            transform: void 0,
            shouldEvaluate: e => {
                if (!e)
                    return !1;
                let {expression_type: t, is_inequality: n} = e.evaluationState;
                return !!(t === A.POLYGON || t === A.PARAMETRIC || n)
            }
            ,
            getLatex: void 0,
            seed: "fo"
        },
        surfaceOpacity: {
            parseNode: "surfaceOpacity",
            valueOutputProp: "computedSurfaceOpacity",
            formulaOutputProp: "",
            validOutputProp: "surface_opacity_valid",
            default: () => 1,
            transform: void 0,
            shouldEvaluate: e => {
                if (!e)
                    return !1;
                let {expression_type: t} = e.evaluationState;
                return t === A.CURVE3D_xyz_t || t === A.SURFACE || t === A.SPHERE3D || t === A.SURFACE_AMBIGUOUS || t === A.SURFACE_CONSTANT_AMBIGUOUS || t === A.IMPLICIT_SURFACE || t === A.IMPLICIT_SURFACE_AMBIGUOUS || t === A.SURFACE_xyz_uv || t === A.SURFACE_z_r\u03B8 || t === A.SURFACE_r_\u03B8z || t === A.SURFACE_r_\u03B8\u03C6 || t === A.SURFACE_r_\u03B8z_AMBIGUOUS || t === A.TRIANGLE3D
            }
            ,
            getLatex: void 0,
            seed: "fo"
        },
        labelSize: {
            parseNode: "labelSize",
            valueOutputProp: "computedLabelSize",
            formulaOutputProp: "",
            validOutputProp: "label_size_valid",
            transform: void 0,
            default: () => 1,
            shouldEvaluate: void 0,
            getLatex: void 0,
            seed: "ls"
        },
        labelAngle: {
            parseNode: "labelAngle",
            valueOutputProp: "computedLabelAngle",
            formulaOutputProp: "label_angle_value",
            validOutputProp: "label_angle_valid",
            default: () => 0,
            transform: e => `-\\trigAngleMultiplier*(${e})`,
            shouldEvaluate: void 0,
            getLatex: void 0,
            seed: "la"
        },
        hypothesis: {
            getLatex: e => "inference"in e && e.inference.significance.show ? e.inference.significance.hypothesis : void 0,
            parseNode: "hypothesis",
            valueOutputProp: "computedHypothesis",
            formulaOutputProp: "hypothesis_value",
            validOutputProp: "hypothesis_valid",
            transform: void 0,
            seed: "hy",
            default: (e, t) => {
                let {rawTree: n, concreteTree: r} = t;
                return S2(n, r)
            }
            ,
            shouldEvaluate: e => {
                var t, n;
                return Ti((n = (t = e == null ? void 0 : e.evaluationState) == null ? void 0 : t.typed_constant_value) == null ? void 0 : n.valueType)
            }
        },
        confidenceLevel: {
            getLatex: e => "inference"in e && e.inference.confidence.show ? e.inference.confidence.confidenceLevel : void 0,
            parseNode: "confidenceLevel",
            valueOutputProp: "computedConfidenceLevel",
            formulaOutputProp: "confidence_level_value",
            validOutputProp: "confidence_level_valid",
            transform: void 0,
            seed: "co",
            default: () => RA,
            shouldEvaluate: e => {
                var t, n;
                return Ti((n = (t = e == null ? void 0 : e.evaluationState) == null ? void 0 : t.typed_constant_value) == null ? void 0 : n.valueType)
            }
        }
    };
    function W3(e, t, n, r, o, i) {
        let s = Fg[o]
          , a = s.default && s.default(n, i)
          , u = ["lineWidth", "pointSize", "movablePointSize"].indexOf(o) >= 0
          , c = C9(n, r, t[s.parseNode], a, u ? 1e4 : void 0);
        t[s.valueOutputProp] = c.value,
        s.formulaOutputProp && (e[s.formulaOutputProp] = c.value),
        e[s.validOutputProp] = c.valid,
        Nc(e, n, c.missingVarsMap)
    }
    function v9(e, t, n, r) {
        let o, i;
        if (Vu(e.rawTree) && e.evaluationState.column_data && e.rawTree.columns)
            for (let s = 0; s < e.evaluationState.column_data.length; s++) {
                o = e.evaluationState.column_data[s];
                let a = e.rawTree.columns[s];
                if (!To(a)) {
                    if (Bu(a))
                        throw F("Unexpected concrete column.");
                    i = a.header.metaData,
                    W3(o, i, t, n, r, e)
                }
            }
        else
            o = e.evaluationState,
            i = e.rawTree.metaData,
            W3(o, i, t, n, r, e)
    }
    function j3(e) {
        return Wl(e[0], e[1], e[2]).formatHex()
    }
    function J3(e, t, n, r, o) {
        let i;
        if (e) {
            let s = pe(e, r, o)
              , a = s.getDependencies().length > 0 ? void 0 : s.asValue()
              , {valueType: u} = s;
            if (i = !!(a && (u === bn || u === Ao)),
            i) {
                let c = s && s.valueType === bn ? j3(a) : a.map(j3);
                t.colorLatexValue = c,
                n.color_latex_value = c
            } else
                delete t.colorLatexValue,
                delete n.color_latex_value
        } else
            i = !0;
        n.color_latex_valid = i
    }
    function M9(e, t, n) {
        let r, o, i;
        if (Vu(e.rawTree) && e.evaluationState.column_data && e.rawTree.columns)
            for (let s = 0; s < e.evaluationState.column_data.length; s++) {
                r = e.evaluationState.column_data[s];
                let a = e.rawTree.columns[s];
                if (!To(a)) {
                    if (Bu(a))
                        throw F("Unexpected concrete column.");
                    o = a.header.metaData,
                    i = o.colorLatex,
                    J3(i, o, r, t, n)
                }
            }
        else
            r = e.evaluationState,
            o = e.rawTree.metaData,
            i = o.colorLatex,
            J3(i, o, r, t, n)
    }
    function D9(e) {
        if (e.concreteTree.valueType === bn && e.concreteTree.getDependencies().length > 0) {
            let t = e.concreteTree._chunk;
            try {
                e.evaluationState.shader = as(t, 0)
            } catch (n) {
                e.evaluationState.error = n instanceof O.Error ? n.getError() : F(n).getError()
            }
        }
    }
    function _9(e, t, n) {
        let r = e.evaluationState
          , o = e.rawTree
          , i = {}
          , s = o.metaData.clickHandler;
        if (!s)
            return;
        let a = pe(s, t, n);
        !a.isError && a.valueType !== pt && (a = ey(se(a.valueType)));
        for (let c of a.getDependencies())
            t.validActionVariable(c) || (i[c] = !0);
        let u = Object.keys(i);
        u.length > 0 && (a = xn(u).setDependencies(a.getDependencies())),
        a.isError && !W_(t, a) ? r.click_handler = {
            status: "error",
            error: a.getError()
        } : a.isEmptyAction ? r.click_handler = {
            status: "empty"
        } : r.click_handler = {
            status: "maybe-valid"
        },
        Nc(r, t, i)
    }
    function R9(e, t, n) {
        let r, o = e.evaluationState, i = e.rawTree, s, a;
        o.internal_domain_dependency ? (r = o.internal_domain_dependency,
        r === "u" ? (s = i.metaData.parametricDomain3DuMin,
        a = i.metaData.parametricDomain3DuMax) : r === "v" ? (s = i.metaData.parametricDomain3DvMin,
        a = i.metaData.parametricDomain3DvMax) : (s = i.metaData.parametricDomainMin,
        a = i.metaData.parametricDomainMax)) : o.expression_type === A.POLAR || FL(o.expression_type) ? (s = i.metaData.polarDomainMin,
        a = i.metaData.polarDomainMax,
        r = "theta") : (s = i.metaData.parametricDomainMin,
        a = i.metaData.parametricDomainMax,
        r = "t");
        let u = {}
          , c = !!(s || a)
          , l = Ss(t, n, s, u, 0)
          , p = NaN;
        a ? p = Ss(t, n, a, u, NaN) : o.expression_type === A.PARAMETRIC || o.expression_type === A.CURVE3D_xyz_t ? p = 1 : o.expression_type === A.POLAR ? p = Math.PI * 12 / +n.trigAngleMultiplier.asValue() : (o.expression_type === A.SURFACE_r_\u03B8z || o.expression_type === A.SURFACE_r_\u03B8z_AMBIGUOUS || o.expression_type === A.SLICE_r\u03B8z_at_z) && (p = Math.PI * 2 / +n.trigAngleMultiplier.asValue());
        let m = IR(l, p, o);
        ({min: l, max: p} = m),
        i.metaData.evaluatedDomainMin = l,
        i.metaData.evaluatedDomainMax = p,
        (o.expression_type === A.POLAR || o.expression_type === A.SURFACE_r_\u03B8z || o.expression_type === A.SURFACE_r_\u03B8z_AMBIGUOUS || o.expression_type === A.SLICE_r\u03B8z_at_z) && (i.metaData.isExplicitDomain = c),
        o.domains = [{
            variable: r,
            minNumber: l,
            maxNumber: p,
            minValid: m.minValid,
            maxValid: m.maxValid
        }],
        o.expression_type === A.PARAMETRIC && delete u.t,
        o.expression_type === A.CURVE3D_xyz_t && (delete u.t,
        delete u.u,
        delete u.v),
        Nc(o, t, u)
    }
    function N9(e, t, n) {
        let r = e.evaluationState, o = r.expression_type, i = e.rawTree, s, a, u, c, l = {}, p = 0, m = 1, d = 0, y = 1, g, f;
        wL(o) ? (g = "theta",
        f = "phi",
        s = i.metaData.polarDomainMin,
        a = i.metaData.polarDomainMax,
        u = i.metaData.parametricDomain3DphiMin,
        c = i.metaData.parametricDomain3DphiMax,
        m = 2 * Math.PI / +n.trigAngleMultiplier.asValue(),
        y = Math.PI / +n.trigAngleMultiplier.asValue()) : LL(o) ? (g = "r",
        f = "theta",
        s = i.metaData.parametricDomain3DrMin,
        a = i.metaData.parametricDomain3DrMax,
        u = i.metaData.polarDomainMin,
        c = i.metaData.polarDomainMax,
        m = Yr.xmax,
        y = 2 * Math.PI / +n.trigAngleMultiplier.asValue()) : (g = "u",
        f = "v",
        s = i.metaData.parametricDomain3DuMin,
        a = i.metaData.parametricDomain3DuMax,
        u = i.metaData.parametricDomain3DvMin,
        c = i.metaData.parametricDomain3DvMax),
        p = Ss(t, n, s, l, p),
        m = Ss(t, n, a, l, m),
        d = Ss(t, n, u, l, d),
        y = Ss(t, n, c, l, y);
        let h = IR(p, m, r);
        ({min: p, max: m} = h);
        let x = IR(d, y, r);
        ({min: d, max: y} = x),
        i.metaData.evaluatedDomain3DMin1 = p,
        i.metaData.evaluatedDomain3DMax1 = m,
        i.metaData.evaluatedDomain3DMin2 = d,
        i.metaData.evaluatedDomain3DMax2 = y,
        r.domains = [{
            variable: g,
            minNumber: p,
            minValid: h.minValid,
            maxNumber: m,
            maxValid: h.maxValid
        }, {
            variable: f,
            minNumber: d,
            minValid: x.minValid,
            maxNumber: y,
            maxValid: x.maxValid
        }],
        (r.expression_type === A.SURFACE_xyz_uv || r.expression_type === A.SLICE_xyz_uv) && (delete l.u,
        delete l.v),
        Nc(r, t, l)
    }
    function Ss(e, t, n, r, o) {
        if (n) {
            let i = pe(n, e, t, ER);
            for (let s of i.getDependencies())
                r[s] = !0;
            return i.type === "IRExpression" && i.isConstant ? +i.asValue() : NaN
        } else
            return o
    }
    function IR(e, t, n) {
        let r = !0
          , o = !0;
        return isFinite(e) || (r = !1,
        e = NaN),
        isFinite(t) || (o = !1,
        t = NaN),
        r ? o ? e > t && (r = !1,
        o = !1,
        n.error = zC().getError()) : n.error = qC().getError() : n.error = GC().getError(),
        {
            min: e,
            max: t,
            minValid: r,
            maxValid: o
        }
    }
    function O9(e, t, n) {
        let r = e.evaluationState
          , o = e.rawTree
          , i = o.metaData.vizAxisOffset
          , s = o.metaData.vizBreadth
          , a = {}
          , u = Ss(t, n, i, a, 1)
          , c = Ss(t, n, s, a, 1)
          , l = !0
          , p = !0;
        isFinite(u) || (l = !1,
        u = NaN),
        isFinite(c) || (p = !1,
        c = NaN),
        l ? p || (r.error = YE().getError()) : r.error = $E().getError(),
        o.metaData.evaluatedAxisOffset = u,
        o.metaData.evaluatedBreadth = c,
        r.viz_values = {
            axisOffset: u,
            breadth: c
        },
        r.viz_valids = {
            axisOffset: l,
            breadth: p
        },
        Nc(r, t, a)
    }
    function TR(e, t, n, r, o) {
        if (e.type === "Error" || e.getDependencies().length || e.valueType !== pt)
            return;
        let i = e.asValue();
        if (!i)
            return;
        function s(a) {
            let u = o.get(a);
            if (u)
                return u;
            let c = {};
            return o.set(a, c),
            c
        }
        for (let a of ue(i.updateRules)) {
            n[a] = X_(i, a);
            let u = r.resolveDefiningFrameID(Gn(t, a));
            if (!u)
                throw new Error("Programming error: action updating undefined symbol.");
            let c = s(u)
              , l = r.getFrame(u);
            c[a] || (c[a] = l[a]),
            l[a] = new O.Assignment(a,dt(i.updateRules[a]))
        }
    }
    function A9(e, t) {
        if (e.type !== "statement" || t.type !== "statement" || $o(e.latexSelection, t.latexSelection))
            return !1;
        let n = Vi(e)
          , r = Vi(t);
        return delete n.latexSelection,
        delete r.latexSelection,
        $o(n, r)
    }
    function w9(e, t) {
        if (!(e instanceof _r))
            return !1;
        let n = t[e._symbol];
        return n ? !!n.recursionInfo : !1
    }
    function Ws(e) {
        return e.toString()
    }
    function PR(e) {
        return e ? e : or
    }
    function L9(e, t) {
        return "moduleID"in e && e.moduleID ? e.moduleID : nq(e, t)
    }
    function nq(e, t) {
        return "rootModuleId"in e && e.rootModuleId ? PR(e.rootModuleId) : t
    }
    var AI = class {
        constructor(t) {
            this.inner = new SR(t)
        }
        processChangeSet(t) {
            return this.inner.processChangeSet(t)
        }
        getCLSymbolMap() {
            return this.inner.getCLSymbolMap()
        }
        get mainFrameContext() {
            let t = this;
            return {
                get global() {
                    return t.inner.getGlobalFrameForMathtools()
                }
            }
        }
        setDegreeMode(t) {
            this.inner.processEvaluatorConfig({
                degreeMode: t
            })
        }
        setEvaluationMode(t) {
            this.inner.processEvaluatorConfig({
                evaluationMode: t
            })
        }
        setGlobalRandomSeed(t) {
            this.inner.processEvaluatorConfig({
                globalRandomSeed: t
            })
        }
        get statements() {
            return this.inner.getStatements()
        }
        get analysis() {
            return this.inner.analysis
        }
        getFullStatementMap() {
            return this.inner.getFullStatementMap()
        }
        getModuleContexts() {
            return this.inner.moduleContexts
        }
        addStatement(t) {
            this.inner.addStatement(t, or)
        }
        updateAnalysis() {
            this.inner.updateAnalysis()
        }
        get evaluationMode() {
            return this.inner.moduleContexts.getPolicyContext(or).evaluationMode
        }
        get dirtyExportedSymbolRoots() {
            return this.inner.dirtyExportedSymbolRoots
        }
        get dirtyStatementRoots() {
            return this.inner.dirtyStatementRoots
        }
        get policy() {
            return this.inner.moduleContexts.getPolicyContext(or).policy
        }
        get use_degrees() {
            return this.inner.moduleContexts.getPolicyContext(or).use_degrees
        }
        get childIntersections() {
            return this.inner.childIntersections
        }
        processEvaluatorConfig(t) {
            this.inner.processEvaluatorConfig(t)
        }
        setViewState(t) {
            this.inner.processEvaluatorConfig({
                viewState: t
            })
        }
        removeStatement(t, n) {
            this.inner.removeStatement(Ws(t), n != null ? n : tq())
        }
        markExportsDirty(t) {
            this.inner.markExportsDirty(Ws(t))
        }
        getFrame() {
            return this.inner.updateAnalysis(),
            this.inner.getGlobalFrameForMathtools()
        }
        getAnalysis() {
            return this.inner.getAnalysis()
        }
        getEvaluationState(t) {
            return this.inner.getEvaluationState(Ws(t))
        }
        buildSymbolToExpressionDirtyMap() {
            return this.inner.buildSymbolToExpressionDirtyMap()
        }
        getPolicy() {
            return this.inner.moduleContexts.getPolicyContext(or).policy
        }
    }
      , SR = class {
        constructor(t) {
            this.sendMessageForProgressUpdate = t;
            this.fullStatements = new Map;
            this.statementGraphIDs = new Map;
            this.analysis = {};
            this.currentStatus = {};
            this.currentLabel = {};
            this.analysisNeedsPublishIds = new Set;
            this.needGraphingIds = new Set;
            this.selectionOnlyChangeIds = new Set;
            this.intersectId = void 0;
            this.dirtyExportedSymbolRoots = new ho;
            this.dirtyStatementRoots = {};
            this.markedRegressionDirty = !1;
            this.childIntersections = new Ud;
            this.globalEventCount = 0;
            this.moduleContexts = new gI;
            this.lastClockTickTime = void 0;
            this.moduleContexts.getOrCreatePolicyContext(or),
            this.invalidate()
        }
        getGlobalFrameForMathtools() {
            return this.mainFrameContext.getFrame(or)
        }
        getStatements() {
            let t = {};
            for (let[n,r] of this.fullStatements)
                t[n] = r.statement;
            return t
        }
        _getStatement(t) {
            var n;
            return (n = this.getFullStatement(t)) == null ? void 0 : n.statement
        }
        _getOrigin(t) {
            var n;
            return (n = this.getFullStatement(t)) == null ? void 0 : n.origin
        }
        getFullStatementMap() {
            return this.fullStatements
        }
        getFullStatement(t) {
            return this.fullStatements.get(t)
        }
        assertFullStatement(t) {
            let n = this.getFullStatement(t);
            if (!n)
                throw F(`Programming Error: expected FullStatement for id ${t}`);
            return n
        }
        _deleteStatement(t) {
            this.fullStatements.delete(t)
        }
        _allStatementIDs() {
            return [...this.fullStatements.keys()]
        }
        invalidate() {
            this._deleteStatement(rc);
            for (let t of this._allStatementIDs())
                this.markAsDirtyRoot(t);
            this.currentStatus = {},
            this.analysis = {},
            this.mainFrameContext = new af(this.moduleContexts,!1),
            this.lastMainFrameMap = this.mainFrameContext.cloneFrameMapWithoutPrototypes(),
            this.lastClockTickTime = void 0
        }
        invalidateGraphsOnly() {
            for (let t of this._allStatementIDs())
                this.markNeedsGraphing(t)
        }
        getCLSymbolMap() {
            return this.updateConstruction(),
            G3(this.getFullStatementMap(), this.moduleContexts.getPolicyContext(or).policy)
        }
        processEvaluatorConfig(t) {
            let n = [...this._configs(t)];
            if (t.removesRootModules)
                for (let i of ue(t.removesRootModules)) {
                    let s = i;
                    this.moduleContexts.deleteModule(s),
                    this.mainFrameContext.deleteFrame(s),
                    this.mainFrameContext.deleteFrame(nl(s))
                }
            let r = !1
              , o = !1;
            for (let[i,s] of n) {
                let u = this.moduleContexts.getOrCreatePolicyContext(i).processEvaluatorConfig(s);
                r || (r = u.invalidateAll),
                o || (o = u.invalidateGraphs),
                s.hasOwnProperty("globalRandomSeed") && this.dirtyExportedSymbolRoots.add(Gn(i, "globalRandomSeed"))
            }
            this.moduleContexts.updateParentFrameMap(this.fullStatements),
            r ? this.invalidate() : o && this.invalidateGraphsOnly()
        }
        *_configs(t) {
            var o;
            yield[PR(t.defaultRootModuleId), t];
            let r = (o = t.rootModuleConfigs) != null ? o : {};
            if (t.defaultRootModuleId && (r != null && r[t.defaultRootModuleId]))
                throw new Error("Programming error: defaultRootModuleId found on rootModuleConfigs.");
            for (let i of ue(r)) {
                let s = r[i];
                t.isCompleteState && (s = {
                    ...s,
                    isCompleteState: !0
                }),
                yield[i, s]
            }
        }
        processChangeSet(t) {
            let n = Hl()
              , r = {
                cacheWrites: 0,
                cacheReads: 0,
                cacheHits: 0,
                cacheMisses: 0
            };
            gw(r);
            let o = tq();
            if (t.isCompleteState && this.clearState(o),
            t.hasOwnProperty("selectedIds")) {
                let l = t.selectedIds || {};
                if (this.intersectId === void 0 || !l[this.intersectId]) {
                    let[p] = ue(l);
                    this.intersectId = p
                }
            }
            this.processEvaluatorConfig(t);
            let i = Hl();
            this.processStatements(t, o);
            let s = Hl();
            r.processStatements = s - i,
            i = s;
            let a = this.updateAnalysis();
            s = Hl(),
            r.updateAnalysis = s - i,
            i = s;
            let u = this._publishAllStatuses();
            s = Hl(),
            r.publishAllStatuses = s - i,
            i = s,
            this._computeAllLabels(),
            s = Hl(),
            r.computeAllLabels = s - i,
            i = s,
            this._computeAriaDescriptions(),
            s = Hl(),
            r.computeAriaDescriptions = s - i,
            i = s,
            this._graphAllChanged(o),
            s = Hl(),
            r.graphAllChanges = s - i,
            r.updateIntersections = 0;
            let c = this.processEvents(t.events);
            return this.analysisNeedsPublishIds = new Set,
            this.needGraphingIds = new Set,
            this.selectionOnlyChangeIds = new Set,
            r.timeInWorker = s - n,
            {
                syncId: t.syncId,
                isCompleteState: t.isCompleteState,
                intersectionChanges: o.intersections,
                statusChanges: u,
                graphChanges: o.graphs,
                timingData: r,
                eventUpdates: c,
                dependencyOrder: LA(a)
            }
        }
        processStatements(t, n) {
            if (t.removesRootModules) {
                let r = new Set;
                for (let i of ue(t.removesRootModules))
                    r.add(i);
                let o = [];
                for (let[i,s] of this.fullStatements)
                    r.has(s.rootModuleId) && o.push(i);
                for (let i of o)
                    this.removeStatement(i, n)
            }
            if (t.removes)
                for (let r of ue(t.removes))
                    this.removeStatement(r, n);
            if (t.statements)
                for (let r in t.statements) {
                    let o = t.statements[r];
                    o === null || (o.id = Ws(o.id),
                    this.addStatement(o, PR(t.defaultRootModuleId)))
                }
        }
        _publishAllStatuses() {
            let t = {}
              , n = this.currentStatus;
            this.currentStatus = {};
            for (let r of this.analysisNeedsPublishIds) {
                if (!this.analysis.hasOwnProperty(r))
                    continue;
                let o = this.analysis[r].evaluationState;
                $o(o, n[r]) || (t[r] = o),
                this.currentStatus[r] = o
            }
            return t
        }
        _computeAllLabels() {
            for (let t of ue(this.currentLabel)) {
                let n = this.getFullStatement(t);
                if (!n)
                    continue;
                let r = wc(this.mainFrameContext, n)
                  , o = n.statement
                  , i = Es(this.moduleContexts, n)
                  , s = hl(o, i, r)
                  , a = 1;
                (s.valueType === zt || s.valueType === ke || s.valueType === Tr || s.valueType === Dr || s.valueType === Ar || s.valueType === wr) && (a = s.length);
                let u = []
                  , c = this.currentLabel[t];
                if (xc(c))
                    for (let l = 0; l < a; l++)
                        u.push(xR(c, i, r, l));
                $o(u, o.computedLabels) || (o.computedLabels = u,
                this.markNeedsGraphing(t))
            }
        }
        _computeAriaDescriptions() {
            for (let t of ue(this.analysis)) {
                let n = this.getFullStatement(t);
                if (!n)
                    continue;
                let r = this.analysis[t], o = r.evaluationState, s = r.rawTree.userData, a;
                if (s.description ? a = s.description : s.label && (a = s.label),
                a) {
                    o.computed_description = [];
                    let u = 1;
                    r.concreteTree.isList ? u = r.concreteTree.length : o.dimensions && o.dimensions.x && Array.isArray(o.dimensions.x) && (u = o.dimensions.x.length);
                    let c = wc(this.mainFrameContext, n)
                      , l = Es(this.moduleContexts, n);
                    for (let p = 0; p < u; p++)
                        o.computed_description.push(xR(bR(a), l, c, p))
                }
            }
        }
        _graphAllChanged(t) {
            var o;
            let n = !1
              , r = !1;
            for (let i of this.needGraphingIds) {
                let s = this.getFullStatement(i);
                if (!s)
                    continue;
                let a = this.moduleContexts.getPolicyContext(s.rootModuleId).viewState;
                if (!a || !SF(a))
                    continue;
                let u = this._getOrigin(i);
                if ((u == null ? void 0 : u.type) !== "REAL")
                    continue;
                let c = (o = this.statementGraphIDs.get(i)) != null ? o : [];
                for (let d of c)
                    this._notifyGraphRemoved(d, t);
                let l = B9(this.analysis, i, a, this.postProgressUpdate.bind(this), this.childIntersections)
                  , p = [];
                for (let {graphID: d, graphData: y} of l)
                    y && (this._notifyGraphComputed(d, y, t),
                    p.push(d));
                this.statementGraphIDs.set(i, p);
                let m = this.analysis[i];
                m && !Vu(m.rawTree) && (r = !0,
                i === this.intersectId && (n = !0,
                this._updateIntersections(i, t)))
            }
            r && !n && (this.lastComputedIntersectId = void 0),
            this.intersectId !== void 0 && !n && (r || this.intersectId !== this.lastComputedIntersectId) && this._updateIntersections(this.intersectId, t)
        }
        _notifyGraphRemoved(t, n) {
            n.graphs[t] = void 0
        }
        _notifyGraphComputed(t, n, r) {
            zA(n),
            r.graphs[t] = n
        }
        _updateIntersections(t, n) {
            this.lastComputedIntersectId = t;
            let r = this.getFullStatement(t);
            if (!r)
                return;
            let o = this.moduleContexts.getPolicyContext(r.rootModuleId).viewState;
            if (!o)
                return;
            if (!this.analysis[t] || !this.analysis[t].shouldIntersect()) {
                n.intersections[t] = [];
                return
            }
            this.postProgressUpdate("GRAPHING", [t]);
            let i = B3(this.analysis, o, t);
            n.intersections[t] = i,
            this.postProgressUpdate("UNPUBLISHED", [t])
        }
        addStatement(t, n) {
            if (!t)
                return;
            t.id = Ws(t.id);
            let r = t
              , o = r.id
              , i = this.getFullStatement(o)
              , s = this._getOrigin(o)
              , a = i == null ? void 0 : i.statement
              , u = a == null ? void 0 : a.userData
              , c = !!u && !!i && A9(u, r) && !w9(a, wc(this.mainFrameContext, i))
              , l = L9(t, n)
              , p = nq(t, n);
            l !== p && this.moduleContexts.setRootModule(l, p);
            let m = this.moduleContexts.getPolicyContext(p)
              , d = V9(r, m.getParseOptions(r), m.policy, l, p)
              , y = new Set(d.map(f => f.id));
            for (let {id: f, statementNode: h, moduleID: x} of d) {
                let T = f === r.id ? {
                    type: "REAL",
                    childIDs: y
                } : {
                    type: "CHILD",
                    parentID: r.id
                };
                this.updateSingleStatement(f, new ef({
                    id: f,
                    statement: h,
                    moduleID: x,
                    rootModuleId: p,
                    origin: T
                }), {
                    selectionOnlyChange: c
                })
            }
            if ((s == null ? void 0 : s.type) === "REAL")
                for (let f of s.childIDs)
                    y.has(f) || this.removeSingleStatement(f);
            let g = r.label;
            if (g) {
                let f = this.currentLabel[o];
                (!f || f.raw !== g) && (this.currentLabel[o] = bR(g))
            } else
                delete this.currentLabel[o]
        }
        replaceStatementParsenode(t, n) {
            this.updateSingleStatement(t.id, new ef({
                id: t.id,
                statement: n,
                moduleID: t.moduleID,
                rootModuleId: t.rootModuleId,
                origin: t.origin
            }), {
                selectionOnlyChange: !1
            })
        }
        updateSingleStatement(t, n, {selectionOnlyChange: r}) {
            r ? this.selectionOnlyChangeIds.add(t) : (this.markExportsDirty(t),
            this.markAsDirtyRoot(t)),
            this.fullStatements.set(t, n)
        }
        clearState(t) {
            this.invalidate(),
            this.currentLabel = {},
            this.fullStatements = new Map;
            for (let n of this.statementGraphIDs.values())
                for (let r of n)
                    this._notifyGraphRemoved(r, t);
            this.statementGraphIDs = new Map
        }
        removeStatement(t, n) {
            let r = this._getOrigin(t);
            if ((r == null ? void 0 : r.type) === "REAL") {
                for (let i of r.childIDs)
                    this.removeSingleStatement(i);
                let o = this.statementGraphIDs.get(t);
                for (let i of o != null ? o : [])
                    this._notifyGraphRemoved(i, n)
            }
            this.removeSingleStatement(t)
        }
        removeSingleStatement(t) {
            this._getStatement(t) && (this.markExportsDirty(t),
            delete this.currentLabel[t],
            this._deleteStatement(t),
            delete this.analysis[t],
            delete this.currentStatus[t],
            this.mainFrameContext.deleteTableFrame(t))
        }
        markExportsDirty(t) {
            let n = this.getFullStatement(t);
            if (!n)
                return;
            ss(n.statement) && (this.markedRegressionDirty = !0);
            let r = Es(this.moduleContexts, n);
            for (let o of n.statement.getLegalExports(r)) {
                let i = Gn(n.moduleID, o);
                this.dirtyExportedSymbolRoots.add(i)
            }
        }
        markAsDirtyRoot(t) {
            this.dirtyStatementRoots[t] = !0
        }
        shouldPublishAndGraph(t) {
            let n = this._getOrigin(t);
            return (n == null ? void 0 : n.type) === "REAL"
        }
        markNeedsGraphing(t) {
            this.shouldPublishAndGraph(t) && this.needGraphingIds.add(t)
        }
        getAnalysis() {
            return this.updateAnalysis(),
            this.analysis
        }
        getEvaluationState(t) {
            if (this.updateAnalysis(),
            !!this.analysis[t])
                return this.analysis[t].evaluationState
        }
        _updateRegressions(t) {
            var d, y, g;
            let n = [];
            for (let f of t.keys()) {
                let h = this._getStatement(f);
                h && ss(h) && n.push(f)
            }
            if (n.length === 0)
                return;
            let r = new af(this.moduleContexts,!0)
              , o = Ry(this.moduleContexts, this.getFullStatementMap(), n);
            r.markDependencyOrder(o),
            X3(o, r, this.moduleContexts);
            let i = o.resolved;
            this.postProgressUpdate("RESOLVED", i);
            let s = {};
            for (let f of this._allStatementIDs()) {
                let h = this._getStatement(f);
                h && Vu(h) && (s[f] = h)
            }
            let a = new Map
              , u = new Set;
            for (let f of i) {
                if (f === rc) {
                    this.postProgressUpdate("UNPUBLISHED", [f]);
                    continue
                }
                if (u.has(f))
                    continue;
                this.postProgressUpdate("ANALYZING", [f]);
                let h = this.getFullStatement(f);
                if (!h) {
                    this.postProgressUpdate("UNPUBLISHED", [f]);
                    continue
                }
                let x = h.statement
                  , T = Es(this.moduleContexts, h);
                if (ss(x)) {
                    if (!T.graphingEnabled())
                        throw new Error("Programming Error: expected graphing policy when analyzing regression");
                    let P = ((d = x.tableRegressionData) == null ? void 0 : d.tableId) === void 0 ? wc(r, h) : r.getFrame(x.tableRegressionData.tableId)
                      , C = (y = this.lastMainFrameMap.get(Lg(h))) != null ? y : {
                        [Symbol("DUMMY_NO_LAST_FRAME")]: !0
                    }
                      , S = _3(x, T, P, C);
                    a.set(f, S),
                    this.postProgressUpdate("UNPUBLISHED", [f])
                } else {
                    let P = wc(r, h)
                      , C = this.analyzeSingleStatementGraphing(f, this.analysis, P, o, "regression")
                      , S = [];
                    for (let E of C)
                        this.exportTo(E, r),
                        S.push(E.id),
                        E.id !== f && u.add(E.id);
                    this.postProgressUpdate("UNPUBLISHED", S)
                }
            }
            let c = new ho;
            for (let[f,h] of a) {
                if (h instanceof v)
                    continue;
                let x = this.getFullStatement(f)
                  , T = Lg(x);
                for (let P of ue(h.parameters)) {
                    if (Es(this.moduleContexts, x).assignmentForbidden(P))
                        continue;
                    let C = Gn(T, P);
                    c.add(C)
                }
            }
            let l = new Map
              , p = f => {
                var T, P;
                let h = this.getFullStatement(f)
                  , x = Lg(h);
                return E3(h.statement, (T = o.assignmentMaps.assignments.mapForFrame(x)) != null ? T : new Map, (P = c.mapForFrame(x)) != null ? P : new Map)
            }
              , m = (f, h) => {
                l.set(f, h);
                let x = this.getFullStatement(f);
                if (!Es(this.moduleContexts, x).assignmentForbidden(h)) {
                    let T = Lg(x);
                    c.add(Gn(T, h))
                }
            }
            ;
            for (let[f,h] of a) {
                if (h instanceof v)
                    continue;
                let x = this._getStatement(f);
                if (!((g = x.userData) != null && g.residualVariable))
                    continue;
                let T = p(f);
                T === Bs(x.userData.residualVariable) && m(f, T)
            }
            for (let f of a.keys()) {
                if (l.has(f))
                    continue;
                let h = p(f);
                m(f, h)
            }
            for (let[f,h] of a) {
                let x = this.getFullStatement(f)
                  , T = Es(this.moduleContexts, x);
                if (!T.graphingEnabled())
                    throw new Error("Programming Error: expected graphing policy when analyzing regression");
                let P = wc(this.mainFrameContext, x)
                  , C = l.get(f)
                  , S = R3(x.statement, T, P, {
                    residualVariable: C,
                    tableStatements: s
                }, h);
                this.analysis[f] = S;
                let E = this.exportTo({
                    id: f,
                    stmtAnalysis: S
                }, this.mainFrameContext);
                S.evaluationState.exported_variables = E,
                t.delete(f)
            }
        }
        _updateAnalysisAndFrame(t, n, r) {
            var a;
            let o = this.analysis;
            this.mainFrameContext.markDependencyOrder(t),
            X3(t, this.mainFrameContext, this.moduleContexts);
            let i = t.resolved.filter(u => r.has(u));
            this.postProgressUpdate("RESOLVED", i);
            let s = new Set;
            for (let u of i) {
                if (u === rc) {
                    this.postProgressUpdate("UNPUBLISHED", [u]);
                    continue
                }
                if (n.has(u)) {
                    this.postProgressUpdate("UNPUBLISHED", [u]);
                    continue
                }
                if (s.has(u))
                    continue;
                this.postProgressUpdate("ANALYZING", [u]);
                let c = this.analyzeSingleStatement(u, o, t)
                  , l = [];
                for (let p of c) {
                    o[p.id] = p.stmtAnalysis;
                    let m = this.exportTo(p, this.mainFrameContext)
                      , d = this._getOrigin(p.id);
                    if ((d == null ? void 0 : d.type) === "REAL") {
                        let y = new Set(m);
                        for (let g of d.childIDs) {
                            let f = this.analysis[g]
                              , h = (a = f == null ? void 0 : f.evaluationState.exported_variables) != null ? a : [];
                            for (let x of h)
                                y.add(x)
                        }
                        m = [...y]
                    }
                    p.stmtAnalysis.evaluationState.exported_variables = m,
                    l.push(p.id),
                    p.id !== u && s.add(p.id)
                }
                this.postProgressUpdate("UNPUBLISHED", l)
            }
            return {
                analyzedStatements: i
            }
        }
        exportTo(t, n) {
            let r = this.getFullStatement(t.id);
            if (!r)
                throw F("Missing statement corresponding to entry that was just created.");
            let {statement: o, moduleID: i} = r
              , s = Es(this.moduleContexts, r)
              , a = t.stmtAnalysis.rawTree.exportTo(s, t.stmtAnalysis.concreteTree, n.getFrame(i));
            if (o instanceof sa) {
                let u = wc(n, r);
                o.exportToLocal(s, t.stmtAnalysis.concreteTree, u)
            }
            return a
        }
        buildSymbolToExpressionDirtyMap() {
            return L3(this.moduleContexts, this.fullStatements)
        }
        buildChildIntersectionMap() {
            let t = this.childIntersections
              , n = new Ud;
            for (let o of ue(this.analysis)) {
                let i = this.analysis[o]
                  , {geometry: s} = i.evaluationState;
                if (s != null && s.call && s.call.symbol === "intersection" && this._getStatement(o).userData.shouldGraph && i.concreteTree.type !== "Error") {
                    let a = !!this.needGraphingIds.has(o)
                      , u = Rr(i.concreteTree);
                    for (let c of s.call.parents) {
                        if (c.type === "arbitrary-expression")
                            continue;
                        let l = ku(c);
                        if (!l)
                            continue;
                        let p = this.mainFrameContext.getFrame(or)[l]
                          , m = p && p.userData.id;
                        if (m == null)
                            continue;
                        let d = this.analysis[m]
                          , y = Rr(d.concreteTree);
                        y && u && n.addChildIntersection({
                            id: m,
                            valueType: y.valueType,
                            ref: c
                        }, u),
                        a && this.markNeedsGraphing(m)
                    }
                }
            }
            let r = Ud.compareIntersectionCounts({
                nextChildIntersections: n,
                prevChildIntersections: t
            });
            for (let o of ue(r)) {
                let {prev: i, next: s} = r[o];
                s < i && this.markNeedsGraphing(o)
            }
            return n
        }
        findAllRegressionExports() {
            let t = new Map
              , n = new ho;
            for (let r of this._allStatementIDs()) {
                let o = this.getFullStatement(r);
                if (!o || !ss(o.statement))
                    continue;
                let i = this.analysis[r];
                if (!i || !ss(i.rawTree))
                    continue;
                let s = i.concreteTree
                  , a = i.rawTree.getExportsFromConcrete(Es(this.moduleContexts, o), s)
                  , u = [];
                for (let c of a) {
                    let l = Gn(o.moduleID, c);
                    n.add(l),
                    u.push(l)
                }
                t.set(r, u)
            }
            return {
                regressionExportMap: t,
                regressionExportRoots: n
            }
        }
        updateConstruction() {
            let t = [];
            for (let s of this._allStatementIDs())
                this._getStatement(s).userData.isInConstructionsFolder && t.push(s);
            let n = this._getStatement(rc)
              , r = new b9(t);
            r.metaData = {
                extraDepNodes: []
            },
            r.userData = {};
            let o = {};
            for (let s of (n == null ? void 0 : n.getDependencies()) || [])
                o[s] = !0;
            let i = {};
            for (let s of r.getDependencies())
                i[s] = !0;
            if (!n || !$o(o, i)) {
                let s = {
                    type: "AUX"
                }
                  , a = or
                  , u = or;
                this.updateSingleStatement(rc, new ef({
                    id: rc,
                    statement: r,
                    moduleID: a,
                    rootModuleId: u,
                    origin: s
                }), {
                    selectionOnlyChange: !1
                }),
                this.moduleContexts.getPolicyContext(a).markConstruction(r)
            }
        }
        analyzeExternalRecursiveBaseCases() {
            let t = []
              , n = {};
            for (let a of this._allStatementIDs()) {
                let u = this.getFullStatement(a);
                if (!u)
                    continue;
                let c = this.moduleContexts.getPolicyContext(u.moduleID);
                if (!c.recursion)
                    continue;
                let l = this._getStatement(a);
                l instanceof _r && !c.policy.assignmentForbidden(l._symbol) && (t.push(a),
                n[l._symbol] = l)
            }
            let {recursiveFunctionGroups: r} = Ry(this.moduleContexts, this.getFullStatementMap(), t)
              , o = new Set;
            for (let a of t) {
                let u = this._getStatement(a);
                u instanceof _r && r[a] && o.add(u._symbol)
            }
            let i = {}
              , s = [];
            for (let a of this._allStatementIDs()) {
                let u = this.getFullStatement(a);
                if (!u)
                    continue;
                let c = u.statement;
                if (c instanceof gl && o.has(c._lhs._symbol)) {
                    let l = xo.fromCallAssignment(n, c);
                    if (!l)
                        continue;
                    this.replaceStatementParsenode(u, l);
                    let p = l._symbol;
                    i[p] || (i[p] = []),
                    i[p].push(l),
                    l.getDependencies().length && s.push(a)
                } else if (c instanceof xo) {
                    let l = c._symbol;
                    o.has(c._symbol) ? (i[l] || (i[l] = []),
                    i[l].push(c),
                    c.getDependencies().length && s.push(a)) : this.replaceStatementParsenode(u, c.originalNode)
                }
            }
            for (let a of ue(n)) {
                let u = n[a]
                  , c = u.getExternalBaseCases()
                  , l = i[a] || [];
                F9(l, c) || (u.setExternalBaseCases(l),
                this.markExportsDirty(u.userData.id),
                this.markAsDirtyRoot(u.userData.id))
            }
            if (s.length) {
                let {recursiveFunctionBaseCasesWithCycles: a} = Ry(this.moduleContexts, this.getFullStatementMap(), s);
                for (let u of a) {
                    let c = this.getFullStatement(u);
                    if (!c)
                        continue;
                    let l = c.statement;
                    if (l instanceof xo) {
                        let p = n[l._symbol];
                        p.setExternalBaseCases(p.getExternalBaseCases().filter(m => m !== l)),
                        this.replaceStatementParsenode(c, l.originalNode)
                    }
                }
            }
        }
        updateAnalysis() {
            var S, E, M, _, U, Q, K;
            this.updateConstruction(),
            this.moduleContexts.updateParentFrameMap(this.fullStatements),
            this.mainFrameContext.syncPolicyFramesAndFixPrototypes(),
            this.analyzeExternalRecursiveBaseCases();
            let t = this.getFullStatementMap()
              , n = this.buildSymbolToExpressionDirtyMap()
              , r = Kp(this.moduleContexts, this.fullStatements, n, this.dirtyStatementRoots, this.dirtyExportedSymbolRoots)
              , o = !1;
            for (let w of this.moduleContexts.rootModules()) {
                let B = Gn(w, Qb);
                r.symbols.has(B) && (o = !0)
            }
            o && this.invalidateGraphsOnly();
            let i = this.markedRegressionDirty;
            for (let w of ue(r.ids)) {
                let B = this._getStatement(w);
                B && ss(B) && (i = !0)
            }
            let s = new Set;
            if (i) {
                for (let w of this._allStatementIDs())
                    this._getStatement(w) && s.add(w);
                this.mainFrameContext = new af(this.moduleContexts,!1)
            } else {
                let w = r.ids;
                for (let W of ue(w))
                    this._getStatement(W) && s.add(W);
                let B = r.symbols;
                for (let W of B)
                    this.mainFrameContext.deleteName(W)
            }
            let a = !1;
            for (let w of s.keys()) {
                this.markNeedsGraphing(w);
                let B = this.mainFrameContext.deleteTableFrame(w);
                a || (a = B)
            }
            if (a)
                for (let w of this._allStatementIDs()) {
                    let B = this._getStatement(w);
                    B.tableFrameID && s.has(B.tableFrameID) && s.add(w)
                }
            let u = new Set([...s, ...this.selectionOnlyChangeIds]);
            this.analysisNeedsPublishIds = new Set;
            for (let w of u)
                this.shouldPublishAndGraph(w) && this.analysisNeedsPublishIds.add(w);
            this.markedRegressionDirty = !1,
            this.dirtyExportedSymbolRoots = new ho,
            this.dirtyStatementRoots = {};
            let c = this.analysis;
            i && [...this.moduleContexts.getAllContexts()].some(w => w.evaluationMode === "graphing" || w.evaluationMode === "geometry" || w.evaluationMode === "graphing_3d") && this._updateRegressions(s);
            let {regressionExportMap: l, regressionExportRoots: p} = this.findAllRegressionExports()
              , m = Ry(this.moduleContexts, t, this._allStatementIDs(), l)
              , d = {};
            for (let w of m.viewportTransitiveDependencies)
                (S = this.lastViewportDependencies) != null && S.has(w) || (d[w] = !0);
            for (let w of (E = this.lastViewportDependencies) != null ? E : [])
                !m.viewportTransitiveDependencies.has(w) && this.fullStatements.has(w) && (d[w] = !0);
            this.lastViewportDependencies = m.viewportTransitiveDependencies;
            let y = Kp(this.moduleContexts, this.fullStatements, n, d, new ho)
              , g = new Set(m.resolved);
            for (let w of ue(y.ids))
                g.has(w) || m.resolved.push(w),
                u.has(w) || u.add(w),
                this.shouldPublishAndGraph(w) && this.analysisNeedsPublishIds.add(w);
            let {analyzedStatements: f} = this._updateAnalysisAndFrame(m, new Set(l.keys()), u);
            for (let w of f) {
                let B = this.getFullStatement(w);
                B && bc(B.statement) && (B.statement.isViewportDependency = m.viewportTransitiveDependencies.has(w))
            }
            let h = Kp(this.moduleContexts, this.fullStatements, n, {}, p)
              , x = new ho;
            for (let w of m.recursiveFunctionSymbols)
                x.add(w);
            let T = Kp(this.moduleContexts, this.fullStatements, n, {}, x);
            this.markRegressionAndRecursionDependents({
                regressionDependentStatements: h.ids,
                recursionDependentStatements: T.ids
            });
            for (let w of ue(this.analysis)) {
                let B = this.analysis[w];
                if (ss(B.rawTree) && ((M = B.rawTree.tableRegressionData) != null && M.tableId)) {
                    let W = B.evaluationState
                      , oe = this.analysis[B.rawTree.tableRegressionData.tableId];
                    if (!oe)
                        throw new Error(`Programming error: table ${B.rawTree.tableRegressionData.tableId} not found for table regression ${w}`);
                    let te = oe.evaluationState;
                    if (W.regression) {
                        let Tt = B.rawTree.tableRegressionData.columnInfo.filter(k => k.isIdentifier).map(k => Bs(k.latex)).filter(k => B.policy.assignmentForbidden(k)), ye = (_ = B.rawTree.tableRegressionData.columnInfo.find(k => !k.isIdentifier)) == null ? void 0 : _.latex, ee;
                        Tt.length > 0 ? ee = oM(Tt).getError() : ye && (ee = rM(ye).getError()),
                        te.table_regression = {
                            status: "success",
                            result: W.regression,
                            export_info: ee ? {
                                status: "unexportable",
                                reason: ee
                            } : {
                                status: "exportable"
                            }
                        }
                    } else
                        te.table_regression = {
                            status: "error",
                            error: (U = W.error) != null ? U : F('Expected regression state to define either "regression" or "error"').getError()
                        }
                }
            }
            for (let w of this.moduleContexts.rootModules()) {
                let B = this.moduleContexts.getPolicyContext(w);
                if (!(B.policy.graphingEnabled() && B.viewState))
                    continue;
                let oe = (Q = this.mainFrameContext.getFrame(w)[Qb]) == null ? void 0 : Q.userData.id;
                if (!oe)
                    continue;
                let te = c[oe]
                  , st = te == null ? void 0 : te.evaluationState;
                (st == null ? void 0 : st.viewport.status) === "valid" && B.updateEvaluatedViewport(st.viewport.value)
            }
            for (let w of f) {
                let B = this.getFullStatement(w);
                if (!B)
                    continue;
                let W = Es(this.moduleContexts, B);
                W.graphingEnabled() && this.evaluateMetadataForStatement(w, wc(this.mainFrameContext, B), W)
            }
            this.childIntersections = this.buildChildIntersectionMap(),
            F3(n).forEach(w => {
                c[w].evaluationState.depends_on_random_seed = !0
            }
            );
            let P = Kp(this.moduleContexts, this.fullStatements, n, {
                [rc]: !0
            }, new ho([Gn(or, "construction")]));
            for (let w of ue(P.ids)) {
                if (w === rc)
                    continue;
                let B = c[w].evaluationState;
                B.geometry && (B.geometry.unconstructable = !0)
            }
            let C;
            for (let w of this._allStatementIDs())
                if ((K = this._getStatement(w).userData) != null && K.latexSelection) {
                    C = w;
                    break
                }
            if (C) {
                let w = Kp(this.moduleContexts, this.fullStatements, n, {
                    [C]: !0
                }, new ho([Gn(or, `idref_${C}`)]));
                for (let B of ue(w.ids)) {
                    if (B === rc)
                        continue;
                    let W = c[B].evaluationState;
                    W.geometry && (W.geometry.depends_on_selected = !0)
                }
            }
            return this.lastMainFrameMap = this.mainFrameContext.cloneFrameMapWithoutPrototypes(),
            m
        }
        analyzeSingleStatement(t, n, r) {
            let o = this.getFullStatement(t)
              , i = wc(this.mainFrameContext, o)
              , s = o.statement
              , a = this.moduleContexts.getPolicyContext(o.moduleID);
            switch (a.evaluationMode) {
            case "fourFunction":
            case "singleExpressionFourFunction":
                return [{
                    id: t,
                    stmtAnalysis: A3(s, a.policy, i)
                }];
            case "scientific":
                return [{
                    id: t,
                    stmtAnalysis: O3(s, a.policy, i)
                }];
            case "singleExpressionScientific":
                return [{
                    id: t,
                    stmtAnalysis: NI(s, a.policy, i)
                }];
            case "graphing":
            case "graphing_3d":
            case "geometry":
                return this.analyzeSingleStatementGraphing(t, n, i, r, "main")
            }
        }
        analyzeSingleStatementGraphing(t, n, r, o, i) {
            let s = this.getFullStatement(t);
            if (!s)
                throw F("Missing full statement.");
            let a = this.moduleContexts.getPolicyContext(s.moduleID);
            if (!a.policy.graphingEnabled())
                throw F("Expected graphing policy");
            if (i === "main" && r.r) {
                let c = Fn(r);
                c.r = void 0;
                let l = sf(this._getStatement(t), a.policy, c, n);
                if (l.getGraphMode() === 6)
                    return [{
                        id: t,
                        stmtAnalysis: l
                    }]
            }
            let u = o.recursiveFunctionGroups[t];
            if (u && a.recursion) {
                if (i === "regression")
                    for (let l of u) {
                        let p = this.assertFullStatement(l)
                          , m = this._getStatement(l)
                          , d = EE()
                          , y = {
                            policy: Es(this.moduleContexts, p),
                            rawTree: m,
                            concreteTree: d
                        };
                        return [{
                            id: l,
                            stmtAnalysis: y
                        }]
                    }
                let c = {};
                for (let l of u)
                    c[l] = this._getStatement(l);
                return N3(a.policy, r, c)
            }
            if (i === "regression") {
                let c = this._getStatement(t)
                  , l = hl(c, a.policy, r)
                  , p = {
                    policy: a.policy,
                    rawTree: c,
                    concreteTree: l
                };
                return [{
                    id: t,
                    stmtAnalysis: p
                }]
            } else {
                let c = sf(this._getStatement(t), a.policy, r, n);
                return [{
                    id: t,
                    stmtAnalysis: c
                }]
            }
        }
        evaluateMetadataForStatement(t, n, r) {
            var a, u;
            if (t === rc)
                return;
            let o = this.analysis[t]
              , i = o.evaluationState.expression_type
              , s = this.moduleContexts.getPolicyContext(this.assertFullStatement(t).moduleID);
            for (let c of ue(Fg)) {
                let l = Fg[c];
                s.evaluationMode !== "graphing_3d" && c === "resolution" || (!l.shouldEvaluate || l.shouldEvaluate(o)) && v9(o, r, n, c)
            }
            M9(o, r, n),
            s.product === "graphing-3d" && D9(o),
            s.actions && x9(o) && _9(o, r, n),
            i === A.PARAMETRIC || i === A.CURVE3D_xyz_t || i === A.POLAR || i === A.SURFACE_r_\u03B8z || i === A.SURFACE_r_\u03B8z_AMBIGUOUS || i === A.SLICE_r\u03B8z_at_z ? R9(o, r, n) : i === A.SURFACE_xyz_uv || i === A.SLICE_xyz_uv || i === A.SURFACE_r_\u03B8\u03C6 || i === A.SURFACE_z_r\u03B8 || i === A.SLICE_zr\u03B8_at_r || i === A.SLICE_zr\u03B8_at_\u03B8 || i === A.SLICE_zr\u03B8_at_xyz || i === A.SLICE_r\u03B8\u03C6_at_\u03B8 || i === A.SLICE_r\u03B8\u03C6_at_\u03C6 || i === A.SLICE_r\u03B8\u03C6_at_xyz ? N9(o, r, n) : i === A.BOXPLOT ? O9(o, r, n) : ((a = o.evaluationState.top_level_function_spec) == null ? void 0 : a.type) === "distribution" ? Z2(o, r, n) : (Ti((u = o.evaluationState.typed_constant_value) == null ? void 0 : u.valueType) || q_(o.rawTree)) && P2(o, r, n)
        }
        markRegressionAndRecursionDependents(t) {
            for (let n of ue(this.analysis)) {
                let r = this.analysis[n];
                if (bc(r.rawTree)) {
                    let o = this.analysis[r.rawTree.tableID];
                    if (!o)
                        continue;
                    let i = o.evaluationState.column_data[r.rawTree.columnIndex];
                    if (!i)
                        continue;
                    i.depends_on_regression = !!t.regressionDependentStatements[n],
                    i.depends_on_recursive_function = !!t.recursionDependentStatements[n]
                } else
                    r.evaluationState.depends_on_regression = !!t.regressionDependentStatements[n],
                    r.evaluationState.depends_on_recursive_function = !!t.recursionDependentStatements[n]
            }
        }
        childFrameWithIncrementedEventCount(t) {
            let n = this.mainFrameContext.getFrame(t)
              , r = Fn(n);
            return this.globalEventCount += 1,
            r.globalEventCount = new O.Constant(this.globalEventCount),
            r
        }
        processEvents(t) {
            if (!t || [...this.moduleContexts.getAllContexts()].every(a => !a.actions))
                return;
            let n = {}, r = new Map, o = !1, i = !1, s;
            for (let a of t)
                switch (a.type) {
                case "step":
                    {
                        let c = this.getFullStatement(Ws(a.expressionId))
                          , l = c == null ? void 0 : c.statement;
                        if (!l)
                            continue;
                        let p = c.moduleID
                          , m = this.childFrameWithIncrementedEventCount(p)
                          , d = hl(l, Es(this.moduleContexts, c), m);
                        i = !0,
                        TR(d, p, n, this.mainFrameContext, r);
                        break
                    }
                case "click":
                    {
                        let c = this.getFullStatement(Ws(a.expressionId))
                          , l = c == null ? void 0 : c.statement;
                        if (!l || !l.metaData.clickHandler)
                            continue;
                        let p = c.moduleID
                          , m = this.childFrameWithIncrementedEventCount(p);
                        m.index = new O.Constant(a.indexVar + 1);
                        let d = pe(l.metaData.clickHandler, Es(this.moduleContexts, c), m);
                        i = !0,
                        o = !0,
                        TR(d, p, n, this.mainFrameContext, r);
                        break
                    }
                case "clock-tick":
                    {
                        (s === void 0 || a.isFirstTick && !s.isFirstTick) && (s = a);
                        break
                    }
                default:
                    return a
                }
            if (s) {
                let a = this.getFullStatement(Ws(s.id))
                  , u = a == null ? void 0 : a.statement;
                if (u && u instanceof O.Ticker) {
                    let c = Es(this.moduleContexts, a)
                      , l = a.moduleID
                      , p = this.childFrameWithIncrementedEventCount(l)
                      , m = pe(u.minStep, c, p, ER).asValue();
                    if (typeof m == "number" && m >= 0 && isFinite(m)) {
                        let y = this.lastClockTickTime;
                        if (this.lastClockTickTime = Date.now(),
                        !s.isFirstTick && y !== void 0) {
                            p.dt = new O.Constant(this.lastClockTickTime - y);
                            let g = pe(u.handler, c, p);
                            TR(g, l, n, this.mainFrameContext, r)
                        }
                    }
                }
            }
            for (let[a,u] of r) {
                let c = this.mainFrameContext.getFrame(a);
                for (let l of ue(u))
                    c[l] = u[l]
            }
            return {
                objectClicked: o,
                userAction: i,
                updates: n
            }
        }
        postProgressUpdate(t, n) {
            var r;
            (r = this.sendMessageForProgressUpdate) == null || r.call(this, "evaluatorProgressUpdate", {
                update: t,
                ids: n
            })
        }
    }
    ;
    function F9(e, t) {
        if (e.length !== t.length)
            return !1;
        for (let n = 0; n < e.length; n++)
            if (e[n] !== t[n])
                return !1;
        return !0
    }
    function Q3(e) {
        let t = C_(e.symbol);
        return t instanceof v ? t : Gn(e.frameID, t._symbol)
    }
    function K3(e, t, n) {
        return {
            id: e,
            moduleID: n.frameID,
            rootModuleId: n.frameID,
            statementNode: new O.AssignmentImport(n.symbol,t)
        }
    }
    function V9(e, t, n, r, o) {
        let i = e.id
          , s = {
            extraDepNodes: []
        }
          , a = !1;
        function u(c) {
            return c.userData = e,
            c.metaData = s,
            [{
                id: i,
                statementNode: c,
                moduleID: r,
                rootModuleId: o
            }]
        }
        switch (e.type) {
        case "table":
            {
                e.shouldGraph = !0;
                let c = e.columns
                  , l = []
                  , p = new Map
                  , m = f => !f.replace(/\\space|\\ /g, "").match(/\S/)
                  , d = [];
                for (let f = 0; f < c.length; f++) {
                    let h = c[f]
                      , x = mi(h.latex, {
                        ...t,
                        seedPrefix: Mn(i, [["tr", 0], ["tc", f]])
                    })
                      , T = []
                      , P = -1;
                    for (let M = 0; M < c[f].values.length; M++)
                        m(h.values[M]) ? T.push(new wI(NaN)) : (T.push(mi(h.values[M], {
                            ...t,
                            seedPrefix: Mn(i, [["tr", M + 1], ["tc", f]])
                        })),
                        P = M);
                    T = T.slice(0, P + 1);
                    let C = new sa(x,T,Ws(e.id),f)
                      , S = Ws(`dcgcolumnstmt${h.id}`);
                    C.userData = {
                        id: S
                    },
                    p.set(Ws(h.id), C),
                    d.push({
                        id: S,
                        statementNode: C,
                        moduleID: r,
                        rootModuleId: o
                    });
                    let E = new sa(x,T,e.id,f);
                    if (E.userData = h,
                    E.header) {
                        if (E.header.userData = h,
                        E.header.metaData = {
                            extraDepNodes: []
                        },
                        h.colorLatex) {
                            let M = kr(h.colorLatex, {
                                ...t,
                                seedPrefix: Mn(i, [["tr", 0], ["tc", f], ["cl", f]])
                            });
                            E.header.metaData.colorLatex = M,
                            E.header.metaData.extraDepNodes.push(M)
                        }
                        if (h.pointSize) {
                            let M = kr(h.pointSize, {
                                ...t,
                                seedPrefix: Mn(i, [["tr", 0], ["tc", f], ["ps", f]])
                            });
                            E.header.metaData.pointSize = M,
                            E.header.metaData.extraDepNodes.push(M)
                        }
                        if (h.pointOpacity) {
                            let M = kr(h.pointOpacity, {
                                ...t,
                                seedPrefix: Mn(i, [["tr", 0], ["tc", f], ["po", f]])
                            });
                            E.header.metaData.pointOpacity = M,
                            E.header.metaData.extraDepNodes.push(M)
                        }
                        if (h.lineWidth) {
                            let M = kr(h.lineWidth, {
                                ...t,
                                seedPrefix: Mn(i, [["tr", 0], ["tc", f], ["lw", f]])
                            });
                            E.header.metaData.lineWidth = M,
                            E.header.metaData.extraDepNodes.push(M)
                        }
                        if (h.lineOpacity) {
                            let M = kr(h.lineOpacity, {
                                ...t,
                                seedPrefix: Mn(i, [["tr", 0], ["tc", f], ["lo", f]])
                            });
                            E.header.metaData.lineOpacity = M,
                            E.header.metaData.extraDepNodes.push(M)
                        }
                    }
                    l.push(E)
                }
                let y;
                e.regression && (y = Y3(e, i, t, p),
                y !== void 0 && d.push({
                    id: Ws(e.regression.id),
                    statementNode: y,
                    moduleID: r,
                    rootModuleId: o
                }));
                let g = new Gu(l,[...p.values()],y,i);
                return g.userData = e,
                g.metaData = s,
                d.push({
                    id: i,
                    statementNode: g,
                    moduleID: r,
                    rootModuleId: o
                }),
                d
            }
        case "image":
            {
                let c = "-\\trigAngleMultiplier*(" + e.angle + ")"
                  , l = kr(e.center, {
                    ...t,
                    seedPrefix: Mn(i, [["ic", i]])
                })
                  , p = kr(c, {
                    ...t,
                    seedPrefix: Mn(i, [["ia", i]])
                })
                  , m = kr(e.width, {
                    ...t,
                    seedPrefix: Mn(i, [["iw", i]])
                })
                  , d = kr(e.height, {
                    ...t,
                    seedPrefix: Mn(i, [["ih", i]])
                })
                  , y = kr(e.opacity, {
                    ...t,
                    seedPrefix: Mn(i, [["io", i]])
                });
                return eq(s, e, t),
                u(new g9({
                    center: l,
                    radianAngle: p,
                    width: m,
                    height: d,
                    opacity: y
                }))
            }
        case "ticker":
            return u(new O.Ticker({
                handler: kr(e.handlerLatex, {
                    ...t,
                    allowDt: !0
                }),
                minStep: kr(e.minStepLatex || "0", t)
            }));
        case "geometry-toolbar-predicate":
            return u(kr(`\\{${e.latex}:1,0\\}`, {
                ...t
            }));
        case "module":
            {
                let c = [];
                for (let l = 0; l < e.imports.length; l++) {
                    let p = e.imports[l]
                      , m = iM(e.id, l)
                      , d = Q3(p.to)
                      , y = Q3(p.from);
                    if (d instanceof v) {
                        c.push({
                            id: m,
                            statementNode: d,
                            moduleID: or,
                            rootModuleId: or
                        });
                        continue
                    }
                    if (y instanceof v) {
                        c.push({
                            id: m,
                            statementNode: y,
                            moduleID: or,
                            rootModuleId: or
                        });
                        continue
                    }
                    c.push(K3(m, y, d))
                }
                return c
            }
        case "viewport":
            return u(new O.Viewport({
                xmin: kr(e.viewport.xmin, t),
                xmax: kr(e.viewport.xmax, t),
                ymin: kr(e.viewport.ymin, t),
                ymax: kr(e.viewport.ymax, t),
                zmin: e.viewport.zmin ? kr(e.viewport.zmin, t) : void 0,
                zmax: e.viewport.zmax ? kr(e.viewport.zmax, t) : void 0
            }));
        default:
            {
                e = e;
                let c, l = Au(e.latex);
                !e.disallowAssignment && l.slice(-1) === "=" ? c = l.substring(0, l.length - 1) : l.startsWith("\\operatorname{export}") ? (a = !0,
                c = l.slice(21)) : c = e.latex;
                for (let y of ue(Fg)) {
                    let g = Fg[y]
                      , f = g.getLatex ? g.getLatex(e) : e[y];
                    if (f) {
                        g.transform && (f = g.transform(f));
                        let h = Li(f, {
                            ...t,
                            seedPrefix: Mn(i, [[g.seed, i]])
                        });
                        s[y] = h,
                        s.extraDepNodes.push(h)
                    }
                }
                if (e.colorLatex) {
                    let y = Ac(e.colorLatex, {
                        ...t,
                        seedPrefix: Mn(i, [["ac", i]])
                    });
                    s.colorLatex = y,
                    s.extraDepNodes.push(y)
                }
                e.polarDomain && e.polarDomain.min && (s.polarDomainMin = Li(e.polarDomain.min, {
                    ...t,
                    seedPrefix: Mn(i, [["lm", i]])
                }),
                s.extraDepNodes.push(s.polarDomainMin)),
                e.polarDomain && e.polarDomain.max && (s.polarDomainMax = Li(e.polarDomain.max, {
                    ...t,
                    seedPrefix: Mn(i, [["lM", i]])
                }),
                s.extraDepNodes.push(s.polarDomainMax)),
                e.parametricDomain && e.parametricDomain.min && (s.parametricDomainMin = Li(e.parametricDomain.min, {
                    ...t,
                    seedPrefix: Mn(i, [["lm", i]])
                }),
                s.extraDepNodes.push(s.parametricDomainMin)),
                e.parametricDomain && e.parametricDomain.max && (s.parametricDomainMax = Li(e.parametricDomain.max, {
                    ...t,
                    seedPrefix: Mn(i, [["lM", i]])
                }),
                s.extraDepNodes.push(s.parametricDomainMax)),
                e.parametricDomain3Du && e.parametricDomain3Du.min && (s.parametricDomain3DuMin = Li(e.parametricDomain3Du.min, {
                    ...t,
                    seedPrefix: Mn(i, [["lm", i]])
                }),
                s.extraDepNodes.push(s.parametricDomain3DuMin)),
                e.parametricDomain3Du && e.parametricDomain3Du.max && (s.parametricDomain3DuMax = Li(e.parametricDomain3Du.max, {
                    ...t,
                    seedPrefix: Mn(i, [["lM", i]])
                }),
                s.extraDepNodes.push(s.parametricDomain3DuMax)),
                e.parametricDomain3Dv && e.parametricDomain3Dv.min && (s.parametricDomain3DvMin = Li(e.parametricDomain3Dv.min, {
                    ...t,
                    seedPrefix: Mn(i, [["lm", i]])
                }),
                s.extraDepNodes.push(s.parametricDomain3DvMin)),
                e.parametricDomain3Dv && e.parametricDomain3Dv.max && (s.parametricDomain3DvMax = Li(e.parametricDomain3Dv.max, {
                    ...t,
                    seedPrefix: Mn(i, [["lM", i]])
                }),
                s.extraDepNodes.push(s.parametricDomain3DvMax)),
                e.parametricDomain3Dr && e.parametricDomain3Dr.min && (s.parametricDomain3DrMin = Li(e.parametricDomain3Dr.min, {
                    ...t,
                    seedPrefix: Mn(i, [["lm", i]])
                }),
                s.extraDepNodes.push(s.parametricDomain3DrMin)),
                e.parametricDomain3Dr && e.parametricDomain3Dr.max && (s.parametricDomain3DrMax = Li(e.parametricDomain3Dr.max, {
                    ...t,
                    seedPrefix: Mn(i, [["lM", i]])
                }),
                s.extraDepNodes.push(s.parametricDomain3DrMax)),
                e.parametricDomain3Dphi && e.parametricDomain3Dphi.min && (s.parametricDomain3DphiMin = Li(e.parametricDomain3Dphi.min, {
                    ...t,
                    seedPrefix: Mn(i, [["lm", i]])
                }),
                s.extraDepNodes.push(s.parametricDomain3DphiMin)),
                e.parametricDomain3Dphi && e.parametricDomain3Dphi.max && (s.parametricDomain3DphiMax = Li(e.parametricDomain3Dphi.max, {
                    ...t,
                    seedPrefix: Mn(i, [["lM", i]])
                }),
                s.extraDepNodes.push(s.parametricDomain3DphiMax)),
                e.vizProps && (e.vizProps.axisOffset && (s.vizAxisOffset = Li(e.vizProps.axisOffset, {
                    ...t,
                    seedPrefix: Mn(i, [["vo", i]])
                }),
                s.extraDepNodes.push(s.vizAxisOffset)),
                e.vizProps.breadth && (s.vizBreadth = Li(e.vizProps.breadth, {
                    ...t,
                    seedPrefix: Mn(i, [["vb", i]])
                }),
                s.extraDepNodes.push(s.vizBreadth))),
                e.cdf && e.cdf.show && (e.cdf.bound1 && (s.cdfBound1 = Ac(e.cdf.bound1, {
                    ...t,
                    seedPrefix: Mn(i, [["lm", i]])
                }),
                s.extraDepNodes.push(s.cdfBound1)),
                e.cdf.bound2 && (s.cdfBound2 = Ac(e.cdf.bound2, {
                    ...t,
                    seedPrefix: Mn(i, [["lM", i]])
                }),
                s.extraDepNodes.push(s.cdfBound2)),
                e.cdf.p && (s.cdfP = Ac(e.cdf.p, {
                    ...t,
                    seedPrefix: Mn(i, [["pv", i]])
                }),
                s.extraDepNodes.push(s.cdfP)));
                let p = e.disallowAssignment ? Li(c, t) : mi(c, t);
                if (p.shouldPromoteToSlider(n)) {
                    let y = e.slider
                      , g = !!(y && y.isPlayingOnce)
                      , f = Ac(y && y.softMin, t)
                      , h = Ac(y && y.softMax, t)
                      , x = Ac(y && y.min, {
                        ...t,
                        seedPrefix: Mn(i, [["lm", i]])
                    })
                      , T = Ac(y && y.max, {
                        ...t,
                        seedPrefix: Mn(i, [["lM", i]])
                    })
                      , P = Ac(y && y.step, {
                        ...t,
                        seedPrefix: Mn(i, [["ls", i]])
                    });
                    p = new h9(p,{
                        sliderMin: x,
                        sliderMax: T,
                        sliderStep: P,
                        sliderIsPlayingOnce: g,
                        sliderSoftMin: f,
                        sliderSoftMax: h
                    })
                }
                a && p.isRegression && (p = xy()),
                eq(s, e, t);
                let m = u(p)
                  , d = n.globParentId;
                if (a && d) {
                    let y = 0;
                    for (let g of p.getLegalExports(n)) {
                        if (g.startsWith("idref_"))
                            continue;
                        let f = iM(i, y)
                          , h = Gn(r, g)
                          , x = Gn(d, g);
                        m.push(K3(f, h, x)),
                        y++
                    }
                }
                return m
            }
        }
    }
    function eq(e, t, n) {
        let r = t.clickableInfo;
        r && r.enabled && r.latex && (e.clickHandler = kr(r.latex, {
            ...n,
            allowIndex: !0
        }))
    }
    function B9(e, t, n, r, o) {
        var u;
        if (!e.hasOwnProperty(t))
            return [];
        let i = e[t]
          , s = i.evaluationState.expression_type
          , a = s === A.SINGLE_POINT || s === A.POINT_LIST;
        if (Vu(i.rawTree)) {
            let c = i.graph(n, void 0)
              , l = i.rawTree.getColumnIdsForGraphing()
              , p = [];
            for (let m of l)
                p.push({
                    graphID: m,
                    graphData: c[m]
                });
            if ((u = i.rawTree.regression) != null && u.userData) {
                let m = i.rawTree.regression.userData.id
                  , d = e[m];
                if (d != null && d.evaluationState.is_graphable && i.rawTree.regression.userData.shouldGraph) {
                    let y = d.graph(n, void 0);
                    p.push({
                        graphID: m,
                        graphData: y
                    })
                }
            }
            return p
        } else if (i.evaluationState.is_graphable && (i.rawTree.userData.shouldGraph || i.rawTree.userData.showLabel && a)) {
            r("GRAPHING", [t]);
            let c = i.graph(n, o.getChildIntersections(t));
            return r("UNPUBLISHED", [t]),
            [{
                graphID: t,
                graphData: c
            }]
        }
        return []
    }
    var rq = class {
        constructor(t) {
            this.context = new AI(t),
            this.sendMessage = t
        }
        processChangeSet(t) {
            let n = this.context.processChangeSet(t);
            this.sendMessage("changeSetResult", n)
        }
    }
    ;
    Object.defineProperty(__dcg_chunk_exports__, 'a', {
        get: () => q9
    });
    Object.defineProperty(__dcg_chunk_exports__, 'b', {
        get: () => Sn
    });
    Object.defineProperty(__dcg_chunk_exports__, 'c', {
        get: () => z9
    });
    Object.defineProperty(__dcg_chunk_exports__, 'd', {
        get: () => cu
    });
    Object.defineProperty(__dcg_chunk_exports__, 'e', {
        get: () => H9
    });
    Object.defineProperty(__dcg_chunk_exports__, 'f', {
        get: () => qI
    });
    Object.defineProperty(__dcg_chunk_exports__, 'g', {
        get: () => dq
    });
    Object.defineProperty(__dcg_chunk_exports__, 'h', {
        get: () => k9
    });
    Object.defineProperty(__dcg_chunk_exports__, 'i', {
        get: () => $9
    });
    Object.defineProperty(__dcg_chunk_exports__, 'j', {
        get: () => Y9
    });
    Object.defineProperty(__dcg_chunk_exports__, 'k', {
        get: () => Z9
    });
    Object.defineProperty(__dcg_chunk_exports__, 'l', {
        get: () => X9
    });
    Object.defineProperty(__dcg_chunk_exports__, 'm', {
        get: () => W9
    });
    Object.defineProperty(__dcg_chunk_exports__, 'n', {
        get: () => J9
    });
    Object.defineProperty(__dcg_chunk_exports__, 'o', {
        get: () => Q9
    });
    Object.defineProperty(__dcg_chunk_exports__, 'p', {
        get: () => yq
    });
    Object.defineProperty(__dcg_chunk_exports__, 'q', {
        get: () => K9
    });
    Object.defineProperty(__dcg_chunk_exports__, 'r', {
        get: () => Pj
    });
    Object.defineProperty(__dcg_chunk_exports__, 's', {
        get: () => ue
    });
    Object.defineProperty(__dcg_chunk_exports__, 't', {
        get: () => Cj
    });
    Object.defineProperty(__dcg_chunk_exports__, 'u', {
        get: () => vj
    });
    Object.defineProperty(__dcg_chunk_exports__, 'v', {
        get: () => _j
    });
    Object.defineProperty(__dcg_chunk_exports__, 'w', {
        get: () => wq
    });
    Object.defineProperty(__dcg_chunk_exports__, 'x', {
        get: () => Nj
    });
    Object.defineProperty(__dcg_chunk_exports__, 'y', {
        get: () => Oj
    });
    Object.defineProperty(__dcg_chunk_exports__, 'z', {
        get: () => Lj
    });
    Object.defineProperty(__dcg_chunk_exports__, 'A', {
        get: () => Jj
    });
    Object.defineProperty(__dcg_chunk_exports__, 'B', {
        get: () => f7
    });
    Object.defineProperty(__dcg_chunk_exports__, 'C', {
        get: () => h7
    });
    Object.defineProperty(__dcg_chunk_exports__, 'D', {
        get: () => $r
    });
    Object.defineProperty(__dcg_chunk_exports__, 'E', {
        get: () => Vi
    });
    Object.defineProperty(__dcg_chunk_exports__, 'F', {
        get: () => j1
    });
    Object.defineProperty(__dcg_chunk_exports__, 'G', {
        get: () => Z1
    });
    Object.defineProperty(__dcg_chunk_exports__, 'H', {
        get: () => Jg
    });
    Object.defineProperty(__dcg_chunk_exports__, 'I', {
        get: () => UJ
    });
    Object.defineProperty(__dcg_chunk_exports__, 'J', {
        get: () => _s
    });
    Object.defineProperty(__dcg_chunk_exports__, 'K', {
        get: () => ac
    });
    Object.defineProperty(__dcg_chunk_exports__, 'L', {
        get: () => Qs
    });
    Object.defineProperty(__dcg_chunk_exports__, 'M', {
        get: () => Tz
    });
    Object.defineProperty(__dcg_chunk_exports__, 'N', {
        get: () => $J
    });
    Object.defineProperty(__dcg_chunk_exports__, 'O', {
        get: () => YJ
    });
    Object.defineProperty(__dcg_chunk_exports__, 'P', {
        get: () => Bi
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Q', {
        get: () => ZJ
    });
    Object.defineProperty(__dcg_chunk_exports__, 'R', {
        get: () => ns
    });
    Object.defineProperty(__dcg_chunk_exports__, 'S', {
        get: () => tN
    });
    Object.defineProperty(__dcg_chunk_exports__, 'T', {
        get: () => QJ
    });
    Object.defineProperty(__dcg_chunk_exports__, 'U', {
        get: () => rQ
    });
    Object.defineProperty(__dcg_chunk_exports__, 'V', {
        get: () => vf
    });
    Object.defineProperty(__dcg_chunk_exports__, 'W', {
        get: () => uh
    });
    Object.defineProperty(__dcg_chunk_exports__, 'X', {
        get: () => kq
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Y', {
        get: () => J7
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Z', {
        get: () => Q7
    });
    Object.defineProperty(__dcg_chunk_exports__, '_', {
        get: () => JI
    });
    Object.defineProperty(__dcg_chunk_exports__, '$', {
        get: () => tJ
    });
    Object.defineProperty(__dcg_chunk_exports__, 'aa', {
        get: () => rJ
    });
    Object.defineProperty(__dcg_chunk_exports__, 'ba', {
        get: () => QI
    });
    Object.defineProperty(__dcg_chunk_exports__, 'ca', {
        get: () => KI
    });
    Object.defineProperty(__dcg_chunk_exports__, 'da', {
        get: () => jq
    });
    Object.defineProperty(__dcg_chunk_exports__, 'ea', {
        get: () => uJ
    });
    Object.defineProperty(__dcg_chunk_exports__, 'fa', {
        get: () => pJ
    });
    Object.defineProperty(__dcg_chunk_exports__, 'ga', {
        get: () => mJ
    });
    Object.defineProperty(__dcg_chunk_exports__, 'ha', {
        get: () => iz
    });
    Object.defineProperty(__dcg_chunk_exports__, 'ia', {
        get: () => $o
    });
    Object.defineProperty(__dcg_chunk_exports__, 'ja', {
        get: () => gJ
    });
    Object.defineProperty(__dcg_chunk_exports__, 'ka', {
        get: () => cz
    });
    Object.defineProperty(__dcg_chunk_exports__, 'la', {
        get: () => vJ
    });
    Object.defineProperty(__dcg_chunk_exports__, 'ma', {
        get: () => ia
    });
    Object.defineProperty(__dcg_chunk_exports__, 'na', {
        get: () => $h
    });
    Object.defineProperty(__dcg_chunk_exports__, 'oa', {
        get: () => vS
    });
    Object.defineProperty(__dcg_chunk_exports__, 'pa', {
        get: () => $8
    });
    Object.defineProperty(__dcg_chunk_exports__, 'qa', {
        get: () => lA
    });
    Object.defineProperty(__dcg_chunk_exports__, 'ra', {
        get: () => MS
    });
    Object.defineProperty(__dcg_chunk_exports__, 'sa', {
        get: () => mA
    });
    Object.defineProperty(__dcg_chunk_exports__, 'ta', {
        get: () => Zh
    });
    Object.defineProperty(__dcg_chunk_exports__, 'ua', {
        get: () => Xh
    });
    Object.defineProperty(__dcg_chunk_exports__, 'va', {
        get: () => Jc
    });
    Object.defineProperty(__dcg_chunk_exports__, 'wa', {
        get: () => go
    });
    Object.defineProperty(__dcg_chunk_exports__, 'xa', {
        get: () => Bs
    });
    Object.defineProperty(__dcg_chunk_exports__, 'ya', {
        get: () => Au
    });
    Object.defineProperty(__dcg_chunk_exports__, 'za', {
        get: () => kf
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Aa', {
        get: () => e$
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Ba', {
        get: () => t$
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Ca', {
        get: () => La
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Da', {
        get: () => $f
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Ea', {
        get: () => VQ
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Fa', {
        get: () => I
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Ga', {
        get: () => Ir
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Ha', {
        get: () => ur
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Ia', {
        get: () => Dn
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Ja', {
        get: () => b
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Ka', {
        get: () => R
    });
    Object.defineProperty(__dcg_chunk_exports__, 'La', {
        get: () => nr
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Ma', {
        get: () => Y
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Na', {
        get: () => zt
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Oa', {
        get: () => He
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Pa', {
        get: () => bn
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Qa', {
        get: () => Ao
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Ra', {
        get: () => De
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Sa', {
        get: () => Ee
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Ta', {
        get: () => Tr
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Ua', {
        get: () => he
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Va', {
        get: () => ce
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Wa', {
        get: () => Ce
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Xa', {
        get: () => bi
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Ya', {
        get: () => Ae
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Za', {
        get: () => fo
    });
    Object.defineProperty(__dcg_chunk_exports__, '_a', {
        get: () => Oe
    });
    Object.defineProperty(__dcg_chunk_exports__, '$a', {
        get: () => Ar
    });
    Object.defineProperty(__dcg_chunk_exports__, 'ab', {
        get: () => Se
    });
    Object.defineProperty(__dcg_chunk_exports__, 'bb', {
        get: () => wr
    });
    Object.defineProperty(__dcg_chunk_exports__, 'cb', {
        get: () => we
    });
    Object.defineProperty(__dcg_chunk_exports__, 'db', {
        get: () => Ks
    });
    Object.defineProperty(__dcg_chunk_exports__, 'eb', {
        get: () => Ie
    });
    Object.defineProperty(__dcg_chunk_exports__, 'fb', {
        get: () => xi
    });
    Object.defineProperty(__dcg_chunk_exports__, 'gb', {
        get: () => N
    });
    Object.defineProperty(__dcg_chunk_exports__, 'hb', {
        get: () => ke
    });
    Object.defineProperty(__dcg_chunk_exports__, 'ib', {
        get: () => cr
    });
    Object.defineProperty(__dcg_chunk_exports__, 'jb', {
        get: () => hu
    });
    Object.defineProperty(__dcg_chunk_exports__, 'kb', {
        get: () => Pt
    });
    Object.defineProperty(__dcg_chunk_exports__, 'lb', {
        get: () => $t
    });
    Object.defineProperty(__dcg_chunk_exports__, 'mb', {
        get: () => wt
    });
    Object.defineProperty(__dcg_chunk_exports__, 'nb', {
        get: () => Qt
    });
    Object.defineProperty(__dcg_chunk_exports__, 'ob', {
        get: () => Ht
    });
    Object.defineProperty(__dcg_chunk_exports__, 'pb', {
        get: () => an
    });
    Object.defineProperty(__dcg_chunk_exports__, 'qb', {
        get: () => Yt
    });
    Object.defineProperty(__dcg_chunk_exports__, 'rb', {
        get: () => Kt
    });
    Object.defineProperty(__dcg_chunk_exports__, 'sb', {
        get: () => qn
    });
    Object.defineProperty(__dcg_chunk_exports__, 'tb', {
        get: () => zn
    });
    Object.defineProperty(__dcg_chunk_exports__, 'ub', {
        get: () => pn
    });
    Object.defineProperty(__dcg_chunk_exports__, 'vb', {
        get: () => mn
    });
    Object.defineProperty(__dcg_chunk_exports__, 'wb', {
        get: () => G
    });
    Object.defineProperty(__dcg_chunk_exports__, 'xb', {
        get: () => to
    });
    Object.defineProperty(__dcg_chunk_exports__, 'yb', {
        get: () => DN
    });
    Object.defineProperty(__dcg_chunk_exports__, 'zb', {
        get: () => xr
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Ab', {
        get: () => Yz
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Bb', {
        get: () => Ke
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Cb', {
        get: () => se
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Db', {
        get: () => X
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Eb', {
        get: () => Qe
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Fb', {
        get: () => rr
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Gb', {
        get: () => _f
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Hb', {
        get: () => Ru
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Ib', {
        get: () => ph
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Jb', {
        get: () => ae
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Kb', {
        get: () => wa
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Lb', {
        get: () => Ti
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Mb', {
        get: () => Jz
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Nb', {
        get: () => St
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Ob', {
        get: () => q
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Pb', {
        get: () => gh
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Qb', {
        get: () => le
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Rb', {
        get: () => yA
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Sb', {
        get: () => vE
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Tb', {
        get: () => i$
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Ub', {
        get: () => u$
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Vb', {
        get: () => wo
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Wb', {
        get: () => Wo
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Xb', {
        get: () => oH
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Yb', {
        get: () => pr
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Zb', {
        get: () => wP
    });
    Object.defineProperty(__dcg_chunk_exports__, '_b', {
        get: () => wh
    });
    Object.defineProperty(__dcg_chunk_exports__, '$b', {
        get: () => Lh
    });
    Object.defineProperty(__dcg_chunk_exports__, 'ac', {
        get: () => rS
    });
    Object.defineProperty(__dcg_chunk_exports__, 'bc', {
        get: () => oU
    });
    Object.defineProperty(__dcg_chunk_exports__, 'cc', {
        get: () => _O
    });
    Object.defineProperty(__dcg_chunk_exports__, 'dc', {
        get: () => Em
    });
    Object.defineProperty(__dcg_chunk_exports__, 'ec', {
        get: () => Dm
    });
    Object.defineProperty(__dcg_chunk_exports__, 'fc', {
        get: () => _m
    });
    Object.defineProperty(__dcg_chunk_exports__, 'gc', {
        get: () => mS
    });
    Object.defineProperty(__dcg_chunk_exports__, 'hc', {
        get: () => dS
    });
    Object.defineProperty(__dcg_chunk_exports__, 'ic', {
        get: () => GP
    });
    Object.defineProperty(__dcg_chunk_exports__, 'jc', {
        get: () => vk
    });
    Object.defineProperty(__dcg_chunk_exports__, 'kc', {
        get: () => kO
    });
    Object.defineProperty(__dcg_chunk_exports__, 'lc', {
        get: () => Dk
    });
    Object.defineProperty(__dcg_chunk_exports__, 'mc', {
        get: () => kh
    });
    Object.defineProperty(__dcg_chunk_exports__, 'nc', {
        get: () => Bf
    });
    Object.defineProperty(__dcg_chunk_exports__, 'oc', {
        get: () => fS
    });
    Object.defineProperty(__dcg_chunk_exports__, 'pc', {
        get: () => yS
    });
    Object.defineProperty(__dcg_chunk_exports__, 'qc', {
        get: () => $O
    });
    Object.defineProperty(__dcg_chunk_exports__, 'rc', {
        get: () => Nk
    });
    Object.defineProperty(__dcg_chunk_exports__, 'sc', {
        get: () => YO
    });
    Object.defineProperty(__dcg_chunk_exports__, 'tc', {
        get: () => Ok
    });
    Object.defineProperty(__dcg_chunk_exports__, 'uc', {
        get: () => ZO
    });
    Object.defineProperty(__dcg_chunk_exports__, 'vc', {
        get: () => Ak
    });
    Object.defineProperty(__dcg_chunk_exports__, 'wc', {
        get: () => Zk
    });
    Object.defineProperty(__dcg_chunk_exports__, 'xc', {
        get: () => jk
    });
    Object.defineProperty(__dcg_chunk_exports__, 'yc', {
        get: () => Jk
    });
    Object.defineProperty(__dcg_chunk_exports__, 'zc', {
        get: () => oa
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Ac', {
        get: () => Zt
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Bc', {
        get: () => f8
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Cc', {
        get: () => y8
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Dc', {
        get: () => PS
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Ec', {
        get: () => Z
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Fc', {
        get: () => dn
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Gc', {
        get: () => rt
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Hc', {
        get: () => ro
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Ic', {
        get: () => Jo
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Jc', {
        get: () => xc
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Kc', {
        get: () => Dne
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Lc', {
        get: () => X$
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Mc', {
        get: () => An
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Nc', {
        get: () => PM
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Oc', {
        get: () => or
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Pc', {
        get: () => aM
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Qc', {
        get: () => vA
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Rc', {
        get: () => Rr
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Sc', {
        get: () => Yr
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Tc', {
        get: () => gse
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Uc', {
        get: () => Cx
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Vc', {
        get: () => Iw
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Wc', {
        get: () => hl
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Xc', {
        get: () => Ja
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Yc', {
        get: () => ku
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Zc', {
        get: () => Fy
    });
    Object.defineProperty(__dcg_chunk_exports__, '_c', {
        get: () => Mw
    });
    Object.defineProperty(__dcg_chunk_exports__, '$c', {
        get: () => ece
    });
    Object.defineProperty(__dcg_chunk_exports__, 'ad', {
        get: () => fe
    });
    Object.defineProperty(__dcg_chunk_exports__, 'bd', {
        get: () => lce
    });
    Object.defineProperty(__dcg_chunk_exports__, 'cd', {
        get: () => pce
    });
    Object.defineProperty(__dcg_chunk_exports__, 'dd', {
        get: () => A
    });
    Object.defineProperty(__dcg_chunk_exports__, 'ed', {
        get: () => A0
    });
    Object.defineProperty(__dcg_chunk_exports__, 'fd', {
        get: () => AL
    });
    Object.defineProperty(__dcg_chunk_exports__, 'gd', {
        get: () => wL
    });
    Object.defineProperty(__dcg_chunk_exports__, 'hd', {
        get: () => LL
    });
    Object.defineProperty(__dcg_chunk_exports__, 'id', {
        get: () => FL
    });
    Object.defineProperty(__dcg_chunk_exports__, 'jd', {
        get: () => Zu
    });
    Object.defineProperty(__dcg_chunk_exports__, 'kd', {
        get: () => El
    });
    Object.defineProperty(__dcg_chunk_exports__, 'ld', {
        get: () => Pce
    });
    Object.defineProperty(__dcg_chunk_exports__, 'md', {
        get: () => it
    });
    Object.defineProperty(__dcg_chunk_exports__, 'nd', {
        get: () => EY
    });
    Object.defineProperty(__dcg_chunk_exports__, 'od', {
        get: () => $0
    });
    Object.defineProperty(__dcg_chunk_exports__, 'pd', {
        get: () => Y0
    });
    Object.defineProperty(__dcg_chunk_exports__, 'qd', {
        get: () => Z0
    });
    Object.defineProperty(__dcg_chunk_exports__, 'rd', {
        get: () => Kx
    });
    Object.defineProperty(__dcg_chunk_exports__, 'sd', {
        get: () => eT
    });
    Object.defineProperty(__dcg_chunk_exports__, 'td', {
        get: () => Rl
    });
    Object.defineProperty(__dcg_chunk_exports__, 'ud', {
        get: () => Jy
    });
    Object.defineProperty(__dcg_chunk_exports__, 'vd', {
        get: () => iF
    });
    Object.defineProperty(__dcg_chunk_exports__, 'wd', {
        get: () => dT
    });
    Object.defineProperty(__dcg_chunk_exports__, 'xd', {
        get: () => fT
    });
    Object.defineProperty(__dcg_chunk_exports__, 'yd', {
        get: () => Jle
    });
    Object.defineProperty(__dcg_chunk_exports__, 'zd', {
        get: () => Qle
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Ad', {
        get: () => ID
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Bd', {
        get: () => bT
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Cd', {
        get: () => vZ
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Dd', {
        get: () => CF
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Ed', {
        get: () => MZ
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Fd', {
        get: () => vF
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Gd', {
        get: () => hT
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Hd', {
        get: () => _Z
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Id', {
        get: () => PD
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Jd', {
        get: () => kp
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Kd', {
        get: () => RZ
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Ld', {
        get: () => NZ
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Md', {
        get: () => Gc
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Nd', {
        get: () => cm
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Od', {
        get: () => AZ
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Pd', {
        get: () => LF
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Qd', {
        get: () => Jt
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Rd', {
        get: () => U1
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Sd', {
        get: () => kd
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Td', {
        get: () => ff
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Ud', {
        get: () => yf
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Vd', {
        get: () => _J
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Wd', {
        get: () => k1
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Xd', {
        get: () => NJ
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Yd', {
        get: () => $1
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Zd', {
        get: () => Bc
    });
    Object.defineProperty(__dcg_chunk_exports__, '_d', {
        get: () => wJ
    });
    Object.defineProperty(__dcg_chunk_exports__, '$d', {
        get: () => BJ
    });
    Object.defineProperty(__dcg_chunk_exports__, 'ae', {
        get: () => GJ
    });
    Object.defineProperty(__dcg_chunk_exports__, 'be', {
        get: () => Y1
    });
    Object.defineProperty(__dcg_chunk_exports__, 'ce', {
        get: () => qJ
    });
    Object.defineProperty(__dcg_chunk_exports__, 'de', {
        get: () => tK
    });
    Object.defineProperty(__dcg_chunk_exports__, 'ee', {
        get: () => nK
    });
    Object.defineProperty(__dcg_chunk_exports__, 'fe', {
        get: () => rK
    });
    Object.defineProperty(__dcg_chunk_exports__, 'ge', {
        get: () => sK
    });
    Object.defineProperty(__dcg_chunk_exports__, 'he', {
        get: () => aK
    });
    Object.defineProperty(__dcg_chunk_exports__, 'ie', {
        get: () => pM
    });
    Object.defineProperty(__dcg_chunk_exports__, 'je', {
        get: () => uK
    });
    Object.defineProperty(__dcg_chunk_exports__, 'ke', {
        get: () => cK
    });
    Object.defineProperty(__dcg_chunk_exports__, 'le', {
        get: () => zb
    });
    Object.defineProperty(__dcg_chunk_exports__, 'me', {
        get: () => N$
    });
    Object.defineProperty(__dcg_chunk_exports__, 'ne', {
        get: () => xK
    });
    Object.defineProperty(__dcg_chunk_exports__, 'oe', {
        get: () => _A
    });
    Object.defineProperty(__dcg_chunk_exports__, 'pe', {
        get: () => qb
    });
    Object.defineProperty(__dcg_chunk_exports__, 'qe', {
        get: () => RA
    });
    Object.defineProperty(__dcg_chunk_exports__, 're', {
        get: () => NA
    });
    Object.defineProperty(__dcg_chunk_exports__, 'se', {
        get: () => OA
    });
    Object.defineProperty(__dcg_chunk_exports__, 'te', {
        get: () => AA
    });
    Object.defineProperty(__dcg_chunk_exports__, 'ue', {
        get: () => TK
    });
    Object.defineProperty(__dcg_chunk_exports__, 've', {
        get: () => IK
    });
    Object.defineProperty(__dcg_chunk_exports__, 'we', {
        get: () => O$
    });
    Object.defineProperty(__dcg_chunk_exports__, 'xe', {
        get: () => PK
    });
    Object.defineProperty(__dcg_chunk_exports__, 'ye', {
        get: () => SK
    });
    Object.defineProperty(__dcg_chunk_exports__, 'ze', {
        get: () => A$
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Ae', {
        get: () => Qde
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Be', {
        get: () => cX
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Ce', {
        get: () => Bfe
    });
    Object.defineProperty(__dcg_chunk_exports__, 'De', {
        get: () => Dc
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Ee', {
        get: () => Gfe
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Fe', {
        get: () => FT
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Ge', {
        get: () => VT
    });
    Object.defineProperty(__dcg_chunk_exports__, 'He', {
        get: () => Sr
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Ie', {
        get: () => eye
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Je', {
        get: () => yG
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Ke', {
        get: () => bG
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Le', {
        get: () => Sa
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Me', {
        get: () => WT
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Ne', {
        get: () => _G
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Oe', {
        get: () => mi
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Pe', {
        get: () => JT
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Qe', {
        get: () => _g
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Re', {
        get: () => Vbe
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Se', {
        get: () => dI
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Te', {
        get: () => D7
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Ue', {
        get: () => Jp
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Ve', {
        get: () => $_
    });
    Object.defineProperty(__dcg_chunk_exports__, 'We', {
        get: () => Y_
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Xe', {
        get: () => bI
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Ye', {
        get: () => tr
    });
    Object.defineProperty(__dcg_chunk_exports__, 'Ze', {
        get: () => w4
    });
    Object.defineProperty(__dcg_chunk_exports__, '_e', {
        get: () => z4
    });
    Object.defineProperty(__dcg_chunk_exports__, '$e', {
        get: () => C2
    });
    Object.defineProperty(__dcg_chunk_exports__, 'af', {
        get: () => v2
    });
    Object.defineProperty(__dcg_chunk_exports__, 'bf', {
        get: () => _2
    });
    Object.defineProperty(__dcg_chunk_exports__, 'cf', {
        get: () => fr
    });
    Object.defineProperty(__dcg_chunk_exports__, 'df', {
        get: () => PI
    });
    Object.defineProperty(__dcg_chunk_exports__, 'ef', {
        get: () => s6
    });
    Object.defineProperty(__dcg_chunk_exports__, 'ff', {
        get: () => q3
    });
    Object.defineProperty(__dcg_chunk_exports__, 'gf', {
        get: () => z3
    });
    Object.defineProperty(__dcg_chunk_exports__, 'hf', {
        get: () => u9
    });
    Object.defineProperty(__dcg_chunk_exports__, 'if', {
        get: () => c9
    });
    Object.defineProperty(__dcg_chunk_exports__, 'jf', {
        get: () => $3
    });
    Object.defineProperty(__dcg_chunk_exports__, 'kf', {
        get: () => ZSe
    });
    Object.defineProperty(__dcg_chunk_exports__, 'lf', {
        get: () => AI
    });
    Object.defineProperty(__dcg_chunk_exports__, 'mf', {
        get: () => rq
    });

    return __dcg_chunk_exports__;
}
)();
;// call the worker module, passing in the shared module exports
__dcg_worker_module__(__dcg_worker_shared_module_exports__);
